function nj(s,e){for(var t=0;t<e.length;t++){const n=e[t];if(typeof n!="string"&&!Array.isArray(n)){for(const i in n)if(i!=="default"&&!(i in s)){const r=Object.getOwnPropertyDescriptor(n,i);r&&Object.defineProperty(s,i,r.get?r:{enumerable:!0,get:()=>n[i]})}}}return Object.freeze(Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();function yC(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}function sj(s){if(Object.prototype.hasOwnProperty.call(s,"__esModule"))return s;var e=s.default;if(typeof e=="function"){var t=function n(){return this instanceof n?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(s).forEach(function(n){var i=Object.getOwnPropertyDescriptor(s,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return s[n]}})}),t}var ON={exports:{}},x1={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var MF;function ij(){if(MF)return x1;MF=1;var s=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(n,i,r){var a=null;if(r!==void 0&&(a=""+r),i.key!==void 0&&(a=""+i.key),"key"in i){r={};for(var o in i)o!=="key"&&(r[o]=i[o])}else r=i;return i=r.ref,{$$typeof:s,type:n,key:a,ref:i!==void 0?i:null,props:r}}return x1.Fragment=e,x1.jsx=t,x1.jsxs=t,x1}var NF;function rj(){return NF||(NF=1,ON.exports=ij()),ON.exports}var ft=rj(),BN={exports:{}},Rn={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var RF;function aj(){if(RF)return Rn;RF=1;var s=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),f=Symbol.iterator;function d(G){return G===null||typeof G!="object"?null:(G=f&&G[f]||G["@@iterator"],typeof G=="function"?G:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,S={};function b(G,ne,oe){this.props=G,this.context=ne,this.refs=S,this.updater=oe||g}b.prototype.isReactComponent={},b.prototype.setState=function(G,ne){if(typeof G!="object"&&typeof G!="function"&&G!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,G,ne,"setState")},b.prototype.forceUpdate=function(G){this.updater.enqueueForceUpdate(this,G,"forceUpdate")};function _(){}_.prototype=b.prototype;function T(G,ne,oe){this.props=G,this.context=ne,this.refs=S,this.updater=oe||g}var E=T.prototype=new _;E.constructor=T,x(E,b.prototype),E.isPureReactComponent=!0;var C=Array.isArray,R={H:null,A:null,T:null,S:null,V:null},I=Object.prototype.hasOwnProperty;function L(G,ne,oe,ue,re,ce){return oe=ce.ref,{$$typeof:s,type:G,key:ne,ref:oe!==void 0?oe:null,props:ce}}function P(G,ne){return L(G.type,ne,void 0,void 0,void 0,G.props)}function D(G){return typeof G=="object"&&G!==null&&G.$$typeof===s}function O(G){var ne={"=":"=0",":":"=2"};return"$"+G.replace(/[=:]/g,function(oe){return ne[oe]})}var F=/\/+/g;function X(G,ne){return typeof G=="object"&&G!==null&&G.key!=null?O(""+G.key):ne.toString(36)}function q(){}function J(G){switch(G.status){case"fulfilled":return G.value;case"rejected":throw G.reason;default:switch(typeof G.status=="string"?G.then(q,q):(G.status="pending",G.then(function(ne){G.status==="pending"&&(G.status="fulfilled",G.value=ne)},function(ne){G.status==="pending"&&(G.status="rejected",G.reason=ne)})),G.status){case"fulfilled":return G.value;case"rejected":throw G.reason}}throw G}function Y(G,ne,oe,ue,re){var ce=typeof G;(ce==="undefined"||ce==="boolean")&&(G=null);var Te=!1;if(G===null)Te=!0;else switch(ce){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(G.$$typeof){case s:case e:Te=!0;break;case c:return Te=G._init,Y(Te(G._payload),ne,oe,ue,re)}}if(Te)return re=re(G),Te=ue===""?"."+X(G,0):ue,C(re)?(oe="",Te!=null&&(oe=Te.replace(F,"$&/")+"/"),Y(re,ne,oe,"",function(ut){return ut})):re!=null&&(D(re)&&(re=P(re,oe+(re.key==null||G&&G.key===re.key?"":(""+re.key).replace(F,"$&/")+"/")+Te)),ne.push(re)),1;Te=0;var Be=ue===""?".":ue+":";if(C(G))for(var Ke=0;Ke<G.length;Ke++)ue=G[Ke],ce=Be+X(ue,Ke),Te+=Y(ue,ne,oe,ce,re);else if(Ke=d(G),typeof Ke=="function")for(G=Ke.call(G),Ke=0;!(ue=G.next()).done;)ue=ue.value,ce=Be+X(ue,Ke++),Te+=Y(ue,ne,oe,ce,re);else if(ce==="object"){if(typeof G.then=="function")return Y(J(G),ne,oe,ue,re);throw ne=String(G),Error("Objects are not valid as a React child (found: "+(ne==="[object Object]"?"object with keys {"+Object.keys(G).join(", ")+"}":ne)+"). If you meant to render a collection of children, use an array instead.")}return Te}function $(G,ne,oe){if(G==null)return G;var ue=[],re=0;return Y(G,ue,"","",function(ce){return ne.call(oe,ce,re++)}),ue}function W(G){if(G._status===-1){var ne=G._result;ne=ne(),ne.then(function(oe){(G._status===0||G._status===-1)&&(G._status=1,G._result=oe)},function(oe){(G._status===0||G._status===-1)&&(G._status=2,G._result=oe)}),G._status===-1&&(G._status=0,G._result=ne)}if(G._status===1)return G._result.default;throw G._result}var V=typeof reportError=="function"?reportError:function(G){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var ne=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof G=="object"&&G!==null&&typeof G.message=="string"?String(G.message):String(G),error:G});if(!window.dispatchEvent(ne))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",G);return}console.error(G)};function se(){}return Rn.Children={map:$,forEach:function(G,ne,oe){$(G,function(){ne.apply(this,arguments)},oe)},count:function(G){var ne=0;return $(G,function(){ne++}),ne},toArray:function(G){return $(G,function(ne){return ne})||[]},only:function(G){if(!D(G))throw Error("React.Children.only expected to receive a single React element child.");return G}},Rn.Component=b,Rn.Fragment=t,Rn.Profiler=i,Rn.PureComponent=T,Rn.StrictMode=n,Rn.Suspense=l,Rn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=R,Rn.__COMPILER_RUNTIME={__proto__:null,c:function(G){return R.H.useMemoCache(G)}},Rn.cache=function(G){return function(){return G.apply(null,arguments)}},Rn.cloneElement=function(G,ne,oe){if(G==null)throw Error("The argument must be a React element, but you passed "+G+".");var ue=x({},G.props),re=G.key,ce=void 0;if(ne!=null)for(Te in ne.ref!==void 0&&(ce=void 0),ne.key!==void 0&&(re=""+ne.key),ne)!I.call(ne,Te)||Te==="key"||Te==="__self"||Te==="__source"||Te==="ref"&&ne.ref===void 0||(ue[Te]=ne[Te]);var Te=arguments.length-2;if(Te===1)ue.children=oe;else if(1<Te){for(var Be=Array(Te),Ke=0;Ke<Te;Ke++)Be[Ke]=arguments[Ke+2];ue.children=Be}return L(G.type,re,void 0,void 0,ce,ue)},Rn.createContext=function(G){return G={$$typeof:a,_currentValue:G,_currentValue2:G,_threadCount:0,Provider:null,Consumer:null},G.Provider=G,G.Consumer={$$typeof:r,_context:G},G},Rn.createElement=function(G,ne,oe){var ue,re={},ce=null;if(ne!=null)for(ue in ne.key!==void 0&&(ce=""+ne.key),ne)I.call(ne,ue)&&ue!=="key"&&ue!=="__self"&&ue!=="__source"&&(re[ue]=ne[ue]);var Te=arguments.length-2;if(Te===1)re.children=oe;else if(1<Te){for(var Be=Array(Te),Ke=0;Ke<Te;Ke++)Be[Ke]=arguments[Ke+2];re.children=Be}if(G&&G.defaultProps)for(ue in Te=G.defaultProps,Te)re[ue]===void 0&&(re[ue]=Te[ue]);return L(G,ce,void 0,void 0,null,re)},Rn.createRef=function(){return{current:null}},Rn.forwardRef=function(G){return{$$typeof:o,render:G}},Rn.isValidElement=D,Rn.lazy=function(G){return{$$typeof:c,_payload:{_status:-1,_result:G},_init:W}},Rn.memo=function(G,ne){return{$$typeof:u,type:G,compare:ne===void 0?null:ne}},Rn.startTransition=function(G){var ne=R.T,oe={};R.T=oe;try{var ue=G(),re=R.S;re!==null&&re(oe,ue),typeof ue=="object"&&ue!==null&&typeof ue.then=="function"&&ue.then(se,V)}catch(ce){V(ce)}finally{R.T=ne}},Rn.unstable_useCacheRefresh=function(){return R.H.useCacheRefresh()},Rn.use=function(G){return R.H.use(G)},Rn.useActionState=function(G,ne,oe){return R.H.useActionState(G,ne,oe)},Rn.useCallback=function(G,ne){return R.H.useCallback(G,ne)},Rn.useContext=function(G){return R.H.useContext(G)},Rn.useDebugValue=function(){},Rn.useDeferredValue=function(G,ne){return R.H.useDeferredValue(G,ne)},Rn.useEffect=function(G,ne,oe){var ue=R.H;if(typeof oe=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return ue.useEffect(G,ne)},Rn.useId=function(){return R.H.useId()},Rn.useImperativeHandle=function(G,ne,oe){return R.H.useImperativeHandle(G,ne,oe)},Rn.useInsertionEffect=function(G,ne){return R.H.useInsertionEffect(G,ne)},Rn.useLayoutEffect=function(G,ne){return R.H.useLayoutEffect(G,ne)},Rn.useMemo=function(G,ne){return R.H.useMemo(G,ne)},Rn.useOptimistic=function(G,ne){return R.H.useOptimistic(G,ne)},Rn.useReducer=function(G,ne,oe){return R.H.useReducer(G,ne,oe)},Rn.useRef=function(G){return R.H.useRef(G)},Rn.useState=function(G){return R.H.useState(G)},Rn.useSyncExternalStore=function(G,ne,oe){return R.H.useSyncExternalStore(G,ne,oe)},Rn.useTransition=function(){return R.H.useTransition()},Rn.version="19.1.0",Rn}var IF;function Dx(){return IF||(IF=1,BN.exports=aj()),BN.exports}var Me=Dx();const Wd=yC(Me);var kN={exports:{}},v1={},LN={exports:{}},FN={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DF;function oj(){return DF||(DF=1,function(s){function e($,W){var V=$.length;$.push(W);e:for(;0<V;){var se=V-1>>>1,G=$[se];if(0<i(G,W))$[se]=W,$[V]=G,V=se;else break e}}function t($){return $.length===0?null:$[0]}function n($){if($.length===0)return null;var W=$[0],V=$.pop();if(V!==W){$[0]=V;e:for(var se=0,G=$.length,ne=G>>>1;se<ne;){var oe=2*(se+1)-1,ue=$[oe],re=oe+1,ce=$[re];if(0>i(ue,V))re<G&&0>i(ce,ue)?($[se]=ce,$[re]=V,se=re):($[se]=ue,$[oe]=V,se=oe);else if(re<G&&0>i(ce,V))$[se]=ce,$[re]=V,se=re;else break e}}return W}function i($,W){var V=$.sortIndex-W.sortIndex;return V!==0?V:$.id-W.id}if(s.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;s.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();s.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,f=null,d=3,g=!1,x=!1,S=!1,b=!1,_=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,E=typeof setImmediate<"u"?setImmediate:null;function C($){for(var W=t(u);W!==null;){if(W.callback===null)n(u);else if(W.startTime<=$)n(u),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(u)}}function R($){if(S=!1,C($),!x)if(t(l)!==null)x=!0,I||(I=!0,X());else{var W=t(u);W!==null&&Y(R,W.startTime-$)}}var I=!1,L=-1,P=5,D=-1;function O(){return b?!0:!(s.unstable_now()-D<P)}function F(){if(b=!1,I){var $=s.unstable_now();D=$;var W=!0;try{e:{x=!1,S&&(S=!1,T(L),L=-1),g=!0;var V=d;try{t:{for(C($),f=t(l);f!==null&&!(f.expirationTime>$&&O());){var se=f.callback;if(typeof se=="function"){f.callback=null,d=f.priorityLevel;var G=se(f.expirationTime<=$);if($=s.unstable_now(),typeof G=="function"){f.callback=G,C($),W=!0;break t}f===t(l)&&n(l),C($)}else n(l);f=t(l)}if(f!==null)W=!0;else{var ne=t(u);ne!==null&&Y(R,ne.startTime-$),W=!1}}break e}finally{f=null,d=V,g=!1}W=void 0}}finally{W?X():I=!1}}}var X;if(typeof E=="function")X=function(){E(F)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,J=q.port2;q.port1.onmessage=F,X=function(){J.postMessage(null)}}else X=function(){_(F,0)};function Y($,W){L=_(function(){$(s.unstable_now())},W)}s.unstable_IdlePriority=5,s.unstable_ImmediatePriority=1,s.unstable_LowPriority=4,s.unstable_NormalPriority=3,s.unstable_Profiling=null,s.unstable_UserBlockingPriority=2,s.unstable_cancelCallback=function($){$.callback=null},s.unstable_forceFrameRate=function($){0>$||125<$?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<$?Math.floor(1e3/$):5},s.unstable_getCurrentPriorityLevel=function(){return d},s.unstable_next=function($){switch(d){case 1:case 2:case 3:var W=3;break;default:W=d}var V=d;d=W;try{return $()}finally{d=V}},s.unstable_requestPaint=function(){b=!0},s.unstable_runWithPriority=function($,W){switch($){case 1:case 2:case 3:case 4:case 5:break;default:$=3}var V=d;d=$;try{return W()}finally{d=V}},s.unstable_scheduleCallback=function($,W,V){var se=s.unstable_now();switch(typeof V=="object"&&V!==null?(V=V.delay,V=typeof V=="number"&&0<V?se+V:se):V=se,$){case 1:var G=-1;break;case 2:G=250;break;case 5:G=1073741823;break;case 4:G=1e4;break;default:G=5e3}return G=V+G,$={id:c++,callback:W,priorityLevel:$,startTime:V,expirationTime:G,sortIndex:-1},V>se?($.sortIndex=V,e(u,$),t(l)===null&&$===t(u)&&(S?(T(L),L=-1):S=!0,Y(R,V-se))):($.sortIndex=G,e(l,$),x||g||(x=!0,I||(I=!0,X()))),$},s.unstable_shouldYield=O,s.unstable_wrapCallback=function($){var W=d;return function(){var V=d;d=W;try{return $.apply(this,arguments)}finally{d=V}}}}(FN)),FN}var OF;function lj(){return OF||(OF=1,LN.exports=oj()),LN.exports}var PN={exports:{}},ma={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var BF;function uj(){if(BF)return ma;BF=1;var s=Dx();function e(l){var u="https://react.dev/errors/"+l;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var c=2;c<arguments.length;c++)u+="&args[]="+encodeURIComponent(arguments[c])}return"Minified React error #"+l+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var n={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(l,u,c){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:f==null?null:""+f,children:l,containerInfo:u,implementation:c}}var a=s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,u){if(l==="font")return"";if(typeof u=="string")return u==="use-credentials"?u:""}return ma.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=n,ma.createPortal=function(l,u){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)throw Error(e(299));return r(l,u,null,c)},ma.flushSync=function(l){var u=a.T,c=n.p;try{if(a.T=null,n.p=2,l)return l()}finally{a.T=u,n.p=c,n.d.f()}},ma.preconnect=function(l,u){typeof l=="string"&&(u?(u=u.crossOrigin,u=typeof u=="string"?u==="use-credentials"?u:"":void 0):u=null,n.d.C(l,u))},ma.prefetchDNS=function(l){typeof l=="string"&&n.d.D(l)},ma.preinit=function(l,u){if(typeof l=="string"&&u&&typeof u.as=="string"){var c=u.as,f=o(c,u.crossOrigin),d=typeof u.integrity=="string"?u.integrity:void 0,g=typeof u.fetchPriority=="string"?u.fetchPriority:void 0;c==="style"?n.d.S(l,typeof u.precedence=="string"?u.precedence:void 0,{crossOrigin:f,integrity:d,fetchPriority:g}):c==="script"&&n.d.X(l,{crossOrigin:f,integrity:d,fetchPriority:g,nonce:typeof u.nonce=="string"?u.nonce:void 0})}},ma.preinitModule=function(l,u){if(typeof l=="string")if(typeof u=="object"&&u!==null){if(u.as==null||u.as==="script"){var c=o(u.as,u.crossOrigin);n.d.M(l,{crossOrigin:c,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0})}}else u==null&&n.d.M(l)},ma.preload=function(l,u){if(typeof l=="string"&&typeof u=="object"&&u!==null&&typeof u.as=="string"){var c=u.as,f=o(c,u.crossOrigin);n.d.L(l,c,{crossOrigin:f,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0,type:typeof u.type=="string"?u.type:void 0,fetchPriority:typeof u.fetchPriority=="string"?u.fetchPriority:void 0,referrerPolicy:typeof u.referrerPolicy=="string"?u.referrerPolicy:void 0,imageSrcSet:typeof u.imageSrcSet=="string"?u.imageSrcSet:void 0,imageSizes:typeof u.imageSizes=="string"?u.imageSizes:void 0,media:typeof u.media=="string"?u.media:void 0})}},ma.preloadModule=function(l,u){if(typeof l=="string")if(u){var c=o(u.as,u.crossOrigin);n.d.m(l,{as:typeof u.as=="string"&&u.as!=="script"?u.as:void 0,crossOrigin:c,integrity:typeof u.integrity=="string"?u.integrity:void 0})}else n.d.m(l)},ma.requestFormReset=function(l){n.d.r(l)},ma.unstable_batchedUpdates=function(l,u){return l(u)},ma.useFormState=function(l,u,c){return a.H.useFormState(l,u,c)},ma.useFormStatus=function(){return a.H.useHostTransitionStatus()},ma.version="19.1.0",ma}var kF;function cj(){if(kF)return PN.exports;kF=1;function s(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s)}catch(e){console.error(e)}}return s(),PN.exports=uj(),PN.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var LF;function hj(){if(LF)return v1;LF=1;var s=lj(),e=Dx(),t=cj();function n(h){var p="https://react.dev/errors/"+h;if(1<arguments.length){p+="?args[]="+encodeURIComponent(arguments[1]);for(var v=2;v<arguments.length;v++)p+="&args[]="+encodeURIComponent(arguments[v])}return"Minified React error #"+h+"; visit "+p+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(h){return!(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)}function r(h){var p=h,v=h;if(h.alternate)for(;p.return;)p=p.return;else{h=p;do p=h,(p.flags&4098)!==0&&(v=p.return),h=p.return;while(h)}return p.tag===3?v:null}function a(h){if(h.tag===13){var p=h.memoizedState;if(p===null&&(h=h.alternate,h!==null&&(p=h.memoizedState)),p!==null)return p.dehydrated}return null}function o(h){if(r(h)!==h)throw Error(n(188))}function l(h){var p=h.alternate;if(!p){if(p=r(h),p===null)throw Error(n(188));return p!==h?null:h}for(var v=h,A=p;;){var M=v.return;if(M===null)break;var B=M.alternate;if(B===null){if(A=M.return,A!==null){v=A;continue}break}if(M.child===B.child){for(B=M.child;B;){if(B===v)return o(M),h;if(B===A)return o(M),p;B=B.sibling}throw Error(n(188))}if(v.return!==A.return)v=M,A=B;else{for(var H=!1,Z=M.child;Z;){if(Z===v){H=!0,v=M,A=B;break}if(Z===A){H=!0,A=M,v=B;break}Z=Z.sibling}if(!H){for(Z=B.child;Z;){if(Z===v){H=!0,v=B,A=M;break}if(Z===A){H=!0,A=B,v=M;break}Z=Z.sibling}if(!H)throw Error(n(189))}}if(v.alternate!==A)throw Error(n(190))}if(v.tag!==3)throw Error(n(188));return v.stateNode.current===v?h:p}function u(h){var p=h.tag;if(p===5||p===26||p===27||p===6)return h;for(h=h.child;h!==null;){if(p=u(h),p!==null)return p;h=h.sibling}return null}var c=Object.assign,f=Symbol.for("react.element"),d=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),b=Symbol.for("react.profiler"),_=Symbol.for("react.provider"),T=Symbol.for("react.consumer"),E=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),L=Symbol.for("react.memo"),P=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),O=Symbol.for("react.memo_cache_sentinel"),F=Symbol.iterator;function X(h){return h===null||typeof h!="object"?null:(h=F&&h[F]||h["@@iterator"],typeof h=="function"?h:null)}var q=Symbol.for("react.client.reference");function J(h){if(h==null)return null;if(typeof h=="function")return h.$$typeof===q?null:h.displayName||h.name||null;if(typeof h=="string")return h;switch(h){case x:return"Fragment";case b:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case I:return"SuspenseList";case D:return"Activity"}if(typeof h=="object")switch(h.$$typeof){case g:return"Portal";case E:return(h.displayName||"Context")+".Provider";case T:return(h._context.displayName||"Context")+".Consumer";case C:var p=h.render;return h=h.displayName,h||(h=p.displayName||p.name||"",h=h!==""?"ForwardRef("+h+")":"ForwardRef"),h;case L:return p=h.displayName||null,p!==null?p:J(h.type)||"Memo";case P:p=h._payload,h=h._init;try{return J(h(p))}catch{}}return null}var Y=Array.isArray,$=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,W=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V={pending:!1,data:null,method:null,action:null},se=[],G=-1;function ne(h){return{current:h}}function oe(h){0>G||(h.current=se[G],se[G]=null,G--)}function ue(h,p){G++,se[G]=h.current,h.current=p}var re=ne(null),ce=ne(null),Te=ne(null),Be=ne(null);function Ke(h,p){switch(ue(Te,p),ue(ce,h),ue(re,null),p.nodeType){case 9:case 11:h=(h=p.documentElement)&&(h=h.namespaceURI)?nF(h):0;break;default:if(h=p.tagName,p=p.namespaceURI)p=nF(p),h=sF(p,h);else switch(h){case"svg":h=1;break;case"math":h=2;break;default:h=0}}oe(re),ue(re,h)}function ut(){oe(re),oe(ce),oe(Te)}function ct(h){h.memoizedState!==null&&ue(Be,h);var p=re.current,v=sF(p,h.type);p!==v&&(ue(ce,h),ue(re,v))}function xt(h){ce.current===h&&(oe(re),oe(ce)),Be.current===h&&(oe(Be),d1._currentValue=V)}var kt=Object.prototype.hasOwnProperty,Et=s.unstable_scheduleCallback,le=s.unstable_cancelCallback,Wt=s.unstable_shouldYield,ze=s.unstable_requestPaint,Fe=s.unstable_now,Pe=s.unstable_getCurrentPriorityLevel,ht=s.unstable_ImmediatePriority,ke=s.unstable_UserBlockingPriority,ie=s.unstable_NormalPriority,j=s.unstable_LowPriority,Ae=s.unstable_IdlePriority,Ue=s.log,Ye=s.unstable_setDisableYieldValue,qe=null,mt=null;function at(h){if(typeof Ue=="function"&&Ye(h),mt&&typeof mt.setStrictMode=="function")try{mt.setStrictMode(qe,h)}catch{}}var gt=Math.clz32?Math.clz32:Dt,dn=Math.log,lt=Math.LN2;function Dt(h){return h>>>=0,h===0?32:31-(dn(h)/lt|0)|0}var Ft=256,Pt=4194304;function vt(h){var p=h&42;if(p!==0)return p;switch(h&-h){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return h&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return h}}function ye(h,p,v){var A=h.pendingLanes;if(A===0)return 0;var M=0,B=h.suspendedLanes,H=h.pingedLanes;h=h.warmLanes;var Z=A&134217727;return Z!==0?(A=Z&~B,A!==0?M=vt(A):(H&=Z,H!==0?M=vt(H):v||(v=Z&~h,v!==0&&(M=vt(v))))):(Z=A&~B,Z!==0?M=vt(Z):H!==0?M=vt(H):v||(v=A&~h,v!==0&&(M=vt(v)))),M===0?0:p!==0&&p!==M&&(p&B)===0&&(B=M&-M,v=p&-p,B>=v||B===32&&(v&4194048)!==0)?p:M}function Je(h,p){return(h.pendingLanes&~(h.suspendedLanes&~h.pingedLanes)&p)===0}function _t(h,p){switch(h){case 1:case 2:case 4:case 8:case 64:return p+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function ge(){var h=Ft;return Ft<<=1,(Ft&4194048)===0&&(Ft=256),h}function dt(){var h=Pt;return Pt<<=1,(Pt&62914560)===0&&(Pt=4194304),h}function We(h){for(var p=[],v=0;31>v;v++)p.push(h);return p}function Ze(h,p){h.pendingLanes|=p,p!==268435456&&(h.suspendedLanes=0,h.pingedLanes=0,h.warmLanes=0)}function Mt(h,p,v,A,M,B){var H=h.pendingLanes;h.pendingLanes=v,h.suspendedLanes=0,h.pingedLanes=0,h.warmLanes=0,h.expiredLanes&=v,h.entangledLanes&=v,h.errorRecoveryDisabledLanes&=v,h.shellSuspendCounter=0;var Z=h.entanglements,he=h.expirationTimes,De=h.hiddenUpdates;for(v=H&~v;0<v;){var et=31-gt(v),st=1<<et;Z[et]=0,he[et]=-1;var Le=De[et];if(Le!==null)for(De[et]=null,et=0;et<Le.length;et++){var He=Le[et];He!==null&&(He.lane&=-536870913)}v&=~st}A!==0&&At(h,A,0),B!==0&&M===0&&h.tag!==0&&(h.suspendedLanes|=B&~(H&~p))}function At(h,p,v){h.pendingLanes|=p,h.suspendedLanes&=~p;var A=31-gt(p);h.entangledLanes|=p,h.entanglements[A]=h.entanglements[A]|1073741824|v&4194090}function Kt(h,p){var v=h.entangledLanes|=p;for(h=h.entanglements;v;){var A=31-gt(v),M=1<<A;M&p|h[A]&p&&(h[A]|=p),v&=~M}}function Nn(h){switch(h){case 2:h=1;break;case 8:h=4;break;case 32:h=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:h=128;break;case 268435456:h=134217728;break;default:h=0}return h}function cs(h){return h&=-h,2<h?8<h?(h&134217727)!==0?32:268435456:8:2}function _n(){var h=W.p;return h!==0?h:(h=window.event,h===void 0?32:SF(h.type))}function xi(h,p){var v=W.p;try{return W.p=h,p()}finally{W.p=v}}var $s=Math.random().toString(36).slice(2),vi="__reactFiber$"+$s,Oi="__reactProps$"+$s,wr="__reactContainer$"+$s,aa="__reactEvents$"+$s,Dp="__reactListeners$"+$s,Ho="__reactHandles$"+$s,Hr="__reactResources$"+$s,Vo="__reactMarker$"+$s;function gs(h){delete h[vi],delete h[Oi],delete h[aa],delete h[Dp],delete h[Ho]}function Wo(h){var p=h[vi];if(p)return p;for(var v=h.parentNode;v;){if(p=v[wr]||v[vi]){if(v=p.alternate,p.child!==null||v!==null&&v.child!==null)for(h=oF(h);h!==null;){if(v=h[vi])return v;h=oF(h)}return p}h=v,v=h.parentNode}return null}function Xo(h){if(h=h[vi]||h[wr]){var p=h.tag;if(p===5||p===6||p===13||p===26||p===27||p===3)return h}return null}function fc(h){var p=h.tag;if(p===5||p===26||p===27||p===6)return h.stateNode;throw Error(n(33))}function yu(h){var p=h[Hr];return p||(p=h[Hr]={hoistableStyles:new Map,hoistableScripts:new Map}),p}function bi(h){h[Vo]=!0}var Of=new Set,Bf={};function qo(h,p){ee(h,p),ee(h+"Capture",p)}function ee(h,p){for(Bf[h]=p,h=0;h<p.length;h++)Of.add(p[h])}var Se=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),$e={},Ge={};function Ee(h){return kt.call(Ge,h)?!0:kt.call($e,h)?!1:Se.test(h)?Ge[h]=!0:($e[h]=!0,!1)}function ot(h,p,v){if(Ee(p))if(v===null)h.removeAttribute(p);else{switch(typeof v){case"undefined":case"function":case"symbol":h.removeAttribute(p);return;case"boolean":var A=p.toLowerCase().slice(0,5);if(A!=="data-"&&A!=="aria-"){h.removeAttribute(p);return}}h.setAttribute(p,""+v)}}function bt(h,p,v){if(v===null)h.removeAttribute(p);else{switch(typeof v){case"undefined":case"function":case"symbol":case"boolean":h.removeAttribute(p);return}h.setAttribute(p,""+v)}}function Tt(h,p,v,A){if(A===null)h.removeAttribute(v);else{switch(typeof A){case"undefined":case"function":case"symbol":case"boolean":h.removeAttribute(v);return}h.setAttributeNS(p,v,""+A)}}var Lt,an;function Zt(h){if(Lt===void 0)try{throw Error()}catch(v){var p=v.stack.trim().match(/\n( *(at )?)/);Lt=p&&p[1]||"",an=-1<v.stack.indexOf(`
    at`)?" (<anonymous>)":-1<v.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Lt+h+an}var Xt=!1;function Dn(h,p){if(!h||Xt)return"";Xt=!0;var v=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var A={DetermineComponentFrameRoot:function(){try{if(p){var st=function(){throw Error()};if(Object.defineProperty(st.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(st,[])}catch(He){var Le=He}Reflect.construct(h,[],st)}else{try{st.call()}catch(He){Le=He}h.call(st.prototype)}}else{try{throw Error()}catch(He){Le=He}(st=h())&&typeof st.catch=="function"&&st.catch(function(){})}}catch(He){if(He&&Le&&typeof He.stack=="string")return[He.stack,Le.stack]}return[null,null]}};A.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var M=Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot,"name");M&&M.configurable&&Object.defineProperty(A.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var B=A.DetermineComponentFrameRoot(),H=B[0],Z=B[1];if(H&&Z){var he=H.split(`
`),De=Z.split(`
`);for(M=A=0;A<he.length&&!he[A].includes("DetermineComponentFrameRoot");)A++;for(;M<De.length&&!De[M].includes("DetermineComponentFrameRoot");)M++;if(A===he.length||M===De.length)for(A=he.length-1,M=De.length-1;1<=A&&0<=M&&he[A]!==De[M];)M--;for(;1<=A&&0<=M;A--,M--)if(he[A]!==De[M]){if(A!==1||M!==1)do if(A--,M--,0>M||he[A]!==De[M]){var et=`
`+he[A].replace(" at new "," at ");return h.displayName&&et.includes("<anonymous>")&&(et=et.replace("<anonymous>",h.displayName)),et}while(1<=A&&0<=M);break}}}finally{Xt=!1,Error.prepareStackTrace=v}return(v=h?h.displayName||h.name:"")?Zt(v):""}function Yn(h){switch(h.tag){case 26:case 27:case 5:return Zt(h.type);case 16:return Zt("Lazy");case 13:return Zt("Suspense");case 19:return Zt("SuspenseList");case 0:case 15:return Dn(h.type,!1);case 11:return Dn(h.type.render,!1);case 1:return Dn(h.type,!0);case 31:return Zt("Activity");default:return""}}function zs(h){try{var p="";do p+=Yn(h),h=h.return;while(h);return p}catch(v){return`
Error generating stack: `+v.message+`
`+v.stack}}function Fn(h){switch(typeof h){case"bigint":case"boolean":case"number":case"string":case"undefined":return h;case"object":return h;default:return""}}function $n(h){var p=h.type;return(h=h.nodeName)&&h.toLowerCase()==="input"&&(p==="checkbox"||p==="radio")}function Qt(h){var p=$n(h)?"checked":"value",v=Object.getOwnPropertyDescriptor(h.constructor.prototype,p),A=""+h[p];if(!h.hasOwnProperty(p)&&typeof v<"u"&&typeof v.get=="function"&&typeof v.set=="function"){var M=v.get,B=v.set;return Object.defineProperty(h,p,{configurable:!0,get:function(){return M.call(this)},set:function(H){A=""+H,B.call(this,H)}}),Object.defineProperty(h,p,{enumerable:v.enumerable}),{getValue:function(){return A},setValue:function(H){A=""+H},stopTracking:function(){h._valueTracker=null,delete h[p]}}}}function Vs(h){h._valueTracker||(h._valueTracker=Qt(h))}function Xn(h){if(!h)return!1;var p=h._valueTracker;if(!p)return!0;var v=p.getValue(),A="";return h&&(A=$n(h)?h.checked?"true":"false":h.value),h=A,h!==v?(p.setValue(h),!0):!1}function or(h){if(h=h||(typeof document<"u"?document:void 0),typeof h>"u")return null;try{return h.activeElement||h.body}catch{return h.body}}var Cl=/[\n"\\]/g;function _s(h){return h.replace(Cl,function(p){return"\\"+p.charCodeAt(0).toString(16)+" "})}function El(h,p,v,A,M,B,H,Z){h.name="",H!=null&&typeof H!="function"&&typeof H!="symbol"&&typeof H!="boolean"?h.type=H:h.removeAttribute("type"),p!=null?H==="number"?(p===0&&h.value===""||h.value!=p)&&(h.value=""+Fn(p)):h.value!==""+Fn(p)&&(h.value=""+Fn(p)):H!=="submit"&&H!=="reset"||h.removeAttribute("value"),p!=null?lr(h,H,Fn(p)):v!=null?lr(h,H,Fn(v)):A!=null&&h.removeAttribute("value"),M==null&&B!=null&&(h.defaultChecked=!!B),M!=null&&(h.checked=M&&typeof M!="function"&&typeof M!="symbol"),Z!=null&&typeof Z!="function"&&typeof Z!="symbol"&&typeof Z!="boolean"?h.name=""+Fn(Z):h.removeAttribute("name")}function ys(h,p,v,A,M,B,H,Z){if(B!=null&&typeof B!="function"&&typeof B!="symbol"&&typeof B!="boolean"&&(h.type=B),p!=null||v!=null){if(!(B!=="submit"&&B!=="reset"||p!=null))return;v=v!=null?""+Fn(v):"",p=p!=null?""+Fn(p):v,Z||p===h.value||(h.value=p),h.defaultValue=p}A=A??M,A=typeof A!="function"&&typeof A!="symbol"&&!!A,h.checked=Z?h.checked:!!A,h.defaultChecked=!!A,H!=null&&typeof H!="function"&&typeof H!="symbol"&&typeof H!="boolean"&&(h.name=H)}function lr(h,p,v){p==="number"&&or(h.ownerDocument)===h||h.defaultValue===""+v||(h.defaultValue=""+v)}function _i(h,p,v,A){if(h=h.options,p){p={};for(var M=0;M<v.length;M++)p["$"+v[M]]=!0;for(v=0;v<h.length;v++)M=p.hasOwnProperty("$"+h[v].value),h[v].selected!==M&&(h[v].selected=M),M&&A&&(h[v].defaultSelected=!0)}else{for(v=""+Fn(v),p=null,M=0;M<h.length;M++){if(h[M].value===v){h[M].selected=!0,A&&(h[M].defaultSelected=!0);return}p!==null||h[M].disabled||(p=h[M])}p!==null&&(p.selected=!0)}}function Gi(h,p,v){if(p!=null&&(p=""+Fn(p),p!==h.value&&(h.value=p),v==null)){h.defaultValue!==p&&(h.defaultValue=p);return}h.defaultValue=v!=null?""+Fn(v):""}function Hi(h,p,v,A){if(p==null){if(A!=null){if(v!=null)throw Error(n(92));if(Y(A)){if(1<A.length)throw Error(n(93));A=A[0]}v=A}v==null&&(v=""),p=v}v=Fn(p),h.defaultValue=v,A=h.textContent,A===v&&A!==""&&A!==null&&(h.value=A)}function Vr(h,p){if(p){var v=h.firstChild;if(v&&v===h.lastChild&&v.nodeType===3){v.nodeValue=p;return}}h.textContent=p}var Ml=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Op(h,p,v){var A=p.indexOf("--")===0;v==null||typeof v=="boolean"||v===""?A?h.setProperty(p,""):p==="float"?h.cssFloat="":h[p]="":A?h.setProperty(p,v):typeof v!="number"||v===0||Ml.has(p)?p==="float"?h.cssFloat=v:h[p]=(""+v).trim():h[p]=v+"px"}function Bp(h,p,v){if(p!=null&&typeof p!="object")throw Error(n(62));if(h=h.style,v!=null){for(var A in v)!v.hasOwnProperty(A)||p!=null&&p.hasOwnProperty(A)||(A.indexOf("--")===0?h.setProperty(A,""):A==="float"?h.cssFloat="":h[A]="");for(var M in p)A=p[M],p.hasOwnProperty(M)&&v[M]!==A&&Op(h,M,A)}else for(var B in p)p.hasOwnProperty(B)&&Op(h,B,p[B])}function l0(h){if(h.indexOf("-")===-1)return!1;switch(h){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var rv=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),BS=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function kp(h){return BS.test(""+h)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":h}var u0=null;function c0(h){return h=h.target||h.srcElement||window,h.correspondingUseElement&&(h=h.correspondingUseElement),h.nodeType===3?h.parentNode:h}var dc=null,bh=null;function av(h){var p=Xo(h);if(p&&(h=p.stateNode)){var v=h[Oi]||null;e:switch(h=p.stateNode,p.type){case"input":if(El(h,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name),p=v.name,v.type==="radio"&&p!=null){for(v=h;v.parentNode;)v=v.parentNode;for(v=v.querySelectorAll('input[name="'+_s(""+p)+'"][type="radio"]'),p=0;p<v.length;p++){var A=v[p];if(A!==h&&A.form===h.form){var M=A[Oi]||null;if(!M)throw Error(n(90));El(A,M.value,M.defaultValue,M.defaultValue,M.checked,M.defaultChecked,M.type,M.name)}}for(p=0;p<v.length;p++)A=v[p],A.form===h.form&&Xn(A)}break e;case"textarea":Gi(h,v.value,v.defaultValue);break e;case"select":p=v.value,p!=null&&_i(h,!!v.multiple,p,!1)}}}var Lp=!1;function ov(h,p,v){if(Lp)return h(p,v);Lp=!0;try{var A=h(p);return A}finally{if(Lp=!1,(dc!==null||bh!==null)&&(Vl(),dc&&(p=dc,h=bh,bh=dc=null,av(p),h)))for(p=0;p<h.length;p++)av(h[p])}}function kf(h,p){var v=h.stateNode;if(v===null)return null;var A=v[Oi]||null;if(A===null)return null;v=A[p];e:switch(p){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(A=!A.disabled)||(h=h.type,A=!(h==="button"||h==="input"||h==="select"||h==="textarea")),h=!A;break e;default:h=!1}if(h)return null;if(v&&typeof v!="function")throw Error(n(231,p,typeof v));return v}var Nl=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Fp=!1;if(Nl)try{var Lf={};Object.defineProperty(Lf,"passive",{get:function(){Fp=!0}}),window.addEventListener("test",Lf,Lf),window.removeEventListener("test",Lf,Lf)}catch{Fp=!1}var xu=null,lv=null,h0=null;function uv(){if(h0)return h0;var h,p=lv,v=p.length,A,M="value"in xu?xu.value:xu.textContent,B=M.length;for(h=0;h<v&&p[h]===M[h];h++);var H=v-h;for(A=1;A<=H&&p[v-A]===M[B-A];A++);return h0=M.slice(h,1<A?1-A:void 0)}function pc(h){var p=h.keyCode;return"charCode"in h?(h=h.charCode,h===0&&p===13&&(h=13)):h=p,h===10&&(h=13),32<=h||h===13?h:0}function Ff(){return!0}function Pp(){return!1}function Wr(h){function p(v,A,M,B,H){this._reactName=v,this._targetInst=M,this.type=A,this.nativeEvent=B,this.target=H,this.currentTarget=null;for(var Z in h)h.hasOwnProperty(Z)&&(v=h[Z],this[Z]=v?v(B):B[Z]);return this.isDefaultPrevented=(B.defaultPrevented!=null?B.defaultPrevented:B.returnValue===!1)?Ff:Pp,this.isPropagationStopped=Pp,this}return c(p.prototype,{preventDefault:function(){this.defaultPrevented=!0;var v=this.nativeEvent;v&&(v.preventDefault?v.preventDefault():typeof v.returnValue!="unknown"&&(v.returnValue=!1),this.isDefaultPrevented=Ff)},stopPropagation:function(){var v=this.nativeEvent;v&&(v.stopPropagation?v.stopPropagation():typeof v.cancelBubble!="unknown"&&(v.cancelBubble=!0),this.isPropagationStopped=Ff)},persist:function(){},isPersistent:Ff}),p}var mc={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(h){return h.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Pf=Wr(mc),Uf=c({},mc,{view:0,detail:0}),kS=Wr(Uf),vu,$f,zf,Gf=c({},Uf,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:$p,button:0,buttons:0,relatedTarget:function(h){return h.relatedTarget===void 0?h.fromElement===h.srcElement?h.toElement:h.fromElement:h.relatedTarget},movementX:function(h){return"movementX"in h?h.movementX:(h!==zf&&(zf&&h.type==="mousemove"?(vu=h.screenX-zf.screenX,$f=h.screenY-zf.screenY):$f=vu=0,zf=h),vu)},movementY:function(h){return"movementY"in h?h.movementY:$f}}),cv=Wr(Gf),LS=c({},Gf,{dataTransfer:0}),JM=Wr(LS),ur=c({},Uf,{relatedTarget:0}),f0=Wr(ur),FS=c({},mc,{animationName:0,elapsedTime:0,pseudoElement:0}),PS=Wr(FS),US=c({},mc,{clipboardData:function(h){return"clipboardData"in h?h.clipboardData:window.clipboardData}}),$S=Wr(US),Up=c({},mc,{data:0}),d0=Wr(Up),zS={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},GS={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},HS={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function hv(h){var p=this.nativeEvent;return p.getModifierState?p.getModifierState(h):(h=HS[h])?!!p[h]:!1}function $p(){return hv}var VS=c({},Uf,{key:function(h){if(h.key){var p=zS[h.key]||h.key;if(p!=="Unidentified")return p}return h.type==="keypress"?(h=pc(h),h===13?"Enter":String.fromCharCode(h)):h.type==="keydown"||h.type==="keyup"?GS[h.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:$p,charCode:function(h){return h.type==="keypress"?pc(h):0},keyCode:function(h){return h.type==="keydown"||h.type==="keyup"?h.keyCode:0},which:function(h){return h.type==="keypress"?pc(h):h.type==="keydown"||h.type==="keyup"?h.keyCode:0}}),fv=Wr(VS),dv=c({},Gf,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),p0=Wr(dv),WS=c({},Uf,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:$p}),pv=Wr(WS),XS=c({},mc,{propertyName:0,elapsedTime:0,pseudoElement:0}),bu=Wr(XS),mv=c({},Gf,{deltaX:function(h){return"deltaX"in h?h.deltaX:"wheelDeltaX"in h?-h.wheelDeltaX:0},deltaY:function(h){return"deltaY"in h?h.deltaY:"wheelDeltaY"in h?-h.wheelDeltaY:"wheelDelta"in h?-h.wheelDelta:0},deltaZ:0,deltaMode:0}),ZM=Wr(mv),qS=c({},mc,{newState:0,oldState:0}),gc=Wr(qS),_u=[9,13,27,32],zp=Nl&&"CompositionEvent"in window,_h=null;Nl&&"documentMode"in document&&(_h=document.documentMode);var Gp=Nl&&"TextEvent"in window&&!_h,Hp=Nl&&(!zp||_h&&8<_h&&11>=_h),yc=" ",cr=!1;function Vp(h,p){switch(h){case"keyup":return _u.indexOf(p.keyCode)!==-1;case"keydown":return p.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function gv(h){return h=h.detail,typeof h=="object"&&"data"in h?h.data:null}var xc=!1;function Wp(h,p){switch(h){case"compositionend":return gv(p);case"keypress":return p.which!==32?null:(cr=!0,yc);case"textInput":return h=p.data,h===yc&&cr?null:h;default:return null}}function yv(h,p){if(xc)return h==="compositionend"||!zp&&Vp(h,p)?(h=uv(),h0=lv=xu=null,xc=!1,h):null;switch(h){case"paste":return null;case"keypress":if(!(p.ctrlKey||p.altKey||p.metaKey)||p.ctrlKey&&p.altKey){if(p.char&&1<p.char.length)return p.char;if(p.which)return String.fromCharCode(p.which)}return null;case"compositionend":return Hp&&p.locale!=="ko"?null:p.data;default:return null}}var m0={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xv(h){var p=h&&h.nodeName&&h.nodeName.toLowerCase();return p==="input"?!!m0[h.type]:p==="textarea"}function oa(h,p,v,A){dc?bh?bh.push(A):bh=[A]:dc=A,p=XA(p,"onChange"),0<p.length&&(v=new Pf("onChange","change",null,v,A),h.push({event:v,listeners:p}))}var Hf=null,Sh=null;function jS(h){JL(h,0)}function Xp(h){var p=fc(h);if(Xn(p))return h}function g0(h,p){if(h==="change")return p}var y0=!1;if(Nl){var x0;if(Nl){var Vf="oninput"in document;if(!Vf){var Wf=document.createElement("div");Wf.setAttribute("oninput","return;"),Vf=typeof Wf.oninput=="function"}x0=Vf}else x0=!1;y0=x0&&(!document.documentMode||9<document.documentMode)}function Gs(){Hf&&(Hf.detachEvent("onpropertychange",KS),Sh=Hf=null)}function KS(h){if(h.propertyName==="value"&&Xp(Sh)){var p=[];oa(p,Sh,h,c0(h)),ov(jS,p)}}function QM(h,p,v){h==="focusin"?(Gs(),Hf=p,Sh=v,Hf.attachEvent("onpropertychange",KS)):h==="focusout"&&Gs()}function YS(h){if(h==="selectionchange"||h==="keyup"||h==="keydown")return Xp(Sh)}function qp(h,p){if(h==="click")return Xp(p)}function vc(h,p){if(h==="input"||h==="change")return Xp(p)}function JS(h,p){return h===p&&(h!==0||1/h===1/p)||h!==h&&p!==p}var la=typeof Object.is=="function"?Object.is:JS;function jo(h,p){if(la(h,p))return!0;if(typeof h!="object"||h===null||typeof p!="object"||p===null)return!1;var v=Object.keys(h),A=Object.keys(p);if(v.length!==A.length)return!1;for(A=0;A<v.length;A++){var M=v[A];if(!kt.call(p,M)||!la(h[M],p[M]))return!1}return!0}function ua(h){for(;h&&h.firstChild;)h=h.firstChild;return h}function vv(h,p){var v=ua(h);h=0;for(var A;v;){if(v.nodeType===3){if(A=h+v.textContent.length,h<=p&&A>=p)return{node:v,offset:p-h};h=A}e:{for(;v;){if(v.nextSibling){v=v.nextSibling;break e}v=v.parentNode}v=void 0}v=ua(v)}}function bv(h,p){return h&&p?h===p?!0:h&&h.nodeType===3?!1:p&&p.nodeType===3?bv(h,p.parentNode):"contains"in h?h.contains(p):h.compareDocumentPosition?!!(h.compareDocumentPosition(p)&16):!1:!1}function _v(h){h=h!=null&&h.ownerDocument!=null&&h.ownerDocument.defaultView!=null?h.ownerDocument.defaultView:window;for(var p=or(h.document);p instanceof h.HTMLIFrameElement;){try{var v=typeof p.contentWindow.location.href=="string"}catch{v=!1}if(v)h=p.contentWindow;else break;p=or(h.document)}return p}function jp(h){var p=h&&h.nodeName&&h.nodeName.toLowerCase();return p&&(p==="input"&&(h.type==="text"||h.type==="search"||h.type==="tel"||h.type==="url"||h.type==="password")||p==="textarea"||h.contentEditable==="true")}var Sv=Nl&&"documentMode"in document&&11>=document.documentMode,Su=null,v0=null,Kp=null,b0=!1;function Av(h,p,v){var A=v.window===v?v.document:v.nodeType===9?v:v.ownerDocument;b0||Su==null||Su!==or(A)||(A=Su,"selectionStart"in A&&jp(A)?A={start:A.selectionStart,end:A.selectionEnd}:(A=(A.ownerDocument&&A.ownerDocument.defaultView||window).getSelection(),A={anchorNode:A.anchorNode,anchorOffset:A.anchorOffset,focusNode:A.focusNode,focusOffset:A.focusOffset}),Kp&&jo(Kp,A)||(Kp=A,A=XA(v0,"onSelect"),0<A.length&&(p=new Pf("onSelect","select",null,p,v),h.push({event:p,listeners:A}),p.target=Su)))}function hr(h,p){var v={};return v[h.toLowerCase()]=p.toLowerCase(),v["Webkit"+h]="webkit"+p,v["Moz"+h]="moz"+p,v}var bc={animationend:hr("Animation","AnimationEnd"),animationiteration:hr("Animation","AnimationIteration"),animationstart:hr("Animation","AnimationStart"),transitionrun:hr("Transition","TransitionRun"),transitionstart:hr("Transition","TransitionStart"),transitioncancel:hr("Transition","TransitionCancel"),transitionend:hr("Transition","TransitionEnd")},_0={},ZS={};Nl&&(ZS=document.createElement("div").style,"AnimationEvent"in window||(delete bc.animationend.animation,delete bc.animationiteration.animation,delete bc.animationstart.animation),"TransitionEvent"in window||delete bc.transitionend.transition);function Au(h){if(_0[h])return _0[h];if(!bc[h])return h;var p=bc[h],v;for(v in p)if(p.hasOwnProperty(v)&&v in ZS)return _0[h]=p[v];return h}var Xr=Au("animationend"),Tv=Au("animationiteration"),ca=Au("animationstart"),QS=Au("transitionrun"),Tu=Au("transitionstart"),Xf=Au("transitioncancel"),wu=Au("transitionend"),S0=new Map,Yp="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Yp.push("scrollEnd");function Vi(h,p){S0.set(h,p),qo(p,[h])}var wv=new WeakMap;function fr(h,p){if(typeof h=="object"&&h!==null){var v=wv.get(h);return v!==void 0?v:(p={value:h,source:p,stack:zs(p)},wv.set(h,p),p)}return{value:h,source:p,stack:zs(p)}}var Cr=[],ao=0,A0=0;function Jp(){for(var h=ao,p=A0=ao=0;p<h;){var v=Cr[p];Cr[p++]=null;var A=Cr[p];Cr[p++]=null;var M=Cr[p];Cr[p++]=null;var B=Cr[p];if(Cr[p++]=null,A!==null&&M!==null){var H=A.pending;H===null?M.next=M:(M.next=H.next,H.next=M),A.pending=M}B!==0&&Cv(v,M,B)}}function _c(h,p,v,A){Cr[ao++]=h,Cr[ao++]=p,Cr[ao++]=v,Cr[ao++]=A,A0|=A,h.lanes|=A,h=h.alternate,h!==null&&(h.lanes|=A)}function T0(h,p,v,A){return _c(h,p,v,A),qf(h)}function Cu(h,p){return _c(h,null,null,p),qf(h)}function Cv(h,p,v){h.lanes|=v;var A=h.alternate;A!==null&&(A.lanes|=v);for(var M=!1,B=h.return;B!==null;)B.childLanes|=v,A=B.alternate,A!==null&&(A.childLanes|=v),B.tag===22&&(h=B.stateNode,h===null||h._visibility&1||(M=!0)),h=B,B=B.return;return h.tag===3?(B=h.stateNode,M&&p!==null&&(M=31-gt(v),h=B.hiddenUpdates,A=h[M],A===null?h[M]=[p]:A.push(p),p.lane=v|536870912),B):null}function qf(h){if(50<Hl)throw Hl=0,$h=null,Error(n(185));for(var p=h.return;p!==null;)h=p,p=h.return;return h.tag===3?h.stateNode:null}var Sc={};function Ev(h,p,v,A){this.tag=h,this.key=v,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=p,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=A,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ha(h,p,v,A){return new Ev(h,p,v,A)}function Zp(h){return h=h.prototype,!(!h||!h.isReactComponent)}function ai(h,p){var v=h.alternate;return v===null?(v=ha(h.tag,p,h.key,h.mode),v.elementType=h.elementType,v.type=h.type,v.stateNode=h.stateNode,v.alternate=h,h.alternate=v):(v.pendingProps=p,v.type=h.type,v.flags=0,v.subtreeFlags=0,v.deletions=null),v.flags=h.flags&65011712,v.childLanes=h.childLanes,v.lanes=h.lanes,v.child=h.child,v.memoizedProps=h.memoizedProps,v.memoizedState=h.memoizedState,v.updateQueue=h.updateQueue,p=h.dependencies,v.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext},v.sibling=h.sibling,v.index=h.index,v.ref=h.ref,v.refCleanup=h.refCleanup,v}function Mv(h,p){h.flags&=65011714;var v=h.alternate;return v===null?(h.childLanes=0,h.lanes=p,h.child=null,h.subtreeFlags=0,h.memoizedProps=null,h.memoizedState=null,h.updateQueue=null,h.dependencies=null,h.stateNode=null):(h.childLanes=v.childLanes,h.lanes=v.lanes,h.child=v.child,h.subtreeFlags=0,h.deletions=null,h.memoizedProps=v.memoizedProps,h.memoizedState=v.memoizedState,h.updateQueue=v.updateQueue,h.type=v.type,p=v.dependencies,h.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext}),h}function Wi(h,p,v,A,M,B){var H=0;if(A=h,typeof h=="function")Zp(h)&&(H=1);else if(typeof h=="string")H=Hq(h,v,re.current)?26:h==="html"||h==="head"||h==="body"?27:5;else e:switch(h){case D:return h=ha(31,v,p,M),h.elementType=D,h.lanes=B,h;case x:return Ac(v.children,M,B,p);case S:H=8,M|=24;break;case b:return h=ha(12,v,p,M|2),h.elementType=b,h.lanes=B,h;case R:return h=ha(13,v,p,M),h.elementType=R,h.lanes=B,h;case I:return h=ha(19,v,p,M),h.elementType=I,h.lanes=B,h;default:if(typeof h=="object"&&h!==null)switch(h.$$typeof){case _:case E:H=10;break e;case T:H=9;break e;case C:H=11;break e;case L:H=14;break e;case P:H=16,A=null;break e}H=29,v=Error(n(130,h===null?"null":typeof h,"")),A=null}return p=ha(H,v,p,M),p.elementType=h,p.type=A,p.lanes=B,p}function Ac(h,p,v,A){return h=ha(7,h,A,p),h.lanes=v,h}function Qp(h,p,v){return h=ha(6,h,null,p),h.lanes=v,h}function w0(h,p,v){return p=ha(4,h.children!==null?h.children:[],h.key,p),p.lanes=v,p.stateNode={containerInfo:h.containerInfo,pendingChildren:null,implementation:h.implementation},p}var jf=[],fa=0,em=null,Kf=0,dr=[],Ba=0,Tc=null,Rl=1,Il="";function Eu(h,p){jf[fa++]=Kf,jf[fa++]=em,em=h,Kf=p}function C0(h,p,v){dr[Ba++]=Rl,dr[Ba++]=Il,dr[Ba++]=Tc,Tc=h;var A=Rl;h=Il;var M=32-gt(A)-1;A&=~(1<<M),v+=1;var B=32-gt(p)+M;if(30<B){var H=M-M%5;B=(A&(1<<H)-1).toString(32),A>>=H,M-=H,Rl=1<<32-gt(p)+M|v<<M|A,Il=B+h}else Rl=1<<B|v<<M|A,Il=h}function Nv(h){h.return!==null&&(Eu(h,1),C0(h,1,0))}function Rv(h){for(;h===em;)em=jf[--fa],jf[fa]=null,Kf=jf[--fa],jf[fa]=null;for(;h===Tc;)Tc=dr[--Ba],dr[Ba]=null,Il=dr[--Ba],dr[Ba]=null,Rl=dr[--Ba],dr[Ba]=null}var qr=null,Ws=null,ss=!1,oo=null,ka=!1,E0=Error(n(519));function wc(h){var p=Error(n(418,""));throw Ah(fr(p,h)),E0}function eA(h){var p=h.stateNode,v=h.type,A=h.memoizedProps;switch(p[vi]=h,p[Oi]=A,v){case"dialog":Hn("cancel",p),Hn("close",p);break;case"iframe":case"object":case"embed":Hn("load",p);break;case"video":case"audio":for(v=0;v<o1.length;v++)Hn(o1[v],p);break;case"source":Hn("error",p);break;case"img":case"image":case"link":Hn("error",p),Hn("load",p);break;case"details":Hn("toggle",p);break;case"input":Hn("invalid",p),ys(p,A.value,A.defaultValue,A.checked,A.defaultChecked,A.type,A.name,!0),Vs(p);break;case"select":Hn("invalid",p);break;case"textarea":Hn("invalid",p),Hi(p,A.value,A.defaultValue,A.children),Vs(p)}v=A.children,typeof v!="string"&&typeof v!="number"&&typeof v!="bigint"||p.textContent===""+v||A.suppressHydrationWarning===!0||tF(p.textContent,v)?(A.popover!=null&&(Hn("beforetoggle",p),Hn("toggle",p)),A.onScroll!=null&&Hn("scroll",p),A.onScrollEnd!=null&&Hn("scrollend",p),A.onClick!=null&&(p.onclick=qA),p=!0):p=!1,p||wc(h)}function Iv(h){for(qr=h.return;qr;)switch(qr.tag){case 5:case 13:ka=!1;return;case 27:case 3:ka=!0;return;default:qr=qr.return}}function Ko(h){if(h!==qr)return!1;if(!ss)return Iv(h),ss=!0,!1;var p=h.tag,v;if((v=p!==3&&p!==27)&&((v=p===5)&&(v=h.type,v=!(v!=="form"&&v!=="button")||vN(h.type,h.memoizedProps)),v=!v),v&&Ws&&wc(h),Iv(h),p===13){if(h=h.memoizedState,h=h!==null?h.dehydrated:null,!h)throw Error(n(317));e:{for(h=h.nextSibling,p=0;h;){if(h.nodeType===8)if(v=h.data,v==="/$"){if(p===0){Ws=zu(h.nextSibling);break e}p--}else v!=="$"&&v!=="$!"&&v!=="$?"||p++;h=h.nextSibling}Ws=null}}else p===27?(p=Ws,bd(h.type)?(h=AN,AN=null,Ws=h):Ws=p):Ws=qr?zu(h.stateNode.nextSibling):null;return!0}function Yf(){Ws=qr=null,ss=!1}function hs(){var h=oo;return h!==null&&(nn===null?nn=h:nn.push.apply(nn,h),oo=null),h}function Ah(h){oo===null?oo=[h]:oo.push(h)}var Dv=ne(null),Cc=null,Mu=null;function Ec(h,p,v){ue(Dv,p._currentValue),p._currentValue=v}function Nu(h){h._currentValue=Dv.current,oe(Dv)}function Ov(h,p,v){for(;h!==null;){var A=h.alternate;if((h.childLanes&p)!==p?(h.childLanes|=p,A!==null&&(A.childLanes|=p)):A!==null&&(A.childLanes&p)!==p&&(A.childLanes|=p),h===v)break;h=h.return}}function tm(h,p,v,A){var M=h.child;for(M!==null&&(M.return=h);M!==null;){var B=M.dependencies;if(B!==null){var H=M.child;B=B.firstContext;e:for(;B!==null;){var Z=B;B=M;for(var he=0;he<p.length;he++)if(Z.context===p[he]){B.lanes|=v,Z=B.alternate,Z!==null&&(Z.lanes|=v),Ov(B.return,v,h),A||(H=null);break e}B=Z.next}}else if(M.tag===18){if(H=M.return,H===null)throw Error(n(341));H.lanes|=v,B=H.alternate,B!==null&&(B.lanes|=v),Ov(H,v,h),H=null}else H=M.child;if(H!==null)H.return=M;else for(H=M;H!==null;){if(H===h){H=null;break}if(M=H.sibling,M!==null){M.return=H.return,H=M;break}H=H.return}M=H}}function lo(h,p,v,A){h=null;for(var M=p,B=!1;M!==null;){if(!B){if((M.flags&524288)!==0)B=!0;else if((M.flags&262144)!==0)break}if(M.tag===10){var H=M.alternate;if(H===null)throw Error(n(387));if(H=H.memoizedProps,H!==null){var Z=M.type;la(M.pendingProps.value,H.value)||(h!==null?h.push(Z):h=[Z])}}else if(M===Be.current){if(H=M.alternate,H===null)throw Error(n(387));H.memoizedState.memoizedState!==M.memoizedState.memoizedState&&(h!==null?h.push(d1):h=[d1])}M=M.return}h!==null&&tm(p,h,v,A),p.flags|=262144}function nm(h){for(h=h.firstContext;h!==null;){if(!la(h.context._currentValue,h.memoizedValue))return!0;h=h.next}return!1}function Dl(h){Cc=h,Mu=null,h=h.dependencies,h!==null&&(h.firstContext=null)}function Ys(h){return M0(Cc,h)}function sm(h,p){return Cc===null&&Dl(h),M0(h,p)}function M0(h,p){var v=p._currentValue;if(p={context:p,memoizedValue:v,next:null},Mu===null){if(h===null)throw Error(n(308));Mu=p,h.dependencies={lanes:0,firstContext:p},h.flags|=524288}else Mu=Mu.next=p;return v}var Bv=typeof AbortController<"u"?AbortController:function(){var h=[],p=this.signal={aborted:!1,addEventListener:function(v,A){h.push(A)}};this.abort=function(){p.aborted=!0,h.forEach(function(v){return v()})}},eN=s.unstable_scheduleCallback,tA=s.unstable_NormalPriority,Si={$$typeof:E,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function N0(){return{controller:new Bv,data:new Map,refCount:0}}function Jf(h){h.refCount--,h.refCount===0&&eN(tA,function(){h.controller.abort()})}var Zf=null,im=0,yn=0,Qf=null;function La(h,p){if(Zf===null){var v=Zf=[];im=0,yn=cN(),Qf={status:"pending",value:void 0,then:function(A){v.push(A)}}}return im++,p.then(R0,R0),p}function R0(){if(--im===0&&Zf!==null){Qf!==null&&(Qf.status="fulfilled");var h=Zf;Zf=null,yn=0,Qf=null;for(var p=0;p<h.length;p++)(0,h[p])()}}function tN(h,p){var v=[],A={status:"pending",value:null,reason:null,then:function(M){v.push(M)}};return h.then(function(){A.status="fulfilled",A.value=p;for(var M=0;M<v.length;M++)(0,v[M])(p)},function(M){for(A.status="rejected",A.reason=M,M=0;M<v.length;M++)(0,v[M])(void 0)}),A}var rm=$.S;$.S=function(h,p){typeof p=="object"&&p!==null&&typeof p.then=="function"&&La(h,p),rm!==null&&rm(h,p)};var uo=ne(null);function Mc(){var h=uo.current;return h!==null?h:pn.pooledCache}function am(h,p){p===null?ue(uo,uo.current):ue(uo,p.pool)}function I0(){var h=Mc();return h===null?null:{parent:Si._currentValue,pool:h}}var om=Error(n(460)),kv=Error(n(474)),Yo=Error(n(542)),lm={then:function(){}};function D0(h){return h=h.status,h==="fulfilled"||h==="rejected"}function ed(){}function O0(h,p,v){switch(v=h[v],v===void 0?h.push(p):v!==p&&(p.then(ed,ed),p=v),p.status){case"fulfilled":return p.value;case"rejected":throw h=p.reason,nA(h),h;default:if(typeof p.status=="string")p.then(ed,ed);else{if(h=pn,h!==null&&100<h.shellSuspendCounter)throw Error(n(482));h=p,h.status="pending",h.then(function(A){if(p.status==="pending"){var M=p;M.status="fulfilled",M.value=A}},function(A){if(p.status==="pending"){var M=p;M.status="rejected",M.reason=A}})}switch(p.status){case"fulfilled":return p.value;case"rejected":throw h=p.reason,nA(h),h}throw co=p,om}}var co=null;function Lv(){if(co===null)throw Error(n(459));var h=co;return co=null,h}function nA(h){if(h===om||h===Yo)throw Error(n(483))}var Ru=!1;function Fv(h){h.updateQueue={baseState:h.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function cn(h,p){h=h.updateQueue,p.updateQueue===h&&(p.updateQueue={baseState:h.baseState,firstBaseUpdate:h.firstBaseUpdate,lastBaseUpdate:h.lastBaseUpdate,shared:h.shared,callbacks:null})}function Ol(h){return{lane:h,tag:0,payload:null,callback:null,next:null}}function Iu(h,p,v){var A=h.updateQueue;if(A===null)return null;if(A=A.shared,(fs&2)!==0){var M=A.pending;return M===null?p.next=p:(p.next=M.next,M.next=p),A.pending=p,p=qf(h),Cv(h,null,v),p}return _c(h,A,p,v),qf(h)}function Th(h,p,v){if(p=p.updateQueue,p!==null&&(p=p.shared,(v&4194048)!==0)){var A=p.lanes;A&=h.pendingLanes,v|=A,p.lanes=v,Kt(h,v)}}function td(h,p){var v=h.updateQueue,A=h.alternate;if(A!==null&&(A=A.updateQueue,v===A)){var M=null,B=null;if(v=v.firstBaseUpdate,v!==null){do{var H={lane:v.lane,tag:v.tag,payload:v.payload,callback:null,next:null};B===null?M=B=H:B=B.next=H,v=v.next}while(v!==null);B===null?M=B=p:B=B.next=p}else M=B=p;v={baseState:A.baseState,firstBaseUpdate:M,lastBaseUpdate:B,shared:A.shared,callbacks:A.callbacks},h.updateQueue=v;return}h=v.lastBaseUpdate,h===null?v.firstBaseUpdate=p:h.next=p,v.lastBaseUpdate=p}var Pv=!1;function um(){if(Pv){var h=Qf;if(h!==null)throw h}}function nd(h,p,v,A){Pv=!1;var M=h.updateQueue;Ru=!1;var B=M.firstBaseUpdate,H=M.lastBaseUpdate,Z=M.shared.pending;if(Z!==null){M.shared.pending=null;var he=Z,De=he.next;he.next=null,H===null?B=De:H.next=De,H=he;var et=h.alternate;et!==null&&(et=et.updateQueue,Z=et.lastBaseUpdate,Z!==H&&(Z===null?et.firstBaseUpdate=De:Z.next=De,et.lastBaseUpdate=he))}if(B!==null){var st=M.baseState;H=0,et=De=he=null,Z=B;do{var Le=Z.lane&-536870913,He=Le!==Z.lane;if(He?(en&Le)===Le:(A&Le)===Le){Le!==0&&Le===yn&&(Pv=!0),et!==null&&(et=et.next={lane:0,tag:Z.tag,payload:Z.payload,callback:null,next:null});e:{var fn=h,on=Z;Le=p;var Ds=v;switch(on.tag){case 1:if(fn=on.payload,typeof fn=="function"){st=fn.call(Ds,st,Le);break e}st=fn;break e;case 3:fn.flags=fn.flags&-65537|128;case 0:if(fn=on.payload,Le=typeof fn=="function"?fn.call(Ds,st,Le):fn,Le==null)break e;st=c({},st,Le);break e;case 2:Ru=!0}}Le=Z.callback,Le!==null&&(h.flags|=64,He&&(h.flags|=8192),He=M.callbacks,He===null?M.callbacks=[Le]:He.push(Le))}else He={lane:Le,tag:Z.tag,payload:Z.payload,callback:Z.callback,next:null},et===null?(De=et=He,he=st):et=et.next=He,H|=Le;if(Z=Z.next,Z===null){if(Z=M.shared.pending,Z===null)break;He=Z,Z=He.next,He.next=null,M.lastBaseUpdate=He,M.shared.pending=null}}while(!0);et===null&&(he=st),M.baseState=he,M.firstBaseUpdate=De,M.lastBaseUpdate=et,B===null&&(M.shared.lanes=0),il|=H,h.lanes=H,h.memoizedState=st}}function sd(h,p){if(typeof h!="function")throw Error(n(191,h));h.call(p)}function sA(h,p){var v=h.callbacks;if(v!==null)for(h.callbacks=null,h=0;h<v.length;h++)sd(v[h],p)}var id=ne(null),B0=ne(0);function iA(h,p){h=yo,ue(B0,h),ue(id,p),yo=h|p.baseLanes}function Uv(){ue(B0,yo),ue(id,id.current)}function cm(){yo=B0.current,oe(id),oe(B0)}var Du=0,xn=null,ms=null,Ai=null,k0=!1,Nc=!1,jr=!1,Bi=0,ho=0,pr=null,rA=0;function oi(){throw Error(n(321))}function Er(h,p){if(p===null)return!1;for(var v=0;v<p.length&&v<h.length;v++)if(!la(h[v],p[v]))return!1;return!0}function Ou(h,p,v,A,M,B){return Du=B,xn=p,p.memoizedState=null,p.updateQueue=null,p.lanes=0,$.H=h===null||h.memoizedState===null?V0:t1,jr=!1,B=v(A,M),jr=!1,Nc&&(B=oA(p,v,A,M)),aA(h),B}function aA(h){$.H=dm;var p=ms!==null&&ms.next!==null;if(Du=0,Ai=ms=xn=null,k0=!1,ho=0,pr=null,p)throw Error(n(300));h===null||Xi||(h=h.dependencies,h!==null&&nm(h)&&(Xi=!0))}function oA(h,p,v,A){xn=h;var M=0;do{if(Nc&&(pr=null),ho=0,Nc=!1,25<=M)throw Error(n(301));if(M+=1,Ai=ms=null,h.updateQueue!=null){var B=h.updateQueue;B.lastEffect=null,B.events=null,B.stores=null,B.memoCache!=null&&(B.memoCache.index=0)}$.H=OA,B=p(v,A)}while(Nc);return B}function nN(){var h=$.H,p=h.useState()[0];return p=typeof p.then=="function"?Jo(p):p,h=h.useState()[0],(ms!==null?ms.memoizedState:null)!==h&&(xn.flags|=1024),p}function $v(){var h=Bi!==0;return Bi=0,h}function L0(h,p,v){p.updateQueue=h.updateQueue,p.flags&=-2053,h.lanes&=~v}function zv(h){if(k0){for(h=h.memoizedState;h!==null;){var p=h.queue;p!==null&&(p.pending=null),h=h.next}k0=!1}Du=0,Ai=ms=xn=null,Nc=!1,ho=Bi=0,pr=null}function Kr(){var h={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ai===null?xn.memoizedState=Ai=h:Ai=Ai.next=h,Ai}function Ti(){if(ms===null){var h=xn.alternate;h=h!==null?h.memoizedState:null}else h=ms.next;var p=Ai===null?xn.memoizedState:Ai.next;if(p!==null)Ai=p,ms=h;else{if(h===null)throw xn.alternate===null?Error(n(467)):Error(n(310));ms=h,h={memoizedState:ms.memoizedState,baseState:ms.baseState,baseQueue:ms.baseQueue,queue:ms.queue,next:null},Ai===null?xn.memoizedState=Ai=h:Ai=Ai.next=h}return Ai}function Rc(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Jo(h){var p=ho;return ho+=1,pr===null&&(pr=[]),h=O0(pr,h,p),p=xn,(Ai===null?p.memoizedState:Ai.next)===null&&(p=p.alternate,$.H=p===null||p.memoizedState===null?V0:t1),h}function F0(h){if(h!==null&&typeof h=="object"){if(typeof h.then=="function")return Jo(h);if(h.$$typeof===E)return Ys(h)}throw Error(n(438,String(h)))}function Gv(h){var p=null,v=xn.updateQueue;if(v!==null&&(p=v.memoCache),p==null){var A=xn.alternate;A!==null&&(A=A.updateQueue,A!==null&&(A=A.memoCache,A!=null&&(p={data:A.data.map(function(M){return M.slice()}),index:0})))}if(p==null&&(p={data:[],index:0}),v===null&&(v=Rc(),xn.updateQueue=v),v.memoCache=p,v=p.data[p.index],v===void 0)for(v=p.data[p.index]=Array(h),A=0;A<h;A++)v[A]=O;return p.index++,v}function Bu(h,p){return typeof p=="function"?p(h):p}function Ic(h){var p=Ti();return Hv(p,ms,h)}function Hv(h,p,v){var A=h.queue;if(A===null)throw Error(n(311));A.lastRenderedReducer=v;var M=h.baseQueue,B=A.pending;if(B!==null){if(M!==null){var H=M.next;M.next=B.next,B.next=H}p.baseQueue=M=B,A.pending=null}if(B=h.baseState,M===null)h.memoizedState=B;else{p=M.next;var Z=H=null,he=null,De=p,et=!1;do{var st=De.lane&-536870913;if(st!==De.lane?(en&st)===st:(Du&st)===st){var Le=De.revertLane;if(Le===0)he!==null&&(he=he.next={lane:0,revertLane:0,action:De.action,hasEagerState:De.hasEagerState,eagerState:De.eagerState,next:null}),st===yn&&(et=!0);else if((Du&Le)===Le){De=De.next,Le===yn&&(et=!0);continue}else st={lane:0,revertLane:De.revertLane,action:De.action,hasEagerState:De.hasEagerState,eagerState:De.eagerState,next:null},he===null?(Z=he=st,H=B):he=he.next=st,xn.lanes|=Le,il|=Le;st=De.action,jr&&v(B,st),B=De.hasEagerState?De.eagerState:v(B,st)}else Le={lane:st,revertLane:De.revertLane,action:De.action,hasEagerState:De.hasEagerState,eagerState:De.eagerState,next:null},he===null?(Z=he=Le,H=B):he=he.next=Le,xn.lanes|=st,il|=st;De=De.next}while(De!==null&&De!==p);if(he===null?H=B:he.next=Z,!la(B,h.memoizedState)&&(Xi=!0,et&&(v=Qf,v!==null)))throw v;h.memoizedState=B,h.baseState=H,h.baseQueue=he,A.lastRenderedState=B}return M===null&&(A.lanes=0),[h.memoizedState,A.dispatch]}function Vv(h){var p=Ti(),v=p.queue;if(v===null)throw Error(n(311));v.lastRenderedReducer=h;var A=v.dispatch,M=v.pending,B=p.memoizedState;if(M!==null){v.pending=null;var H=M=M.next;do B=h(B,H.action),H=H.next;while(H!==M);la(B,p.memoizedState)||(Xi=!0),p.memoizedState=B,p.baseQueue===null&&(p.baseState=B),v.lastRenderedState=B}return[B,A]}function lA(h,p,v){var A=xn,M=Ti(),B=ss;if(B){if(v===void 0)throw Error(n(407));v=v()}else v=p();var H=!la((ms||M).memoizedState,v);H&&(M.memoizedState=v,Xi=!0),M=M.queue;var Z=cA.bind(null,A,M,h);if(od(2048,8,Z,[h]),M.getSnapshot!==p||H||Ai!==null&&Ai.memoizedState.tag&1){if(A.flags|=2048,ad(9,hm(),uA.bind(null,A,M,v,p),null),pn===null)throw Error(n(349));B||(Du&124)!==0||rd(A,p,v)}return v}function rd(h,p,v){h.flags|=16384,h={getSnapshot:p,value:v},p=xn.updateQueue,p===null?(p=Rc(),xn.updateQueue=p,p.stores=[h]):(v=p.stores,v===null?p.stores=[h]:v.push(h))}function uA(h,p,v,A){p.value=v,p.getSnapshot=A,hA(p)&&fA(h)}function cA(h,p,v){return v(function(){hA(p)&&fA(h)})}function hA(h){var p=h.getSnapshot;h=h.value;try{var v=p();return!la(h,v)}catch{return!0}}function fA(h){var p=Cu(h,2);p!==null&&Zr(p,h,2)}function Wv(h){var p=Kr();if(typeof h=="function"){var v=h;if(h=v(),jr){at(!0);try{v()}finally{at(!1)}}}return p.memoizedState=p.baseState=h,p.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Bu,lastRenderedState:h},p}function dA(h,p,v,A){return h.baseState=v,Hv(h,ms,typeof A=="function"?A:Bu)}function sN(h,p,v,A,M){if(H0(h))throw Error(n(485));if(h=p.action,h!==null){var B={payload:M,action:h,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(H){B.listeners.push(H)}};$.T!==null?v(!0):B.isTransition=!1,A(B),v=p.pending,v===null?(B.next=p.pending=B,pA(p,B)):(B.next=v.next,p.pending=v.next=B)}}function pA(h,p){var v=p.action,A=p.payload,M=h.state;if(p.isTransition){var B=$.T,H={};$.T=H;try{var Z=v(M,A),he=$.S;he!==null&&he(H,Z),mA(h,p,Z)}catch(De){Xv(h,p,De)}finally{$.T=B}}else try{B=v(M,A),mA(h,p,B)}catch(De){Xv(h,p,De)}}function mA(h,p,v){v!==null&&typeof v=="object"&&typeof v.then=="function"?v.then(function(A){gA(h,p,A)},function(A){return Xv(h,p,A)}):gA(h,p,v)}function gA(h,p,v){p.status="fulfilled",p.value=v,yA(p),h.state=v,p=h.pending,p!==null&&(v=p.next,v===p?h.pending=null:(v=v.next,p.next=v,pA(h,v)))}function Xv(h,p,v){var A=h.pending;if(h.pending=null,A!==null){A=A.next;do p.status="rejected",p.reason=v,yA(p),p=p.next;while(p!==A)}h.action=null}function yA(h){h=h.listeners;for(var p=0;p<h.length;p++)(0,h[p])()}function qv(h,p){return p}function xA(h,p){if(ss){var v=pn.formState;if(v!==null){e:{var A=xn;if(ss){if(Ws){t:{for(var M=Ws,B=ka;M.nodeType!==8;){if(!B){M=null;break t}if(M=zu(M.nextSibling),M===null){M=null;break t}}B=M.data,M=B==="F!"||B==="F"?M:null}if(M){Ws=zu(M.nextSibling),A=M.data==="F!";break e}}wc(A)}A=!1}A&&(p=v[0])}}return v=Kr(),v.memoizedState=v.baseState=p,A={pending:null,lanes:0,dispatch:null,lastRenderedReducer:qv,lastRenderedState:p},v.queue=A,v=IA.bind(null,xn,A),A.dispatch=v,A=Wv(!1),B=G0.bind(null,xn,!1,A.queue),A=Kr(),M={state:p,dispatch:null,action:h,pending:null},A.queue=M,v=sN.bind(null,xn,M,B,v),M.dispatch=v,A.memoizedState=h,[p,v,!1]}function vA(h){var p=Ti();return bA(p,ms,h)}function bA(h,p,v){if(p=Hv(h,p,qv)[0],h=Ic(Bu)[0],typeof p=="object"&&p!==null&&typeof p.then=="function")try{var A=Jo(p)}catch(H){throw H===om?Yo:H}else A=p;p=Ti();var M=p.queue,B=M.dispatch;return v!==p.memoizedState&&(xn.flags|=2048,ad(9,hm(),iN.bind(null,M,v),null)),[A,B,h]}function iN(h,p){h.action=p}function _A(h){var p=Ti(),v=ms;if(v!==null)return bA(p,v,h);Ti(),p=p.memoizedState,v=Ti();var A=v.queue.dispatch;return v.memoizedState=h,[p,A,!1]}function ad(h,p,v,A){return h={tag:h,create:v,deps:A,inst:p,next:null},p=xn.updateQueue,p===null&&(p=Rc(),xn.updateQueue=p),v=p.lastEffect,v===null?p.lastEffect=h.next=h:(A=v.next,v.next=h,h.next=A,p.lastEffect=h),h}function hm(){return{destroy:void 0,resource:void 0}}function jv(){return Ti().memoizedState}function P0(h,p,v,A){var M=Kr();A=A===void 0?null:A,xn.flags|=h,M.memoizedState=ad(1|p,hm(),v,A)}function od(h,p,v,A){var M=Ti();A=A===void 0?null:A;var B=M.memoizedState.inst;ms!==null&&A!==null&&Er(A,ms.memoizedState.deps)?M.memoizedState=ad(p,B,v,A):(xn.flags|=h,M.memoizedState=ad(1|p,B,v,A))}function Kv(h,p){P0(8390656,8,h,p)}function Yv(h,p){od(2048,8,h,p)}function U0(h,p){return od(4,2,h,p)}function $0(h,p){return od(4,4,h,p)}function SA(h,p){if(typeof p=="function"){h=h();var v=p(h);return function(){typeof v=="function"?v():p(null)}}if(p!=null)return h=h(),p.current=h,function(){p.current=null}}function AA(h,p,v){v=v!=null?v.concat([h]):null,od(4,4,SA.bind(null,p,h),v)}function Jv(){}function TA(h,p){var v=Ti();p=p===void 0?null:p;var A=v.memoizedState;return p!==null&&Er(p,A[1])?A[0]:(v.memoizedState=[h,p],h)}function Zv(h,p){var v=Ti();p=p===void 0?null:p;var A=v.memoizedState;if(p!==null&&Er(p,A[1]))return A[0];if(A=h(),jr){at(!0);try{h()}finally{at(!1)}}return v.memoizedState=[A,p],A}function z0(h,p,v){return v===void 0||(Du&1073741824)!==0?h.memoizedState=p:(h.memoizedState=v,h=ty(),xn.lanes|=h,il|=h,v)}function wA(h,p,v,A){return la(v,p)?v:id.current!==null?(h=z0(h,v,A),la(h,p)||(Xi=!0),h):(Du&42)===0?(Xi=!0,h.memoizedState=v):(h=ty(),xn.lanes|=h,il|=h,p)}function CA(h,p,v,A,M){var B=W.p;W.p=B!==0&&8>B?B:8;var H=$.T,Z={};$.T=Z,G0(h,!1,p,v);try{var he=M(),De=$.S;if(De!==null&&De(Z,he),he!==null&&typeof he=="object"&&typeof he.then=="function"){var et=tN(he,A);fm(h,p,et,Qs(h))}else fm(h,p,A,Qs(h))}catch(st){fm(h,p,{then:function(){},status:"rejected",reason:st},Qs())}finally{W.p=B,$.T=H}}function rN(){}function Qv(h,p,v,A){if(h.tag!==5)throw Error(n(476));var M=EA(h).queue;CA(h,M,p,V,v===null?rN:function(){return MA(h),v(A)})}function EA(h){var p=h.memoizedState;if(p!==null)return p;p={memoizedState:V,baseState:V,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Bu,lastRenderedState:V},next:null};var v={};return p.next={memoizedState:v,baseState:v,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Bu,lastRenderedState:v},next:null},h.memoizedState=p,h=h.alternate,h!==null&&(h.memoizedState=p),p}function MA(h){var p=EA(h).next.queue;fm(h,p,{},Qs())}function e1(){return Ys(d1)}function NA(){return Ti().memoizedState}function RA(){return Ti().memoizedState}function aN(h){for(var p=h.return;p!==null;){switch(p.tag){case 24:case 3:var v=Qs();h=Ol(v);var A=Iu(p,h,v);A!==null&&(Zr(A,p,v),Th(A,p,v)),p={cache:N0()},h.payload=p;return}p=p.return}}function oN(h,p,v){var A=Qs();v={lane:A,revertLane:0,action:v,hasEagerState:!1,eagerState:null,next:null},H0(h)?DA(p,v):(v=T0(h,p,v,A),v!==null&&(Zr(v,h,A),Fa(v,p,A)))}function IA(h,p,v){var A=Qs();fm(h,p,v,A)}function fm(h,p,v,A){var M={lane:A,revertLane:0,action:v,hasEagerState:!1,eagerState:null,next:null};if(H0(h))DA(p,M);else{var B=h.alternate;if(h.lanes===0&&(B===null||B.lanes===0)&&(B=p.lastRenderedReducer,B!==null))try{var H=p.lastRenderedState,Z=B(H,v);if(M.hasEagerState=!0,M.eagerState=Z,la(Z,H))return _c(h,p,M,0),pn===null&&Jp(),!1}catch{}finally{}if(v=T0(h,p,M,A),v!==null)return Zr(v,h,A),Fa(v,p,A),!0}return!1}function G0(h,p,v,A){if(A={lane:2,revertLane:cN(),action:A,hasEagerState:!1,eagerState:null,next:null},H0(h)){if(p)throw Error(n(479))}else p=T0(h,v,A,2),p!==null&&Zr(p,h,2)}function H0(h){var p=h.alternate;return h===xn||p!==null&&p===xn}function DA(h,p){Nc=k0=!0;var v=h.pending;v===null?p.next=p:(p.next=v.next,v.next=p),h.pending=p}function Fa(h,p,v){if((v&4194048)!==0){var A=p.lanes;A&=h.pendingLanes,v|=A,p.lanes=v,Kt(h,v)}}var dm={readContext:Ys,use:F0,useCallback:oi,useContext:oi,useEffect:oi,useImperativeHandle:oi,useLayoutEffect:oi,useInsertionEffect:oi,useMemo:oi,useReducer:oi,useRef:oi,useState:oi,useDebugValue:oi,useDeferredValue:oi,useTransition:oi,useSyncExternalStore:oi,useId:oi,useHostTransitionStatus:oi,useFormState:oi,useActionState:oi,useOptimistic:oi,useMemoCache:oi,useCacheRefresh:oi},V0={readContext:Ys,use:F0,useCallback:function(h,p){return Kr().memoizedState=[h,p===void 0?null:p],h},useContext:Ys,useEffect:Kv,useImperativeHandle:function(h,p,v){v=v!=null?v.concat([h]):null,P0(4194308,4,SA.bind(null,p,h),v)},useLayoutEffect:function(h,p){return P0(4194308,4,h,p)},useInsertionEffect:function(h,p){P0(4,2,h,p)},useMemo:function(h,p){var v=Kr();p=p===void 0?null:p;var A=h();if(jr){at(!0);try{h()}finally{at(!1)}}return v.memoizedState=[A,p],A},useReducer:function(h,p,v){var A=Kr();if(v!==void 0){var M=v(p);if(jr){at(!0);try{v(p)}finally{at(!1)}}}else M=p;return A.memoizedState=A.baseState=M,h={pending:null,lanes:0,dispatch:null,lastRenderedReducer:h,lastRenderedState:M},A.queue=h,h=h.dispatch=oN.bind(null,xn,h),[A.memoizedState,h]},useRef:function(h){var p=Kr();return h={current:h},p.memoizedState=h},useState:function(h){h=Wv(h);var p=h.queue,v=IA.bind(null,xn,p);return p.dispatch=v,[h.memoizedState,v]},useDebugValue:Jv,useDeferredValue:function(h,p){var v=Kr();return z0(v,h,p)},useTransition:function(){var h=Wv(!1);return h=CA.bind(null,xn,h.queue,!0,!1),Kr().memoizedState=h,[!1,h]},useSyncExternalStore:function(h,p,v){var A=xn,M=Kr();if(ss){if(v===void 0)throw Error(n(407));v=v()}else{if(v=p(),pn===null)throw Error(n(349));(en&124)!==0||rd(A,p,v)}M.memoizedState=v;var B={value:v,getSnapshot:p};return M.queue=B,Kv(cA.bind(null,A,B,h),[h]),A.flags|=2048,ad(9,hm(),uA.bind(null,A,B,v,p),null),v},useId:function(){var h=Kr(),p=pn.identifierPrefix;if(ss){var v=Il,A=Rl;v=(A&~(1<<32-gt(A)-1)).toString(32)+v,p="«"+p+"R"+v,v=Bi++,0<v&&(p+="H"+v.toString(32)),p+="»"}else v=rA++,p="«"+p+"r"+v.toString(32)+"»";return h.memoizedState=p},useHostTransitionStatus:e1,useFormState:xA,useActionState:xA,useOptimistic:function(h){var p=Kr();p.memoizedState=p.baseState=h;var v={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return p.queue=v,p=G0.bind(null,xn,!0,v),v.dispatch=p,[h,p]},useMemoCache:Gv,useCacheRefresh:function(){return Kr().memoizedState=aN.bind(null,xn)}},t1={readContext:Ys,use:F0,useCallback:TA,useContext:Ys,useEffect:Yv,useImperativeHandle:AA,useInsertionEffect:U0,useLayoutEffect:$0,useMemo:Zv,useReducer:Ic,useRef:jv,useState:function(){return Ic(Bu)},useDebugValue:Jv,useDeferredValue:function(h,p){var v=Ti();return wA(v,ms.memoizedState,h,p)},useTransition:function(){var h=Ic(Bu)[0],p=Ti().memoizedState;return[typeof h=="boolean"?h:Jo(h),p]},useSyncExternalStore:lA,useId:NA,useHostTransitionStatus:e1,useFormState:vA,useActionState:vA,useOptimistic:function(h,p){var v=Ti();return dA(v,ms,h,p)},useMemoCache:Gv,useCacheRefresh:RA},OA={readContext:Ys,use:F0,useCallback:TA,useContext:Ys,useEffect:Yv,useImperativeHandle:AA,useInsertionEffect:U0,useLayoutEffect:$0,useMemo:Zv,useReducer:Vv,useRef:jv,useState:function(){return Vv(Bu)},useDebugValue:Jv,useDeferredValue:function(h,p){var v=Ti();return ms===null?z0(v,h,p):wA(v,ms.memoizedState,h,p)},useTransition:function(){var h=Vv(Bu)[0],p=Ti().memoizedState;return[typeof h=="boolean"?h:Jo(h),p]},useSyncExternalStore:lA,useId:NA,useHostTransitionStatus:e1,useFormState:_A,useActionState:_A,useOptimistic:function(h,p){var v=Ti();return ms!==null?dA(v,ms,h,p):(v.baseState=h,[h,v.queue.dispatch])},useMemoCache:Gv,useCacheRefresh:RA},wh=null,pm=0;function mm(h){var p=pm;return pm+=1,wh===null&&(wh=[]),O0(wh,h,p)}function ld(h,p){p=p.props.ref,h.ref=p!==void 0?p:null}function W0(h,p){throw p.$$typeof===f?Error(n(525)):(h=Object.prototype.toString.call(p),Error(n(31,h==="[object Object]"?"object with keys {"+Object.keys(p).join(", ")+"}":h)))}function BA(h){var p=h._init;return p(h._payload)}function kA(h){function p(Ce,_e){if(h){var Re=Ce.deletions;Re===null?(Ce.deletions=[_e],Ce.flags|=16):Re.push(_e)}}function v(Ce,_e){if(!h)return null;for(;_e!==null;)p(Ce,_e),_e=_e.sibling;return null}function A(Ce){for(var _e=new Map;Ce!==null;)Ce.key!==null?_e.set(Ce.key,Ce):_e.set(Ce.index,Ce),Ce=Ce.sibling;return _e}function M(Ce,_e){return Ce=ai(Ce,_e),Ce.index=0,Ce.sibling=null,Ce}function B(Ce,_e,Re){return Ce.index=Re,h?(Re=Ce.alternate,Re!==null?(Re=Re.index,Re<_e?(Ce.flags|=67108866,_e):Re):(Ce.flags|=67108866,_e)):(Ce.flags|=1048576,_e)}function H(Ce){return h&&Ce.alternate===null&&(Ce.flags|=67108866),Ce}function Z(Ce,_e,Re,nt){return _e===null||_e.tag!==6?(_e=Qp(Re,Ce.mode,nt),_e.return=Ce,_e):(_e=M(_e,Re),_e.return=Ce,_e)}function he(Ce,_e,Re,nt){var Gt=Re.type;return Gt===x?et(Ce,_e,Re.props.children,nt,Re.key):_e!==null&&(_e.elementType===Gt||typeof Gt=="object"&&Gt!==null&&Gt.$$typeof===P&&BA(Gt)===_e.type)?(_e=M(_e,Re.props),ld(_e,Re),_e.return=Ce,_e):(_e=Wi(Re.type,Re.key,Re.props,null,Ce.mode,nt),ld(_e,Re),_e.return=Ce,_e)}function De(Ce,_e,Re,nt){return _e===null||_e.tag!==4||_e.stateNode.containerInfo!==Re.containerInfo||_e.stateNode.implementation!==Re.implementation?(_e=w0(Re,Ce.mode,nt),_e.return=Ce,_e):(_e=M(_e,Re.children||[]),_e.return=Ce,_e)}function et(Ce,_e,Re,nt,Gt){return _e===null||_e.tag!==7?(_e=Ac(Re,Ce.mode,nt,Gt),_e.return=Ce,_e):(_e=M(_e,Re),_e.return=Ce,_e)}function st(Ce,_e,Re){if(typeof _e=="string"&&_e!==""||typeof _e=="number"||typeof _e=="bigint")return _e=Qp(""+_e,Ce.mode,Re),_e.return=Ce,_e;if(typeof _e=="object"&&_e!==null){switch(_e.$$typeof){case d:return Re=Wi(_e.type,_e.key,_e.props,null,Ce.mode,Re),ld(Re,_e),Re.return=Ce,Re;case g:return _e=w0(_e,Ce.mode,Re),_e.return=Ce,_e;case P:var nt=_e._init;return _e=nt(_e._payload),st(Ce,_e,Re)}if(Y(_e)||X(_e))return _e=Ac(_e,Ce.mode,Re,null),_e.return=Ce,_e;if(typeof _e.then=="function")return st(Ce,mm(_e),Re);if(_e.$$typeof===E)return st(Ce,sm(Ce,_e),Re);W0(Ce,_e)}return null}function Le(Ce,_e,Re,nt){var Gt=_e!==null?_e.key:null;if(typeof Re=="string"&&Re!==""||typeof Re=="number"||typeof Re=="bigint")return Gt!==null?null:Z(Ce,_e,""+Re,nt);if(typeof Re=="object"&&Re!==null){switch(Re.$$typeof){case d:return Re.key===Gt?he(Ce,_e,Re,nt):null;case g:return Re.key===Gt?De(Ce,_e,Re,nt):null;case P:return Gt=Re._init,Re=Gt(Re._payload),Le(Ce,_e,Re,nt)}if(Y(Re)||X(Re))return Gt!==null?null:et(Ce,_e,Re,nt,null);if(typeof Re.then=="function")return Le(Ce,_e,mm(Re),nt);if(Re.$$typeof===E)return Le(Ce,_e,sm(Ce,Re),nt);W0(Ce,Re)}return null}function He(Ce,_e,Re,nt,Gt){if(typeof nt=="string"&&nt!==""||typeof nt=="number"||typeof nt=="bigint")return Ce=Ce.get(Re)||null,Z(_e,Ce,""+nt,Gt);if(typeof nt=="object"&&nt!==null){switch(nt.$$typeof){case d:return Ce=Ce.get(nt.key===null?Re:nt.key)||null,he(_e,Ce,nt,Gt);case g:return Ce=Ce.get(nt.key===null?Re:nt.key)||null,De(_e,Ce,nt,Gt);case P:var Gn=nt._init;return nt=Gn(nt._payload),He(Ce,_e,Re,nt,Gt)}if(Y(nt)||X(nt))return Ce=Ce.get(Re)||null,et(_e,Ce,nt,Gt,null);if(typeof nt.then=="function")return He(Ce,_e,Re,mm(nt),Gt);if(nt.$$typeof===E)return He(Ce,_e,Re,sm(_e,nt),Gt);W0(_e,nt)}return null}function fn(Ce,_e,Re,nt){for(var Gt=null,Gn=null,Yt=_e,ln=_e=0,Rr=null;Yt!==null&&ln<Re.length;ln++){Yt.index>ln?(Rr=Yt,Yt=null):Rr=Yt.sibling;var ps=Le(Ce,Yt,Re[ln],nt);if(ps===null){Yt===null&&(Yt=Rr);break}h&&Yt&&ps.alternate===null&&p(Ce,Yt),_e=B(ps,_e,ln),Gn===null?Gt=ps:Gn.sibling=ps,Gn=ps,Yt=Rr}if(ln===Re.length)return v(Ce,Yt),ss&&Eu(Ce,ln),Gt;if(Yt===null){for(;ln<Re.length;ln++)Yt=st(Ce,Re[ln],nt),Yt!==null&&(_e=B(Yt,_e,ln),Gn===null?Gt=Yt:Gn.sibling=Yt,Gn=Yt);return ss&&Eu(Ce,ln),Gt}for(Yt=A(Yt);ln<Re.length;ln++)Rr=He(Yt,Ce,ln,Re[ln],nt),Rr!==null&&(h&&Rr.alternate!==null&&Yt.delete(Rr.key===null?ln:Rr.key),_e=B(Rr,_e,ln),Gn===null?Gt=Rr:Gn.sibling=Rr,Gn=Rr);return h&&Yt.forEach(function(wd){return p(Ce,wd)}),ss&&Eu(Ce,ln),Gt}function on(Ce,_e,Re,nt){if(Re==null)throw Error(n(151));for(var Gt=null,Gn=null,Yt=_e,ln=_e=0,Rr=null,ps=Re.next();Yt!==null&&!ps.done;ln++,ps=Re.next()){Yt.index>ln?(Rr=Yt,Yt=null):Rr=Yt.sibling;var wd=Le(Ce,Yt,ps.value,nt);if(wd===null){Yt===null&&(Yt=Rr);break}h&&Yt&&wd.alternate===null&&p(Ce,Yt),_e=B(wd,_e,ln),Gn===null?Gt=wd:Gn.sibling=wd,Gn=wd,Yt=Rr}if(ps.done)return v(Ce,Yt),ss&&Eu(Ce,ln),Gt;if(Yt===null){for(;!ps.done;ln++,ps=Re.next())ps=st(Ce,ps.value,nt),ps!==null&&(_e=B(ps,_e,ln),Gn===null?Gt=ps:Gn.sibling=ps,Gn=ps);return ss&&Eu(Ce,ln),Gt}for(Yt=A(Yt);!ps.done;ln++,ps=Re.next())ps=He(Yt,Ce,ln,ps.value,nt),ps!==null&&(h&&ps.alternate!==null&&Yt.delete(ps.key===null?ln:ps.key),_e=B(ps,_e,ln),Gn===null?Gt=ps:Gn.sibling=ps,Gn=ps);return h&&Yt.forEach(function(tj){return p(Ce,tj)}),ss&&Eu(Ce,ln),Gt}function Ds(Ce,_e,Re,nt){if(typeof Re=="object"&&Re!==null&&Re.type===x&&Re.key===null&&(Re=Re.props.children),typeof Re=="object"&&Re!==null){switch(Re.$$typeof){case d:e:{for(var Gt=Re.key;_e!==null;){if(_e.key===Gt){if(Gt=Re.type,Gt===x){if(_e.tag===7){v(Ce,_e.sibling),nt=M(_e,Re.props.children),nt.return=Ce,Ce=nt;break e}}else if(_e.elementType===Gt||typeof Gt=="object"&&Gt!==null&&Gt.$$typeof===P&&BA(Gt)===_e.type){v(Ce,_e.sibling),nt=M(_e,Re.props),ld(nt,Re),nt.return=Ce,Ce=nt;break e}v(Ce,_e);break}else p(Ce,_e);_e=_e.sibling}Re.type===x?(nt=Ac(Re.props.children,Ce.mode,nt,Re.key),nt.return=Ce,Ce=nt):(nt=Wi(Re.type,Re.key,Re.props,null,Ce.mode,nt),ld(nt,Re),nt.return=Ce,Ce=nt)}return H(Ce);case g:e:{for(Gt=Re.key;_e!==null;){if(_e.key===Gt)if(_e.tag===4&&_e.stateNode.containerInfo===Re.containerInfo&&_e.stateNode.implementation===Re.implementation){v(Ce,_e.sibling),nt=M(_e,Re.children||[]),nt.return=Ce,Ce=nt;break e}else{v(Ce,_e);break}else p(Ce,_e);_e=_e.sibling}nt=w0(Re,Ce.mode,nt),nt.return=Ce,Ce=nt}return H(Ce);case P:return Gt=Re._init,Re=Gt(Re._payload),Ds(Ce,_e,Re,nt)}if(Y(Re))return fn(Ce,_e,Re,nt);if(X(Re)){if(Gt=X(Re),typeof Gt!="function")throw Error(n(150));return Re=Gt.call(Re),on(Ce,_e,Re,nt)}if(typeof Re.then=="function")return Ds(Ce,_e,mm(Re),nt);if(Re.$$typeof===E)return Ds(Ce,_e,sm(Ce,Re),nt);W0(Ce,Re)}return typeof Re=="string"&&Re!==""||typeof Re=="number"||typeof Re=="bigint"?(Re=""+Re,_e!==null&&_e.tag===6?(v(Ce,_e.sibling),nt=M(_e,Re),nt.return=Ce,Ce=nt):(v(Ce,_e),nt=Qp(Re,Ce.mode,nt),nt.return=Ce,Ce=nt),H(Ce)):v(Ce,_e)}return function(Ce,_e,Re,nt){try{pm=0;var Gt=Ds(Ce,_e,Re,nt);return wh=null,Gt}catch(Yt){if(Yt===om||Yt===Yo)throw Yt;var Gn=ha(29,Yt,null,Ce.mode);return Gn.lanes=nt,Gn.return=Ce,Gn}finally{}}}var Ch=kA(!0),LA=kA(!1),Ss=ne(null),Zo=null;function Dc(h){var p=h.alternate;ue(li,li.current&1),ue(Ss,h),Zo===null&&(p===null||id.current!==null||p.memoizedState!==null)&&(Zo=h)}function FA(h){if(h.tag===22){if(ue(li,li.current),ue(Ss,h),Zo===null){var p=h.alternate;p!==null&&p.memoizedState!==null&&(Zo=h)}}else Oc()}function Oc(){ue(li,li.current),ue(Ss,Ss.current)}function Bl(h){oe(Ss),Zo===h&&(Zo=null),oe(li)}var li=ne(0);function ku(h){for(var p=h;p!==null;){if(p.tag===13){var v=p.memoizedState;if(v!==null&&(v=v.dehydrated,v===null||v.data==="$?"||SN(v)))return p}else if(p.tag===19&&p.memoizedProps.revealOrder!==void 0){if((p.flags&128)!==0)return p}else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===h)break;for(;p.sibling===null;){if(p.return===null||p.return===h)return null;p=p.return}p.sibling.return=p.return,p=p.sibling}return null}function Bc(h,p,v,A){p=h.memoizedState,v=v(A,p),v=v==null?p:c({},p,v),h.memoizedState=v,h.lanes===0&&(h.updateQueue.baseState=v)}var Yr={enqueueSetState:function(h,p,v){h=h._reactInternals;var A=Qs(),M=Ol(A);M.payload=p,v!=null&&(M.callback=v),p=Iu(h,M,A),p!==null&&(Zr(p,h,A),Th(p,h,A))},enqueueReplaceState:function(h,p,v){h=h._reactInternals;var A=Qs(),M=Ol(A);M.tag=1,M.payload=p,v!=null&&(M.callback=v),p=Iu(h,M,A),p!==null&&(Zr(p,h,A),Th(p,h,A))},enqueueForceUpdate:function(h,p){h=h._reactInternals;var v=Qs(),A=Ol(v);A.tag=2,p!=null&&(A.callback=p),p=Iu(h,A,v),p!==null&&(Zr(p,h,v),Th(p,h,v))}};function PA(h,p,v,A,M,B,H){return h=h.stateNode,typeof h.shouldComponentUpdate=="function"?h.shouldComponentUpdate(A,B,H):p.prototype&&p.prototype.isPureReactComponent?!jo(v,A)||!jo(M,B):!0}function UA(h,p,v,A){h=p.state,typeof p.componentWillReceiveProps=="function"&&p.componentWillReceiveProps(v,A),typeof p.UNSAFE_componentWillReceiveProps=="function"&&p.UNSAFE_componentWillReceiveProps(v,A),p.state!==h&&Yr.enqueueReplaceState(p,p.state,null)}function kl(h,p){var v=p;if("ref"in p){v={};for(var A in p)A!=="ref"&&(v[A]=p[A])}if(h=h.defaultProps){v===p&&(v=c({},v));for(var M in h)v[M]===void 0&&(v[M]=h[M])}return v}var Eh=typeof reportError=="function"?reportError:function(h){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var p=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof h=="object"&&h!==null&&typeof h.message=="string"?String(h.message):String(h),error:h});if(!window.dispatchEvent(p))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",h);return}console.error(h)};function gm(h){Eh(h)}function X0(h){console.error(h)}function $A(h){Eh(h)}function q0(h,p){try{var v=h.onUncaughtError;v(p.value,{componentStack:p.stack})}catch(A){setTimeout(function(){throw A})}}function fo(h,p,v){try{var A=h.onCaughtError;A(v.value,{componentStack:v.stack,errorBoundary:p.tag===1?p.stateNode:null})}catch(M){setTimeout(function(){throw M})}}function j0(h,p,v){return v=Ol(v),v.tag=3,v.payload={element:null},v.callback=function(){q0(h,p)},v}function zA(h){return h=Ol(h),h.tag=3,h}function K0(h,p,v,A){var M=v.type.getDerivedStateFromError;if(typeof M=="function"){var B=A.value;h.payload=function(){return M(B)},h.callback=function(){fo(p,v,A)}}var H=v.stateNode;H!==null&&typeof H.componentDidCatch=="function"&&(h.callback=function(){fo(p,v,A),typeof M!="function"&&(Wa===null?Wa=new Set([this]):Wa.add(this));var Z=A.stack;this.componentDidCatch(A.value,{componentStack:Z!==null?Z:""})})}function lN(h,p,v,A,M){if(v.flags|=32768,A!==null&&typeof A=="object"&&typeof A.then=="function"){if(p=v.alternate,p!==null&&lo(p,v,M,!0),v=Ss.current,v!==null){switch(v.tag){case 13:return Zo===null?m():v.alternate===null&&ks===0&&(ks=3),v.flags&=-257,v.flags|=65536,v.lanes=M,A===lm?v.flags|=16384:(p=v.updateQueue,p===null?v.updateQueue=new Set([A]):p.add(A),Ve(h,A,M)),!1;case 22:return v.flags|=65536,A===lm?v.flags|=16384:(p=v.updateQueue,p===null?(p={transitions:null,markerInstances:null,retryQueue:new Set([A])},v.updateQueue=p):(v=p.retryQueue,v===null?p.retryQueue=new Set([A]):v.add(A)),Ve(h,A,M)),!1}throw Error(n(435,v.tag))}return Ve(h,A,M),m(),!1}if(ss)return p=Ss.current,p!==null?((p.flags&65536)===0&&(p.flags|=256),p.flags|=65536,p.lanes=M,A!==E0&&(h=Error(n(422),{cause:A}),Ah(fr(h,v)))):(A!==E0&&(p=Error(n(423),{cause:A}),Ah(fr(p,v))),h=h.current.alternate,h.flags|=65536,M&=-M,h.lanes|=M,A=fr(A,v),M=j0(h.stateNode,A,M),td(h,M),ks!==4&&(ks=2)),!1;var B=Error(n(520),{cause:A});if(B=fr(B,v),ds===null?ds=[B]:ds.push(B),ks!==4&&(ks=2),p===null)return!0;A=fr(A,v),v=p;do{switch(v.tag){case 3:return v.flags|=65536,h=M&-M,v.lanes|=h,h=j0(v.stateNode,A,h),td(v,h),!1;case 1:if(p=v.type,B=v.stateNode,(v.flags&128)===0&&(typeof p.getDerivedStateFromError=="function"||B!==null&&typeof B.componentDidCatch=="function"&&(Wa===null||!Wa.has(B))))return v.flags|=65536,M&=-M,v.lanes|=M,M=zA(M),K0(M,h,v,A),td(v,M),!1}v=v.return}while(v!==null);return!1}var GA=Error(n(461)),Xi=!1;function ui(h,p,v,A){p.child=h===null?LA(p,null,v,A):Ch(p,h.child,v,A)}function da(h,p,v,A,M){v=v.render;var B=p.ref;if("ref"in A){var H={};for(var Z in A)Z!=="ref"&&(H[Z]=A[Z])}else H=A;return Dl(p),A=Ou(h,p,v,H,B,M),Z=$v(),h!==null&&!Xi?(L0(h,p,M),qi(h,p,M)):(ss&&Z&&Nv(p),p.flags|=1,ui(h,p,A,M),p.child)}function pa(h,p,v,A,M){if(h===null){var B=v.type;return typeof B=="function"&&!Zp(B)&&B.defaultProps===void 0&&v.compare===null?(p.tag=15,p.type=B,n1(h,p,B,A,M)):(h=Wi(v.type,null,A,p,p.mode,M),h.ref=p.ref,h.return=p,p.child=h)}if(B=h.child,!ym(h,M)){var H=B.memoizedProps;if(v=v.compare,v=v!==null?v:jo,v(H,A)&&h.ref===p.ref)return qi(h,p,M)}return p.flags|=1,h=ai(B,A),h.ref=p.ref,h.return=p,p.child=h}function n1(h,p,v,A,M){if(h!==null){var B=h.memoizedProps;if(jo(B,A)&&h.ref===p.ref)if(Xi=!1,p.pendingProps=A=B,ym(h,M))(h.flags&131072)!==0&&(Xi=!0);else return p.lanes=h.lanes,qi(h,p,M)}return ud(h,p,v,A,M)}function Mh(h,p,v){var A=p.pendingProps,M=A.children,B=h!==null?h.memoizedState:null;if(A.mode==="hidden"){if((p.flags&128)!==0){if(A=B!==null?B.baseLanes|v:v,h!==null){for(M=p.child=h.child,B=0;M!==null;)B=B|M.lanes|M.childLanes,M=M.sibling;p.childLanes=B&~A}else p.childLanes=0,p.child=null;return Nh(h,p,A,v)}if((v&536870912)!==0)p.memoizedState={baseLanes:0,cachePool:null},h!==null&&am(p,B!==null?B.cachePool:null),B!==null?iA(p,B):Uv(),FA(p);else return p.lanes=p.childLanes=536870912,Nh(h,p,B!==null?B.baseLanes|v:v,v)}else B!==null?(am(p,B.cachePool),iA(p,B),Oc(),p.memoizedState=null):(h!==null&&am(p,null),Uv(),Oc());return ui(h,p,M,v),p.child}function Nh(h,p,v,A){var M=Mc();return M=M===null?null:{parent:Si._currentValue,pool:M},p.memoizedState={baseLanes:v,cachePool:M},h!==null&&am(p,null),Uv(),FA(p),h!==null&&lo(h,p,A,!0),null}function Rh(h,p){var v=p.ref;if(v===null)h!==null&&h.ref!==null&&(p.flags|=4194816);else{if(typeof v!="function"&&typeof v!="object")throw Error(n(284));(h===null||h.ref!==v)&&(p.flags|=4194816)}}function ud(h,p,v,A,M){return Dl(p),v=Ou(h,p,v,A,void 0,M),A=$v(),h!==null&&!Xi?(L0(h,p,M),qi(h,p,M)):(ss&&A&&Nv(p),p.flags|=1,ui(h,p,v,M),p.child)}function Pa(h,p,v,A,M,B){return Dl(p),p.updateQueue=null,v=oA(p,A,v,M),aA(h),A=$v(),h!==null&&!Xi?(L0(h,p,B),qi(h,p,B)):(ss&&A&&Nv(p),p.flags|=1,ui(h,p,v,B),p.child)}function Ua(h,p,v,A,M){if(Dl(p),p.stateNode===null){var B=Sc,H=v.contextType;typeof H=="object"&&H!==null&&(B=Ys(H)),B=new v(A,B),p.memoizedState=B.state!==null&&B.state!==void 0?B.state:null,B.updater=Yr,p.stateNode=B,B._reactInternals=p,B=p.stateNode,B.props=A,B.state=p.memoizedState,B.refs={},Fv(p),H=v.contextType,B.context=typeof H=="object"&&H!==null?Ys(H):Sc,B.state=p.memoizedState,H=v.getDerivedStateFromProps,typeof H=="function"&&(Bc(p,v,H,A),B.state=p.memoizedState),typeof v.getDerivedStateFromProps=="function"||typeof B.getSnapshotBeforeUpdate=="function"||typeof B.UNSAFE_componentWillMount!="function"&&typeof B.componentWillMount!="function"||(H=B.state,typeof B.componentWillMount=="function"&&B.componentWillMount(),typeof B.UNSAFE_componentWillMount=="function"&&B.UNSAFE_componentWillMount(),H!==B.state&&Yr.enqueueReplaceState(B,B.state,null),nd(p,A,B,M),um(),B.state=p.memoizedState),typeof B.componentDidMount=="function"&&(p.flags|=4194308),A=!0}else if(h===null){B=p.stateNode;var Z=p.memoizedProps,he=kl(v,Z);B.props=he;var De=B.context,et=v.contextType;H=Sc,typeof et=="object"&&et!==null&&(H=Ys(et));var st=v.getDerivedStateFromProps;et=typeof st=="function"||typeof B.getSnapshotBeforeUpdate=="function",Z=p.pendingProps!==Z,et||typeof B.UNSAFE_componentWillReceiveProps!="function"&&typeof B.componentWillReceiveProps!="function"||(Z||De!==H)&&UA(p,B,A,H),Ru=!1;var Le=p.memoizedState;B.state=Le,nd(p,A,B,M),um(),De=p.memoizedState,Z||Le!==De||Ru?(typeof st=="function"&&(Bc(p,v,st,A),De=p.memoizedState),(he=Ru||PA(p,v,he,A,Le,De,H))?(et||typeof B.UNSAFE_componentWillMount!="function"&&typeof B.componentWillMount!="function"||(typeof B.componentWillMount=="function"&&B.componentWillMount(),typeof B.UNSAFE_componentWillMount=="function"&&B.UNSAFE_componentWillMount()),typeof B.componentDidMount=="function"&&(p.flags|=4194308)):(typeof B.componentDidMount=="function"&&(p.flags|=4194308),p.memoizedProps=A,p.memoizedState=De),B.props=A,B.state=De,B.context=H,A=he):(typeof B.componentDidMount=="function"&&(p.flags|=4194308),A=!1)}else{B=p.stateNode,cn(h,p),H=p.memoizedProps,et=kl(v,H),B.props=et,st=p.pendingProps,Le=B.context,De=v.contextType,he=Sc,typeof De=="object"&&De!==null&&(he=Ys(De)),Z=v.getDerivedStateFromProps,(De=typeof Z=="function"||typeof B.getSnapshotBeforeUpdate=="function")||typeof B.UNSAFE_componentWillReceiveProps!="function"&&typeof B.componentWillReceiveProps!="function"||(H!==st||Le!==he)&&UA(p,B,A,he),Ru=!1,Le=p.memoizedState,B.state=Le,nd(p,A,B,M),um();var He=p.memoizedState;H!==st||Le!==He||Ru||h!==null&&h.dependencies!==null&&nm(h.dependencies)?(typeof Z=="function"&&(Bc(p,v,Z,A),He=p.memoizedState),(et=Ru||PA(p,v,et,A,Le,He,he)||h!==null&&h.dependencies!==null&&nm(h.dependencies))?(De||typeof B.UNSAFE_componentWillUpdate!="function"&&typeof B.componentWillUpdate!="function"||(typeof B.componentWillUpdate=="function"&&B.componentWillUpdate(A,He,he),typeof B.UNSAFE_componentWillUpdate=="function"&&B.UNSAFE_componentWillUpdate(A,He,he)),typeof B.componentDidUpdate=="function"&&(p.flags|=4),typeof B.getSnapshotBeforeUpdate=="function"&&(p.flags|=1024)):(typeof B.componentDidUpdate!="function"||H===h.memoizedProps&&Le===h.memoizedState||(p.flags|=4),typeof B.getSnapshotBeforeUpdate!="function"||H===h.memoizedProps&&Le===h.memoizedState||(p.flags|=1024),p.memoizedProps=A,p.memoizedState=He),B.props=A,B.state=He,B.context=he,A=et):(typeof B.componentDidUpdate!="function"||H===h.memoizedProps&&Le===h.memoizedState||(p.flags|=4),typeof B.getSnapshotBeforeUpdate!="function"||H===h.memoizedProps&&Le===h.memoizedState||(p.flags|=1024),A=!1)}return B=A,Rh(h,p),A=(p.flags&128)!==0,B||A?(B=p.stateNode,v=A&&typeof v.getDerivedStateFromError!="function"?null:B.render(),p.flags|=1,h!==null&&A?(p.child=Ch(p,h.child,null,M),p.child=Ch(p,null,v,M)):ui(h,p,v,M),p.memoizedState=B.state,h=p.child):h=qi(h,p,M),h}function kc(h,p,v,A){return Yf(),p.flags|=256,ui(h,p,v,A),p.child}var Qo={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function el(h){return{baseLanes:h,cachePool:I0()}}function ki(h,p,v){return h=h!==null?h.childLanes&~v:0,p&&(h|=xo),h}function cd(h,p,v){var A=p.pendingProps,M=!1,B=(p.flags&128)!==0,H;if((H=B)||(H=h!==null&&h.memoizedState===null?!1:(li.current&2)!==0),H&&(M=!0,p.flags&=-129),H=(p.flags&32)!==0,p.flags&=-33,h===null){if(ss){if(M?Dc(p):Oc(),ss){var Z=Ws,he;if(he=Z){e:{for(he=Z,Z=ka;he.nodeType!==8;){if(!Z){Z=null;break e}if(he=zu(he.nextSibling),he===null){Z=null;break e}}Z=he}Z!==null?(p.memoizedState={dehydrated:Z,treeContext:Tc!==null?{id:Rl,overflow:Il}:null,retryLane:536870912,hydrationErrors:null},he=ha(18,null,null,0),he.stateNode=Z,he.return=p,p.child=he,qr=p,Ws=null,he=!0):he=!1}he||wc(p)}if(Z=p.memoizedState,Z!==null&&(Z=Z.dehydrated,Z!==null))return SN(Z)?p.lanes=32:p.lanes=536870912,null;Bl(p)}return Z=A.children,A=A.fallback,M?(Oc(),M=p.mode,Z=Ih({mode:"hidden",children:Z},M),A=Ac(A,M,v,null),Z.return=p,A.return=p,Z.sibling=A,p.child=Z,M=p.child,M.memoizedState=el(v),M.childLanes=ki(h,H,v),p.memoizedState=Qo,A):(Dc(p),Ll(p,Z))}if(he=h.memoizedState,he!==null&&(Z=he.dehydrated,Z!==null)){if(B)p.flags&256?(Dc(p),p.flags&=-257,p=mr(h,p,v)):p.memoizedState!==null?(Oc(),p.child=h.child,p.flags|=128,p=null):(Oc(),M=A.fallback,Z=p.mode,A=Ih({mode:"visible",children:A.children},Z),M=Ac(M,Z,v,null),M.flags|=2,A.return=p,M.return=p,A.sibling=M,p.child=A,Ch(p,h.child,null,v),A=p.child,A.memoizedState=el(v),A.childLanes=ki(h,H,v),p.memoizedState=Qo,p=M);else if(Dc(p),SN(Z)){if(H=Z.nextSibling&&Z.nextSibling.dataset,H)var De=H.dgst;H=De,A=Error(n(419)),A.stack="",A.digest=H,Ah({value:A,source:null,stack:null}),p=mr(h,p,v)}else if(Xi||lo(h,p,v,!1),H=(v&h.childLanes)!==0,Xi||H){if(H=pn,H!==null&&(A=v&-v,A=(A&42)!==0?1:Nn(A),A=(A&(H.suspendedLanes|v))!==0?0:A,A!==0&&A!==he.retryLane))throw he.retryLane=A,Cu(h,A),Zr(H,h,A),GA;Z.data==="$?"||m(),p=mr(h,p,v)}else Z.data==="$?"?(p.flags|=192,p.child=h.child,p=null):(h=he.treeContext,Ws=zu(Z.nextSibling),qr=p,ss=!0,oo=null,ka=!1,h!==null&&(dr[Ba++]=Rl,dr[Ba++]=Il,dr[Ba++]=Tc,Rl=h.id,Il=h.overflow,Tc=p),p=Ll(p,A.children),p.flags|=4096);return p}return M?(Oc(),M=A.fallback,Z=p.mode,he=h.child,De=he.sibling,A=ai(he,{mode:"hidden",children:A.children}),A.subtreeFlags=he.subtreeFlags&65011712,De!==null?M=ai(De,M):(M=Ac(M,Z,v,null),M.flags|=2),M.return=p,A.return=p,A.sibling=M,p.child=A,A=M,M=p.child,Z=h.child.memoizedState,Z===null?Z=el(v):(he=Z.cachePool,he!==null?(De=Si._currentValue,he=he.parent!==De?{parent:De,pool:De}:he):he=I0(),Z={baseLanes:Z.baseLanes|v,cachePool:he}),M.memoizedState=Z,M.childLanes=ki(h,H,v),p.memoizedState=Qo,A):(Dc(p),v=h.child,h=v.sibling,v=ai(v,{mode:"visible",children:A.children}),v.return=p,v.sibling=null,h!==null&&(H=p.deletions,H===null?(p.deletions=[h],p.flags|=16):H.push(h)),p.child=v,p.memoizedState=null,v)}function Ll(h,p){return p=Ih({mode:"visible",children:p},h.mode),p.return=h,h.child=p}function Ih(h,p){return h=ha(22,h,null,p),h.lanes=0,h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},h}function mr(h,p,v){return Ch(p,h.child,null,v),h=Ll(p,p.pendingProps.children),h.flags|=2,p.memoizedState=null,h}function gr(h,p,v){h.lanes|=p;var A=h.alternate;A!==null&&(A.lanes|=p),Ov(h.return,p,v)}function qn(h,p,v,A,M){var B=h.memoizedState;B===null?h.memoizedState={isBackwards:p,rendering:null,renderingStartTime:0,last:A,tail:v,tailMode:M}:(B.isBackwards=p,B.rendering=null,B.renderingStartTime=0,B.last=A,B.tail=v,B.tailMode=M)}function po(h,p,v){var A=p.pendingProps,M=A.revealOrder,B=A.tail;if(ui(h,p,A.children,v),A=li.current,(A&2)!==0)A=A&1|2,p.flags|=128;else{if(h!==null&&(h.flags&128)!==0)e:for(h=p.child;h!==null;){if(h.tag===13)h.memoizedState!==null&&gr(h,v,p);else if(h.tag===19)gr(h,v,p);else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===p)break e;for(;h.sibling===null;){if(h.return===null||h.return===p)break e;h=h.return}h.sibling.return=h.return,h=h.sibling}A&=1}switch(ue(li,A),M){case"forwards":for(v=p.child,M=null;v!==null;)h=v.alternate,h!==null&&ku(h)===null&&(M=v),v=v.sibling;v=M,v===null?(M=p.child,p.child=null):(M=v.sibling,v.sibling=null),qn(p,!1,M,v,B);break;case"backwards":for(v=null,M=p.child,p.child=null;M!==null;){if(h=M.alternate,h!==null&&ku(h)===null){p.child=M;break}h=M.sibling,M.sibling=v,v=M,M=h}qn(p,!0,v,null,B);break;case"together":qn(p,!1,null,null,void 0);break;default:p.memoizedState=null}return p.child}function qi(h,p,v){if(h!==null&&(p.dependencies=h.dependencies),il|=p.lanes,(v&p.childLanes)===0)if(h!==null){if(lo(h,p,v,!1),(v&p.childLanes)===0)return null}else return null;if(h!==null&&p.child!==h.child)throw Error(n(153));if(p.child!==null){for(h=p.child,v=ai(h,h.pendingProps),p.child=v,v.return=p;h.sibling!==null;)h=h.sibling,v=v.sibling=ai(h,h.pendingProps),v.return=p;v.sibling=null}return p.child}function ym(h,p){return(h.lanes&p)!==0?!0:(h=h.dependencies,!!(h!==null&&nm(h)))}function mo(h,p,v){switch(p.tag){case 3:Ke(p,p.stateNode.containerInfo),Ec(p,Si,h.memoizedState.cache),Yf();break;case 27:case 5:ct(p);break;case 4:Ke(p,p.stateNode.containerInfo);break;case 10:Ec(p,p.type,p.memoizedProps.value);break;case 13:var A=p.memoizedState;if(A!==null)return A.dehydrated!==null?(Dc(p),p.flags|=128,null):(v&p.child.childLanes)!==0?cd(h,p,v):(Dc(p),h=qi(h,p,v),h!==null?h.sibling:null);Dc(p);break;case 19:var M=(h.flags&128)!==0;if(A=(v&p.childLanes)!==0,A||(lo(h,p,v,!1),A=(v&p.childLanes)!==0),M){if(A)return po(h,p,v);p.flags|=128}if(M=p.memoizedState,M!==null&&(M.rendering=null,M.tail=null,M.lastEffect=null),ue(li,li.current),A)break;return null;case 22:case 23:return p.lanes=0,Mh(h,p,v);case 24:Ec(p,Si,h.memoizedState.cache)}return qi(h,p,v)}function Dh(h,p,v){if(h!==null)if(h.memoizedProps!==p.pendingProps)Xi=!0;else{if(!ym(h,v)&&(p.flags&128)===0)return Xi=!1,mo(h,p,v);Xi=(h.flags&131072)!==0}else Xi=!1,ss&&(p.flags&1048576)!==0&&C0(p,Kf,p.index);switch(p.lanes=0,p.tag){case 16:e:{h=p.pendingProps;var A=p.elementType,M=A._init;if(A=M(A._payload),p.type=A,typeof A=="function")Zp(A)?(h=kl(A,h),p.tag=1,p=Ua(null,p,A,h,v)):(p.tag=0,p=ud(null,p,A,h,v));else{if(A!=null){if(M=A.$$typeof,M===C){p.tag=11,p=da(null,p,A,h,v);break e}else if(M===L){p.tag=14,p=pa(null,p,A,h,v);break e}}throw p=J(A)||A,Error(n(306,p,""))}}return p;case 0:return ud(h,p,p.type,p.pendingProps,v);case 1:return A=p.type,M=kl(A,p.pendingProps),Ua(h,p,A,M,v);case 3:e:{if(Ke(p,p.stateNode.containerInfo),h===null)throw Error(n(387));A=p.pendingProps;var B=p.memoizedState;M=B.element,cn(h,p),nd(p,A,null,v);var H=p.memoizedState;if(A=H.cache,Ec(p,Si,A),A!==B.cache&&tm(p,[Si],v,!0),um(),A=H.element,B.isDehydrated)if(B={element:A,isDehydrated:!1,cache:H.cache},p.updateQueue.baseState=B,p.memoizedState=B,p.flags&256){p=kc(h,p,A,v);break e}else if(A!==M){M=fr(Error(n(424)),p),Ah(M),p=kc(h,p,A,v);break e}else{switch(h=p.stateNode.containerInfo,h.nodeType){case 9:h=h.body;break;default:h=h.nodeName==="HTML"?h.ownerDocument.body:h}for(Ws=zu(h.firstChild),qr=p,ss=!0,oo=null,ka=!0,v=LA(p,null,A,v),p.child=v;v;)v.flags=v.flags&-3|4096,v=v.sibling}else{if(Yf(),A===M){p=qi(h,p,v);break e}ui(h,p,A,v)}p=p.child}return p;case 26:return Rh(h,p),h===null?(v=hF(p.type,null,p.pendingProps,null))?p.memoizedState=v:ss||(v=p.type,h=p.pendingProps,A=jA(Te.current).createElement(v),A[vi]=p,A[Oi]=h,Qr(A,v,h),bi(A),p.stateNode=A):p.memoizedState=hF(p.type,h.memoizedProps,p.pendingProps,h.memoizedState),null;case 27:return ct(p),h===null&&ss&&(A=p.stateNode=lF(p.type,p.pendingProps,Te.current),qr=p,ka=!0,M=Ws,bd(p.type)?(AN=M,Ws=zu(A.firstChild)):Ws=M),ui(h,p,p.pendingProps.children,v),Rh(h,p),h===null&&(p.flags|=4194304),p.child;case 5:return h===null&&ss&&((M=A=Ws)&&(A=Rq(A,p.type,p.pendingProps,ka),A!==null?(p.stateNode=A,qr=p,Ws=zu(A.firstChild),ka=!1,M=!0):M=!1),M||wc(p)),ct(p),M=p.type,B=p.pendingProps,H=h!==null?h.memoizedProps:null,A=B.children,vN(M,B)?A=null:H!==null&&vN(M,H)&&(p.flags|=32),p.memoizedState!==null&&(M=Ou(h,p,nN,null,null,v),d1._currentValue=M),Rh(h,p),ui(h,p,A,v),p.child;case 6:return h===null&&ss&&((h=v=Ws)&&(v=Iq(v,p.pendingProps,ka),v!==null?(p.stateNode=v,qr=p,Ws=null,h=!0):h=!1),h||wc(p)),null;case 13:return cd(h,p,v);case 4:return Ke(p,p.stateNode.containerInfo),A=p.pendingProps,h===null?p.child=Ch(p,null,A,v):ui(h,p,A,v),p.child;case 11:return da(h,p,p.type,p.pendingProps,v);case 7:return ui(h,p,p.pendingProps,v),p.child;case 8:return ui(h,p,p.pendingProps.children,v),p.child;case 12:return ui(h,p,p.pendingProps.children,v),p.child;case 10:return A=p.pendingProps,Ec(p,p.type,A.value),ui(h,p,A.children,v),p.child;case 9:return M=p.type._context,A=p.pendingProps.children,Dl(p),M=Ys(M),A=A(M),p.flags|=1,ui(h,p,A,v),p.child;case 14:return pa(h,p,p.type,p.pendingProps,v);case 15:return n1(h,p,p.type,p.pendingProps,v);case 19:return po(h,p,v);case 31:return A=p.pendingProps,v=p.mode,A={mode:A.mode,children:A.children},h===null?(v=Ih(A,v),v.ref=p.ref,p.child=v,v.return=p,p=v):(v=ai(h.child,A),v.ref=p.ref,p.child=v,v.return=p,p=v),p;case 22:return Mh(h,p,v);case 24:return Dl(p),A=Ys(Si),h===null?(M=Mc(),M===null&&(M=pn,B=N0(),M.pooledCache=B,B.refCount++,B!==null&&(M.pooledCacheLanes|=v),M=B),p.memoizedState={parent:A,cache:M},Fv(p),Ec(p,Si,M)):((h.lanes&v)!==0&&(cn(h,p),nd(p,null,null,v),um()),M=h.memoizedState,B=p.memoizedState,M.parent!==A?(M={parent:A,cache:A},p.memoizedState=M,p.lanes===0&&(p.memoizedState=p.updateQueue.baseState=M),Ec(p,Si,A)):(A=B.cache,Ec(p,Si,A),A!==M.cache&&tm(p,[Si],v,!0))),ui(h,p,p.pendingProps.children,v),p.child;case 29:throw p.pendingProps}throw Error(n(156,p.tag))}function tl(h){h.flags|=4}function xm(h,p){if(p.type!=="stylesheet"||(p.state.loading&4)!==0)h.flags&=-16777217;else if(h.flags|=16777216,!gF(p)){if(p=Ss.current,p!==null&&((en&4194048)===en?Zo!==null:(en&62914560)!==en&&(en&536870912)===0||p!==Zo))throw co=lm,kv;h.flags|=8192}}function Lu(h,p){p!==null&&(h.flags|=4),h.flags&16384&&(p=h.tag!==22?dt():536870912,h.lanes|=p,Zn|=p)}function Oh(h,p){if(!ss)switch(h.tailMode){case"hidden":p=h.tail;for(var v=null;p!==null;)p.alternate!==null&&(v=p),p=p.sibling;v===null?h.tail=null:v.sibling=null;break;case"collapsed":v=h.tail;for(var A=null;v!==null;)v.alternate!==null&&(A=v),v=v.sibling;A===null?p||h.tail===null?h.tail=null:h.tail.sibling=null:A.sibling=null}}function Ms(h){var p=h.alternate!==null&&h.alternate.child===h.child,v=0,A=0;if(p)for(var M=h.child;M!==null;)v|=M.lanes|M.childLanes,A|=M.subtreeFlags&65011712,A|=M.flags&65011712,M.return=h,M=M.sibling;else for(M=h.child;M!==null;)v|=M.lanes|M.childLanes,A|=M.subtreeFlags,A|=M.flags,M.return=h,M=M.sibling;return h.subtreeFlags|=A,h.childLanes=v,p}function s1(h,p,v){var A=p.pendingProps;switch(Rv(p),p.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ms(p),null;case 1:return Ms(p),null;case 3:return v=p.stateNode,A=null,h!==null&&(A=h.memoizedState.cache),p.memoizedState.cache!==A&&(p.flags|=2048),Nu(Si),ut(),v.pendingContext&&(v.context=v.pendingContext,v.pendingContext=null),(h===null||h.child===null)&&(Ko(p)?tl(p):h===null||h.memoizedState.isDehydrated&&(p.flags&256)===0||(p.flags|=1024,hs())),Ms(p),null;case 26:return v=p.memoizedState,h===null?(tl(p),v!==null?(Ms(p),xm(p,v)):(Ms(p),p.flags&=-16777217)):v?v!==h.memoizedState?(tl(p),Ms(p),xm(p,v)):(Ms(p),p.flags&=-16777217):(h.memoizedProps!==A&&tl(p),Ms(p),p.flags&=-16777217),null;case 27:xt(p),v=Te.current;var M=p.type;if(h!==null&&p.stateNode!=null)h.memoizedProps!==A&&tl(p);else{if(!A){if(p.stateNode===null)throw Error(n(166));return Ms(p),null}h=re.current,Ko(p)?eA(p):(h=lF(M,A,v),p.stateNode=h,tl(p))}return Ms(p),null;case 5:if(xt(p),v=p.type,h!==null&&p.stateNode!=null)h.memoizedProps!==A&&tl(p);else{if(!A){if(p.stateNode===null)throw Error(n(166));return Ms(p),null}if(h=re.current,Ko(p))eA(p);else{switch(M=jA(Te.current),h){case 1:h=M.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:h=M.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":h=M.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":h=M.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":h=M.createElement("div"),h.innerHTML="<script><\/script>",h=h.removeChild(h.firstChild);break;case"select":h=typeof A.is=="string"?M.createElement("select",{is:A.is}):M.createElement("select"),A.multiple?h.multiple=!0:A.size&&(h.size=A.size);break;default:h=typeof A.is=="string"?M.createElement(v,{is:A.is}):M.createElement(v)}}h[vi]=p,h[Oi]=A;e:for(M=p.child;M!==null;){if(M.tag===5||M.tag===6)h.appendChild(M.stateNode);else if(M.tag!==4&&M.tag!==27&&M.child!==null){M.child.return=M,M=M.child;continue}if(M===p)break e;for(;M.sibling===null;){if(M.return===null||M.return===p)break e;M=M.return}M.sibling.return=M.return,M=M.sibling}p.stateNode=h;e:switch(Qr(h,v,A),v){case"button":case"input":case"select":case"textarea":h=!!A.autoFocus;break e;case"img":h=!0;break e;default:h=!1}h&&tl(p)}}return Ms(p),p.flags&=-16777217,null;case 6:if(h&&p.stateNode!=null)h.memoizedProps!==A&&tl(p);else{if(typeof A!="string"&&p.stateNode===null)throw Error(n(166));if(h=Te.current,Ko(p)){if(h=p.stateNode,v=p.memoizedProps,A=null,M=qr,M!==null)switch(M.tag){case 27:case 5:A=M.memoizedProps}h[vi]=p,h=!!(h.nodeValue===v||A!==null&&A.suppressHydrationWarning===!0||tF(h.nodeValue,v)),h||wc(p)}else h=jA(h).createTextNode(A),h[vi]=p,p.stateNode=h}return Ms(p),null;case 13:if(A=p.memoizedState,h===null||h.memoizedState!==null&&h.memoizedState.dehydrated!==null){if(M=Ko(p),A!==null&&A.dehydrated!==null){if(h===null){if(!M)throw Error(n(318));if(M=p.memoizedState,M=M!==null?M.dehydrated:null,!M)throw Error(n(317));M[vi]=p}else Yf(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;Ms(p),M=!1}else M=hs(),h!==null&&h.memoizedState!==null&&(h.memoizedState.hydrationErrors=M),M=!0;if(!M)return p.flags&256?(Bl(p),p):(Bl(p),null)}if(Bl(p),(p.flags&128)!==0)return p.lanes=v,p;if(v=A!==null,h=h!==null&&h.memoizedState!==null,v){A=p.child,M=null,A.alternate!==null&&A.alternate.memoizedState!==null&&A.alternate.memoizedState.cachePool!==null&&(M=A.alternate.memoizedState.cachePool.pool);var B=null;A.memoizedState!==null&&A.memoizedState.cachePool!==null&&(B=A.memoizedState.cachePool.pool),B!==M&&(A.flags|=2048)}return v!==h&&v&&(p.child.flags|=8192),Lu(p,p.updateQueue),Ms(p),null;case 4:return ut(),h===null&&pN(p.stateNode.containerInfo),Ms(p),null;case 10:return Nu(p.type),Ms(p),null;case 19:if(oe(li),M=p.memoizedState,M===null)return Ms(p),null;if(A=(p.flags&128)!==0,B=M.rendering,B===null)if(A)Oh(M,!1);else{if(ks!==0||h!==null&&(h.flags&128)!==0)for(h=p.child;h!==null;){if(B=ku(h),B!==null){for(p.flags|=128,Oh(M,!1),h=B.updateQueue,p.updateQueue=h,Lu(p,h),p.subtreeFlags=0,h=v,v=p.child;v!==null;)Mv(v,h),v=v.sibling;return ue(li,li.current&1|2),p.child}h=h.sibling}M.tail!==null&&Fe()>Mr&&(p.flags|=128,A=!0,Oh(M,!1),p.lanes=4194304)}else{if(!A)if(h=ku(B),h!==null){if(p.flags|=128,A=!0,h=h.updateQueue,p.updateQueue=h,Lu(p,h),Oh(M,!0),M.tail===null&&M.tailMode==="hidden"&&!B.alternate&&!ss)return Ms(p),null}else 2*Fe()-M.renderingStartTime>Mr&&v!==536870912&&(p.flags|=128,A=!0,Oh(M,!1),p.lanes=4194304);M.isBackwards?(B.sibling=p.child,p.child=B):(h=M.last,h!==null?h.sibling=B:p.child=B,M.last=B)}return M.tail!==null?(p=M.tail,M.rendering=p,M.tail=p.sibling,M.renderingStartTime=Fe(),p.sibling=null,h=li.current,ue(li,A?h&1|2:h&1),p):(Ms(p),null);case 22:case 23:return Bl(p),cm(),A=p.memoizedState!==null,h!==null?h.memoizedState!==null!==A&&(p.flags|=8192):A&&(p.flags|=8192),A?(v&536870912)!==0&&(p.flags&128)===0&&(Ms(p),p.subtreeFlags&6&&(p.flags|=8192)):Ms(p),v=p.updateQueue,v!==null&&Lu(p,v.retryQueue),v=null,h!==null&&h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(v=h.memoizedState.cachePool.pool),A=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(A=p.memoizedState.cachePool.pool),A!==v&&(p.flags|=2048),h!==null&&oe(uo),null;case 24:return v=null,h!==null&&(v=h.memoizedState.cache),p.memoizedState.cache!==v&&(p.flags|=2048),Nu(Si),Ms(p),null;case 25:return null;case 30:return null}throw Error(n(156,p.tag))}function hd(h,p){switch(Rv(p),p.tag){case 1:return h=p.flags,h&65536?(p.flags=h&-65537|128,p):null;case 3:return Nu(Si),ut(),h=p.flags,(h&65536)!==0&&(h&128)===0?(p.flags=h&-65537|128,p):null;case 26:case 27:case 5:return xt(p),null;case 13:if(Bl(p),h=p.memoizedState,h!==null&&h.dehydrated!==null){if(p.alternate===null)throw Error(n(340));Yf()}return h=p.flags,h&65536?(p.flags=h&-65537|128,p):null;case 19:return oe(li),null;case 4:return ut(),null;case 10:return Nu(p.type),null;case 22:case 23:return Bl(p),cm(),h!==null&&oe(uo),h=p.flags,h&65536?(p.flags=h&-65537|128,p):null;case 24:return Nu(Si),null;case 25:return null;default:return null}}function fd(h,p){switch(Rv(p),p.tag){case 3:Nu(Si),ut();break;case 26:case 27:case 5:xt(p);break;case 4:ut();break;case 13:Bl(p);break;case 19:oe(li);break;case 10:Nu(p.type);break;case 22:case 23:Bl(p),cm(),h!==null&&oe(uo);break;case 24:Nu(Si)}}function Bh(h,p){try{var v=p.updateQueue,A=v!==null?v.lastEffect:null;if(A!==null){var M=A.next;v=M;do{if((v.tag&h)===h){A=void 0;var B=v.create,H=v.inst;A=B(),H.destroy=A}v=v.next}while(v!==M)}}catch(Z){be(p,p.return,Z)}}function $a(h,p,v){try{var A=p.updateQueue,M=A!==null?A.lastEffect:null;if(M!==null){var B=M.next;A=B;do{if((A.tag&h)===h){var H=A.inst,Z=H.destroy;if(Z!==void 0){H.destroy=void 0,M=p;var he=v,De=Z;try{De()}catch(et){be(M,he,et)}}}A=A.next}while(A!==B)}}catch(et){be(p,p.return,et)}}function kh(h){var p=h.updateQueue;if(p!==null){var v=h.stateNode;try{sA(p,v)}catch(A){be(h,h.return,A)}}}function Fu(h,p,v){v.props=kl(h.type,h.memoizedProps),v.state=h.memoizedState;try{v.componentWillUnmount()}catch(A){be(h,p,A)}}function Lh(h,p){try{var v=h.ref;if(v!==null){switch(h.tag){case 26:case 27:case 5:var A=h.stateNode;break;case 30:A=h.stateNode;break;default:A=h.stateNode}typeof v=="function"?h.refCleanup=v(A):v.current=A}}catch(M){be(h,p,M)}}function Fl(h,p){var v=h.ref,A=h.refCleanup;if(v!==null)if(typeof A=="function")try{A()}catch(M){be(h,p,M)}finally{h.refCleanup=null,h=h.alternate,h!=null&&(h.refCleanup=null)}else if(typeof v=="function")try{v(null)}catch(M){be(h,p,M)}else v.current=null}function dd(h){var p=h.type,v=h.memoizedProps,A=h.stateNode;try{e:switch(p){case"button":case"input":case"select":case"textarea":v.autoFocus&&A.focus();break e;case"img":v.src?A.src=v.src:v.srcSet&&(A.srcset=v.srcSet)}}catch(M){be(h,h.return,M)}}function vm(h,p,v){try{var A=h.stateNode;wq(A,h.type,v,p),A[Oi]=p}catch(M){be(h,h.return,M)}}function bm(h){return h.tag===5||h.tag===3||h.tag===26||h.tag===27&&bd(h.type)||h.tag===4}function Lc(h){e:for(;;){for(;h.sibling===null;){if(h.return===null||bm(h.return))return null;h=h.return}for(h.sibling.return=h.return,h=h.sibling;h.tag!==5&&h.tag!==6&&h.tag!==18;){if(h.tag===27&&bd(h.type)||h.flags&2||h.child===null||h.tag===4)continue e;h.child.return=h,h=h.child}if(!(h.flags&2))return h.stateNode}}function Fc(h,p,v){var A=h.tag;if(A===5||A===6)h=h.stateNode,p?(v.nodeType===9?v.body:v.nodeName==="HTML"?v.ownerDocument.body:v).insertBefore(h,p):(p=v.nodeType===9?v.body:v.nodeName==="HTML"?v.ownerDocument.body:v,p.appendChild(h),v=v._reactRootContainer,v!=null||p.onclick!==null||(p.onclick=qA));else if(A!==4&&(A===27&&bd(h.type)&&(v=h.stateNode,p=null),h=h.child,h!==null))for(Fc(h,p,v),h=h.sibling;h!==null;)Fc(h,p,v),h=h.sibling}function Pc(h,p,v){var A=h.tag;if(A===5||A===6)h=h.stateNode,p?v.insertBefore(h,p):v.appendChild(h);else if(A!==4&&(A===27&&bd(h.type)&&(v=h.stateNode),h=h.child,h!==null))for(Pc(h,p,v),h=h.sibling;h!==null;)Pc(h,p,v),h=h.sibling}function Uc(h){var p=h.stateNode,v=h.memoizedProps;try{for(var A=h.type,M=p.attributes;M.length;)p.removeAttributeNode(M[0]);Qr(p,A,v),p[vi]=h,p[Oi]=v}catch(B){be(h,h.return,B)}}var Pl=!1,Ns=!1,pd=!1,za=typeof WeakSet=="function"?WeakSet:Set,As=null;function Li(h,p){if(h=h.containerInfo,yN=eT,h=_v(h),jp(h)){if("selectionStart"in h)var v={start:h.selectionStart,end:h.selectionEnd};else e:{v=(v=h.ownerDocument)&&v.defaultView||window;var A=v.getSelection&&v.getSelection();if(A&&A.rangeCount!==0){v=A.anchorNode;var M=A.anchorOffset,B=A.focusNode;A=A.focusOffset;try{v.nodeType,B.nodeType}catch{v=null;break e}var H=0,Z=-1,he=-1,De=0,et=0,st=h,Le=null;t:for(;;){for(var He;st!==v||M!==0&&st.nodeType!==3||(Z=H+M),st!==B||A!==0&&st.nodeType!==3||(he=H+A),st.nodeType===3&&(H+=st.nodeValue.length),(He=st.firstChild)!==null;)Le=st,st=He;for(;;){if(st===h)break t;if(Le===v&&++De===M&&(Z=H),Le===B&&++et===A&&(he=H),(He=st.nextSibling)!==null)break;st=Le,Le=st.parentNode}st=He}v=Z===-1||he===-1?null:{start:Z,end:he}}else v=null}v=v||{start:0,end:0}}else v=null;for(xN={focusedElem:h,selectionRange:v},eT=!1,As=p;As!==null;)if(p=As,h=p.child,(p.subtreeFlags&1024)!==0&&h!==null)h.return=p,As=h;else for(;As!==null;){switch(p=As,B=p.alternate,h=p.flags,p.tag){case 0:break;case 11:case 15:break;case 1:if((h&1024)!==0&&B!==null){h=void 0,v=p,M=B.memoizedProps,B=B.memoizedState,A=v.stateNode;try{var fn=kl(v.type,M,v.elementType===v.type);h=A.getSnapshotBeforeUpdate(fn,B),A.__reactInternalSnapshotBeforeUpdate=h}catch(on){be(v,v.return,on)}}break;case 3:if((h&1024)!==0){if(h=p.stateNode.containerInfo,v=h.nodeType,v===9)_N(h);else if(v===1)switch(h.nodeName){case"HEAD":case"HTML":case"BODY":_N(h);break;default:h.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((h&1024)!==0)throw Error(n(163))}if(h=p.sibling,h!==null){h.return=p.return,As=h;break}As=p.return}}function Pu(h,p,v){var A=v.flags;switch(v.tag){case 0:case 11:case 15:Jr(h,v),A&4&&Bh(5,v);break;case 1:if(Jr(h,v),A&4)if(h=v.stateNode,p===null)try{h.componentDidMount()}catch(H){be(v,v.return,H)}else{var M=kl(v.type,p.memoizedProps);p=p.memoizedState;try{h.componentDidUpdate(M,p,h.__reactInternalSnapshotBeforeUpdate)}catch(H){be(v,v.return,H)}}A&64&&kh(v),A&512&&Lh(v,v.return);break;case 3:if(Jr(h,v),A&64&&(h=v.updateQueue,h!==null)){if(p=null,v.child!==null)switch(v.child.tag){case 27:case 5:p=v.child.stateNode;break;case 1:p=v.child.stateNode}try{sA(h,p)}catch(H){be(v,v.return,H)}}break;case 27:p===null&&A&4&&Uc(v);case 26:case 5:Jr(h,v),p===null&&A&4&&dd(v),A&512&&Lh(v,v.return);break;case 12:Jr(h,v);break;case 13:Jr(h,v),A&4&&$c(h,v),A&64&&(h=v.memoizedState,h!==null&&(h=h.dehydrated,h!==null&&(v=Ls.bind(null,v),Dq(h,v))));break;case 22:if(A=v.memoizedState!==null||Pl,!A){p=p!==null&&p.memoizedState!==null||Ns,M=Pl;var B=Ns;Pl=A,(Ns=p)&&!B?Ul(h,v,(v.subtreeFlags&8772)!==0):Jr(h,v),Pl=M,Ns=B}break;case 30:break;default:Jr(h,v)}}function wn(h){var p=h.alternate;p!==null&&(h.alternate=null,wn(p)),h.child=null,h.deletions=null,h.sibling=null,h.tag===5&&(p=h.stateNode,p!==null&&gs(p)),h.stateNode=null,h.return=null,h.dependencies=null,h.memoizedProps=null,h.memoizedState=null,h.pendingProps=null,h.stateNode=null,h.updateQueue=null}var tn=null,Jn=!1;function go(h,p,v){for(v=v.child;v!==null;)Fh(h,p,v),v=v.sibling}function Fh(h,p,v){if(mt&&typeof mt.onCommitFiberUnmount=="function")try{mt.onCommitFiberUnmount(qe,v)}catch{}switch(v.tag){case 26:Ns||Fl(v,p),go(h,p,v),v.memoizedState?v.memoizedState.count--:v.stateNode&&(v=v.stateNode,v.parentNode.removeChild(v));break;case 27:Ns||Fl(v,p);var A=tn,M=Jn;bd(v.type)&&(tn=v.stateNode,Jn=!1),go(h,p,v),u1(v.stateNode),tn=A,Jn=M;break;case 5:Ns||Fl(v,p);case 6:if(A=tn,M=Jn,tn=null,go(h,p,v),tn=A,Jn=M,tn!==null)if(Jn)try{(tn.nodeType===9?tn.body:tn.nodeName==="HTML"?tn.ownerDocument.body:tn).removeChild(v.stateNode)}catch(B){be(v,p,B)}else try{tn.removeChild(v.stateNode)}catch(B){be(v,p,B)}break;case 18:tn!==null&&(Jn?(h=tn,aF(h.nodeType===9?h.body:h.nodeName==="HTML"?h.ownerDocument.body:h,v.stateNode),y1(h)):aF(tn,v.stateNode));break;case 4:A=tn,M=Jn,tn=v.stateNode.containerInfo,Jn=!0,go(h,p,v),tn=A,Jn=M;break;case 0:case 11:case 14:case 15:Ns||$a(2,v,p),Ns||$a(4,v,p),go(h,p,v);break;case 1:Ns||(Fl(v,p),A=v.stateNode,typeof A.componentWillUnmount=="function"&&Fu(v,p,A)),go(h,p,v);break;case 21:go(h,p,v);break;case 22:Ns=(A=Ns)||v.memoizedState!==null,go(h,p,v),Ns=A;break;default:go(h,p,v)}}function $c(h,p){if(p.memoizedState===null&&(h=p.alternate,h!==null&&(h=h.memoizedState,h!==null&&(h=h.dehydrated,h!==null))))try{y1(h)}catch(v){be(p,p.return,v)}}function Y0(h){switch(h.tag){case 13:case 19:var p=h.stateNode;return p===null&&(p=h.stateNode=new za),p;case 22:return h=h.stateNode,p=h._retryCache,p===null&&(p=h._retryCache=new za),p;default:throw Error(n(435,h.tag))}}function Ph(h,p){var v=Y0(h);p.forEach(function(A){var M=hn.bind(null,h,A);v.has(A)||(v.add(A),A.then(M,M))})}function ji(h,p){var v=p.deletions;if(v!==null)for(var A=0;A<v.length;A++){var M=v[A],B=h,H=p,Z=H;e:for(;Z!==null;){switch(Z.tag){case 27:if(bd(Z.type)){tn=Z.stateNode,Jn=!1;break e}break;case 5:tn=Z.stateNode,Jn=!1;break e;case 3:case 4:tn=Z.stateNode.containerInfo,Jn=!0;break e}Z=Z.return}if(tn===null)throw Error(n(160));Fh(B,H,M),tn=null,Jn=!1,B=M.alternate,B!==null&&(B.return=null),M.return=null}if(p.subtreeFlags&13878)for(p=p.child;p!==null;)J0(p,h),p=p.sibling}var nl=null;function J0(h,p){var v=h.alternate,A=h.flags;switch(h.tag){case 0:case 11:case 14:case 15:ji(p,h),Js(h),A&4&&($a(3,h,h.return),Bh(3,h),$a(5,h,h.return));break;case 1:ji(p,h),Js(h),A&512&&(Ns||v===null||Fl(v,v.return)),A&64&&Pl&&(h=h.updateQueue,h!==null&&(A=h.callbacks,A!==null&&(v=h.shared.hiddenCallbacks,h.shared.hiddenCallbacks=v===null?A:v.concat(A))));break;case 26:var M=nl;if(ji(p,h),Js(h),A&512&&(Ns||v===null||Fl(v,v.return)),A&4){var B=v!==null?v.memoizedState:null;if(A=h.memoizedState,v===null)if(A===null)if(h.stateNode===null){e:{A=h.type,v=h.memoizedProps,M=M.ownerDocument||M;t:switch(A){case"title":B=M.getElementsByTagName("title")[0],(!B||B[Vo]||B[vi]||B.namespaceURI==="http://www.w3.org/2000/svg"||B.hasAttribute("itemprop"))&&(B=M.createElement(A),M.head.insertBefore(B,M.querySelector("head > title"))),Qr(B,A,v),B[vi]=h,bi(B),A=B;break e;case"link":var H=pF("link","href",M).get(A+(v.href||""));if(H){for(var Z=0;Z<H.length;Z++)if(B=H[Z],B.getAttribute("href")===(v.href==null||v.href===""?null:v.href)&&B.getAttribute("rel")===(v.rel==null?null:v.rel)&&B.getAttribute("title")===(v.title==null?null:v.title)&&B.getAttribute("crossorigin")===(v.crossOrigin==null?null:v.crossOrigin)){H.splice(Z,1);break t}}B=M.createElement(A),Qr(B,A,v),M.head.appendChild(B);break;case"meta":if(H=pF("meta","content",M).get(A+(v.content||""))){for(Z=0;Z<H.length;Z++)if(B=H[Z],B.getAttribute("content")===(v.content==null?null:""+v.content)&&B.getAttribute("name")===(v.name==null?null:v.name)&&B.getAttribute("property")===(v.property==null?null:v.property)&&B.getAttribute("http-equiv")===(v.httpEquiv==null?null:v.httpEquiv)&&B.getAttribute("charset")===(v.charSet==null?null:v.charSet)){H.splice(Z,1);break t}}B=M.createElement(A),Qr(B,A,v),M.head.appendChild(B);break;default:throw Error(n(468,A))}B[vi]=h,bi(B),A=B}h.stateNode=A}else mF(M,h.type,h.stateNode);else h.stateNode=dF(M,A,h.memoizedProps);else B!==A?(B===null?v.stateNode!==null&&(v=v.stateNode,v.parentNode.removeChild(v)):B.count--,A===null?mF(M,h.type,h.stateNode):dF(M,A,h.memoizedProps)):A===null&&h.stateNode!==null&&vm(h,h.memoizedProps,v.memoizedProps)}break;case 27:ji(p,h),Js(h),A&512&&(Ns||v===null||Fl(v,v.return)),v!==null&&A&4&&vm(h,h.memoizedProps,v.memoizedProps);break;case 5:if(ji(p,h),Js(h),A&512&&(Ns||v===null||Fl(v,v.return)),h.flags&32){M=h.stateNode;try{Vr(M,"")}catch(He){be(h,h.return,He)}}A&4&&h.stateNode!=null&&(M=h.memoizedProps,vm(h,M,v!==null?v.memoizedProps:M)),A&1024&&(pd=!0);break;case 6:if(ji(p,h),Js(h),A&4){if(h.stateNode===null)throw Error(n(162));A=h.memoizedProps,v=h.stateNode;try{v.nodeValue=A}catch(He){be(h,h.return,He)}}break;case 3:if(JA=null,M=nl,nl=KA(p.containerInfo),ji(p,h),nl=M,Js(h),A&4&&v!==null&&v.memoizedState.isDehydrated)try{y1(p.containerInfo)}catch(He){be(h,h.return,He)}pd&&(pd=!1,zc(h));break;case 4:A=nl,nl=KA(h.stateNode.containerInfo),ji(p,h),Js(h),nl=A;break;case 12:ji(p,h),Js(h);break;case 13:ji(p,h),Js(h),h.child.flags&8192&&h.memoizedState!==null!=(v!==null&&v.memoizedState!==null)&&(xs=Fe()),A&4&&(A=h.updateQueue,A!==null&&(h.updateQueue=null,Ph(h,A)));break;case 22:M=h.memoizedState!==null;var he=v!==null&&v.memoizedState!==null,De=Pl,et=Ns;if(Pl=De||M,Ns=et||he,ji(p,h),Ns=et,Pl=De,Js(h),A&8192)e:for(p=h.stateNode,p._visibility=M?p._visibility&-2:p._visibility|1,M&&(v===null||he||Pl||Ns||Ga(h)),v=null,p=h;;){if(p.tag===5||p.tag===26){if(v===null){he=v=p;try{if(B=he.stateNode,M)H=B.style,typeof H.setProperty=="function"?H.setProperty("display","none","important"):H.display="none";else{Z=he.stateNode;var st=he.memoizedProps.style,Le=st!=null&&st.hasOwnProperty("display")?st.display:null;Z.style.display=Le==null||typeof Le=="boolean"?"":(""+Le).trim()}}catch(He){be(he,he.return,He)}}}else if(p.tag===6){if(v===null){he=p;try{he.stateNode.nodeValue=M?"":he.memoizedProps}catch(He){be(he,he.return,He)}}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===h)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===h)break e;for(;p.sibling===null;){if(p.return===null||p.return===h)break e;v===p&&(v=null),p=p.return}v===p&&(v=null),p.sibling.return=p.return,p=p.sibling}A&4&&(A=h.updateQueue,A!==null&&(v=A.retryQueue,v!==null&&(A.retryQueue=null,Ph(h,v))));break;case 19:ji(p,h),Js(h),A&4&&(A=h.updateQueue,A!==null&&(h.updateQueue=null,Ph(h,A)));break;case 30:break;case 21:break;default:ji(p,h),Js(h)}}function Js(h){var p=h.flags;if(p&2){try{for(var v,A=h.return;A!==null;){if(bm(A)){v=A;break}A=A.return}if(v==null)throw Error(n(160));switch(v.tag){case 27:var M=v.stateNode,B=Lc(h);Pc(h,B,M);break;case 5:var H=v.stateNode;v.flags&32&&(Vr(H,""),v.flags&=-33);var Z=Lc(h);Pc(h,Z,H);break;case 3:case 4:var he=v.stateNode.containerInfo,De=Lc(h);Fc(h,De,he);break;default:throw Error(n(161))}}catch(et){be(h,h.return,et)}h.flags&=-3}p&4096&&(h.flags&=-4097)}function zc(h){if(h.subtreeFlags&1024)for(h=h.child;h!==null;){var p=h;zc(p),p.tag===5&&p.flags&1024&&p.stateNode.reset(),h=h.sibling}}function Jr(h,p){if(p.subtreeFlags&8772)for(p=p.child;p!==null;)Pu(h,p.alternate,p),p=p.sibling}function Ga(h){for(h=h.child;h!==null;){var p=h;switch(p.tag){case 0:case 11:case 14:case 15:$a(4,p,p.return),Ga(p);break;case 1:Fl(p,p.return);var v=p.stateNode;typeof v.componentWillUnmount=="function"&&Fu(p,p.return,v),Ga(p);break;case 27:u1(p.stateNode);case 26:case 5:Fl(p,p.return),Ga(p);break;case 22:p.memoizedState===null&&Ga(p);break;case 30:Ga(p);break;default:Ga(p)}h=h.sibling}}function Ul(h,p,v){for(v=v&&(p.subtreeFlags&8772)!==0,p=p.child;p!==null;){var A=p.alternate,M=h,B=p,H=B.flags;switch(B.tag){case 0:case 11:case 15:Ul(M,B,v),Bh(4,B);break;case 1:if(Ul(M,B,v),A=B,M=A.stateNode,typeof M.componentDidMount=="function")try{M.componentDidMount()}catch(De){be(A,A.return,De)}if(A=B,M=A.updateQueue,M!==null){var Z=A.stateNode;try{var he=M.shared.hiddenCallbacks;if(he!==null)for(M.shared.hiddenCallbacks=null,M=0;M<he.length;M++)sd(he[M],Z)}catch(De){be(A,A.return,De)}}v&&H&64&&kh(B),Lh(B,B.return);break;case 27:Uc(B);case 26:case 5:Ul(M,B,v),v&&A===null&&H&4&&dd(B),Lh(B,B.return);break;case 12:Ul(M,B,v);break;case 13:Ul(M,B,v),v&&H&4&&$c(M,B);break;case 22:B.memoizedState===null&&Ul(M,B,v),Lh(B,B.return);break;case 30:break;default:Ul(M,B,v)}p=p.sibling}}function Z0(h,p){var v=null;h!==null&&h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(v=h.memoizedState.cachePool.pool),h=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(h=p.memoizedState.cachePool.pool),h!==v&&(h!=null&&h.refCount++,v!=null&&Jf(v))}function Q0(h,p){h=null,p.alternate!==null&&(h=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==h&&(p.refCount++,h!=null&&Jf(h))}function Ts(h,p,v,A){if(p.subtreeFlags&10256)for(p=p.child;p!==null;)ey(h,p,v,A),p=p.sibling}function ey(h,p,v,A){var M=p.flags;switch(p.tag){case 0:case 11:case 15:Ts(h,p,v,A),M&2048&&Bh(9,p);break;case 1:Ts(h,p,v,A);break;case 3:Ts(h,p,v,A),M&2048&&(h=null,p.alternate!==null&&(h=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==h&&(p.refCount++,h!=null&&Jf(h)));break;case 12:if(M&2048){Ts(h,p,v,A),h=p.stateNode;try{var B=p.memoizedProps,H=B.id,Z=B.onPostCommit;typeof Z=="function"&&Z(H,p.alternate===null?"mount":"update",h.passiveEffectDuration,-0)}catch(he){be(p,p.return,he)}}else Ts(h,p,v,A);break;case 13:Ts(h,p,v,A);break;case 23:break;case 22:B=p.stateNode,H=p.alternate,p.memoizedState!==null?B._visibility&2?Ts(h,p,v,A):sl(h,p):B._visibility&2?Ts(h,p,v,A):(B._visibility|=2,Uu(h,p,v,A,(p.subtreeFlags&10256)!==0)),M&2048&&Z0(H,p);break;case 24:Ts(h,p,v,A),M&2048&&Q0(p.alternate,p);break;default:Ts(h,p,v,A)}}function Uu(h,p,v,A,M){for(M=M&&(p.subtreeFlags&10256)!==0,p=p.child;p!==null;){var B=h,H=p,Z=v,he=A,De=H.flags;switch(H.tag){case 0:case 11:case 15:Uu(B,H,Z,he,M),Bh(8,H);break;case 23:break;case 22:var et=H.stateNode;H.memoizedState!==null?et._visibility&2?Uu(B,H,Z,he,M):sl(B,H):(et._visibility|=2,Uu(B,H,Z,he,M)),M&&De&2048&&Z0(H.alternate,H);break;case 24:Uu(B,H,Z,he,M),M&&De&2048&&Q0(H.alternate,H);break;default:Uu(B,H,Z,he,M)}p=p.sibling}}function sl(h,p){if(p.subtreeFlags&10256)for(p=p.child;p!==null;){var v=h,A=p,M=A.flags;switch(A.tag){case 22:sl(v,A),M&2048&&Z0(A.alternate,A);break;case 24:sl(v,A),M&2048&&Q0(A.alternate,A);break;default:sl(v,A)}p=p.sibling}}var Ha=8192;function md(h){if(h.subtreeFlags&Ha)for(h=h.child;h!==null;)HA(h),h=h.sibling}function HA(h){switch(h.tag){case 26:md(h),h.flags&Ha&&h.memoizedState!==null&&Wq(nl,h.memoizedState,h.memoizedProps);break;case 5:md(h);break;case 3:case 4:var p=nl;nl=KA(h.stateNode.containerInfo),md(h),nl=p;break;case 22:h.memoizedState===null&&(p=h.alternate,p!==null&&p.memoizedState!==null?(p=Ha,Ha=16777216,md(h),Ha=p):md(h));break;default:md(h)}}function VA(h){var p=h.alternate;if(p!==null&&(h=p.child,h!==null)){p.child=null;do p=h.sibling,h.sibling=null,h=p;while(h!==null)}}function Rs(h){var p=h.deletions;if((h.flags&16)!==0){if(p!==null)for(var v=0;v<p.length;v++){var A=p[v];As=A,zl(A,h)}VA(h)}if(h.subtreeFlags&10256)for(h=h.child;h!==null;)i1(h),h=h.sibling}function i1(h){switch(h.tag){case 0:case 11:case 15:Rs(h),h.flags&2048&&$a(9,h,h.return);break;case 3:Rs(h);break;case 12:Rs(h);break;case 22:var p=h.stateNode;h.memoizedState!==null&&p._visibility&2&&(h.return===null||h.return.tag!==13)?(p._visibility&=-3,$l(h)):Rs(h);break;default:Rs(h)}}function $l(h){var p=h.deletions;if((h.flags&16)!==0){if(p!==null)for(var v=0;v<p.length;v++){var A=p[v];As=A,zl(A,h)}VA(h)}for(h=h.child;h!==null;){switch(p=h,p.tag){case 0:case 11:case 15:$a(8,p,p.return),$l(p);break;case 22:v=p.stateNode,v._visibility&2&&(v._visibility&=-3,$l(p));break;default:$l(p)}h=h.sibling}}function zl(h,p){for(;As!==null;){var v=As;switch(v.tag){case 0:case 11:case 15:$a(8,v,p);break;case 23:case 22:if(v.memoizedState!==null&&v.memoizedState.cachePool!==null){var A=v.memoizedState.cachePool.pool;A!=null&&A.refCount++}break;case 24:Jf(v.memoizedState.cache)}if(A=v.child,A!==null)A.return=v,As=A;else e:for(v=h;As!==null;){A=As;var M=A.sibling,B=A.return;if(wn(A),A===v){As=null;break e}if(M!==null){M.return=B,As=M;break e}As=B}}}var Zs={getCacheForType:function(h){var p=Ys(Si),v=p.data.get(h);return v===void 0&&(v=h(),p.data.set(h,v)),v}},r1=typeof WeakMap=="function"?WeakMap:Map,fs=0,pn=null,On=null,en=0,Sn=0,Xs=null,Va=!1,gd=!1,yd=!1,yo=0,ks=0,il=0,Gl=0,Uh=0,xo=0,Zn=0,ds=null,nn=null,zn=!1,xs=0,Mr=1/0,vo=null,Wa=null,Fi=0,Nr=null,ws=null,Xa=0,$u=0,_m=null,qa=null,Hl=0,$h=null;function Qs(){if((fs&2)!==0&&en!==0)return en&-en;if($.T!==null){var h=yn;return h!==0?h:cN()}return _n()}function ty(){xo===0&&(xo=(en&536870912)===0||ss?ge():536870912);var h=Ss.current;return h!==null&&(h.flags|=32),xo}function Zr(h,p,v){(h===pn&&(Sn===2||Sn===9)||h.cancelPendingCommit!==null)&&(Hc(h,0),rl(h,en,xo,!1)),Ze(h,v),((fs&2)===0||h!==pn)&&(h===pn&&((fs&2)===0&&(Gl|=v),ks===4&&rl(h,en,xo,!1)),Xc(h))}function xd(h,p,v){if((fs&6)!==0)throw Error(n(327));var A=!v&&(p&124)===0&&(p&h.expiredLanes)===0||Je(h,p),M=A?N(h,p):y(h,p,!0),B=A;do{if(M===0){gd&&!A&&rl(h,p,0,!1);break}else{if(v=h.current.alternate,B&&!Gc(v)){M=y(h,p,!1),B=!1;continue}if(M===2){if(B=p,h.errorRecoveryDisabledLanes&B)var H=0;else H=h.pendingLanes&-536870913,H=H!==0?H:H&536870912?536870912:0;if(H!==0){p=H;e:{var Z=h;M=ds;var he=Z.current.memoizedState.isDehydrated;if(he&&(Hc(Z,H).flags|=256),H=y(Z,H,!1),H!==2){if(yd&&!he){Z.errorRecoveryDisabledLanes|=B,Gl|=B,M=4;break e}B=nn,nn=M,B!==null&&(nn===null?nn=B:nn.push.apply(nn,B))}M=H}if(B=!1,M!==2)continue}}if(M===1){Hc(h,0),rl(h,p,0,!0);break}e:{switch(A=h,B=M,B){case 0:case 1:throw Error(n(345));case 4:if((p&4194048)!==p)break;case 6:rl(A,p,xo,!Va);break e;case 2:nn=null;break;case 3:case 5:break;default:throw Error(n(329))}if((p&62914560)===p&&(M=xs+300-Fe(),10<M)){if(rl(A,p,xo,!Va),ye(A,0,!0)!==0)break e;A.timeoutHandle=iF(Sm.bind(null,A,v,nn,vo,zn,p,xo,Gl,Zn,Va,B,2,-0,0),M);break e}Sm(A,v,nn,vo,zn,p,xo,Gl,Zn,Va,B,0,-0,0)}}break}while(!0);Xc(h)}function Sm(h,p,v,A,M,B,H,Z,he,De,et,st,Le,He){if(h.timeoutHandle=-1,st=p.subtreeFlags,(st&8192||(st&16785408)===16785408)&&(f1={stylesheets:null,count:0,unsuspend:Vq},HA(p),st=Xq(),st!==null)){h.cancelPendingCommit=st(yt.bind(null,h,p,B,v,A,M,H,Z,he,et,1,Le,He)),rl(h,B,H,!De);return}yt(h,p,B,v,A,M,H,Z,he)}function Gc(h){for(var p=h;;){var v=p.tag;if((v===0||v===11||v===15)&&p.flags&16384&&(v=p.updateQueue,v!==null&&(v=v.stores,v!==null)))for(var A=0;A<v.length;A++){var M=v[A],B=M.getSnapshot;M=M.value;try{if(!la(B(),M))return!1}catch{return!1}}if(v=p.child,p.subtreeFlags&16384&&v!==null)v.return=p,p=v;else{if(p===h)break;for(;p.sibling===null;){if(p.return===null||p.return===h)return!0;p=p.return}p.sibling.return=p.return,p=p.sibling}}return!0}function rl(h,p,v,A){p&=~Uh,p&=~Gl,h.suspendedLanes|=p,h.pingedLanes&=~p,A&&(h.warmLanes|=p),A=h.expirationTimes;for(var M=p;0<M;){var B=31-gt(M),H=1<<B;A[B]=-1,M&=~H}v!==0&&At(h,v,p)}function Vl(){return(fs&6)===0?(a1(0),!1):!0}function zh(){if(On!==null){if(Sn===0)var h=On.return;else h=On,Mu=Cc=null,zv(h),wh=null,pm=0,h=On;for(;h!==null;)fd(h.alternate,h),h=h.return;On=null}}function Hc(h,p){var v=h.timeoutHandle;v!==-1&&(h.timeoutHandle=-1,Eq(v)),v=h.cancelPendingCommit,v!==null&&(h.cancelPendingCommit=null,v()),zh(),pn=h,On=v=ai(h.current,null),en=p,Sn=0,Xs=null,Va=!1,gd=Je(h,p),yd=!1,Zn=xo=Uh=Gl=il=ks=0,nn=ds=null,zn=!1,(p&8)!==0&&(p|=p&32);var A=h.entangledLanes;if(A!==0)for(h=h.entanglements,A&=p;0<A;){var M=31-gt(A),B=1<<M;p|=h[M],A&=~B}return yo=p,Jp(),v}function ny(h,p){xn=null,$.H=dm,p===om||p===Yo?(p=Lv(),Sn=3):p===kv?(p=Lv(),Sn=4):Sn=p===GA?8:p!==null&&typeof p=="object"&&typeof p.then=="function"?6:1,Xs=p,On===null&&(ks=1,q0(h,fr(p,h.current)))}function vd(){var h=$.H;return $.H=dm,h===null?dm:h}function sy(){var h=$.A;return $.A=Zs,h}function m(){ks=4,Va||(en&4194048)!==en&&Ss.current!==null||(gd=!0),(il&134217727)===0&&(Gl&134217727)===0||pn===null||rl(pn,en,xo,!1)}function y(h,p,v){var A=fs;fs|=2;var M=vd(),B=sy();(pn!==h||en!==p)&&(vo=null,Hc(h,p)),p=!1;var H=ks;e:do try{if(Sn!==0&&On!==null){var Z=On,he=Xs;switch(Sn){case 8:zh(),H=6;break e;case 3:case 2:case 9:case 6:Ss.current===null&&(p=!0);var De=Sn;if(Sn=0,Xs=null,de(h,Z,he,De),v&&gd){H=0;break e}break;default:De=Sn,Sn=0,Xs=null,de(h,Z,he,De)}}w(),H=ks;break}catch(et){ny(h,et)}while(!0);return p&&h.shellSuspendCounter++,Mu=Cc=null,fs=A,$.H=M,$.A=B,On===null&&(pn=null,en=0,Jp()),H}function w(){for(;On!==null;)U(On)}function N(h,p){var v=fs;fs|=2;var A=vd(),M=sy();pn!==h||en!==p?(vo=null,Mr=Fe()+500,Hc(h,p)):gd=Je(h,p);e:do try{if(Sn!==0&&On!==null){p=On;var B=Xs;t:switch(Sn){case 1:Sn=0,Xs=null,de(h,p,B,1);break;case 2:case 9:if(D0(B)){Sn=0,Xs=null,te(p);break}p=function(){Sn!==2&&Sn!==9||pn!==h||(Sn=7),Xc(h)},B.then(p,p);break e;case 3:Sn=7;break e;case 4:Sn=5;break e;case 7:D0(B)?(Sn=0,Xs=null,te(p)):(Sn=0,Xs=null,de(h,p,B,7));break;case 5:var H=null;switch(On.tag){case 26:H=On.memoizedState;case 5:case 27:var Z=On;if(!H||gF(H)){Sn=0,Xs=null;var he=Z.sibling;if(he!==null)On=he;else{var De=Z.return;De!==null?(On=De,Ne(De)):On=null}break t}}Sn=0,Xs=null,de(h,p,B,5);break;case 6:Sn=0,Xs=null,de(h,p,B,6);break;case 8:zh(),ks=6;break e;default:throw Error(n(462))}}k();break}catch(et){ny(h,et)}while(!0);return Mu=Cc=null,$.H=A,$.A=M,fs=v,On!==null?0:(pn=null,en=0,Jp(),ks)}function k(){for(;On!==null&&!Wt();)U(On)}function U(h){var p=Dh(h.alternate,h,yo);h.memoizedProps=h.pendingProps,p===null?Ne(h):On=p}function te(h){var p=h,v=p.alternate;switch(p.tag){case 15:case 0:p=Pa(v,p,p.pendingProps,p.type,void 0,en);break;case 11:p=Pa(v,p,p.pendingProps,p.type.render,p.ref,en);break;case 5:zv(p);default:fd(v,p),p=On=Mv(p,yo),p=Dh(v,p,yo)}h.memoizedProps=h.pendingProps,p===null?Ne(h):On=p}function de(h,p,v,A){Mu=Cc=null,zv(p),wh=null,pm=0;var M=p.return;try{if(lN(h,M,p,v,en)){ks=1,q0(h,fr(v,h.current)),On=null;return}}catch(B){if(M!==null)throw On=M,B;ks=1,q0(h,fr(v,h.current)),On=null;return}p.flags&32768?(ss||A===1?h=!0:gd||(en&536870912)!==0?h=!1:(Va=h=!0,(A===2||A===9||A===3||A===6)&&(A=Ss.current,A!==null&&A.tag===13&&(A.flags|=16384))),Qe(p,h)):Ne(p)}function Ne(h){var p=h;do{if((p.flags&32768)!==0){Qe(p,Va);return}h=p.return;var v=s1(p.alternate,p,yo);if(v!==null){On=v;return}if(p=p.sibling,p!==null){On=p;return}On=p=h}while(p!==null);ks===0&&(ks=5)}function Qe(h,p){do{var v=hd(h.alternate,h);if(v!==null){v.flags&=32767,On=v;return}if(v=h.return,v!==null&&(v.flags|=32768,v.subtreeFlags=0,v.deletions=null),!p&&(h=h.sibling,h!==null)){On=h;return}On=h=v}while(h!==null);ks=6,On=null}function yt(h,p,v,A,M,B,H,Z,he){h.cancelPendingCommit=null;do Vc();while(Fi!==0);if((fs&6)!==0)throw Error(n(327));if(p!==null){if(p===h.current)throw Error(n(177));if(B=p.lanes|p.childLanes,B|=A0,Mt(h,v,B,H,Z,he),h===pn&&(On=pn=null,en=0),ws=p,Nr=h,Xa=v,$u=B,_m=M,qa=A,(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?(h.callbackNode=null,h.callbackPriority=0,is(ie,function(){return Wc(),null})):(h.callbackNode=null,h.callbackPriority=0),A=(p.flags&13878)!==0,(p.subtreeFlags&13878)!==0||A){A=$.T,$.T=null,M=W.p,W.p=2,H=fs,fs|=4;try{Li(h,p,v)}finally{fs=H,W.p=M,$.T=A}}Fi=1,Rt(),Bt(),mn()}}function Rt(){if(Fi===1){Fi=0;var h=Nr,p=ws,v=(p.flags&13878)!==0;if((p.subtreeFlags&13878)!==0||v){v=$.T,$.T=null;var A=W.p;W.p=2;var M=fs;fs|=4;try{J0(p,h);var B=xN,H=_v(h.containerInfo),Z=B.focusedElem,he=B.selectionRange;if(H!==Z&&Z&&Z.ownerDocument&&bv(Z.ownerDocument.documentElement,Z)){if(he!==null&&jp(Z)){var De=he.start,et=he.end;if(et===void 0&&(et=De),"selectionStart"in Z)Z.selectionStart=De,Z.selectionEnd=Math.min(et,Z.value.length);else{var st=Z.ownerDocument||document,Le=st&&st.defaultView||window;if(Le.getSelection){var He=Le.getSelection(),fn=Z.textContent.length,on=Math.min(he.start,fn),Ds=he.end===void 0?on:Math.min(he.end,fn);!He.extend&&on>Ds&&(H=Ds,Ds=on,on=H);var Ce=vv(Z,on),_e=vv(Z,Ds);if(Ce&&_e&&(He.rangeCount!==1||He.anchorNode!==Ce.node||He.anchorOffset!==Ce.offset||He.focusNode!==_e.node||He.focusOffset!==_e.offset)){var Re=st.createRange();Re.setStart(Ce.node,Ce.offset),He.removeAllRanges(),on>Ds?(He.addRange(Re),He.extend(_e.node,_e.offset)):(Re.setEnd(_e.node,_e.offset),He.addRange(Re))}}}}for(st=[],He=Z;He=He.parentNode;)He.nodeType===1&&st.push({element:He,left:He.scrollLeft,top:He.scrollTop});for(typeof Z.focus=="function"&&Z.focus(),Z=0;Z<st.length;Z++){var nt=st[Z];nt.element.scrollLeft=nt.left,nt.element.scrollTop=nt.top}}eT=!!yN,xN=yN=null}finally{fs=M,W.p=A,$.T=v}}h.current=p,Fi=2}}function Bt(){if(Fi===2){Fi=0;var h=Nr,p=ws,v=(p.flags&8772)!==0;if((p.subtreeFlags&8772)!==0||v){v=$.T,$.T=null;var A=W.p;W.p=2;var M=fs;fs|=4;try{Pu(h,p.alternate,p)}finally{fs=M,W.p=A,$.T=v}}Fi=3}}function mn(){if(Fi===4||Fi===3){Fi=0,ze();var h=Nr,p=ws,v=Xa,A=qa;(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?Fi=5:(Fi=0,ws=Nr=null,ja(h,h.pendingLanes));var M=h.pendingLanes;if(M===0&&(Wa=null),cs(v),p=p.stateNode,mt&&typeof mt.onCommitFiberRoot=="function")try{mt.onCommitFiberRoot(qe,p,void 0,(p.current.flags&128)===128)}catch{}if(A!==null){p=$.T,M=W.p,W.p=2,$.T=null;try{for(var B=h.onRecoverableError,H=0;H<A.length;H++){var Z=A[H];B(Z.value,{componentStack:Z.stack})}}finally{$.T=p,W.p=M}}(Xa&3)!==0&&Vc(),Xc(h),M=h.pendingLanes,(v&4194090)!==0&&(M&42)!==0?h===$h?Hl++:(Hl=0,$h=h):Hl=0,a1(0)}}function ja(h,p){(h.pooledCacheLanes&=p)===0&&(p=h.pooledCache,p!=null&&(h.pooledCache=null,Jf(p)))}function Vc(h){return Rt(),Bt(),mn(),Wc()}function Wc(){if(Fi!==5)return!1;var h=Nr,p=$u;$u=0;var v=cs(Xa),A=$.T,M=W.p;try{W.p=32>v?32:v,$.T=null,v=_m,_m=null;var B=Nr,H=Xa;if(Fi=0,ws=Nr=null,Xa=0,(fs&6)!==0)throw Error(n(331));var Z=fs;if(fs|=4,i1(B.current),ey(B,B.current,H,v),fs=Z,a1(0,!1),mt&&typeof mt.onPostCommitFiberRoot=="function")try{mt.onPostCommitFiberRoot(qe,B)}catch{}return!0}finally{W.p=M,$.T=A,ja(h,p)}}function Oe(h,p,v){p=fr(v,p),p=j0(h.stateNode,p,2),h=Iu(h,p,2),h!==null&&(Ze(h,2),Xc(h))}function be(h,p,v){if(h.tag===3)Oe(h,h,v);else for(;p!==null;){if(p.tag===3){Oe(p,h,v);break}else if(p.tag===1){var A=p.stateNode;if(typeof p.type.getDerivedStateFromError=="function"||typeof A.componentDidCatch=="function"&&(Wa===null||!Wa.has(A))){h=fr(v,h),v=zA(2),A=Iu(p,v,2),A!==null&&(K0(v,A,p,h),Ze(A,2),Xc(A));break}}p=p.return}}function Ve(h,p,v){var A=h.pingCache;if(A===null){A=h.pingCache=new r1;var M=new Set;A.set(p,M)}else M=A.get(p),M===void 0&&(M=new Set,A.set(p,M));M.has(v)||(yd=!0,M.add(v),h=pt.bind(null,h,p,v),p.then(h,h))}function pt(h,p,v){var A=h.pingCache;A!==null&&A.delete(p),h.pingedLanes|=h.suspendedLanes&v,h.warmLanes&=~v,pn===h&&(en&v)===v&&(ks===4||ks===3&&(en&62914560)===en&&300>Fe()-xs?(fs&2)===0&&Hc(h,0):Uh|=v,Zn===en&&(Zn=0)),Xc(h)}function qt(h,p){p===0&&(p=dt()),h=Cu(h,p),h!==null&&(Ze(h,p),Xc(h))}function Ls(h){var p=h.memoizedState,v=0;p!==null&&(v=p.retryLane),qt(h,v)}function hn(h,p){var v=0;switch(h.tag){case 13:var A=h.stateNode,M=h.memoizedState;M!==null&&(v=M.retryLane);break;case 19:A=h.stateNode;break;case 22:A=h.stateNode._retryCache;break;default:throw Error(n(314))}A!==null&&A.delete(p),qt(h,v)}function is(h,p){return Et(h,p)}var ci=null,Pn=null,Wl=!1,iy=!1,uN=!1,Am=0;function Xc(h){h!==Pn&&h.next===null&&(Pn===null?ci=Pn=h:Pn=Pn.next=h),iy=!0,Wl||(Wl=!0,xq())}function a1(h,p){if(!uN&&iy){uN=!0;do for(var v=!1,A=ci;A!==null;){if(h!==0){var M=A.pendingLanes;if(M===0)var B=0;else{var H=A.suspendedLanes,Z=A.pingedLanes;B=(1<<31-gt(42|h)+1)-1,B&=M&~(H&~Z),B=B&201326741?B&201326741|1:B?B|2:0}B!==0&&(v=!0,jL(A,B))}else B=en,B=ye(A,A===pn?B:0,A.cancelPendingCommit!==null||A.timeoutHandle!==-1),(B&3)===0||Je(A,B)||(v=!0,jL(A,B));A=A.next}while(v);uN=!1}}function yq(){WL()}function WL(){iy=Wl=!1;var h=0;Am!==0&&(Cq()&&(h=Am),Am=0);for(var p=Fe(),v=null,A=ci;A!==null;){var M=A.next,B=XL(A,p);B===0?(A.next=null,v===null?ci=M:v.next=M,M===null&&(Pn=v)):(v=A,(h!==0||(B&3)!==0)&&(iy=!0)),A=M}a1(h)}function XL(h,p){for(var v=h.suspendedLanes,A=h.pingedLanes,M=h.expirationTimes,B=h.pendingLanes&-62914561;0<B;){var H=31-gt(B),Z=1<<H,he=M[H];he===-1?((Z&v)===0||(Z&A)!==0)&&(M[H]=_t(Z,p)):he<=p&&(h.expiredLanes|=Z),B&=~Z}if(p=pn,v=en,v=ye(h,h===p?v:0,h.cancelPendingCommit!==null||h.timeoutHandle!==-1),A=h.callbackNode,v===0||h===p&&(Sn===2||Sn===9)||h.cancelPendingCommit!==null)return A!==null&&A!==null&&le(A),h.callbackNode=null,h.callbackPriority=0;if((v&3)===0||Je(h,v)){if(p=v&-v,p===h.callbackPriority)return p;switch(A!==null&&le(A),cs(v)){case 2:case 8:v=ke;break;case 32:v=ie;break;case 268435456:v=Ae;break;default:v=ie}return A=qL.bind(null,h),v=Et(v,A),h.callbackPriority=p,h.callbackNode=v,p}return A!==null&&A!==null&&le(A),h.callbackPriority=2,h.callbackNode=null,2}function qL(h,p){if(Fi!==0&&Fi!==5)return h.callbackNode=null,h.callbackPriority=0,null;var v=h.callbackNode;if(Vc()&&h.callbackNode!==v)return null;var A=en;return A=ye(h,h===pn?A:0,h.cancelPendingCommit!==null||h.timeoutHandle!==-1),A===0?null:(xd(h,A,p),XL(h,Fe()),h.callbackNode!=null&&h.callbackNode===v?qL.bind(null,h):null)}function jL(h,p){if(Vc())return null;xd(h,p,!0)}function xq(){Mq(function(){(fs&6)!==0?Et(ht,yq):WL()})}function cN(){return Am===0&&(Am=ge()),Am}function KL(h){return h==null||typeof h=="symbol"||typeof h=="boolean"?null:typeof h=="function"?h:kp(""+h)}function YL(h,p){var v=p.ownerDocument.createElement("input");return v.name=p.name,v.value=p.value,h.id&&v.setAttribute("form",h.id),p.parentNode.insertBefore(v,p),h=new FormData(h),v.parentNode.removeChild(v),h}function vq(h,p,v,A,M){if(p==="submit"&&v&&v.stateNode===M){var B=KL((M[Oi]||null).action),H=A.submitter;H&&(p=(p=H[Oi]||null)?KL(p.formAction):H.getAttribute("formAction"),p!==null&&(B=p,H=null));var Z=new Pf("action","action",null,A,M);h.push({event:Z,listeners:[{instance:null,listener:function(){if(A.defaultPrevented){if(Am!==0){var he=H?YL(M,H):new FormData(M);Qv(v,{pending:!0,data:he,method:M.method,action:B},null,he)}}else typeof B=="function"&&(Z.preventDefault(),he=H?YL(M,H):new FormData(M),Qv(v,{pending:!0,data:he,method:M.method,action:B},B,he))},currentTarget:M}]})}}for(var hN=0;hN<Yp.length;hN++){var fN=Yp[hN],bq=fN.toLowerCase(),_q=fN[0].toUpperCase()+fN.slice(1);Vi(bq,"on"+_q)}Vi(Xr,"onAnimationEnd"),Vi(Tv,"onAnimationIteration"),Vi(ca,"onAnimationStart"),Vi("dblclick","onDoubleClick"),Vi("focusin","onFocus"),Vi("focusout","onBlur"),Vi(QS,"onTransitionRun"),Vi(Tu,"onTransitionStart"),Vi(Xf,"onTransitionCancel"),Vi(wu,"onTransitionEnd"),ee("onMouseEnter",["mouseout","mouseover"]),ee("onMouseLeave",["mouseout","mouseover"]),ee("onPointerEnter",["pointerout","pointerover"]),ee("onPointerLeave",["pointerout","pointerover"]),qo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),qo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),qo("onBeforeInput",["compositionend","keypress","textInput","paste"]),qo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),qo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),qo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var o1="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Sq=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(o1));function JL(h,p){p=(p&4)!==0;for(var v=0;v<h.length;v++){var A=h[v],M=A.event;A=A.listeners;e:{var B=void 0;if(p)for(var H=A.length-1;0<=H;H--){var Z=A[H],he=Z.instance,De=Z.currentTarget;if(Z=Z.listener,he!==B&&M.isPropagationStopped())break e;B=Z,M.currentTarget=De;try{B(M)}catch(et){Eh(et)}M.currentTarget=null,B=he}else for(H=0;H<A.length;H++){if(Z=A[H],he=Z.instance,De=Z.currentTarget,Z=Z.listener,he!==B&&M.isPropagationStopped())break e;B=Z,M.currentTarget=De;try{B(M)}catch(et){Eh(et)}M.currentTarget=null,B=he}}}}function Hn(h,p){var v=p[aa];v===void 0&&(v=p[aa]=new Set);var A=h+"__bubble";v.has(A)||(ZL(p,h,2,!1),v.add(A))}function dN(h,p,v){var A=0;p&&(A|=4),ZL(v,h,A,p)}var WA="_reactListening"+Math.random().toString(36).slice(2);function pN(h){if(!h[WA]){h[WA]=!0,Of.forEach(function(v){v!=="selectionchange"&&(Sq.has(v)||dN(v,!1,h),dN(v,!0,h))});var p=h.nodeType===9?h:h.ownerDocument;p===null||p[WA]||(p[WA]=!0,dN("selectionchange",!1,p))}}function ZL(h,p,v,A){switch(SF(p)){case 2:var M=Kq;break;case 8:M=Yq;break;default:M=MN}v=M.bind(null,p,v,h),M=void 0,!Fp||p!=="touchstart"&&p!=="touchmove"&&p!=="wheel"||(M=!0),A?M!==void 0?h.addEventListener(p,v,{capture:!0,passive:M}):h.addEventListener(p,v,!0):M!==void 0?h.addEventListener(p,v,{passive:M}):h.addEventListener(p,v,!1)}function mN(h,p,v,A,M){var B=A;if((p&1)===0&&(p&2)===0&&A!==null)e:for(;;){if(A===null)return;var H=A.tag;if(H===3||H===4){var Z=A.stateNode.containerInfo;if(Z===M)break;if(H===4)for(H=A.return;H!==null;){var he=H.tag;if((he===3||he===4)&&H.stateNode.containerInfo===M)return;H=H.return}for(;Z!==null;){if(H=Wo(Z),H===null)return;if(he=H.tag,he===5||he===6||he===26||he===27){A=B=H;continue e}Z=Z.parentNode}}A=A.return}ov(function(){var De=B,et=c0(v),st=[];e:{var Le=S0.get(h);if(Le!==void 0){var He=Pf,fn=h;switch(h){case"keypress":if(pc(v)===0)break e;case"keydown":case"keyup":He=fv;break;case"focusin":fn="focus",He=f0;break;case"focusout":fn="blur",He=f0;break;case"beforeblur":case"afterblur":He=f0;break;case"click":if(v.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":He=cv;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":He=JM;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":He=pv;break;case Xr:case Tv:case ca:He=PS;break;case wu:He=bu;break;case"scroll":case"scrollend":He=kS;break;case"wheel":He=ZM;break;case"copy":case"cut":case"paste":He=$S;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":He=p0;break;case"toggle":case"beforetoggle":He=gc}var on=(p&4)!==0,Ds=!on&&(h==="scroll"||h==="scrollend"),Ce=on?Le!==null?Le+"Capture":null:Le;on=[];for(var _e=De,Re;_e!==null;){var nt=_e;if(Re=nt.stateNode,nt=nt.tag,nt!==5&&nt!==26&&nt!==27||Re===null||Ce===null||(nt=kf(_e,Ce),nt!=null&&on.push(l1(_e,nt,Re))),Ds)break;_e=_e.return}0<on.length&&(Le=new He(Le,fn,null,v,et),st.push({event:Le,listeners:on}))}}if((p&7)===0){e:{if(Le=h==="mouseover"||h==="pointerover",He=h==="mouseout"||h==="pointerout",Le&&v!==u0&&(fn=v.relatedTarget||v.fromElement)&&(Wo(fn)||fn[wr]))break e;if((He||Le)&&(Le=et.window===et?et:(Le=et.ownerDocument)?Le.defaultView||Le.parentWindow:window,He?(fn=v.relatedTarget||v.toElement,He=De,fn=fn?Wo(fn):null,fn!==null&&(Ds=r(fn),on=fn.tag,fn!==Ds||on!==5&&on!==27&&on!==6)&&(fn=null)):(He=null,fn=De),He!==fn)){if(on=cv,nt="onMouseLeave",Ce="onMouseEnter",_e="mouse",(h==="pointerout"||h==="pointerover")&&(on=p0,nt="onPointerLeave",Ce="onPointerEnter",_e="pointer"),Ds=He==null?Le:fc(He),Re=fn==null?Le:fc(fn),Le=new on(nt,_e+"leave",He,v,et),Le.target=Ds,Le.relatedTarget=Re,nt=null,Wo(et)===De&&(on=new on(Ce,_e+"enter",fn,v,et),on.target=Re,on.relatedTarget=Ds,nt=on),Ds=nt,He&&fn)t:{for(on=He,Ce=fn,_e=0,Re=on;Re;Re=ry(Re))_e++;for(Re=0,nt=Ce;nt;nt=ry(nt))Re++;for(;0<_e-Re;)on=ry(on),_e--;for(;0<Re-_e;)Ce=ry(Ce),Re--;for(;_e--;){if(on===Ce||Ce!==null&&on===Ce.alternate)break t;on=ry(on),Ce=ry(Ce)}on=null}else on=null;He!==null&&QL(st,Le,He,on,!1),fn!==null&&Ds!==null&&QL(st,Ds,fn,on,!0)}}e:{if(Le=De?fc(De):window,He=Le.nodeName&&Le.nodeName.toLowerCase(),He==="select"||He==="input"&&Le.type==="file")var Gt=g0;else if(xv(Le))if(y0)Gt=vc;else{Gt=YS;var Gn=QM}else He=Le.nodeName,!He||He.toLowerCase()!=="input"||Le.type!=="checkbox"&&Le.type!=="radio"?De&&l0(De.elementType)&&(Gt=g0):Gt=qp;if(Gt&&(Gt=Gt(h,De))){oa(st,Gt,v,et);break e}Gn&&Gn(h,Le,De),h==="focusout"&&De&&Le.type==="number"&&De.memoizedProps.value!=null&&lr(Le,"number",Le.value)}switch(Gn=De?fc(De):window,h){case"focusin":(xv(Gn)||Gn.contentEditable==="true")&&(Su=Gn,v0=De,Kp=null);break;case"focusout":Kp=v0=Su=null;break;case"mousedown":b0=!0;break;case"contextmenu":case"mouseup":case"dragend":b0=!1,Av(st,v,et);break;case"selectionchange":if(Sv)break;case"keydown":case"keyup":Av(st,v,et)}var Yt;if(zp)e:{switch(h){case"compositionstart":var ln="onCompositionStart";break e;case"compositionend":ln="onCompositionEnd";break e;case"compositionupdate":ln="onCompositionUpdate";break e}ln=void 0}else xc?Vp(h,v)&&(ln="onCompositionEnd"):h==="keydown"&&v.keyCode===229&&(ln="onCompositionStart");ln&&(Hp&&v.locale!=="ko"&&(xc||ln!=="onCompositionStart"?ln==="onCompositionEnd"&&xc&&(Yt=uv()):(xu=et,lv="value"in xu?xu.value:xu.textContent,xc=!0)),Gn=XA(De,ln),0<Gn.length&&(ln=new d0(ln,h,null,v,et),st.push({event:ln,listeners:Gn}),Yt?ln.data=Yt:(Yt=gv(v),Yt!==null&&(ln.data=Yt)))),(Yt=Gp?Wp(h,v):yv(h,v))&&(ln=XA(De,"onBeforeInput"),0<ln.length&&(Gn=new d0("onBeforeInput","beforeinput",null,v,et),st.push({event:Gn,listeners:ln}),Gn.data=Yt)),vq(st,h,De,v,et)}JL(st,p)})}function l1(h,p,v){return{instance:h,listener:p,currentTarget:v}}function XA(h,p){for(var v=p+"Capture",A=[];h!==null;){var M=h,B=M.stateNode;if(M=M.tag,M!==5&&M!==26&&M!==27||B===null||(M=kf(h,v),M!=null&&A.unshift(l1(h,M,B)),M=kf(h,p),M!=null&&A.push(l1(h,M,B))),h.tag===3)return A;h=h.return}return[]}function ry(h){if(h===null)return null;do h=h.return;while(h&&h.tag!==5&&h.tag!==27);return h||null}function QL(h,p,v,A,M){for(var B=p._reactName,H=[];v!==null&&v!==A;){var Z=v,he=Z.alternate,De=Z.stateNode;if(Z=Z.tag,he!==null&&he===A)break;Z!==5&&Z!==26&&Z!==27||De===null||(he=De,M?(De=kf(v,B),De!=null&&H.unshift(l1(v,De,he))):M||(De=kf(v,B),De!=null&&H.push(l1(v,De,he)))),v=v.return}H.length!==0&&h.push({event:p,listeners:H})}var Aq=/\r\n?/g,Tq=/\u0000|\uFFFD/g;function eF(h){return(typeof h=="string"?h:""+h).replace(Aq,`
`).replace(Tq,"")}function tF(h,p){return p=eF(p),eF(h)===p}function qA(){}function Is(h,p,v,A,M,B){switch(v){case"children":typeof A=="string"?p==="body"||p==="textarea"&&A===""||Vr(h,A):(typeof A=="number"||typeof A=="bigint")&&p!=="body"&&Vr(h,""+A);break;case"className":bt(h,"class",A);break;case"tabIndex":bt(h,"tabindex",A);break;case"dir":case"role":case"viewBox":case"width":case"height":bt(h,v,A);break;case"style":Bp(h,A,B);break;case"data":if(p!=="object"){bt(h,"data",A);break}case"src":case"href":if(A===""&&(p!=="a"||v!=="href")){h.removeAttribute(v);break}if(A==null||typeof A=="function"||typeof A=="symbol"||typeof A=="boolean"){h.removeAttribute(v);break}A=kp(""+A),h.setAttribute(v,A);break;case"action":case"formAction":if(typeof A=="function"){h.setAttribute(v,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof B=="function"&&(v==="formAction"?(p!=="input"&&Is(h,p,"name",M.name,M,null),Is(h,p,"formEncType",M.formEncType,M,null),Is(h,p,"formMethod",M.formMethod,M,null),Is(h,p,"formTarget",M.formTarget,M,null)):(Is(h,p,"encType",M.encType,M,null),Is(h,p,"method",M.method,M,null),Is(h,p,"target",M.target,M,null)));if(A==null||typeof A=="symbol"||typeof A=="boolean"){h.removeAttribute(v);break}A=kp(""+A),h.setAttribute(v,A);break;case"onClick":A!=null&&(h.onclick=qA);break;case"onScroll":A!=null&&Hn("scroll",h);break;case"onScrollEnd":A!=null&&Hn("scrollend",h);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(n(61));if(v=A.__html,v!=null){if(M.children!=null)throw Error(n(60));h.innerHTML=v}}break;case"multiple":h.multiple=A&&typeof A!="function"&&typeof A!="symbol";break;case"muted":h.muted=A&&typeof A!="function"&&typeof A!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(A==null||typeof A=="function"||typeof A=="boolean"||typeof A=="symbol"){h.removeAttribute("xlink:href");break}v=kp(""+A),h.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",v);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":A!=null&&typeof A!="function"&&typeof A!="symbol"?h.setAttribute(v,""+A):h.removeAttribute(v);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":A&&typeof A!="function"&&typeof A!="symbol"?h.setAttribute(v,""):h.removeAttribute(v);break;case"capture":case"download":A===!0?h.setAttribute(v,""):A!==!1&&A!=null&&typeof A!="function"&&typeof A!="symbol"?h.setAttribute(v,A):h.removeAttribute(v);break;case"cols":case"rows":case"size":case"span":A!=null&&typeof A!="function"&&typeof A!="symbol"&&!isNaN(A)&&1<=A?h.setAttribute(v,A):h.removeAttribute(v);break;case"rowSpan":case"start":A==null||typeof A=="function"||typeof A=="symbol"||isNaN(A)?h.removeAttribute(v):h.setAttribute(v,A);break;case"popover":Hn("beforetoggle",h),Hn("toggle",h),ot(h,"popover",A);break;case"xlinkActuate":Tt(h,"http://www.w3.org/1999/xlink","xlink:actuate",A);break;case"xlinkArcrole":Tt(h,"http://www.w3.org/1999/xlink","xlink:arcrole",A);break;case"xlinkRole":Tt(h,"http://www.w3.org/1999/xlink","xlink:role",A);break;case"xlinkShow":Tt(h,"http://www.w3.org/1999/xlink","xlink:show",A);break;case"xlinkTitle":Tt(h,"http://www.w3.org/1999/xlink","xlink:title",A);break;case"xlinkType":Tt(h,"http://www.w3.org/1999/xlink","xlink:type",A);break;case"xmlBase":Tt(h,"http://www.w3.org/XML/1998/namespace","xml:base",A);break;case"xmlLang":Tt(h,"http://www.w3.org/XML/1998/namespace","xml:lang",A);break;case"xmlSpace":Tt(h,"http://www.w3.org/XML/1998/namespace","xml:space",A);break;case"is":ot(h,"is",A);break;case"innerText":case"textContent":break;default:(!(2<v.length)||v[0]!=="o"&&v[0]!=="O"||v[1]!=="n"&&v[1]!=="N")&&(v=rv.get(v)||v,ot(h,v,A))}}function gN(h,p,v,A,M,B){switch(v){case"style":Bp(h,A,B);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(n(61));if(v=A.__html,v!=null){if(M.children!=null)throw Error(n(60));h.innerHTML=v}}break;case"children":typeof A=="string"?Vr(h,A):(typeof A=="number"||typeof A=="bigint")&&Vr(h,""+A);break;case"onScroll":A!=null&&Hn("scroll",h);break;case"onScrollEnd":A!=null&&Hn("scrollend",h);break;case"onClick":A!=null&&(h.onclick=qA);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Bf.hasOwnProperty(v))e:{if(v[0]==="o"&&v[1]==="n"&&(M=v.endsWith("Capture"),p=v.slice(2,M?v.length-7:void 0),B=h[Oi]||null,B=B!=null?B[v]:null,typeof B=="function"&&h.removeEventListener(p,B,M),typeof A=="function")){typeof B!="function"&&B!==null&&(v in h?h[v]=null:h.hasAttribute(v)&&h.removeAttribute(v)),h.addEventListener(p,A,M);break e}v in h?h[v]=A:A===!0?h.setAttribute(v,""):ot(h,v,A)}}}function Qr(h,p,v){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Hn("error",h),Hn("load",h);var A=!1,M=!1,B;for(B in v)if(v.hasOwnProperty(B)){var H=v[B];if(H!=null)switch(B){case"src":A=!0;break;case"srcSet":M=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(n(137,p));default:Is(h,p,B,H,v,null)}}M&&Is(h,p,"srcSet",v.srcSet,v,null),A&&Is(h,p,"src",v.src,v,null);return;case"input":Hn("invalid",h);var Z=B=H=M=null,he=null,De=null;for(A in v)if(v.hasOwnProperty(A)){var et=v[A];if(et!=null)switch(A){case"name":M=et;break;case"type":H=et;break;case"checked":he=et;break;case"defaultChecked":De=et;break;case"value":B=et;break;case"defaultValue":Z=et;break;case"children":case"dangerouslySetInnerHTML":if(et!=null)throw Error(n(137,p));break;default:Is(h,p,A,et,v,null)}}ys(h,B,Z,he,De,H,M,!1),Vs(h);return;case"select":Hn("invalid",h),A=H=B=null;for(M in v)if(v.hasOwnProperty(M)&&(Z=v[M],Z!=null))switch(M){case"value":B=Z;break;case"defaultValue":H=Z;break;case"multiple":A=Z;default:Is(h,p,M,Z,v,null)}p=B,v=H,h.multiple=!!A,p!=null?_i(h,!!A,p,!1):v!=null&&_i(h,!!A,v,!0);return;case"textarea":Hn("invalid",h),B=M=A=null;for(H in v)if(v.hasOwnProperty(H)&&(Z=v[H],Z!=null))switch(H){case"value":A=Z;break;case"defaultValue":M=Z;break;case"children":B=Z;break;case"dangerouslySetInnerHTML":if(Z!=null)throw Error(n(91));break;default:Is(h,p,H,Z,v,null)}Hi(h,A,M,B),Vs(h);return;case"option":for(he in v)if(v.hasOwnProperty(he)&&(A=v[he],A!=null))switch(he){case"selected":h.selected=A&&typeof A!="function"&&typeof A!="symbol";break;default:Is(h,p,he,A,v,null)}return;case"dialog":Hn("beforetoggle",h),Hn("toggle",h),Hn("cancel",h),Hn("close",h);break;case"iframe":case"object":Hn("load",h);break;case"video":case"audio":for(A=0;A<o1.length;A++)Hn(o1[A],h);break;case"image":Hn("error",h),Hn("load",h);break;case"details":Hn("toggle",h);break;case"embed":case"source":case"link":Hn("error",h),Hn("load",h);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(De in v)if(v.hasOwnProperty(De)&&(A=v[De],A!=null))switch(De){case"children":case"dangerouslySetInnerHTML":throw Error(n(137,p));default:Is(h,p,De,A,v,null)}return;default:if(l0(p)){for(et in v)v.hasOwnProperty(et)&&(A=v[et],A!==void 0&&gN(h,p,et,A,v,void 0));return}}for(Z in v)v.hasOwnProperty(Z)&&(A=v[Z],A!=null&&Is(h,p,Z,A,v,null))}function wq(h,p,v,A){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var M=null,B=null,H=null,Z=null,he=null,De=null,et=null;for(He in v){var st=v[He];if(v.hasOwnProperty(He)&&st!=null)switch(He){case"checked":break;case"value":break;case"defaultValue":he=st;default:A.hasOwnProperty(He)||Is(h,p,He,null,A,st)}}for(var Le in A){var He=A[Le];if(st=v[Le],A.hasOwnProperty(Le)&&(He!=null||st!=null))switch(Le){case"type":B=He;break;case"name":M=He;break;case"checked":De=He;break;case"defaultChecked":et=He;break;case"value":H=He;break;case"defaultValue":Z=He;break;case"children":case"dangerouslySetInnerHTML":if(He!=null)throw Error(n(137,p));break;default:He!==st&&Is(h,p,Le,He,A,st)}}El(h,H,Z,he,De,et,B,M);return;case"select":He=H=Z=Le=null;for(B in v)if(he=v[B],v.hasOwnProperty(B)&&he!=null)switch(B){case"value":break;case"multiple":He=he;default:A.hasOwnProperty(B)||Is(h,p,B,null,A,he)}for(M in A)if(B=A[M],he=v[M],A.hasOwnProperty(M)&&(B!=null||he!=null))switch(M){case"value":Le=B;break;case"defaultValue":Z=B;break;case"multiple":H=B;default:B!==he&&Is(h,p,M,B,A,he)}p=Z,v=H,A=He,Le!=null?_i(h,!!v,Le,!1):!!A!=!!v&&(p!=null?_i(h,!!v,p,!0):_i(h,!!v,v?[]:"",!1));return;case"textarea":He=Le=null;for(Z in v)if(M=v[Z],v.hasOwnProperty(Z)&&M!=null&&!A.hasOwnProperty(Z))switch(Z){case"value":break;case"children":break;default:Is(h,p,Z,null,A,M)}for(H in A)if(M=A[H],B=v[H],A.hasOwnProperty(H)&&(M!=null||B!=null))switch(H){case"value":Le=M;break;case"defaultValue":He=M;break;case"children":break;case"dangerouslySetInnerHTML":if(M!=null)throw Error(n(91));break;default:M!==B&&Is(h,p,H,M,A,B)}Gi(h,Le,He);return;case"option":for(var fn in v)if(Le=v[fn],v.hasOwnProperty(fn)&&Le!=null&&!A.hasOwnProperty(fn))switch(fn){case"selected":h.selected=!1;break;default:Is(h,p,fn,null,A,Le)}for(he in A)if(Le=A[he],He=v[he],A.hasOwnProperty(he)&&Le!==He&&(Le!=null||He!=null))switch(he){case"selected":h.selected=Le&&typeof Le!="function"&&typeof Le!="symbol";break;default:Is(h,p,he,Le,A,He)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var on in v)Le=v[on],v.hasOwnProperty(on)&&Le!=null&&!A.hasOwnProperty(on)&&Is(h,p,on,null,A,Le);for(De in A)if(Le=A[De],He=v[De],A.hasOwnProperty(De)&&Le!==He&&(Le!=null||He!=null))switch(De){case"children":case"dangerouslySetInnerHTML":if(Le!=null)throw Error(n(137,p));break;default:Is(h,p,De,Le,A,He)}return;default:if(l0(p)){for(var Ds in v)Le=v[Ds],v.hasOwnProperty(Ds)&&Le!==void 0&&!A.hasOwnProperty(Ds)&&gN(h,p,Ds,void 0,A,Le);for(et in A)Le=A[et],He=v[et],!A.hasOwnProperty(et)||Le===He||Le===void 0&&He===void 0||gN(h,p,et,Le,A,He);return}}for(var Ce in v)Le=v[Ce],v.hasOwnProperty(Ce)&&Le!=null&&!A.hasOwnProperty(Ce)&&Is(h,p,Ce,null,A,Le);for(st in A)Le=A[st],He=v[st],!A.hasOwnProperty(st)||Le===He||Le==null&&He==null||Is(h,p,st,Le,A,He)}var yN=null,xN=null;function jA(h){return h.nodeType===9?h:h.ownerDocument}function nF(h){switch(h){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function sF(h,p){if(h===0)switch(p){case"svg":return 1;case"math":return 2;default:return 0}return h===1&&p==="foreignObject"?0:h}function vN(h,p){return h==="textarea"||h==="noscript"||typeof p.children=="string"||typeof p.children=="number"||typeof p.children=="bigint"||typeof p.dangerouslySetInnerHTML=="object"&&p.dangerouslySetInnerHTML!==null&&p.dangerouslySetInnerHTML.__html!=null}var bN=null;function Cq(){var h=window.event;return h&&h.type==="popstate"?h===bN?!1:(bN=h,!0):(bN=null,!1)}var iF=typeof setTimeout=="function"?setTimeout:void 0,Eq=typeof clearTimeout=="function"?clearTimeout:void 0,rF=typeof Promise=="function"?Promise:void 0,Mq=typeof queueMicrotask=="function"?queueMicrotask:typeof rF<"u"?function(h){return rF.resolve(null).then(h).catch(Nq)}:iF;function Nq(h){setTimeout(function(){throw h})}function bd(h){return h==="head"}function aF(h,p){var v=p,A=0,M=0;do{var B=v.nextSibling;if(h.removeChild(v),B&&B.nodeType===8)if(v=B.data,v==="/$"){if(0<A&&8>A){v=A;var H=h.ownerDocument;if(v&1&&u1(H.documentElement),v&2&&u1(H.body),v&4)for(v=H.head,u1(v),H=v.firstChild;H;){var Z=H.nextSibling,he=H.nodeName;H[Vo]||he==="SCRIPT"||he==="STYLE"||he==="LINK"&&H.rel.toLowerCase()==="stylesheet"||v.removeChild(H),H=Z}}if(M===0){h.removeChild(B),y1(p);return}M--}else v==="$"||v==="$?"||v==="$!"?M++:A=v.charCodeAt(0)-48;else A=0;v=B}while(v);y1(p)}function _N(h){var p=h.firstChild;for(p&&p.nodeType===10&&(p=p.nextSibling);p;){var v=p;switch(p=p.nextSibling,v.nodeName){case"HTML":case"HEAD":case"BODY":_N(v),gs(v);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(v.rel.toLowerCase()==="stylesheet")continue}h.removeChild(v)}}function Rq(h,p,v,A){for(;h.nodeType===1;){var M=v;if(h.nodeName.toLowerCase()!==p.toLowerCase()){if(!A&&(h.nodeName!=="INPUT"||h.type!=="hidden"))break}else if(A){if(!h[Vo])switch(p){case"meta":if(!h.hasAttribute("itemprop"))break;return h;case"link":if(B=h.getAttribute("rel"),B==="stylesheet"&&h.hasAttribute("data-precedence"))break;if(B!==M.rel||h.getAttribute("href")!==(M.href==null||M.href===""?null:M.href)||h.getAttribute("crossorigin")!==(M.crossOrigin==null?null:M.crossOrigin)||h.getAttribute("title")!==(M.title==null?null:M.title))break;return h;case"style":if(h.hasAttribute("data-precedence"))break;return h;case"script":if(B=h.getAttribute("src"),(B!==(M.src==null?null:M.src)||h.getAttribute("type")!==(M.type==null?null:M.type)||h.getAttribute("crossorigin")!==(M.crossOrigin==null?null:M.crossOrigin))&&B&&h.hasAttribute("async")&&!h.hasAttribute("itemprop"))break;return h;default:return h}}else if(p==="input"&&h.type==="hidden"){var B=M.name==null?null:""+M.name;if(M.type==="hidden"&&h.getAttribute("name")===B)return h}else return h;if(h=zu(h.nextSibling),h===null)break}return null}function Iq(h,p,v){if(p==="")return null;for(;h.nodeType!==3;)if((h.nodeType!==1||h.nodeName!=="INPUT"||h.type!=="hidden")&&!v||(h=zu(h.nextSibling),h===null))return null;return h}function SN(h){return h.data==="$!"||h.data==="$?"&&h.ownerDocument.readyState==="complete"}function Dq(h,p){var v=h.ownerDocument;if(h.data!=="$?"||v.readyState==="complete")p();else{var A=function(){p(),v.removeEventListener("DOMContentLoaded",A)};v.addEventListener("DOMContentLoaded",A),h._reactRetry=A}}function zu(h){for(;h!=null;h=h.nextSibling){var p=h.nodeType;if(p===1||p===3)break;if(p===8){if(p=h.data,p==="$"||p==="$!"||p==="$?"||p==="F!"||p==="F")break;if(p==="/$")return null}}return h}var AN=null;function oF(h){h=h.previousSibling;for(var p=0;h;){if(h.nodeType===8){var v=h.data;if(v==="$"||v==="$!"||v==="$?"){if(p===0)return h;p--}else v==="/$"&&p++}h=h.previousSibling}return null}function lF(h,p,v){switch(p=jA(v),h){case"html":if(h=p.documentElement,!h)throw Error(n(452));return h;case"head":if(h=p.head,!h)throw Error(n(453));return h;case"body":if(h=p.body,!h)throw Error(n(454));return h;default:throw Error(n(451))}}function u1(h){for(var p=h.attributes;p.length;)h.removeAttributeNode(p[0]);gs(h)}var Xl=new Map,uF=new Set;function KA(h){return typeof h.getRootNode=="function"?h.getRootNode():h.nodeType===9?h:h.ownerDocument}var Gh=W.d;W.d={f:Oq,r:Bq,D:kq,C:Lq,L:Fq,m:Pq,X:$q,S:Uq,M:zq};function Oq(){var h=Gh.f(),p=Vl();return h||p}function Bq(h){var p=Xo(h);p!==null&&p.tag===5&&p.type==="form"?MA(p):Gh.r(h)}var ay=typeof document>"u"?null:document;function cF(h,p,v){var A=ay;if(A&&typeof p=="string"&&p){var M=_s(p);M='link[rel="'+h+'"][href="'+M+'"]',typeof v=="string"&&(M+='[crossorigin="'+v+'"]'),uF.has(M)||(uF.add(M),h={rel:h,crossOrigin:v,href:p},A.querySelector(M)===null&&(p=A.createElement("link"),Qr(p,"link",h),bi(p),A.head.appendChild(p)))}}function kq(h){Gh.D(h),cF("dns-prefetch",h,null)}function Lq(h,p){Gh.C(h,p),cF("preconnect",h,p)}function Fq(h,p,v){Gh.L(h,p,v);var A=ay;if(A&&h&&p){var M='link[rel="preload"][as="'+_s(p)+'"]';p==="image"&&v&&v.imageSrcSet?(M+='[imagesrcset="'+_s(v.imageSrcSet)+'"]',typeof v.imageSizes=="string"&&(M+='[imagesizes="'+_s(v.imageSizes)+'"]')):M+='[href="'+_s(h)+'"]';var B=M;switch(p){case"style":B=oy(h);break;case"script":B=ly(h)}Xl.has(B)||(h=c({rel:"preload",href:p==="image"&&v&&v.imageSrcSet?void 0:h,as:p},v),Xl.set(B,h),A.querySelector(M)!==null||p==="style"&&A.querySelector(c1(B))||p==="script"&&A.querySelector(h1(B))||(p=A.createElement("link"),Qr(p,"link",h),bi(p),A.head.appendChild(p)))}}function Pq(h,p){Gh.m(h,p);var v=ay;if(v&&h){var A=p&&typeof p.as=="string"?p.as:"script",M='link[rel="modulepreload"][as="'+_s(A)+'"][href="'+_s(h)+'"]',B=M;switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":B=ly(h)}if(!Xl.has(B)&&(h=c({rel:"modulepreload",href:h},p),Xl.set(B,h),v.querySelector(M)===null)){switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(v.querySelector(h1(B)))return}A=v.createElement("link"),Qr(A,"link",h),bi(A),v.head.appendChild(A)}}}function Uq(h,p,v){Gh.S(h,p,v);var A=ay;if(A&&h){var M=yu(A).hoistableStyles,B=oy(h);p=p||"default";var H=M.get(B);if(!H){var Z={loading:0,preload:null};if(H=A.querySelector(c1(B)))Z.loading=5;else{h=c({rel:"stylesheet",href:h,"data-precedence":p},v),(v=Xl.get(B))&&TN(h,v);var he=H=A.createElement("link");bi(he),Qr(he,"link",h),he._p=new Promise(function(De,et){he.onload=De,he.onerror=et}),he.addEventListener("load",function(){Z.loading|=1}),he.addEventListener("error",function(){Z.loading|=2}),Z.loading|=4,YA(H,p,A)}H={type:"stylesheet",instance:H,count:1,state:Z},M.set(B,H)}}}function $q(h,p){Gh.X(h,p);var v=ay;if(v&&h){var A=yu(v).hoistableScripts,M=ly(h),B=A.get(M);B||(B=v.querySelector(h1(M)),B||(h=c({src:h,async:!0},p),(p=Xl.get(M))&&wN(h,p),B=v.createElement("script"),bi(B),Qr(B,"link",h),v.head.appendChild(B)),B={type:"script",instance:B,count:1,state:null},A.set(M,B))}}function zq(h,p){Gh.M(h,p);var v=ay;if(v&&h){var A=yu(v).hoistableScripts,M=ly(h),B=A.get(M);B||(B=v.querySelector(h1(M)),B||(h=c({src:h,async:!0,type:"module"},p),(p=Xl.get(M))&&wN(h,p),B=v.createElement("script"),bi(B),Qr(B,"link",h),v.head.appendChild(B)),B={type:"script",instance:B,count:1,state:null},A.set(M,B))}}function hF(h,p,v,A){var M=(M=Te.current)?KA(M):null;if(!M)throw Error(n(446));switch(h){case"meta":case"title":return null;case"style":return typeof v.precedence=="string"&&typeof v.href=="string"?(p=oy(v.href),v=yu(M).hoistableStyles,A=v.get(p),A||(A={type:"style",instance:null,count:0,state:null},v.set(p,A)),A):{type:"void",instance:null,count:0,state:null};case"link":if(v.rel==="stylesheet"&&typeof v.href=="string"&&typeof v.precedence=="string"){h=oy(v.href);var B=yu(M).hoistableStyles,H=B.get(h);if(H||(M=M.ownerDocument||M,H={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},B.set(h,H),(B=M.querySelector(c1(h)))&&!B._p&&(H.instance=B,H.state.loading=5),Xl.has(h)||(v={rel:"preload",as:"style",href:v.href,crossOrigin:v.crossOrigin,integrity:v.integrity,media:v.media,hrefLang:v.hrefLang,referrerPolicy:v.referrerPolicy},Xl.set(h,v),B||Gq(M,h,v,H.state))),p&&A===null)throw Error(n(528,""));return H}if(p&&A!==null)throw Error(n(529,""));return null;case"script":return p=v.async,v=v.src,typeof v=="string"&&p&&typeof p!="function"&&typeof p!="symbol"?(p=ly(v),v=yu(M).hoistableScripts,A=v.get(p),A||(A={type:"script",instance:null,count:0,state:null},v.set(p,A)),A):{type:"void",instance:null,count:0,state:null};default:throw Error(n(444,h))}}function oy(h){return'href="'+_s(h)+'"'}function c1(h){return'link[rel="stylesheet"]['+h+"]"}function fF(h){return c({},h,{"data-precedence":h.precedence,precedence:null})}function Gq(h,p,v,A){h.querySelector('link[rel="preload"][as="style"]['+p+"]")?A.loading=1:(p=h.createElement("link"),A.preload=p,p.addEventListener("load",function(){return A.loading|=1}),p.addEventListener("error",function(){return A.loading|=2}),Qr(p,"link",v),bi(p),h.head.appendChild(p))}function ly(h){return'[src="'+_s(h)+'"]'}function h1(h){return"script[async]"+h}function dF(h,p,v){if(p.count++,p.instance===null)switch(p.type){case"style":var A=h.querySelector('style[data-href~="'+_s(v.href)+'"]');if(A)return p.instance=A,bi(A),A;var M=c({},v,{"data-href":v.href,"data-precedence":v.precedence,href:null,precedence:null});return A=(h.ownerDocument||h).createElement("style"),bi(A),Qr(A,"style",M),YA(A,v.precedence,h),p.instance=A;case"stylesheet":M=oy(v.href);var B=h.querySelector(c1(M));if(B)return p.state.loading|=4,p.instance=B,bi(B),B;A=fF(v),(M=Xl.get(M))&&TN(A,M),B=(h.ownerDocument||h).createElement("link"),bi(B);var H=B;return H._p=new Promise(function(Z,he){H.onload=Z,H.onerror=he}),Qr(B,"link",A),p.state.loading|=4,YA(B,v.precedence,h),p.instance=B;case"script":return B=ly(v.src),(M=h.querySelector(h1(B)))?(p.instance=M,bi(M),M):(A=v,(M=Xl.get(B))&&(A=c({},v),wN(A,M)),h=h.ownerDocument||h,M=h.createElement("script"),bi(M),Qr(M,"link",A),h.head.appendChild(M),p.instance=M);case"void":return null;default:throw Error(n(443,p.type))}else p.type==="stylesheet"&&(p.state.loading&4)===0&&(A=p.instance,p.state.loading|=4,YA(A,v.precedence,h));return p.instance}function YA(h,p,v){for(var A=v.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),M=A.length?A[A.length-1]:null,B=M,H=0;H<A.length;H++){var Z=A[H];if(Z.dataset.precedence===p)B=Z;else if(B!==M)break}B?B.parentNode.insertBefore(h,B.nextSibling):(p=v.nodeType===9?v.head:v,p.insertBefore(h,p.firstChild))}function TN(h,p){h.crossOrigin==null&&(h.crossOrigin=p.crossOrigin),h.referrerPolicy==null&&(h.referrerPolicy=p.referrerPolicy),h.title==null&&(h.title=p.title)}function wN(h,p){h.crossOrigin==null&&(h.crossOrigin=p.crossOrigin),h.referrerPolicy==null&&(h.referrerPolicy=p.referrerPolicy),h.integrity==null&&(h.integrity=p.integrity)}var JA=null;function pF(h,p,v){if(JA===null){var A=new Map,M=JA=new Map;M.set(v,A)}else M=JA,A=M.get(v),A||(A=new Map,M.set(v,A));if(A.has(h))return A;for(A.set(h,null),v=v.getElementsByTagName(h),M=0;M<v.length;M++){var B=v[M];if(!(B[Vo]||B[vi]||h==="link"&&B.getAttribute("rel")==="stylesheet")&&B.namespaceURI!=="http://www.w3.org/2000/svg"){var H=B.getAttribute(p)||"";H=h+H;var Z=A.get(H);Z?Z.push(B):A.set(H,[B])}}return A}function mF(h,p,v){h=h.ownerDocument||h,h.head.insertBefore(v,p==="title"?h.querySelector("head > title"):null)}function Hq(h,p,v){if(v===1||p.itemProp!=null)return!1;switch(h){case"meta":case"title":return!0;case"style":if(typeof p.precedence!="string"||typeof p.href!="string"||p.href==="")break;return!0;case"link":if(typeof p.rel!="string"||typeof p.href!="string"||p.href===""||p.onLoad||p.onError)break;switch(p.rel){case"stylesheet":return h=p.disabled,typeof p.precedence=="string"&&h==null;default:return!0}case"script":if(p.async&&typeof p.async!="function"&&typeof p.async!="symbol"&&!p.onLoad&&!p.onError&&p.src&&typeof p.src=="string")return!0}return!1}function gF(h){return!(h.type==="stylesheet"&&(h.state.loading&3)===0)}var f1=null;function Vq(){}function Wq(h,p,v){if(f1===null)throw Error(n(475));var A=f1;if(p.type==="stylesheet"&&(typeof v.media!="string"||matchMedia(v.media).matches!==!1)&&(p.state.loading&4)===0){if(p.instance===null){var M=oy(v.href),B=h.querySelector(c1(M));if(B){h=B._p,h!==null&&typeof h=="object"&&typeof h.then=="function"&&(A.count++,A=ZA.bind(A),h.then(A,A)),p.state.loading|=4,p.instance=B,bi(B);return}B=h.ownerDocument||h,v=fF(v),(M=Xl.get(M))&&TN(v,M),B=B.createElement("link"),bi(B);var H=B;H._p=new Promise(function(Z,he){H.onload=Z,H.onerror=he}),Qr(B,"link",v),p.instance=B}A.stylesheets===null&&(A.stylesheets=new Map),A.stylesheets.set(p,h),(h=p.state.preload)&&(p.state.loading&3)===0&&(A.count++,p=ZA.bind(A),h.addEventListener("load",p),h.addEventListener("error",p))}}function Xq(){if(f1===null)throw Error(n(475));var h=f1;return h.stylesheets&&h.count===0&&CN(h,h.stylesheets),0<h.count?function(p){var v=setTimeout(function(){if(h.stylesheets&&CN(h,h.stylesheets),h.unsuspend){var A=h.unsuspend;h.unsuspend=null,A()}},6e4);return h.unsuspend=p,function(){h.unsuspend=null,clearTimeout(v)}}:null}function ZA(){if(this.count--,this.count===0){if(this.stylesheets)CN(this,this.stylesheets);else if(this.unsuspend){var h=this.unsuspend;this.unsuspend=null,h()}}}var QA=null;function CN(h,p){h.stylesheets=null,h.unsuspend!==null&&(h.count++,QA=new Map,p.forEach(qq,h),QA=null,ZA.call(h))}function qq(h,p){if(!(p.state.loading&4)){var v=QA.get(h);if(v)var A=v.get(null);else{v=new Map,QA.set(h,v);for(var M=h.querySelectorAll("link[data-precedence],style[data-precedence]"),B=0;B<M.length;B++){var H=M[B];(H.nodeName==="LINK"||H.getAttribute("media")!=="not all")&&(v.set(H.dataset.precedence,H),A=H)}A&&v.set(null,A)}M=p.instance,H=M.getAttribute("data-precedence"),B=v.get(H)||A,B===A&&v.set(null,M),v.set(H,M),this.count++,A=ZA.bind(this),M.addEventListener("load",A),M.addEventListener("error",A),B?B.parentNode.insertBefore(M,B.nextSibling):(h=h.nodeType===9?h.head:h,h.insertBefore(M,h.firstChild)),p.state.loading|=4}}var d1={$$typeof:E,Provider:null,Consumer:null,_currentValue:V,_currentValue2:V,_threadCount:0};function jq(h,p,v,A,M,B,H,Z){this.tag=1,this.containerInfo=h,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=We(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=We(0),this.hiddenUpdates=We(null),this.identifierPrefix=A,this.onUncaughtError=M,this.onCaughtError=B,this.onRecoverableError=H,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=Z,this.incompleteTransitions=new Map}function yF(h,p,v,A,M,B,H,Z,he,De,et,st){return h=new jq(h,p,v,H,Z,he,De,st),p=1,B===!0&&(p|=24),B=ha(3,null,null,p),h.current=B,B.stateNode=h,p=N0(),p.refCount++,h.pooledCache=p,p.refCount++,B.memoizedState={element:A,isDehydrated:v,cache:p},Fv(B),h}function xF(h){return h?(h=Sc,h):Sc}function vF(h,p,v,A,M,B){M=xF(M),A.context===null?A.context=M:A.pendingContext=M,A=Ol(p),A.payload={element:v},B=B===void 0?null:B,B!==null&&(A.callback=B),v=Iu(h,A,p),v!==null&&(Zr(v,h,p),Th(v,h,p))}function bF(h,p){if(h=h.memoizedState,h!==null&&h.dehydrated!==null){var v=h.retryLane;h.retryLane=v!==0&&v<p?v:p}}function EN(h,p){bF(h,p),(h=h.alternate)&&bF(h,p)}function _F(h){if(h.tag===13){var p=Cu(h,67108864);p!==null&&Zr(p,h,67108864),EN(h,67108864)}}var eT=!0;function Kq(h,p,v,A){var M=$.T;$.T=null;var B=W.p;try{W.p=2,MN(h,p,v,A)}finally{W.p=B,$.T=M}}function Yq(h,p,v,A){var M=$.T;$.T=null;var B=W.p;try{W.p=8,MN(h,p,v,A)}finally{W.p=B,$.T=M}}function MN(h,p,v,A){if(eT){var M=NN(A);if(M===null)mN(h,p,A,tT,v),AF(h,A);else if(Zq(M,h,p,v,A))A.stopPropagation();else if(AF(h,A),p&4&&-1<Jq.indexOf(h)){for(;M!==null;){var B=Xo(M);if(B!==null)switch(B.tag){case 3:if(B=B.stateNode,B.current.memoizedState.isDehydrated){var H=vt(B.pendingLanes);if(H!==0){var Z=B;for(Z.pendingLanes|=2,Z.entangledLanes|=2;H;){var he=1<<31-gt(H);Z.entanglements[1]|=he,H&=~he}Xc(B),(fs&6)===0&&(Mr=Fe()+500,a1(0))}}break;case 13:Z=Cu(B,2),Z!==null&&Zr(Z,B,2),Vl(),EN(B,2)}if(B=NN(A),B===null&&mN(h,p,A,tT,v),B===M)break;M=B}M!==null&&A.stopPropagation()}else mN(h,p,A,null,v)}}function NN(h){return h=c0(h),RN(h)}var tT=null;function RN(h){if(tT=null,h=Wo(h),h!==null){var p=r(h);if(p===null)h=null;else{var v=p.tag;if(v===13){if(h=a(p),h!==null)return h;h=null}else if(v===3){if(p.stateNode.current.memoizedState.isDehydrated)return p.tag===3?p.stateNode.containerInfo:null;h=null}else p!==h&&(h=null)}}return tT=h,null}function SF(h){switch(h){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Pe()){case ht:return 2;case ke:return 8;case ie:case j:return 32;case Ae:return 268435456;default:return 32}default:return 32}}var IN=!1,_d=null,Sd=null,Ad=null,p1=new Map,m1=new Map,Td=[],Jq="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function AF(h,p){switch(h){case"focusin":case"focusout":_d=null;break;case"dragenter":case"dragleave":Sd=null;break;case"mouseover":case"mouseout":Ad=null;break;case"pointerover":case"pointerout":p1.delete(p.pointerId);break;case"gotpointercapture":case"lostpointercapture":m1.delete(p.pointerId)}}function g1(h,p,v,A,M,B){return h===null||h.nativeEvent!==B?(h={blockedOn:p,domEventName:v,eventSystemFlags:A,nativeEvent:B,targetContainers:[M]},p!==null&&(p=Xo(p),p!==null&&_F(p)),h):(h.eventSystemFlags|=A,p=h.targetContainers,M!==null&&p.indexOf(M)===-1&&p.push(M),h)}function Zq(h,p,v,A,M){switch(p){case"focusin":return _d=g1(_d,h,p,v,A,M),!0;case"dragenter":return Sd=g1(Sd,h,p,v,A,M),!0;case"mouseover":return Ad=g1(Ad,h,p,v,A,M),!0;case"pointerover":var B=M.pointerId;return p1.set(B,g1(p1.get(B)||null,h,p,v,A,M)),!0;case"gotpointercapture":return B=M.pointerId,m1.set(B,g1(m1.get(B)||null,h,p,v,A,M)),!0}return!1}function TF(h){var p=Wo(h.target);if(p!==null){var v=r(p);if(v!==null){if(p=v.tag,p===13){if(p=a(v),p!==null){h.blockedOn=p,xi(h.priority,function(){if(v.tag===13){var A=Qs();A=Nn(A);var M=Cu(v,A);M!==null&&Zr(M,v,A),EN(v,A)}});return}}else if(p===3&&v.stateNode.current.memoizedState.isDehydrated){h.blockedOn=v.tag===3?v.stateNode.containerInfo:null;return}}}h.blockedOn=null}function nT(h){if(h.blockedOn!==null)return!1;for(var p=h.targetContainers;0<p.length;){var v=NN(h.nativeEvent);if(v===null){v=h.nativeEvent;var A=new v.constructor(v.type,v);u0=A,v.target.dispatchEvent(A),u0=null}else return p=Xo(v),p!==null&&_F(p),h.blockedOn=v,!1;p.shift()}return!0}function wF(h,p,v){nT(h)&&v.delete(p)}function Qq(){IN=!1,_d!==null&&nT(_d)&&(_d=null),Sd!==null&&nT(Sd)&&(Sd=null),Ad!==null&&nT(Ad)&&(Ad=null),p1.forEach(wF),m1.forEach(wF)}function sT(h,p){h.blockedOn===p&&(h.blockedOn=null,IN||(IN=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Qq)))}var iT=null;function CF(h){iT!==h&&(iT=h,s.unstable_scheduleCallback(s.unstable_NormalPriority,function(){iT===h&&(iT=null);for(var p=0;p<h.length;p+=3){var v=h[p],A=h[p+1],M=h[p+2];if(typeof A!="function"){if(RN(A||v)===null)continue;break}var B=Xo(v);B!==null&&(h.splice(p,3),p-=3,Qv(B,{pending:!0,data:M,method:v.method,action:A},A,M))}}))}function y1(h){function p(he){return sT(he,h)}_d!==null&&sT(_d,h),Sd!==null&&sT(Sd,h),Ad!==null&&sT(Ad,h),p1.forEach(p),m1.forEach(p);for(var v=0;v<Td.length;v++){var A=Td[v];A.blockedOn===h&&(A.blockedOn=null)}for(;0<Td.length&&(v=Td[0],v.blockedOn===null);)TF(v),v.blockedOn===null&&Td.shift();if(v=(h.ownerDocument||h).$$reactFormReplay,v!=null)for(A=0;A<v.length;A+=3){var M=v[A],B=v[A+1],H=M[Oi]||null;if(typeof B=="function")H||CF(v);else if(H){var Z=null;if(B&&B.hasAttribute("formAction")){if(M=B,H=B[Oi]||null)Z=H.formAction;else if(RN(M)!==null)continue}else Z=H.action;typeof Z=="function"?v[A+1]=Z:(v.splice(A,3),A-=3),CF(v)}}}function DN(h){this._internalRoot=h}rT.prototype.render=DN.prototype.render=function(h){var p=this._internalRoot;if(p===null)throw Error(n(409));var v=p.current,A=Qs();vF(v,A,h,p,null,null)},rT.prototype.unmount=DN.prototype.unmount=function(){var h=this._internalRoot;if(h!==null){this._internalRoot=null;var p=h.containerInfo;vF(h.current,2,null,h,null,null),Vl(),p[wr]=null}};function rT(h){this._internalRoot=h}rT.prototype.unstable_scheduleHydration=function(h){if(h){var p=_n();h={blockedOn:null,target:h,priority:p};for(var v=0;v<Td.length&&p!==0&&p<Td[v].priority;v++);Td.splice(v,0,h),v===0&&TF(h)}};var EF=e.version;if(EF!=="19.1.0")throw Error(n(527,EF,"19.1.0"));W.findDOMNode=function(h){var p=h._reactInternals;if(p===void 0)throw typeof h.render=="function"?Error(n(188)):(h=Object.keys(h).join(","),Error(n(268,h)));return h=l(p),h=h!==null?u(h):null,h=h===null?null:h.stateNode,h};var ej={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:$,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var aT=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!aT.isDisabled&&aT.supportsFiber)try{qe=aT.inject(ej),mt=aT}catch{}}return v1.createRoot=function(h,p){if(!i(h))throw Error(n(299));var v=!1,A="",M=gm,B=X0,H=$A,Z=null;return p!=null&&(p.unstable_strictMode===!0&&(v=!0),p.identifierPrefix!==void 0&&(A=p.identifierPrefix),p.onUncaughtError!==void 0&&(M=p.onUncaughtError),p.onCaughtError!==void 0&&(B=p.onCaughtError),p.onRecoverableError!==void 0&&(H=p.onRecoverableError),p.unstable_transitionCallbacks!==void 0&&(Z=p.unstable_transitionCallbacks)),p=yF(h,1,!1,null,null,v,A,M,B,H,Z,null),h[wr]=p.current,pN(h),new DN(p)},v1.hydrateRoot=function(h,p,v){if(!i(h))throw Error(n(299));var A=!1,M="",B=gm,H=X0,Z=$A,he=null,De=null;return v!=null&&(v.unstable_strictMode===!0&&(A=!0),v.identifierPrefix!==void 0&&(M=v.identifierPrefix),v.onUncaughtError!==void 0&&(B=v.onUncaughtError),v.onCaughtError!==void 0&&(H=v.onCaughtError),v.onRecoverableError!==void 0&&(Z=v.onRecoverableError),v.unstable_transitionCallbacks!==void 0&&(he=v.unstable_transitionCallbacks),v.formState!==void 0&&(De=v.formState)),p=yF(h,1,!0,p,v??null,A,M,B,H,Z,he,De),p.context=xF(null),v=p.current,A=Qs(),A=Nn(A),M=Ol(A),M.callback=null,Iu(v,M,A),v=A,p.current.lanes=v,Ze(p,v),Xc(p),h[wr]=p.current,pN(h),new rT(p)},v1.version="19.1.0",v1}var FF;function fj(){if(FF)return kN.exports;FF=1;function s(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s)}catch(e){console.error(e)}}return s(),kN.exports=hj(),kN.exports}var dj=fj(),b1={},PF;function pj(){if(PF)return b1;PF=1,Object.defineProperty(b1,"__esModule",{value:!0}),b1.parse=a,b1.serialize=u;const s=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,e=/^[\u0021-\u003A\u003C-\u007E]*$/,t=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,n=/^[\u0020-\u003A\u003D-\u007E]*$/,i=Object.prototype.toString,r=(()=>{const d=function(){};return d.prototype=Object.create(null),d})();function a(d,g){const x=new r,S=d.length;if(S<2)return x;const b=(g==null?void 0:g.decode)||c;let _=0;do{const T=d.indexOf("=",_);if(T===-1)break;const E=d.indexOf(";",_),C=E===-1?S:E;if(T>C){_=d.lastIndexOf(";",T-1)+1;continue}const R=o(d,_,T),I=l(d,T,R),L=d.slice(R,I);if(x[L]===void 0){let P=o(d,T+1,C),D=l(d,C,P);const O=b(d.slice(P,D));x[L]=O}_=C+1}while(_<S);return x}function o(d,g,x){do{const S=d.charCodeAt(g);if(S!==32&&S!==9)return g}while(++g<x);return x}function l(d,g,x){for(;g>x;){const S=d.charCodeAt(--g);if(S!==32&&S!==9)return g+1}return x}function u(d,g,x){const S=(x==null?void 0:x.encode)||encodeURIComponent;if(!s.test(d))throw new TypeError(`argument name is invalid: ${d}`);const b=S(g);if(!e.test(b))throw new TypeError(`argument val is invalid: ${g}`);let _=d+"="+b;if(!x)return _;if(x.maxAge!==void 0){if(!Number.isInteger(x.maxAge))throw new TypeError(`option maxAge is invalid: ${x.maxAge}`);_+="; Max-Age="+x.maxAge}if(x.domain){if(!t.test(x.domain))throw new TypeError(`option domain is invalid: ${x.domain}`);_+="; Domain="+x.domain}if(x.path){if(!n.test(x.path))throw new TypeError(`option path is invalid: ${x.path}`);_+="; Path="+x.path}if(x.expires){if(!f(x.expires)||!Number.isFinite(x.expires.valueOf()))throw new TypeError(`option expires is invalid: ${x.expires}`);_+="; Expires="+x.expires.toUTCString()}if(x.httpOnly&&(_+="; HttpOnly"),x.secure&&(_+="; Secure"),x.partitioned&&(_+="; Partitioned"),x.priority)switch(typeof x.priority=="string"?x.priority.toLowerCase():void 0){case"low":_+="; Priority=Low";break;case"medium":_+="; Priority=Medium";break;case"high":_+="; Priority=High";break;default:throw new TypeError(`option priority is invalid: ${x.priority}`)}if(x.sameSite)switch(typeof x.sameSite=="string"?x.sameSite.toLowerCase():x.sameSite){case!0:case"strict":_+="; SameSite=Strict";break;case"lax":_+="; SameSite=Lax";break;case"none":_+="; SameSite=None";break;default:throw new TypeError(`option sameSite is invalid: ${x.sameSite}`)}return _}function c(d){if(d.indexOf("%")===-1)return d;try{return decodeURIComponent(d)}catch{return d}}function f(d){return i.call(d)==="[object Date]"}return b1}pj();/**
 * react-router v7.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var UF="popstate";function mj(s={}){function e(i,r){let{pathname:a="/",search:o="",hash:l=""}=Wg(i.location.hash.substring(1));return!a.startsWith("/")&&!a.startsWith(".")&&(a="/"+a),MI("",{pathname:a,search:o,hash:l},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function t(i,r){let a=i.document.querySelector("base"),o="";if(a&&a.getAttribute("href")){let l=i.location.href,u=l.indexOf("#");o=u===-1?l:l.slice(0,u)}return o+"#"+(typeof r=="string"?r:hb(r))}function n(i,r){lu(i.pathname.charAt(0)==="/",`relative pathnames are not supported in hash history.push(${JSON.stringify(r)})`)}return yj(e,t,n,s)}function gi(s,e){if(s===!1||s===null||typeof s>"u")throw new Error(e)}function lu(s,e){if(!s){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function gj(){return Math.random().toString(36).substring(2,10)}function $F(s,e){return{usr:s.state,key:s.key,idx:e}}function MI(s,e,t=null,n){return{pathname:typeof s=="string"?s:s.pathname,search:"",hash:"",...typeof e=="string"?Wg(e):e,state:t,key:e&&e.key||n||gj()}}function hb({pathname:s="/",search:e="",hash:t=""}){return e&&e!=="?"&&(s+=e.charAt(0)==="?"?e:"?"+e),t&&t!=="#"&&(s+=t.charAt(0)==="#"?t:"#"+t),s}function Wg(s){let e={};if(s){let t=s.indexOf("#");t>=0&&(e.hash=s.substring(t),s=s.substring(0,t));let n=s.indexOf("?");n>=0&&(e.search=s.substring(n),s=s.substring(0,n)),s&&(e.pathname=s)}return e}function yj(s,e,t,n={}){let{window:i=document.defaultView,v5Compat:r=!1}=n,a=i.history,o="POP",l=null,u=c();u==null&&(u=0,a.replaceState({...a.state,idx:u},""));function c(){return(a.state||{idx:null}).idx}function f(){o="POP";let b=c(),_=b==null?null:b-u;u=b,l&&l({action:o,location:S.location,delta:_})}function d(b,_){o="PUSH";let T=MI(S.location,b,_);t&&t(T,b),u=c()+1;let E=$F(T,u),C=S.createHref(T);try{a.pushState(E,"",C)}catch(R){if(R instanceof DOMException&&R.name==="DataCloneError")throw R;i.location.assign(C)}r&&l&&l({action:o,location:S.location,delta:1})}function g(b,_){o="REPLACE";let T=MI(S.location,b,_);t&&t(T,b),u=c();let E=$F(T,u),C=S.createHref(T);a.replaceState(E,"",C),r&&l&&l({action:o,location:S.location,delta:0})}function x(b){let _=i.location.origin!=="null"?i.location.origin:i.location.href,T=typeof b=="string"?b:hb(b);return T=T.replace(/ $/,"%20"),gi(_,`No window.location.(origin|href) available to create URL for href: ${T}`),new URL(T,_)}let S={get action(){return o},get location(){return s(i,a)},listen(b){if(l)throw new Error("A history only accepts one active listener");return i.addEventListener(UF,f),l=b,()=>{i.removeEventListener(UF,f),l=null}},createHref(b){return e(i,b)},createURL:x,encodeLocation(b){let _=x(b);return{pathname:_.pathname,search:_.search,hash:_.hash}},push:d,replace:g,go(b){return a.go(b)}};return S}function bz(s,e,t="/"){return xj(s,e,t,!1)}function xj(s,e,t,n){let i=typeof e=="string"?Wg(e):e,r=gf(i.pathname||"/",t);if(r==null)return null;let a=_z(s);vj(a);let o=null;for(let l=0;o==null&&l<a.length;++l){let u=Rj(r);o=Mj(a[l],u,n)}return o}function _z(s,e=[],t=[],n=""){let i=(r,a,o)=>{let l={relativePath:o===void 0?r.path||"":o,caseSensitive:r.caseSensitive===!0,childrenIndex:a,route:r};l.relativePath.startsWith("/")&&(gi(l.relativePath.startsWith(n),`Absolute route path "${l.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),l.relativePath=l.relativePath.slice(n.length));let u=uf([n,l.relativePath]),c=t.concat(l);r.children&&r.children.length>0&&(gi(r.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${u}".`),_z(r.children,e,c,u)),!(r.path==null&&!r.index)&&e.push({path:u,score:Cj(u,r.index),routesMeta:c})};return s.forEach((r,a)=>{var o;if(r.path===""||!((o=r.path)!=null&&o.includes("?")))i(r,a);else for(let l of Sz(r.path))i(r,a,l)}),e}function Sz(s){let e=s.split("/");if(e.length===0)return[];let[t,...n]=e,i=t.endsWith("?"),r=t.replace(/\?$/,"");if(n.length===0)return i?[r,""]:[r];let a=Sz(n.join("/")),o=[];return o.push(...a.map(l=>l===""?r:[r,l].join("/"))),i&&o.push(...a),o.map(l=>s.startsWith("/")&&l===""?"/":l)}function vj(s){s.sort((e,t)=>e.score!==t.score?t.score-e.score:Ej(e.routesMeta.map(n=>n.childrenIndex),t.routesMeta.map(n=>n.childrenIndex)))}var bj=/^:[\w-]+$/,_j=3,Sj=2,Aj=1,Tj=10,wj=-2,zF=s=>s==="*";function Cj(s,e){let t=s.split("/"),n=t.length;return t.some(zF)&&(n+=wj),e&&(n+=Sj),t.filter(i=>!zF(i)).reduce((i,r)=>i+(bj.test(r)?_j:r===""?Aj:Tj),n)}function Ej(s,e){return s.length===e.length&&s.slice(0,-1).every((n,i)=>n===e[i])?s[s.length-1]-e[e.length-1]:0}function Mj(s,e,t=!1){let{routesMeta:n}=s,i={},r="/",a=[];for(let o=0;o<n.length;++o){let l=n[o],u=o===n.length-1,c=r==="/"?e:e.slice(r.length)||"/",f=Gw({path:l.relativePath,caseSensitive:l.caseSensitive,end:u},c),d=l.route;if(!f&&u&&t&&!n[n.length-1].route.index&&(f=Gw({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},c)),!f)return null;Object.assign(i,f.params),a.push({params:i,pathname:uf([r,f.pathname]),pathnameBase:Bj(uf([r,f.pathnameBase])),route:d}),f.pathnameBase!=="/"&&(r=uf([r,f.pathnameBase]))}return a}function Gw(s,e){typeof s=="string"&&(s={path:s,caseSensitive:!1,end:!0});let[t,n]=Nj(s.path,s.caseSensitive,s.end),i=e.match(t);if(!i)return null;let r=i[0],a=r.replace(/(.)\/+$/,"$1"),o=i.slice(1);return{params:n.reduce((u,{paramName:c,isOptional:f},d)=>{if(c==="*"){let x=o[d]||"";a=r.slice(0,r.length-x.length).replace(/(.)\/+$/,"$1")}const g=o[d];return f&&!g?u[c]=void 0:u[c]=(g||"").replace(/%2F/g,"/"),u},{}),pathname:r,pathnameBase:a,pattern:s}}function Nj(s,e=!1,t=!0){lu(s==="*"||!s.endsWith("*")||s.endsWith("/*"),`Route path "${s}" will be treated as if it were "${s.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${s.replace(/\*$/,"/*")}".`);let n=[],i="^"+s.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(a,o,l)=>(n.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return s.endsWith("*")?(n.push({paramName:"*"}),i+=s==="*"||s==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?i+="\\/*$":s!==""&&s!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),n]}function Rj(s){try{return s.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return lu(!1,`The URL path "${s}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),s}}function gf(s,e){if(e==="/")return s;if(!s.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,n=s.charAt(t);return n&&n!=="/"?null:s.slice(t)||"/"}function Ij(s,e="/"){let{pathname:t,search:n="",hash:i=""}=typeof s=="string"?Wg(s):s;return{pathname:t?t.startsWith("/")?t:Dj(t,e):e,search:kj(n),hash:Lj(i)}}function Dj(s,e){let t=e.replace(/\/+$/,"").split("/");return s.split("/").forEach(i=>{i===".."?t.length>1&&t.pop():i!=="."&&t.push(i)}),t.length>1?t.join("/"):"/"}function UN(s,e,t,n){return`Cannot include a '${s}' character in a manually specified \`to.${e}\` field [${JSON.stringify(n)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function Oj(s){return s.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function Az(s){let e=Oj(s);return e.map((t,n)=>n===e.length-1?t.pathname:t.pathnameBase)}function Tz(s,e,t,n=!1){let i;typeof s=="string"?i=Wg(s):(i={...s},gi(!i.pathname||!i.pathname.includes("?"),UN("?","pathname","search",i)),gi(!i.pathname||!i.pathname.includes("#"),UN("#","pathname","hash",i)),gi(!i.search||!i.search.includes("#"),UN("#","search","hash",i)));let r=s===""||i.pathname==="",a=r?"/":i.pathname,o;if(a==null)o=t;else{let f=e.length-1;if(!n&&a.startsWith("..")){let d=a.split("/");for(;d[0]==="..";)d.shift(),f-=1;i.pathname=d.join("/")}o=f>=0?e[f]:"/"}let l=Ij(i,o),u=a&&a!=="/"&&a.endsWith("/"),c=(r||a===".")&&t.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}var uf=s=>s.join("/").replace(/\/\/+/g,"/"),Bj=s=>s.replace(/\/+$/,"").replace(/^\/*/,"/"),kj=s=>!s||s==="?"?"":s.startsWith("?")?s:"?"+s,Lj=s=>!s||s==="#"?"":s.startsWith("#")?s:"#"+s;function Fj(s){return s!=null&&typeof s.status=="number"&&typeof s.statusText=="string"&&typeof s.internal=="boolean"&&"data"in s}var wz=["POST","PUT","PATCH","DELETE"];new Set(wz);var Pj=["GET",...wz];new Set(Pj);var Ox=Me.createContext(null);Ox.displayName="DataRouter";var xC=Me.createContext(null);xC.displayName="DataRouterState";var Cz=Me.createContext({isTransitioning:!1});Cz.displayName="ViewTransition";var Uj=Me.createContext(new Map);Uj.displayName="Fetchers";var $j=Me.createContext(null);$j.displayName="Await";var gh=Me.createContext(null);gh.displayName="Navigation";var qb=Me.createContext(null);qb.displayName="Location";var Cf=Me.createContext({outlet:null,matches:[],isDataRoute:!1});Cf.displayName="Route";var y3=Me.createContext(null);y3.displayName="RouteError";function zj(s,{relative:e}={}){gi(jb(),"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:n}=Me.useContext(gh),{hash:i,pathname:r,search:a}=Kb(s,{relative:e}),o=r;return t!=="/"&&(o=r==="/"?t:uf([t,r])),n.createHref({pathname:o,search:a,hash:i})}function jb(){return Me.useContext(qb)!=null}function Ef(){return gi(jb(),"useLocation() may be used only in the context of a <Router> component."),Me.useContext(qb).location}var Ez="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function Mz(s){Me.useContext(gh).static||Me.useLayoutEffect(s)}function Nz(){let{isDataRoute:s}=Me.useContext(Cf);return s?eK():Gj()}function Gj(){gi(jb(),"useNavigate() may be used only in the context of a <Router> component.");let s=Me.useContext(Ox),{basename:e,navigator:t}=Me.useContext(gh),{matches:n}=Me.useContext(Cf),{pathname:i}=Ef(),r=JSON.stringify(Az(n)),a=Me.useRef(!1);return Mz(()=>{a.current=!0}),Me.useCallback((l,u={})=>{if(lu(a.current,Ez),!a.current)return;if(typeof l=="number"){t.go(l);return}let c=Tz(l,JSON.parse(r),i,u.relative==="path");s==null&&e!=="/"&&(c.pathname=c.pathname==="/"?e:uf([e,c.pathname])),(u.replace?t.replace:t.push)(c,u.state,u)},[e,t,r,i,s])}Me.createContext(null);function Kb(s,{relative:e}={}){let{matches:t}=Me.useContext(Cf),{pathname:n}=Ef(),i=JSON.stringify(Az(t));return Me.useMemo(()=>Tz(s,JSON.parse(i),n,e==="path"),[s,i,n,e])}function Hj(s,e){return Rz(s,e)}function Rz(s,e,t,n){var T;gi(jb(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:i,static:r}=Me.useContext(gh),{matches:a}=Me.useContext(Cf),o=a[a.length-1],l=o?o.params:{},u=o?o.pathname:"/",c=o?o.pathnameBase:"/",f=o&&o.route;{let E=f&&f.path||"";Iz(u,!f||E.endsWith("*")||E.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${E}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${E}"> to <Route path="${E==="/"?"*":`${E}/*`}">.`)}let d=Ef(),g;if(e){let E=typeof e=="string"?Wg(e):e;gi(c==="/"||((T=E.pathname)==null?void 0:T.startsWith(c)),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${E.pathname}" was given in the \`location\` prop.`),g=E}else g=d;let x=g.pathname||"/",S=x;if(c!=="/"){let E=c.replace(/^\//,"").split("/");S="/"+x.replace(/^\//,"").split("/").slice(E.length).join("/")}let b=!r&&t&&t.matches&&t.matches.length>0?t.matches:bz(s,{pathname:S});lu(f||b!=null,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),lu(b==null||b[b.length-1].route.element!==void 0||b[b.length-1].route.Component!==void 0||b[b.length-1].route.lazy!==void 0,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let _=jj(b&&b.map(E=>Object.assign({},E,{params:Object.assign({},l,E.params),pathname:uf([c,i.encodeLocation?i.encodeLocation(E.pathname).pathname:E.pathname]),pathnameBase:E.pathnameBase==="/"?c:uf([c,i.encodeLocation?i.encodeLocation(E.pathnameBase).pathname:E.pathnameBase])})),a,t,n);return e&&_?Me.createElement(qb.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...g},navigationType:"POP"}},_):_}function Vj(){let s=Qj(),e=Fj(s)?`${s.status} ${s.statusText}`:s instanceof Error?s.message:JSON.stringify(s),t=s instanceof Error?s.stack:null,n="rgba(200,200,200, 0.5)",i={padding:"0.5rem",backgroundColor:n},r={padding:"2px 4px",backgroundColor:n},a=null;return console.error("Error handled by React Router default ErrorBoundary:",s),a=Me.createElement(Me.Fragment,null,Me.createElement("p",null,"💿 Hey developer 👋"),Me.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",Me.createElement("code",{style:r},"ErrorBoundary")," or"," ",Me.createElement("code",{style:r},"errorElement")," prop on your route.")),Me.createElement(Me.Fragment,null,Me.createElement("h2",null,"Unexpected Application Error!"),Me.createElement("h3",{style:{fontStyle:"italic"}},e),t?Me.createElement("pre",{style:i},t):null,a)}var Wj=Me.createElement(Vj,null),Xj=class extends Me.Component{constructor(s){super(s),this.state={location:s.location,revalidation:s.revalidation,error:s.error}}static getDerivedStateFromError(s){return{error:s}}static getDerivedStateFromProps(s,e){return e.location!==s.location||e.revalidation!=="idle"&&s.revalidation==="idle"?{error:s.error,location:s.location,revalidation:s.revalidation}:{error:s.error!==void 0?s.error:e.error,location:e.location,revalidation:s.revalidation||e.revalidation}}componentDidCatch(s,e){console.error("React Router caught the following error during render",s,e)}render(){return this.state.error!==void 0?Me.createElement(Cf.Provider,{value:this.props.routeContext},Me.createElement(y3.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function qj({routeContext:s,match:e,children:t}){let n=Me.useContext(Ox);return n&&n.static&&n.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(n.staticContext._deepestRenderedBoundaryId=e.route.id),Me.createElement(Cf.Provider,{value:s},t)}function jj(s,e=[],t=null,n=null){if(s==null){if(!t)return null;if(t.errors)s=t.matches;else if(e.length===0&&!t.initialized&&t.matches.length>0)s=t.matches;else return null}let i=s,r=t==null?void 0:t.errors;if(r!=null){let l=i.findIndex(u=>u.route.id&&(r==null?void 0:r[u.route.id])!==void 0);gi(l>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(r).join(",")}`),i=i.slice(0,Math.min(i.length,l+1))}let a=!1,o=-1;if(t)for(let l=0;l<i.length;l++){let u=i[l];if((u.route.HydrateFallback||u.route.hydrateFallbackElement)&&(o=l),u.route.id){let{loaderData:c,errors:f}=t,d=u.route.loader&&!c.hasOwnProperty(u.route.id)&&(!f||f[u.route.id]===void 0);if(u.route.lazy||d){a=!0,o>=0?i=i.slice(0,o+1):i=[i[0]];break}}}return i.reduceRight((l,u,c)=>{let f,d=!1,g=null,x=null;t&&(f=r&&u.route.id?r[u.route.id]:void 0,g=u.route.errorElement||Wj,a&&(o<0&&c===0?(Iz("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),d=!0,x=null):o===c&&(d=!0,x=u.route.hydrateFallbackElement||null)));let S=e.concat(i.slice(0,c+1)),b=()=>{let _;return f?_=g:d?_=x:u.route.Component?_=Me.createElement(u.route.Component,null):u.route.element?_=u.route.element:_=l,Me.createElement(qj,{match:u,routeContext:{outlet:l,matches:S,isDataRoute:t!=null},children:_})};return t&&(u.route.ErrorBoundary||u.route.errorElement||c===0)?Me.createElement(Xj,{location:t.location,revalidation:t.revalidation,component:g,error:f,children:b(),routeContext:{outlet:null,matches:S,isDataRoute:!0}}):b()},null)}function x3(s){return`${s} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Kj(s){let e=Me.useContext(Ox);return gi(e,x3(s)),e}function Yj(s){let e=Me.useContext(xC);return gi(e,x3(s)),e}function Jj(s){let e=Me.useContext(Cf);return gi(e,x3(s)),e}function v3(s){let e=Jj(s),t=e.matches[e.matches.length-1];return gi(t.route.id,`${s} can only be used on routes that contain a unique "id"`),t.route.id}function Zj(){return v3("useRouteId")}function Qj(){var n;let s=Me.useContext(y3),e=Yj("useRouteError"),t=v3("useRouteError");return s!==void 0?s:(n=e.errors)==null?void 0:n[t]}function eK(){let{router:s}=Kj("useNavigate"),e=v3("useNavigate"),t=Me.useRef(!1);return Mz(()=>{t.current=!0}),Me.useCallback(async(i,r={})=>{lu(t.current,Ez),t.current&&(typeof i=="number"?s.navigate(i):await s.navigate(i,{fromRouteId:e,...r}))},[s,e])}var GF={};function Iz(s,e,t){!e&&!GF[s]&&(GF[s]=!0,lu(!1,t))}Me.memo(tK);function tK({routes:s,future:e,state:t}){return Rz(s,void 0,t,e)}function Hm(s){gi(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function nK({basename:s="/",children:e=null,location:t,navigationType:n="POP",navigator:i,static:r=!1}){gi(!jb(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let a=s.replace(/^\/*/,"/"),o=Me.useMemo(()=>({basename:a,navigator:i,static:r,future:{}}),[a,i,r]);typeof t=="string"&&(t=Wg(t));let{pathname:l="/",search:u="",hash:c="",state:f=null,key:d="default"}=t,g=Me.useMemo(()=>{let x=gf(l,a);return x==null?null:{location:{pathname:x,search:u,hash:c,state:f,key:d},navigationType:n}},[a,l,u,c,f,d,n]);return lu(g!=null,`<Router basename="${a}"> is not able to match the URL "${l}${u}${c}" because it does not start with the basename, so the <Router> won't render anything.`),g==null?null:Me.createElement(gh.Provider,{value:o},Me.createElement(qb.Provider,{children:e,value:g}))}function sK({children:s,location:e}){return Hj(NI(s),e)}function NI(s,e=[]){let t=[];return Me.Children.forEach(s,(n,i)=>{if(!Me.isValidElement(n))return;let r=[...e,i];if(n.type===Me.Fragment){t.push.apply(t,NI(n.props.children,r));return}gi(n.type===Hm,`[${typeof n.type=="string"?n.type:n.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),gi(!n.props.index||!n.props.children,"An index route cannot have child routes.");let a={id:n.props.id||r.join("-"),caseSensitive:n.props.caseSensitive,element:n.props.element,Component:n.props.Component,index:n.props.index,path:n.props.path,loader:n.props.loader,action:n.props.action,hydrateFallbackElement:n.props.hydrateFallbackElement,HydrateFallback:n.props.HydrateFallback,errorElement:n.props.errorElement,ErrorBoundary:n.props.ErrorBoundary,hasErrorBoundary:n.props.hasErrorBoundary===!0||n.props.ErrorBoundary!=null||n.props.errorElement!=null,shouldRevalidate:n.props.shouldRevalidate,handle:n.props.handle,lazy:n.props.lazy};n.props.children&&(a.children=NI(n.props.children,r)),t.push(a)}),t}var bw="get",_w="application/x-www-form-urlencoded";function vC(s){return s!=null&&typeof s.tagName=="string"}function iK(s){return vC(s)&&s.tagName.toLowerCase()==="button"}function rK(s){return vC(s)&&s.tagName.toLowerCase()==="form"}function aK(s){return vC(s)&&s.tagName.toLowerCase()==="input"}function oK(s){return!!(s.metaKey||s.altKey||s.ctrlKey||s.shiftKey)}function lK(s,e){return s.button===0&&(!e||e==="_self")&&!oK(s)}function RI(s=""){return new URLSearchParams(typeof s=="string"||Array.isArray(s)||s instanceof URLSearchParams?s:Object.keys(s).reduce((e,t)=>{let n=s[t];return e.concat(Array.isArray(n)?n.map(i=>[t,i]):[[t,n]])},[]))}function uK(s,e){let t=RI(s);return e&&e.forEach((n,i)=>{t.has(i)||e.getAll(i).forEach(r=>{t.append(i,r)})}),t}var oT=null;function cK(){if(oT===null)try{new FormData(document.createElement("form"),0),oT=!1}catch{oT=!0}return oT}var hK=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function $N(s){return s!=null&&!hK.has(s)?(lu(!1,`"${s}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${_w}"`),null):s}function fK(s,e){let t,n,i,r,a;if(rK(s)){let o=s.getAttribute("action");n=o?gf(o,e):null,t=s.getAttribute("method")||bw,i=$N(s.getAttribute("enctype"))||_w,r=new FormData(s)}else if(iK(s)||aK(s)&&(s.type==="submit"||s.type==="image")){let o=s.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=s.getAttribute("formaction")||o.getAttribute("action");if(n=l?gf(l,e):null,t=s.getAttribute("formmethod")||o.getAttribute("method")||bw,i=$N(s.getAttribute("formenctype"))||$N(o.getAttribute("enctype"))||_w,r=new FormData(o,s),!cK()){let{name:u,type:c,value:f}=s;if(c==="image"){let d=u?`${u}.`:"";r.append(`${d}x`,"0"),r.append(`${d}y`,"0")}else u&&r.append(u,f)}}else{if(vC(s))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');t=bw,n=null,i=_w,a=s}return r&&i==="text/plain"&&(a=r,r=void 0),{action:n,method:t.toLowerCase(),encType:i,formData:r,body:a}}function b3(s,e){if(s===!1||s===null||typeof s>"u")throw new Error(e)}async function dK(s,e){if(s.id in e)return e[s.id];try{let t=await import(s.module);return e[s.id]=t,t}catch(t){return console.error(`Error loading route module \`${s.module}\`, reloading page...`),console.error(t),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function pK(s){return s==null?!1:s.href==null?s.rel==="preload"&&typeof s.imageSrcSet=="string"&&typeof s.imageSizes=="string":typeof s.rel=="string"&&typeof s.href=="string"}async function mK(s,e,t){let n=await Promise.all(s.map(async i=>{let r=e.routes[i.route.id];if(r){let a=await dK(r,t);return a.links?a.links():[]}return[]}));return vK(n.flat(1).filter(pK).filter(i=>i.rel==="stylesheet"||i.rel==="preload").map(i=>i.rel==="stylesheet"?{...i,rel:"prefetch",as:"style"}:{...i,rel:"prefetch"}))}function HF(s,e,t,n,i,r){let a=(l,u)=>t[u]?l.route.id!==t[u].route.id:!0,o=(l,u)=>{var c;return t[u].pathname!==l.pathname||((c=t[u].route.path)==null?void 0:c.endsWith("*"))&&t[u].params["*"]!==l.params["*"]};return r==="assets"?e.filter((l,u)=>a(l,u)||o(l,u)):r==="data"?e.filter((l,u)=>{var f;let c=n.routes[l.route.id];if(!c||!c.hasLoader)return!1;if(a(l,u)||o(l,u))return!0;if(l.route.shouldRevalidate){let d=l.route.shouldRevalidate({currentUrl:new URL(i.pathname+i.search+i.hash,window.origin),currentParams:((f=t[0])==null?void 0:f.params)||{},nextUrl:new URL(s,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof d=="boolean")return d}return!0}):[]}function gK(s,e,{includeHydrateFallback:t}={}){return yK(s.map(n=>{let i=e.routes[n.route.id];if(!i)return[];let r=[i.module];return i.clientActionModule&&(r=r.concat(i.clientActionModule)),i.clientLoaderModule&&(r=r.concat(i.clientLoaderModule)),t&&i.hydrateFallbackModule&&(r=r.concat(i.hydrateFallbackModule)),i.imports&&(r=r.concat(i.imports)),r}).flat(1))}function yK(s){return[...new Set(s)]}function xK(s){let e={},t=Object.keys(s).sort();for(let n of t)e[n]=s[n];return e}function vK(s,e){let t=new Set;return new Set(e),s.reduce((n,i)=>{let r=JSON.stringify(xK(i));return t.has(r)||(t.add(r),n.push({key:r,link:i})),n},[])}function bK(s,e){let t=typeof s=="string"?new URL(s,typeof window>"u"?"server://singlefetch/":window.location.origin):s;return t.pathname==="/"?t.pathname="_root.data":e&&gf(t.pathname,e)==="/"?t.pathname=`${e.replace(/\/$/,"")}/_root.data`:t.pathname=`${t.pathname.replace(/\/$/,"")}.data`,t}function Dz(){let s=Me.useContext(Ox);return b3(s,"You must render this element inside a <DataRouterContext.Provider> element"),s}function _K(){let s=Me.useContext(xC);return b3(s,"You must render this element inside a <DataRouterStateContext.Provider> element"),s}var _3=Me.createContext(void 0);_3.displayName="FrameworkContext";function Oz(){let s=Me.useContext(_3);return b3(s,"You must render this element inside a <HydratedRouter> element"),s}function SK(s,e){let t=Me.useContext(_3),[n,i]=Me.useState(!1),[r,a]=Me.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:u,onMouseLeave:c,onTouchStart:f}=e,d=Me.useRef(null);Me.useEffect(()=>{if(s==="render"&&a(!0),s==="viewport"){let S=_=>{_.forEach(T=>{a(T.isIntersecting)})},b=new IntersectionObserver(S,{threshold:.5});return d.current&&b.observe(d.current),()=>{b.disconnect()}}},[s]),Me.useEffect(()=>{if(n){let S=setTimeout(()=>{a(!0)},100);return()=>{clearTimeout(S)}}},[n]);let g=()=>{i(!0)},x=()=>{i(!1),a(!1)};return t?s!=="intent"?[r,d,{}]:[r,d,{onFocus:_1(o,g),onBlur:_1(l,x),onMouseEnter:_1(u,g),onMouseLeave:_1(c,x),onTouchStart:_1(f,g)}]:[!1,d,{}]}function _1(s,e){return t=>{s&&s(t),t.defaultPrevented||e(t)}}function AK({page:s,...e}){let{router:t}=Dz(),n=Me.useMemo(()=>bz(t.routes,s,t.basename),[t.routes,s,t.basename]);return n?Me.createElement(wK,{page:s,matches:n,...e}):null}function TK(s){let{manifest:e,routeModules:t}=Oz(),[n,i]=Me.useState([]);return Me.useEffect(()=>{let r=!1;return mK(s,e,t).then(a=>{r||i(a)}),()=>{r=!0}},[s,e,t]),n}function wK({page:s,matches:e,...t}){let n=Ef(),{manifest:i,routeModules:r}=Oz(),{basename:a}=Dz(),{loaderData:o,matches:l}=_K(),u=Me.useMemo(()=>HF(s,e,l,i,n,"data"),[s,e,l,i,n]),c=Me.useMemo(()=>HF(s,e,l,i,n,"assets"),[s,e,l,i,n]),f=Me.useMemo(()=>{if(s===n.pathname+n.search+n.hash)return[];let x=new Set,S=!1;if(e.forEach(_=>{var E;let T=i.routes[_.route.id];!T||!T.hasLoader||(!u.some(C=>C.route.id===_.route.id)&&_.route.id in o&&((E=r[_.route.id])!=null&&E.shouldRevalidate)||T.hasClientLoader?S=!0:x.add(_.route.id))}),x.size===0)return[];let b=bK(s,a);return S&&x.size>0&&b.searchParams.set("_routes",e.filter(_=>x.has(_.route.id)).map(_=>_.route.id).join(",")),[b.pathname+b.search]},[a,o,n,i,u,e,s,r]),d=Me.useMemo(()=>gK(c,i),[c,i]),g=TK(c);return Me.createElement(Me.Fragment,null,f.map(x=>Me.createElement("link",{key:x,rel:"prefetch",as:"fetch",href:x,...t})),d.map(x=>Me.createElement("link",{key:x,rel:"modulepreload",href:x,...t})),g.map(({key:x,link:S})=>Me.createElement("link",{key:x,...S})))}function CK(...s){return e=>{s.forEach(t=>{typeof t=="function"?t(e):t!=null&&(t.current=e)})}}var Bz=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{Bz&&(window.__reactRouterVersion="7.5.0")}catch{}function EK({basename:s,children:e,window:t}){let n=Me.useRef();n.current==null&&(n.current=mj({window:t,v5Compat:!0}));let i=n.current,[r,a]=Me.useState({action:i.action,location:i.location}),o=Me.useCallback(l=>{Me.startTransition(()=>a(l))},[a]);return Me.useLayoutEffect(()=>i.listen(o),[i,o]),Me.createElement(nK,{basename:s,children:e,location:r.location,navigationType:r.action,navigator:i})}var kz=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Yb=Me.forwardRef(function({onClick:e,discover:t="render",prefetch:n="none",relative:i,reloadDocument:r,replace:a,state:o,target:l,to:u,preventScrollReset:c,viewTransition:f,...d},g){let{basename:x}=Me.useContext(gh),S=typeof u=="string"&&kz.test(u),b,_=!1;if(typeof u=="string"&&S&&(b=u,Bz))try{let D=new URL(window.location.href),O=u.startsWith("//")?new URL(D.protocol+u):new URL(u),F=gf(O.pathname,x);O.origin===D.origin&&F!=null?u=F+O.search+O.hash:_=!0}catch{lu(!1,`<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let T=zj(u,{relative:i}),[E,C,R]=SK(n,d),I=IK(u,{replace:a,state:o,target:l,preventScrollReset:c,relative:i,viewTransition:f});function L(D){e&&e(D),D.defaultPrevented||I(D)}let P=Me.createElement("a",{...d,...R,href:b||T,onClick:_||r?e:L,ref:CK(g,C),target:l,"data-discover":!S&&t==="render"?"true":void 0});return E&&!S?Me.createElement(Me.Fragment,null,P,Me.createElement(AK,{page:T})):P});Yb.displayName="Link";var MK=Me.forwardRef(function({"aria-current":e="page",caseSensitive:t=!1,className:n="",end:i=!1,style:r,to:a,viewTransition:o,children:l,...u},c){let f=Kb(a,{relative:u.relative}),d=Ef(),g=Me.useContext(xC),{navigator:x,basename:S}=Me.useContext(gh),b=g!=null&&FK(f)&&o===!0,_=x.encodeLocation?x.encodeLocation(f).pathname:f.pathname,T=d.pathname,E=g&&g.navigation&&g.navigation.location?g.navigation.location.pathname:null;t||(T=T.toLowerCase(),E=E?E.toLowerCase():null,_=_.toLowerCase()),E&&S&&(E=gf(E,S)||E);const C=_!=="/"&&_.endsWith("/")?_.length-1:_.length;let R=T===_||!i&&T.startsWith(_)&&T.charAt(C)==="/",I=E!=null&&(E===_||!i&&E.startsWith(_)&&E.charAt(_.length)==="/"),L={isActive:R,isPending:I,isTransitioning:b},P=R?e:void 0,D;typeof n=="function"?D=n(L):D=[n,R?"active":null,I?"pending":null,b?"transitioning":null].filter(Boolean).join(" ");let O=typeof r=="function"?r(L):r;return Me.createElement(Yb,{...u,"aria-current":P,className:D,ref:c,style:O,to:a,viewTransition:o},typeof l=="function"?l(L):l)});MK.displayName="NavLink";var NK=Me.forwardRef(({discover:s="render",fetcherKey:e,navigate:t,reloadDocument:n,replace:i,state:r,method:a=bw,action:o,onSubmit:l,relative:u,preventScrollReset:c,viewTransition:f,...d},g)=>{let x=kK(),S=LK(o,{relative:u}),b=a.toLowerCase()==="get"?"get":"post",_=typeof o=="string"&&kz.test(o),T=E=>{if(l&&l(E),E.defaultPrevented)return;E.preventDefault();let C=E.nativeEvent.submitter,R=(C==null?void 0:C.getAttribute("formmethod"))||a;x(C||E.currentTarget,{fetcherKey:e,method:R,navigate:t,replace:i,state:r,relative:u,preventScrollReset:c,viewTransition:f})};return Me.createElement("form",{ref:g,method:b,action:S,onSubmit:n?l:T,...d,"data-discover":!_&&s==="render"?"true":void 0})});NK.displayName="Form";function RK(s){return`${s} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Lz(s){let e=Me.useContext(Ox);return gi(e,RK(s)),e}function IK(s,{target:e,replace:t,state:n,preventScrollReset:i,relative:r,viewTransition:a}={}){let o=Nz(),l=Ef(),u=Kb(s,{relative:r});return Me.useCallback(c=>{if(lK(c,e)){c.preventDefault();let f=t!==void 0?t:hb(l)===hb(u);o(s,{replace:f,state:n,preventScrollReset:i,relative:r,viewTransition:a})}},[l,o,u,t,n,e,s,i,r,a])}function DK(s){lu(typeof URLSearchParams<"u","You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");let e=Me.useRef(RI(s)),t=Me.useRef(!1),n=Ef(),i=Me.useMemo(()=>uK(n.search,t.current?null:e.current),[n.search]),r=Nz(),a=Me.useCallback((o,l)=>{const u=RI(typeof o=="function"?o(i):o);t.current=!0,r("?"+u,l)},[r,i]);return[i,a]}var OK=0,BK=()=>`__${String(++OK)}__`;function kK(){let{router:s}=Lz("useSubmit"),{basename:e}=Me.useContext(gh),t=Zj();return Me.useCallback(async(n,i={})=>{let{action:r,method:a,encType:o,formData:l,body:u}=fK(n,e);if(i.navigate===!1){let c=i.fetcherKey||BK();await s.fetch(c,t,i.action||r,{preventScrollReset:i.preventScrollReset,formData:l,body:u,formMethod:i.method||a,formEncType:i.encType||o,flushSync:i.flushSync})}else await s.navigate(i.action||r,{preventScrollReset:i.preventScrollReset,formData:l,body:u,formMethod:i.method||a,formEncType:i.encType||o,replace:i.replace,state:i.state,fromRouteId:t,flushSync:i.flushSync,viewTransition:i.viewTransition})},[s,e,t])}function LK(s,{relative:e}={}){let{basename:t}=Me.useContext(gh),n=Me.useContext(Cf);gi(n,"useFormAction must be used inside a RouteContext");let[i]=n.matches.slice(-1),r={...Kb(s||".",{relative:e})},a=Ef();if(s==null){r.search=a.search;let o=new URLSearchParams(r.search),l=o.getAll("index");if(l.some(c=>c==="")){o.delete("index"),l.filter(f=>f).forEach(f=>o.append("index",f));let c=o.toString();r.search=c?`?${c}`:""}}return(!s||s===".")&&i.route.index&&(r.search=r.search?r.search.replace(/^\?/,"?index&"):"?index"),t!=="/"&&(r.pathname=r.pathname==="/"?t:uf([t,r.pathname])),hb(r)}function FK(s,e={}){let t=Me.useContext(Cz);gi(t!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:n}=Lz("useViewTransitionState"),i=Kb(s,{relative:e.relative});if(!t.isTransitioning)return!1;let r=gf(t.currentLocation.pathname,n)||t.currentLocation.pathname,a=gf(t.nextLocation.pathname,n)||t.nextLocation.pathname;return Gw(i.pathname,a)!=null||Gw(i.pathname,r)!=null}new TextEncoder;const S3=({to:s,children:e})=>ft.jsx(Yb,{to:s,className:"bg-[#7A3D02] hover:bg-[#5c2e01] text-[#DEBE89] text-lg px-6 py-3 rounded-lg shadow-md uppercase font-bold font-poppins transition",children:e});function PK(){return ft.jsxs("div",{className:"min-h-screen flex flex-col items-center justify-center text-center px-4 text-[#402103]",children:[ft.jsx("h1",{className:"text-4xl md:text-5xl font-extrabold mb-4",style:{fontFamily:"IM Fell English, serif"},children:"Welkom bij de Mesolithische Vrouw"}),ft.jsx("p",{className:"text-lg md:text-xl mb-6 max-w-xl font-poppins",children:"Ontdek hoe wetenschap en verbeelding samenkomen in de reconstructie van een vrouw uit het mesolithicum."}),ft.jsx(S3,{to:"/model",children:"Start de reconstructie"})]})}/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Jb="175",Vm={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Wm={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Fz=0,II=1,Pz=2,UK=3,Uz=0,bC=1,J1=2,qu=3,ch=0,so=1,Ju=2,cf=0,hg=1,DI=2,OI=3,BI=4,$z=5,Ld=100,zz=101,Gz=102,Hz=103,Vz=104,Wz=200,Xz=201,qz=202,jz=203,Hw=204,Vw=205,Kz=206,Yz=207,Jz=208,Zz=209,Qz=210,e9=211,t9=212,n9=213,s9=214,Ww=0,Xw=1,qw=2,Sg=3,jw=4,Kw=5,Yw=6,Jw=7,Zb=0,i9=1,r9=2,th=0,a9=1,o9=2,l9=3,A3=4,u9=5,c9=6,h9=7,kI="attached",f9="detached",_C=300,yf=301,ep=302,fb=303,db=304,Bx=306,tp=1e3,hl=1001,tx=1002,Br=1003,SC=1004,$K=1004,ng=1005,zK=1005,$i=1006,Gy=1007,GK=1007,tu=1008,HK=1008,nc=1009,T3=1010,w3=1011,nx=1012,AC=1013,xf=1014,Eo=1015,kx=1016,TC=1017,wC=1018,sx=1020,C3=35902,E3=1021,M3=1022,wa=1023,N3=1024,R3=1025,ix=1026,rx=1027,CC=1028,Qb=1029,I3=1030,EC=1031,VK=1032,MC=1033,Z1=33776,Q1=33777,eb=33778,tb=33779,Zw=35840,Qw=35841,e2=35842,t2=35843,n2=36196,s2=37492,i2=37496,r2=37808,a2=37809,o2=37810,l2=37811,u2=37812,c2=37813,h2=37814,f2=37815,d2=37816,p2=37817,m2=37818,g2=37819,y2=37820,x2=37821,nb=36492,v2=36494,b2=36495,D3=36283,_2=36284,S2=36285,A2=36286,d9=2200,p9=2201,m9=2202,ax=2300,ox=2301,Sw=2302,sg=2400,ig=2401,pb=2402,NC=2500,O3=2501,g9=0,B3=1,T2=2,y9=3200,x9=3201,WK=3202,XK=3203,gp=0,v9=1,sf="",va="srgb",np="srgb-linear",mb="linear",Cs="srgb",qK=0,Xm=7680,jK=7681,KK=7682,YK=7683,JK=34055,ZK=34056,QK=5386,eY=512,tY=513,nY=514,sY=515,iY=516,rY=517,aY=518,LI=519,b9=512,_9=513,S9=514,k3=515,A9=516,T9=517,w9=518,C9=519,gb=35044,oY=35048,lY=35040,uY=35045,cY=35049,hY=35041,fY=35046,dY=35050,pY=35042,mY="100",FI="300 es",Zu=2e3,yb=2001,gY={COMPUTE:"compute",RENDER:"render"};let yh=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){const n=this._listeners;return n===void 0?!1:n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){const n=this._listeners;if(n===void 0)return;const i=n[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const n=t[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}};const ga=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let VF=1234567;const fg=Math.PI/180,lx=180/Math.PI;function gl(){const s=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ga[s&255]+ga[s>>8&255]+ga[s>>16&255]+ga[s>>24&255]+"-"+ga[e&255]+ga[e>>8&255]+"-"+ga[e>>16&15|64]+ga[e>>24&255]+"-"+ga[t&63|128]+ga[t>>8&255]+"-"+ga[t>>16&255]+ga[t>>24&255]+ga[n&255]+ga[n>>8&255]+ga[n>>16&255]+ga[n>>24&255]).toLowerCase()}function vn(s,e,t){return Math.max(e,Math.min(t,s))}function L3(s,e){return(s%e+e)%e}function yY(s,e,t,n,i){return n+(s-e)*(i-n)/(t-e)}function xY(s,e,t){return s!==e?(t-s)/(e-s):0}function sb(s,e,t){return(1-t)*s+t*e}function vY(s,e,t,n){return sb(s,e,1-Math.exp(-t*n))}function bY(s,e=1){return e-Math.abs(L3(s,e*2)-e)}function _Y(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e),s*s*(3-2*s))}function SY(s,e,t){return s<=e?0:s>=t?1:(s=(s-e)/(t-e),s*s*s*(s*(s*6-15)+10))}function AY(s,e){return s+Math.floor(Math.random()*(e-s+1))}function TY(s,e){return s+Math.random()*(e-s)}function wY(s){return s*(.5-Math.random())}function CY(s){s!==void 0&&(VF=s);let e=VF+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function EY(s){return s*fg}function MY(s){return s*lx}function NY(s){return(s&s-1)===0&&s!==0}function RY(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function IY(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function DY(s,e,t,n,i){const r=Math.cos,a=Math.sin,o=r(t/2),l=a(t/2),u=r((e+n)/2),c=a((e+n)/2),f=r((e-n)/2),d=a((e-n)/2),g=r((n-e)/2),x=a((n-e)/2);switch(i){case"XYX":s.set(o*c,l*f,l*d,o*u);break;case"YZY":s.set(l*d,o*c,l*f,o*u);break;case"ZXZ":s.set(l*f,l*d,o*c,o*u);break;case"XZX":s.set(o*c,l*x,l*g,o*u);break;case"YXY":s.set(l*g,o*c,l*x,o*u);break;case"ZYZ":s.set(l*x,l*g,o*c,o*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function eo(s,e){switch(e.constructor){case Float32Array:return s;case Uint32Array:return s/4294967295;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int32Array:return Math.max(s/2147483647,-1);case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function Cn(s,e){switch(e.constructor){case Float32Array:return s;case Uint32Array:return Math.round(s*4294967295);case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int32Array:return Math.round(s*2147483647);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}const E9={DEG2RAD:fg,RAD2DEG:lx,generateUUID:gl,clamp:vn,euclideanModulo:L3,mapLinear:yY,inverseLerp:xY,lerp:sb,damp:vY,pingpong:bY,smoothstep:_Y,smootherstep:SY,randInt:AY,randFloat:TY,randFloatSpread:wY,seededRandom:CY,degToRad:EY,radToDeg:MY,isPowerOfTwo:NY,ceilPowerOfTwo:RY,floorPowerOfTwo:IY,setQuaternionFromProperEuler:DY,normalize:Cn,denormalize:eo};class tt{constructor(e=0,t=0){tt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=vn(this.x,e.x,t.x),this.y=vn(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=vn(this.x,e,t),this.y=vn(this.y,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(vn(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(vn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class An{constructor(e,t,n,i,r,a,o,l,u){An.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,o,l,u)}set(e,t,n,i,r,a,o,l,u){const c=this.elements;return c[0]=e,c[1]=i,c[2]=o,c[3]=t,c[4]=r,c[5]=l,c[6]=n,c[7]=a,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],o=n[3],l=n[6],u=n[1],c=n[4],f=n[7],d=n[2],g=n[5],x=n[8],S=i[0],b=i[3],_=i[6],T=i[1],E=i[4],C=i[7],R=i[2],I=i[5],L=i[8];return r[0]=a*S+o*T+l*R,r[3]=a*b+o*E+l*I,r[6]=a*_+o*C+l*L,r[1]=u*S+c*T+f*R,r[4]=u*b+c*E+f*I,r[7]=u*_+c*C+f*L,r[2]=d*S+g*T+x*R,r[5]=d*b+g*E+x*I,r[8]=d*_+g*C+x*L,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8];return t*a*c-t*o*u-n*r*c+n*o*l+i*r*u-i*a*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8],f=c*a-o*u,d=o*l-c*r,g=u*r-a*l,x=t*f+n*d+i*g;if(x===0)return this.set(0,0,0,0,0,0,0,0,0);const S=1/x;return e[0]=f*S,e[1]=(i*u-c*n)*S,e[2]=(o*n-i*a)*S,e[3]=d*S,e[4]=(c*t-i*l)*S,e[5]=(i*r-o*t)*S,e[6]=g*S,e[7]=(n*l-u*t)*S,e[8]=(a*t-n*r)*S,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,o){const l=Math.cos(r),u=Math.sin(r);return this.set(n*l,n*u,-n*(l*a+u*o)+a+e,-i*u,i*l,-i*(-u*a+l*o)+o+t,0,0,1),this}scale(e,t){return this.premultiply(zN.makeScale(e,t)),this}rotate(e){return this.premultiply(zN.makeRotation(-e)),this}translate(e,t){return this.premultiply(zN.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const zN=new An;function M9(s){for(let e=s.length-1;e>=0;--e)if(s[e]>=65535)return!0;return!1}const OY={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Py(s,e){return new OY[s](e)}function xb(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function N9(){const s=xb("canvas");return s.style.display="block",s}const WF={};function Aw(s){s in WF||(WF[s]=!0,console.warn(s))}function BY(s,e,t){return new Promise(function(n,i){function r(){switch(s.clientWaitSync(e,s.SYNC_FLUSH_COMMANDS_BIT,0)){case s.WAIT_FAILED:i();break;case s.TIMEOUT_EXPIRED:setTimeout(r,t);break;default:n()}}setTimeout(r,t)})}function kY(s){const e=s.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function LY(s){const e=s.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const XF=new An().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),qF=new An().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function FY(){const s={enabled:!0,workingColorSpace:np,spaces:{},convert:function(i,r,a){return this.enabled===!1||r===a||!r||!a||(this.spaces[r].transfer===Cs&&(i.r=hf(i.r),i.g=hf(i.g),i.b=hf(i.b)),this.spaces[r].primaries!==this.spaces[a].primaries&&(i.applyMatrix3(this.spaces[r].toXYZ),i.applyMatrix3(this.spaces[a].fromXYZ)),this.spaces[a].transfer===Cs&&(i.r=Hy(i.r),i.g=Hy(i.g),i.b=Hy(i.b))),i},fromWorkingColorSpace:function(i,r){return this.convert(i,this.workingColorSpace,r)},toWorkingColorSpace:function(i,r){return this.convert(i,r,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===sf?mb:this.spaces[i].transfer},getLuminanceCoefficients:function(i,r=this.workingColorSpace){return i.fromArray(this.spaces[r].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,r,a){return i.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],n=[.3127,.329];return s.define({[np]:{primaries:e,whitePoint:n,transfer:mb,toXYZ:XF,fromXYZ:qF,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:va},outputColorSpaceConfig:{drawingBufferColorSpace:va}},[va]:{primaries:e,whitePoint:n,transfer:Cs,toXYZ:XF,fromXYZ:qF,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:va}}}),s}const Qn=FY();function hf(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function Hy(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}let uy;class R9{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let n;if(e instanceof HTMLCanvasElement)n=e;else{uy===void 0&&(uy=xb("canvas")),uy.width=e.width,uy.height=e.height;const i=uy.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),n=uy}return n.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=xb("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=hf(r[a]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(hf(t[n]/255)*255):t[n]=hf(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let PY=0;class Pd{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:PY++}),this.uuid=gl(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?r.push(GN(i[a].image)):r.push(GN(i[a]))}else r=GN(i);n.url=r}return t||(e.images[this.uuid]=n),n}}function GN(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?R9.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let UY=0;class ii extends yh{constructor(e=ii.DEFAULT_IMAGE,t=ii.DEFAULT_MAPPING,n=hl,i=hl,r=$i,a=tu,o=wa,l=nc,u=ii.DEFAULT_ANISOTROPY,c=sf){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:UY++}),this.uuid=gl(),this.name="",this.source=new Pd(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=u,this.format=o,this.internalFormat=null,this.type=l,this.offset=new tt(0,0),this.repeat=new tt(1,1),this.center=new tt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new An,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==_C)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case tp:e.x=e.x-Math.floor(e.x);break;case hl:e.x=e.x<0?0:1;break;case tx:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case tp:e.y=e.y-Math.floor(e.y);break;case hl:e.y=e.y<0?0:1;break;case tx:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}ii.DEFAULT_IMAGE=null;ii.DEFAULT_MAPPING=_C;ii.DEFAULT_ANISOTROPY=1;class os{constructor(e=0,t=0,n=0,i=1){os.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const l=e.elements,u=l[0],c=l[4],f=l[8],d=l[1],g=l[5],x=l[9],S=l[2],b=l[6],_=l[10];if(Math.abs(c-d)<.01&&Math.abs(f-S)<.01&&Math.abs(x-b)<.01){if(Math.abs(c+d)<.1&&Math.abs(f+S)<.1&&Math.abs(x+b)<.1&&Math.abs(u+g+_-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const E=(u+1)/2,C=(g+1)/2,R=(_+1)/2,I=(c+d)/4,L=(f+S)/4,P=(x+b)/4;return E>C&&E>R?E<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(E),i=I/n,r=L/n):C>R?C<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(C),n=I/i,r=P/i):R<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(R),n=L/r,i=P/r),this.set(n,i,r,t),this}let T=Math.sqrt((b-x)*(b-x)+(f-S)*(f-S)+(d-c)*(d-c));return Math.abs(T)<.001&&(T=1),this.x=(b-x)/T,this.y=(f-S)/T,this.z=(d-c)/T,this.w=Math.acos((u+g+_-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=vn(this.x,e.x,t.x),this.y=vn(this.y,e.y,t.y),this.z=vn(this.z,e.z,t.z),this.w=vn(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=vn(this.x,e,t),this.y=vn(this.y,e,t),this.z=vn(this.z,e,t),this.w=vn(this.w,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(vn(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RC extends yh{constructor(e=1,t=1,n={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new os(0,0,e,t),this.scissorTest=!1,this.viewport=new os(0,0,e,t);const i={width:e,height:t,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:$i,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const r=new ii(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);r.flipY=!1,r.generateMipmaps=n.generateMipmaps,r.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let o=0;o<a;o++)this.textures[o]=r.clone(),this.textures[o].isRenderTargetTexture=!0,this.textures[o].renderTarget=this;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this._depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=e,this.textures[i].image.height=t,this.textures[i].image.depth=n;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,n=e.textures.length;t<n;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const i=Object.assign({},e.textures[t].image);this.textures[t].source=new Pd(i)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class hh extends RC{constructor(e=1,t=1,n={}){super(e,t,n),this.isWebGLRenderTarget=!0}}class e_ extends ii{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Br,this.minFilter=Br,this.wrapR=hl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class $Y extends hh{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new e_(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class IC extends ii{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Br,this.minFilter=Br,this.wrapR=hl,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class zY extends hh{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new IC(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class kr{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,r,a,o){let l=n[i+0],u=n[i+1],c=n[i+2],f=n[i+3];const d=r[a+0],g=r[a+1],x=r[a+2],S=r[a+3];if(o===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=f;return}if(o===1){e[t+0]=d,e[t+1]=g,e[t+2]=x,e[t+3]=S;return}if(f!==S||l!==d||u!==g||c!==x){let b=1-o;const _=l*d+u*g+c*x+f*S,T=_>=0?1:-1,E=1-_*_;if(E>Number.EPSILON){const R=Math.sqrt(E),I=Math.atan2(R,_*T);b=Math.sin(b*I)/R,o=Math.sin(o*I)/R}const C=o*T;if(l=l*b+d*C,u=u*b+g*C,c=c*b+x*C,f=f*b+S*C,b===1-o){const R=1/Math.sqrt(l*l+u*u+c*c+f*f);l*=R,u*=R,c*=R,f*=R}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=f}static multiplyQuaternionsFlat(e,t,n,i,r,a){const o=n[i],l=n[i+1],u=n[i+2],c=n[i+3],f=r[a],d=r[a+1],g=r[a+2],x=r[a+3];return e[t]=o*x+c*f+l*g-u*d,e[t+1]=l*x+c*d+u*f-o*g,e[t+2]=u*x+c*g+o*d-l*f,e[t+3]=c*x-o*f-l*d-u*g,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const n=e._x,i=e._y,r=e._z,a=e._order,o=Math.cos,l=Math.sin,u=o(n/2),c=o(i/2),f=o(r/2),d=l(n/2),g=l(i/2),x=l(r/2);switch(a){case"XYZ":this._x=d*c*f+u*g*x,this._y=u*g*f-d*c*x,this._z=u*c*x+d*g*f,this._w=u*c*f-d*g*x;break;case"YXZ":this._x=d*c*f+u*g*x,this._y=u*g*f-d*c*x,this._z=u*c*x-d*g*f,this._w=u*c*f+d*g*x;break;case"ZXY":this._x=d*c*f-u*g*x,this._y=u*g*f+d*c*x,this._z=u*c*x+d*g*f,this._w=u*c*f-d*g*x;break;case"ZYX":this._x=d*c*f-u*g*x,this._y=u*g*f+d*c*x,this._z=u*c*x-d*g*f,this._w=u*c*f+d*g*x;break;case"YZX":this._x=d*c*f+u*g*x,this._y=u*g*f+d*c*x,this._z=u*c*x-d*g*f,this._w=u*c*f-d*g*x;break;case"XZY":this._x=d*c*f-u*g*x,this._y=u*g*f-d*c*x,this._z=u*c*x+d*g*f,this._w=u*c*f+d*g*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],o=t[5],l=t[9],u=t[2],c=t[6],f=t[10],d=n+o+f;if(d>0){const g=.5/Math.sqrt(d+1);this._w=.25/g,this._x=(c-l)*g,this._y=(r-u)*g,this._z=(a-i)*g}else if(n>o&&n>f){const g=2*Math.sqrt(1+n-o-f);this._w=(c-l)/g,this._x=.25*g,this._y=(i+a)/g,this._z=(r+u)/g}else if(o>f){const g=2*Math.sqrt(1+o-n-f);this._w=(r-u)/g,this._x=(i+a)/g,this._y=.25*g,this._z=(l+c)/g}else{const g=2*Math.sqrt(1+f-n-o);this._w=(a-i)/g,this._x=(r+u)/g,this._y=(l+c)/g,this._z=.25*g}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(vn(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,a=e._w,o=t._x,l=t._y,u=t._z,c=t._w;return this._x=n*c+a*o+i*u-r*l,this._y=i*c+a*l+r*o-n*u,this._z=r*c+a*u+n*l-i*o,this._w=a*c-n*o-i*l-r*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,a=this._w;let o=a*e._w+n*e._x+i*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const g=1-t;return this._w=g*a+t*this._w,this._x=g*n+t*this._x,this._y=g*i+t*this._y,this._z=g*r+t*this._z,this.normalize(),this}const u=Math.sqrt(l),c=Math.atan2(u,o),f=Math.sin((1-t)*c)/u,d=Math.sin(t*c)/u;return this._w=a*f+this._w*d,this._x=n*f+this._x*d,this._y=i*f+this._y*d,this._z=r*f+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),r=Math.sqrt(n);return this.set(i*Math.sin(e),i*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ae{constructor(e=0,t=0,n=0){ae.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(jF.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(jF.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,o=e.z,l=e.w,u=2*(a*i-o*n),c=2*(o*t-r*i),f=2*(r*n-a*t);return this.x=t+l*u+a*f-o*c,this.y=n+l*c+o*u-r*f,this.z=i+l*f+r*c-a*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=vn(this.x,e.x,t.x),this.y=vn(this.y,e.y,t.y),this.z=vn(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=vn(this.x,e,t),this.y=vn(this.y,e,t),this.z=vn(this.z,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(vn(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,a=t.x,o=t.y,l=t.z;return this.x=i*l-r*o,this.y=r*a-n*l,this.z=n*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return HN.copy(this).projectOnVector(e),this.sub(HN)}reflect(e){return this.sub(HN.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(vn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,n=Math.sqrt(1-t*t);return this.x=n*Math.cos(e),this.y=t,this.z=n*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const HN=new ae,jF=new kr;class Ea{constructor(e=new ae(1/0,1/0,1/0),t=new ae(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(Gu.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(Gu.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Gu.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0){const r=n.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let a=0,o=r.count;a<o;a++)e.isMesh===!0?e.getVertexPosition(a,Gu):Gu.fromBufferAttribute(r,a),Gu.applyMatrix4(e.matrixWorld),this.expandByPoint(Gu);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),lT.copy(e.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),lT.copy(n.boundingBox)),lT.applyMatrix4(e.matrixWorld),this.union(lT)}const i=e.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Gu),Gu.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(S1),uT.subVectors(this.max,S1),cy.subVectors(e.a,S1),hy.subVectors(e.b,S1),fy.subVectors(e.c,S1),Cd.subVectors(hy,cy),Ed.subVectors(fy,hy),Tm.subVectors(cy,fy);let t=[0,-Cd.z,Cd.y,0,-Ed.z,Ed.y,0,-Tm.z,Tm.y,Cd.z,0,-Cd.x,Ed.z,0,-Ed.x,Tm.z,0,-Tm.x,-Cd.y,Cd.x,0,-Ed.y,Ed.x,0,-Tm.y,Tm.x,0];return!VN(t,cy,hy,fy,uT)||(t=[1,0,0,0,1,0,0,0,1],!VN(t,cy,hy,fy,uT))?!1:(cT.crossVectors(Cd,Ed),t=[cT.x,cT.y,cT.z],VN(t,cy,hy,fy,uT))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Gu).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Gu).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Hh[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Hh[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Hh[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Hh[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Hh[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Hh[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Hh[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Hh[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Hh),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Hh=[new ae,new ae,new ae,new ae,new ae,new ae,new ae,new ae],Gu=new ae,lT=new Ea,cy=new ae,hy=new ae,fy=new ae,Cd=new ae,Ed=new ae,Tm=new ae,S1=new ae,uT=new ae,cT=new ae,wm=new ae;function VN(s,e,t,n,i){for(let r=0,a=s.length-3;r<=a;r+=3){wm.fromArray(s,r);const o=i.x*Math.abs(wm.x)+i.y*Math.abs(wm.y)+i.z*Math.abs(wm.z),l=e.dot(wm),u=t.dot(wm),c=n.dot(wm);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>o)return!1}return!0}const GY=new Ea,A1=new ae,WN=new ae;class ea{constructor(e=new ae,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):GY.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;A1.subVectors(e,this.center);const t=A1.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(A1,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(WN.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(A1.copy(e.center).add(WN)),this.expandByPoint(A1.copy(e.center).sub(WN))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Vh=new ae,XN=new ae,hT=new ae,Md=new ae,qN=new ae,fT=new ae,jN=new ae;class Xg{constructor(e=new ae,t=new ae(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Vh)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Vh.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Vh.copy(this.origin).addScaledVector(this.direction,t),Vh.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){XN.copy(e).add(t).multiplyScalar(.5),hT.copy(t).sub(e).normalize(),Md.copy(this.origin).sub(XN);const r=e.distanceTo(t)*.5,a=-this.direction.dot(hT),o=Md.dot(this.direction),l=-Md.dot(hT),u=Md.lengthSq(),c=Math.abs(1-a*a);let f,d,g,x;if(c>0)if(f=a*l-o,d=a*o-l,x=r*c,f>=0)if(d>=-x)if(d<=x){const S=1/c;f*=S,d*=S,g=f*(f+a*d+2*o)+d*(a*f+d+2*l)+u}else d=r,f=Math.max(0,-(a*d+o)),g=-f*f+d*(d+2*l)+u;else d=-r,f=Math.max(0,-(a*d+o)),g=-f*f+d*(d+2*l)+u;else d<=-x?(f=Math.max(0,-(-a*r+o)),d=f>0?-r:Math.min(Math.max(-r,-l),r),g=-f*f+d*(d+2*l)+u):d<=x?(f=0,d=Math.min(Math.max(-r,-l),r),g=d*(d+2*l)+u):(f=Math.max(0,-(a*r+o)),d=f>0?r:Math.min(Math.max(-r,-l),r),g=-f*f+d*(d+2*l)+u);else d=a>0?-r:r,f=Math.max(0,-(a*d+o)),g=-f*f+d*(d+2*l)+u;return n&&n.copy(this.origin).addScaledVector(this.direction,f),i&&i.copy(XN).addScaledVector(hT,d),g}intersectSphere(e,t){Vh.subVectors(e.center,this.origin);const n=Vh.dot(this.direction),i=Vh.dot(Vh)-n*n,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),o=n-a,l=n+a;return l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,o,l;const u=1/this.direction.x,c=1/this.direction.y,f=1/this.direction.z,d=this.origin;return u>=0?(n=(e.min.x-d.x)*u,i=(e.max.x-d.x)*u):(n=(e.max.x-d.x)*u,i=(e.min.x-d.x)*u),c>=0?(r=(e.min.y-d.y)*c,a=(e.max.y-d.y)*c):(r=(e.max.y-d.y)*c,a=(e.min.y-d.y)*c),n>a||r>i||((r>n||isNaN(n))&&(n=r),(a<i||isNaN(i))&&(i=a),f>=0?(o=(e.min.z-d.z)*f,l=(e.max.z-d.z)*f):(o=(e.max.z-d.z)*f,l=(e.min.z-d.z)*f),n>l||o>i)||((o>n||n!==n)&&(n=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,Vh)!==null}intersectTriangle(e,t,n,i,r){qN.subVectors(t,e),fT.subVectors(n,e),jN.crossVectors(qN,fT);let a=this.direction.dot(jN),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Md.subVectors(this.origin,e);const l=o*this.direction.dot(fT.crossVectors(Md,fT));if(l<0)return null;const u=o*this.direction.dot(qN.cross(Md));if(u<0||l+u>a)return null;const c=-o*Md.dot(jN);return c<0?null:this.at(c/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class rn{constructor(e,t,n,i,r,a,o,l,u,c,f,d,g,x,S,b){rn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,o,l,u,c,f,d,g,x,S,b)}set(e,t,n,i,r,a,o,l,u,c,f,d,g,x,S,b){const _=this.elements;return _[0]=e,_[4]=t,_[8]=n,_[12]=i,_[1]=r,_[5]=a,_[9]=o,_[13]=l,_[2]=u,_[6]=c,_[10]=f,_[14]=d,_[3]=g,_[7]=x,_[11]=S,_[15]=b,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new rn().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/dy.setFromMatrixColumn(e,0).length(),r=1/dy.setFromMatrixColumn(e,1).length(),a=1/dy.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(i),u=Math.sin(i),c=Math.cos(r),f=Math.sin(r);if(e.order==="XYZ"){const d=a*c,g=a*f,x=o*c,S=o*f;t[0]=l*c,t[4]=-l*f,t[8]=u,t[1]=g+x*u,t[5]=d-S*u,t[9]=-o*l,t[2]=S-d*u,t[6]=x+g*u,t[10]=a*l}else if(e.order==="YXZ"){const d=l*c,g=l*f,x=u*c,S=u*f;t[0]=d+S*o,t[4]=x*o-g,t[8]=a*u,t[1]=a*f,t[5]=a*c,t[9]=-o,t[2]=g*o-x,t[6]=S+d*o,t[10]=a*l}else if(e.order==="ZXY"){const d=l*c,g=l*f,x=u*c,S=u*f;t[0]=d-S*o,t[4]=-a*f,t[8]=x+g*o,t[1]=g+x*o,t[5]=a*c,t[9]=S-d*o,t[2]=-a*u,t[6]=o,t[10]=a*l}else if(e.order==="ZYX"){const d=a*c,g=a*f,x=o*c,S=o*f;t[0]=l*c,t[4]=x*u-g,t[8]=d*u+S,t[1]=l*f,t[5]=S*u+d,t[9]=g*u-x,t[2]=-u,t[6]=o*l,t[10]=a*l}else if(e.order==="YZX"){const d=a*l,g=a*u,x=o*l,S=o*u;t[0]=l*c,t[4]=S-d*f,t[8]=x*f+g,t[1]=f,t[5]=a*c,t[9]=-o*c,t[2]=-u*c,t[6]=g*f+x,t[10]=d-S*f}else if(e.order==="XZY"){const d=a*l,g=a*u,x=o*l,S=o*u;t[0]=l*c,t[4]=-f,t[8]=u*c,t[1]=d*f+S,t[5]=a*c,t[9]=g*f-x,t[2]=x*f-g,t[6]=o*c,t[10]=S*f+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(HY,e,VY)}lookAt(e,t,n){const i=this.elements;return al.subVectors(e,t),al.lengthSq()===0&&(al.z=1),al.normalize(),Nd.crossVectors(n,al),Nd.lengthSq()===0&&(Math.abs(n.z)===1?al.x+=1e-4:al.z+=1e-4,al.normalize(),Nd.crossVectors(n,al)),Nd.normalize(),dT.crossVectors(al,Nd),i[0]=Nd.x,i[4]=dT.x,i[8]=al.x,i[1]=Nd.y,i[5]=dT.y,i[9]=al.y,i[2]=Nd.z,i[6]=dT.z,i[10]=al.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],o=n[4],l=n[8],u=n[12],c=n[1],f=n[5],d=n[9],g=n[13],x=n[2],S=n[6],b=n[10],_=n[14],T=n[3],E=n[7],C=n[11],R=n[15],I=i[0],L=i[4],P=i[8],D=i[12],O=i[1],F=i[5],X=i[9],q=i[13],J=i[2],Y=i[6],$=i[10],W=i[14],V=i[3],se=i[7],G=i[11],ne=i[15];return r[0]=a*I+o*O+l*J+u*V,r[4]=a*L+o*F+l*Y+u*se,r[8]=a*P+o*X+l*$+u*G,r[12]=a*D+o*q+l*W+u*ne,r[1]=c*I+f*O+d*J+g*V,r[5]=c*L+f*F+d*Y+g*se,r[9]=c*P+f*X+d*$+g*G,r[13]=c*D+f*q+d*W+g*ne,r[2]=x*I+S*O+b*J+_*V,r[6]=x*L+S*F+b*Y+_*se,r[10]=x*P+S*X+b*$+_*G,r[14]=x*D+S*q+b*W+_*ne,r[3]=T*I+E*O+C*J+R*V,r[7]=T*L+E*F+C*Y+R*se,r[11]=T*P+E*X+C*$+R*G,r[15]=T*D+E*q+C*W+R*ne,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],o=e[5],l=e[9],u=e[13],c=e[2],f=e[6],d=e[10],g=e[14],x=e[3],S=e[7],b=e[11],_=e[15];return x*(+r*l*f-i*u*f-r*o*d+n*u*d+i*o*g-n*l*g)+S*(+t*l*g-t*u*d+r*a*d-i*a*g+i*u*c-r*l*c)+b*(+t*u*f-t*o*g-r*a*f+n*a*g+r*o*c-n*u*c)+_*(-i*o*c-t*l*f+t*o*d+i*a*f-n*a*d+n*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8],f=e[9],d=e[10],g=e[11],x=e[12],S=e[13],b=e[14],_=e[15],T=f*b*u-S*d*u+S*l*g-o*b*g-f*l*_+o*d*_,E=x*d*u-c*b*u-x*l*g+a*b*g+c*l*_-a*d*_,C=c*S*u-x*f*u+x*o*g-a*S*g-c*o*_+a*f*_,R=x*f*l-c*S*l-x*o*d+a*S*d+c*o*b-a*f*b,I=t*T+n*E+i*C+r*R;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const L=1/I;return e[0]=T*L,e[1]=(S*d*r-f*b*r-S*i*g+n*b*g+f*i*_-n*d*_)*L,e[2]=(o*b*r-S*l*r+S*i*u-n*b*u-o*i*_+n*l*_)*L,e[3]=(f*l*r-o*d*r-f*i*u+n*d*u+o*i*g-n*l*g)*L,e[4]=E*L,e[5]=(c*b*r-x*d*r+x*i*g-t*b*g-c*i*_+t*d*_)*L,e[6]=(x*l*r-a*b*r-x*i*u+t*b*u+a*i*_-t*l*_)*L,e[7]=(a*d*r-c*l*r+c*i*u-t*d*u-a*i*g+t*l*g)*L,e[8]=C*L,e[9]=(x*f*r-c*S*r-x*n*g+t*S*g+c*n*_-t*f*_)*L,e[10]=(a*S*r-x*o*r+x*n*u-t*S*u-a*n*_+t*o*_)*L,e[11]=(c*o*r-a*f*r-c*n*u+t*f*u+a*n*g-t*o*g)*L,e[12]=R*L,e[13]=(c*S*i-x*f*i+x*n*d-t*S*d-c*n*b+t*f*b)*L,e[14]=(x*o*i-a*S*i-x*n*l+t*S*l+a*n*b-t*o*b)*L,e[15]=(a*f*i-c*o*i+c*n*l-t*f*l-a*n*d+t*o*d)*L,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,o=e.y,l=e.z,u=r*a,c=r*o;return this.set(u*a+n,u*o-i*l,u*l+i*o,0,u*o+i*l,c*o+n,c*l-i*a,0,u*l-i*o,c*l+i*a,r*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,a=t._y,o=t._z,l=t._w,u=r+r,c=a+a,f=o+o,d=r*u,g=r*c,x=r*f,S=a*c,b=a*f,_=o*f,T=l*u,E=l*c,C=l*f,R=n.x,I=n.y,L=n.z;return i[0]=(1-(S+_))*R,i[1]=(g+C)*R,i[2]=(x-E)*R,i[3]=0,i[4]=(g-C)*I,i[5]=(1-(d+_))*I,i[6]=(b+T)*I,i[7]=0,i[8]=(x+E)*L,i[9]=(b-T)*L,i[10]=(1-(d+S))*L,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=dy.set(i[0],i[1],i[2]).length();const a=dy.set(i[4],i[5],i[6]).length(),o=dy.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Hu.copy(this);const u=1/r,c=1/a,f=1/o;return Hu.elements[0]*=u,Hu.elements[1]*=u,Hu.elements[2]*=u,Hu.elements[4]*=c,Hu.elements[5]*=c,Hu.elements[6]*=c,Hu.elements[8]*=f,Hu.elements[9]*=f,Hu.elements[10]*=f,t.setFromRotationMatrix(Hu),n.x=r,n.y=a,n.z=o,this}makePerspective(e,t,n,i,r,a,o=Zu){const l=this.elements,u=2*r/(t-e),c=2*r/(n-i),f=(t+e)/(t-e),d=(n+i)/(n-i);let g,x;if(o===Zu)g=-(a+r)/(a-r),x=-2*a*r/(a-r);else if(o===yb)g=-a/(a-r),x=-a*r/(a-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return l[0]=u,l[4]=0,l[8]=f,l[12]=0,l[1]=0,l[5]=c,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=g,l[14]=x,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,i,r,a,o=Zu){const l=this.elements,u=1/(t-e),c=1/(n-i),f=1/(a-r),d=(t+e)*u,g=(n+i)*c;let x,S;if(o===Zu)x=(a+r)*f,S=-2*f;else if(o===yb)x=r*f,S=-1*f;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-g,l[2]=0,l[6]=0,l[10]=S,l[14]=-x,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const dy=new ae,Hu=new rn,HY=new ae(0,0,0),VY=new ae(1,1,1),Nd=new ae,dT=new ae,al=new ae,KF=new rn,YF=new kr;class xl{constructor(e=0,t=0,n=0,i=xl.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],a=i[4],o=i[8],l=i[1],u=i[5],c=i[9],f=i[2],d=i[6],g=i[10];switch(t){case"XYZ":this._y=Math.asin(vn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,g),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-vn(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,g),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-f,r),this._z=0);break;case"ZXY":this._x=Math.asin(vn(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,g),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-vn(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,g),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(vn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-f,r)):(this._x=0,this._y=Math.atan2(o,g));break;case"XZY":this._z=Math.asin(-vn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,g),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return KF.makeRotationFromQuaternion(e),this.setFromRotationMatrix(KF,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return YF.setFromEuler(this),this.setFromQuaternion(YF,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}xl.DEFAULT_ORDER="XYZ";class ux{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let WY=0;const JF=new ae,py=new kr,Wh=new rn,pT=new ae,T1=new ae,XY=new ae,qY=new kr,ZF=new ae(1,0,0),QF=new ae(0,1,0),e4=new ae(0,0,1),t4={type:"added"},jY={type:"removed"},my={type:"childadded",child:null},KN={type:"childremoved",child:null};class ts extends yh{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:WY++}),this.uuid=gl(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ts.DEFAULT_UP.clone();const e=new ae,t=new xl,n=new kr,i=new ae(1,1,1);function r(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new rn},normalMatrix:{value:new An}}),this.matrix=new rn,this.matrixWorld=new rn,this.matrixAutoUpdate=ts.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=ts.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new ux,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return py.setFromAxisAngle(e,t),this.quaternion.multiply(py),this}rotateOnWorldAxis(e,t){return py.setFromAxisAngle(e,t),this.quaternion.premultiply(py),this}rotateX(e){return this.rotateOnAxis(ZF,e)}rotateY(e){return this.rotateOnAxis(QF,e)}rotateZ(e){return this.rotateOnAxis(e4,e)}translateOnAxis(e,t){return JF.copy(e).applyQuaternion(this.quaternion),this.position.add(JF.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(ZF,e)}translateY(e){return this.translateOnAxis(QF,e)}translateZ(e){return this.translateOnAxis(e4,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Wh.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?pT.copy(e):pT.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),T1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Wh.lookAt(T1,pT,this.up):Wh.lookAt(pT,T1,this.up),this.quaternion.setFromRotationMatrix(Wh),i&&(Wh.extractRotation(i.matrixWorld),py.setFromRotationMatrix(Wh),this.quaternion.premultiply(py.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(t4),my.child=e,this.dispatchEvent(my),my.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(jY),KN.child=e,this.dispatchEvent(KN),KN.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Wh.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Wh.multiply(e.parent.matrixWorld)),e.applyMatrix4(Wh),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(t4),my.child=e,this.dispatchEvent(my),my.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t,n=[]){this[e]===t&&n.push(this);const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].getObjectsByProperty(e,t,n);return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(T1,e,XY),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(T1,qY,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(o=>({boxInitialized:o.boxInitialized,boxMin:o.box.min.toArray(),boxMax:o.box.max.toArray(),sphereInitialized:o.sphereInitialized,sphereRadius:o.sphere.radius,sphereCenter:o.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const f=l[u];r(e.shapes,f)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,u=this.material.length;l<u;l++)o.push(r(e.materials,this.material[l]));i.material=o}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(e.animations,l))}}if(t){const o=a(e.geometries),l=a(e.materials),u=a(e.textures),c=a(e.images),f=a(e.shapes),d=a(e.skeletons),g=a(e.animations),x=a(e.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),u.length>0&&(n.textures=u),c.length>0&&(n.images=c),f.length>0&&(n.shapes=f),d.length>0&&(n.skeletons=d),g.length>0&&(n.animations=g),x.length>0&&(n.nodes=x)}return n.object=i,n;function a(o){const l=[];for(const u in o){const c=o[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}ts.DEFAULT_UP=new ae(0,1,0);ts.DEFAULT_MATRIX_AUTO_UPDATE=!0;ts.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Vu=new ae,Xh=new ae,YN=new ae,qh=new ae,gy=new ae,yy=new ae,n4=new ae,JN=new ae,ZN=new ae,QN=new ae,eR=new os,tR=new os,nR=new os;class wo{constructor(e=new ae,t=new ae,n=new ae){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Vu.subVectors(e,t),i.cross(Vu);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){Vu.subVectors(i,t),Xh.subVectors(n,t),YN.subVectors(e,t);const a=Vu.dot(Vu),o=Vu.dot(Xh),l=Vu.dot(YN),u=Xh.dot(Xh),c=Xh.dot(YN),f=a*u-o*o;if(f===0)return r.set(0,0,0),null;const d=1/f,g=(u*l-o*c)*d,x=(a*c-o*l)*d;return r.set(1-g-x,x,g)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,qh)===null?!1:qh.x>=0&&qh.y>=0&&qh.x+qh.y<=1}static getInterpolation(e,t,n,i,r,a,o,l){return this.getBarycoord(e,t,n,i,qh)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(r,qh.x),l.addScaledVector(a,qh.y),l.addScaledVector(o,qh.z),l)}static getInterpolatedAttribute(e,t,n,i,r,a){return eR.setScalar(0),tR.setScalar(0),nR.setScalar(0),eR.fromBufferAttribute(e,t),tR.fromBufferAttribute(e,n),nR.fromBufferAttribute(e,i),a.setScalar(0),a.addScaledVector(eR,r.x),a.addScaledVector(tR,r.y),a.addScaledVector(nR,r.z),a}static isFrontFacing(e,t,n,i){return Vu.subVectors(n,t),Xh.subVectors(e,t),Vu.cross(Xh).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Vu.subVectors(this.c,this.b),Xh.subVectors(this.a,this.b),Vu.cross(Xh).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return wo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return wo.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,n,i,r){return wo.getInterpolation(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return wo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return wo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let a,o;gy.subVectors(i,n),yy.subVectors(r,n),JN.subVectors(e,n);const l=gy.dot(JN),u=yy.dot(JN);if(l<=0&&u<=0)return t.copy(n);ZN.subVectors(e,i);const c=gy.dot(ZN),f=yy.dot(ZN);if(c>=0&&f<=c)return t.copy(i);const d=l*f-c*u;if(d<=0&&l>=0&&c<=0)return a=l/(l-c),t.copy(n).addScaledVector(gy,a);QN.subVectors(e,r);const g=gy.dot(QN),x=yy.dot(QN);if(x>=0&&g<=x)return t.copy(r);const S=g*u-l*x;if(S<=0&&u>=0&&x<=0)return o=u/(u-x),t.copy(n).addScaledVector(yy,o);const b=c*x-g*f;if(b<=0&&f-c>=0&&g-x>=0)return n4.subVectors(r,i),o=(f-c)/(f-c+(g-x)),t.copy(i).addScaledVector(n4,o);const _=1/(b+S+d);return a=S*_,o=d*_,t.copy(n).addScaledVector(gy,a).addScaledVector(yy,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const I9={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Rd={h:0,s:0,l:0},mT={h:0,s:0,l:0};function sR(s,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+(e-s)*6*t:t<1/2?e:t<2/3?s+(e-s)*6*(2/3-t):s}class Nt{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=va){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Qn.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Qn.workingColorSpace){return this.r=e,this.g=t,this.b=n,Qn.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Qn.workingColorSpace){if(e=L3(e,1),t=vn(t,0,1),n=vn(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,a=2*n-r;this.r=sR(a,r,e+1/3),this.g=sR(a,r,e),this.b=sR(a,r,e-1/3)}return Qn.toWorkingColorSpace(this,i),this}setStyle(e,t=va){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],a=r.length;if(a===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=va){const n=I9[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=hf(e.r),this.g=hf(e.g),this.b=hf(e.b),this}copyLinearToSRGB(e){return this.r=Hy(e.r),this.g=Hy(e.g),this.b=Hy(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=va){return Qn.fromWorkingColorSpace(ya.copy(this),e),Math.round(vn(ya.r*255,0,255))*65536+Math.round(vn(ya.g*255,0,255))*256+Math.round(vn(ya.b*255,0,255))}getHexString(e=va){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Qn.workingColorSpace){Qn.fromWorkingColorSpace(ya.copy(this),t);const n=ya.r,i=ya.g,r=ya.b,a=Math.max(n,i,r),o=Math.min(n,i,r);let l,u;const c=(o+a)/2;if(o===a)l=0,u=0;else{const f=a-o;switch(u=c<=.5?f/(a+o):f/(2-a-o),a){case n:l=(i-r)/f+(i<r?6:0);break;case i:l=(r-n)/f+2;break;case r:l=(n-i)/f+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=Qn.workingColorSpace){return Qn.fromWorkingColorSpace(ya.copy(this),t),e.r=ya.r,e.g=ya.g,e.b=ya.b,e}getStyle(e=va){Qn.fromWorkingColorSpace(ya.copy(this),e);const t=ya.r,n=ya.g,i=ya.b;return e!==va?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(Rd),this.setHSL(Rd.h+e,Rd.s+t,Rd.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Rd),e.getHSL(mT);const n=sb(Rd.h,mT.h,t),i=sb(Rd.s,mT.s,t),r=sb(Rd.l,mT.l,t);return this.setHSL(n,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*n+r[6]*i,this.g=r[1]*t+r[4]*n+r[7]*i,this.b=r[2]*t+r[5]*n+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ya=new Nt;Nt.NAMES=I9;let KY=0;class br extends yh{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:KY++}),this.uuid=gl(),this.name="",this.type="Material",this.blending=hg,this.side=ch,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Hw,this.blendDst=Vw,this.blendEquation=Ld,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Nt(0,0,0),this.blendAlpha=0,this.depthFunc=Sg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=LI,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Xm,this.stencilZFail=Xm,this.stencilZPass=Xm,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==hg&&(n.blending=this.blending),this.side!==ch&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==Hw&&(n.blendSrc=this.blendSrc),this.blendDst!==Vw&&(n.blendDst=this.blendDst),this.blendEquation!==Ld&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==Sg&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==LI&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Xm&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Xm&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Xm&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(t){const r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class fl extends br{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xl,this.combine=Zb,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const rf=YY();function YY(){const s=new ArrayBuffer(4),e=new Float32Array(s),t=new Uint32Array(s),n=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(n[l]=0,n[l|256]=32768,i[l]=24,i[l|256]=24):u<-14?(n[l]=1024>>-u-14,n[l|256]=1024>>-u-14|32768,i[l]=-u-1,i[l|256]=-u-1):u<=15?(n[l]=u+15<<10,n[l|256]=u+15<<10|32768,i[l]=13,i[l|256]=13):u<128?(n[l]=31744,n[l|256]=64512,i[l]=24,i[l|256]=24):(n[l]=31744,n[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;(u&8388608)===0;)u<<=1,c-=8388608;u&=-8388609,c+=947912704,r[l]=u|c}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:r,exponentTable:a,offsetTable:o}}function So(s){Math.abs(s)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),s=vn(s,-65504,65504),rf.floatView[0]=s;const e=rf.uint32View[0],t=e>>23&511;return rf.baseTable[t]+((e&8388607)>>rf.shiftTable[t])}function $1(s){const e=s>>10;return rf.uint32View[0]=rf.mantissaTable[rf.offsetTable[e]+(s&1023)]+rf.exponentTable[e],rf.floatView[0]}class JY{static toHalfFloat(e){return So(e)}static fromHalfFloat(e){return $1(e)}}const Ki=new ae,gT=new tt;let ZY=0;class us{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:ZY++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=gb,this.updateRanges=[],this.gpuType=Eo,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)gT.fromBufferAttribute(this,t),gT.applyMatrix3(e),this.setXY(t,gT.x,gT.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Ki.fromBufferAttribute(this,t),Ki.applyMatrix3(e),this.setXYZ(t,Ki.x,Ki.y,Ki.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Ki.fromBufferAttribute(this,t),Ki.applyMatrix4(e),this.setXYZ(t,Ki.x,Ki.y,Ki.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Ki.fromBufferAttribute(this,t),Ki.applyNormalMatrix(e),this.setXYZ(t,Ki.x,Ki.y,Ki.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Ki.fromBufferAttribute(this,t),Ki.transformDirection(e),this.setXYZ(t,Ki.x,Ki.y,Ki.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=eo(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=Cn(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=eo(t,this.array)),t}setX(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=eo(t,this.array)),t}setY(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=eo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=eo(t,this.array)),t}setW(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array),r=Cn(r,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==gb&&(e.usage=this.usage),e}}class QY extends us{constructor(e,t,n){super(new Int8Array(e),t,n)}}class eJ extends us{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class tJ extends us{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class nJ extends us{constructor(e,t,n){super(new Int16Array(e),t,n)}}class F3 extends us{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class sJ extends us{constructor(e,t,n){super(new Int32Array(e),t,n)}}class P3 extends us{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class iJ extends us{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}getX(e){let t=$1(this.array[e*this.itemSize]);return this.normalized&&(t=eo(t,this.array)),t}setX(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize]=So(t),this}getY(e){let t=$1(this.array[e*this.itemSize+1]);return this.normalized&&(t=eo(t,this.array)),t}setY(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+1]=So(t),this}getZ(e){let t=$1(this.array[e*this.itemSize+2]);return this.normalized&&(t=eo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+2]=So(t),this}getW(e){let t=$1(this.array[e*this.itemSize+3]);return this.normalized&&(t=eo(t,this.array)),t}setW(e,t){return this.normalized&&(t=Cn(t,this.array)),this.array[e*this.itemSize+3]=So(t),this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array)),this.array[e+0]=So(t),this.array[e+1]=So(n),this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array)),this.array[e+0]=So(t),this.array[e+1]=So(n),this.array[e+2]=So(i),this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array),r=Cn(r,this.array)),this.array[e+0]=So(t),this.array[e+1]=So(n),this.array[e+2]=So(i),this.array[e+3]=So(r),this}}class Vt extends us{constructor(e,t,n){super(new Float32Array(e),t,n)}}let rJ=0;const ql=new rn,iR=new ts,xy=new ae,ol=new Ea,w1=new Ea,Ir=new ae;class Tn extends yh{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:rJ++}),this.uuid=gl(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(M9(e)?P3:F3)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new An().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return ql.makeRotationFromQuaternion(e),this.applyMatrix4(ql),this}rotateX(e){return ql.makeRotationX(e),this.applyMatrix4(ql),this}rotateY(e){return ql.makeRotationY(e),this.applyMatrix4(ql),this}rotateZ(e){return ql.makeRotationZ(e),this.applyMatrix4(ql),this}translate(e,t,n){return ql.makeTranslation(e,t,n),this.applyMatrix4(ql),this}scale(e,t,n){return ql.makeScale(e,t,n),this.applyMatrix4(ql),this}lookAt(e){return iR.lookAt(e),iR.updateMatrix(),this.applyMatrix4(iR.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(xy).negate(),this.translate(xy.x,xy.y,xy.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const n=[];for(let i=0,r=e.length;i<r;i++){const a=e[i];n.push(a.x,a.y,a.z||0)}this.setAttribute("position",new Vt(n,3))}else{const n=Math.min(e.length,t.count);for(let i=0;i<n;i++){const r=e[i];t.setXYZ(i,r.x,r.y,r.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ea);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new ae(-1/0,-1/0,-1/0),new ae(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];ol.setFromBufferAttribute(r),this.morphTargetsRelative?(Ir.addVectors(this.boundingBox.min,ol.min),this.boundingBox.expandByPoint(Ir),Ir.addVectors(this.boundingBox.max,ol.max),this.boundingBox.expandByPoint(Ir)):(this.boundingBox.expandByPoint(ol.min),this.boundingBox.expandByPoint(ol.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ea);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new ae,1/0);return}if(e){const n=this.boundingSphere.center;if(ol.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const o=t[r];w1.setFromBufferAttribute(o),this.morphTargetsRelative?(Ir.addVectors(ol.min,w1.min),ol.expandByPoint(Ir),Ir.addVectors(ol.max,w1.max),ol.expandByPoint(Ir)):(ol.expandByPoint(w1.min),ol.expandByPoint(w1.max))}ol.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)Ir.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Ir));if(t)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=this.morphTargetsRelative;for(let u=0,c=o.count;u<c;u++)Ir.fromBufferAttribute(o,u),l&&(xy.fromBufferAttribute(e,u),Ir.add(xy)),i=Math.max(i,n.distanceToSquared(Ir))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.position,i=t.normal,r=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new us(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),o=[],l=[];for(let P=0;P<n.count;P++)o[P]=new ae,l[P]=new ae;const u=new ae,c=new ae,f=new ae,d=new tt,g=new tt,x=new tt,S=new ae,b=new ae;function _(P,D,O){u.fromBufferAttribute(n,P),c.fromBufferAttribute(n,D),f.fromBufferAttribute(n,O),d.fromBufferAttribute(r,P),g.fromBufferAttribute(r,D),x.fromBufferAttribute(r,O),c.sub(u),f.sub(u),g.sub(d),x.sub(d);const F=1/(g.x*x.y-x.x*g.y);isFinite(F)&&(S.copy(c).multiplyScalar(x.y).addScaledVector(f,-g.y).multiplyScalar(F),b.copy(f).multiplyScalar(g.x).addScaledVector(c,-x.x).multiplyScalar(F),o[P].add(S),o[D].add(S),o[O].add(S),l[P].add(b),l[D].add(b),l[O].add(b))}let T=this.groups;T.length===0&&(T=[{start:0,count:e.count}]);for(let P=0,D=T.length;P<D;++P){const O=T[P],F=O.start,X=O.count;for(let q=F,J=F+X;q<J;q+=3)_(e.getX(q+0),e.getX(q+1),e.getX(q+2))}const E=new ae,C=new ae,R=new ae,I=new ae;function L(P){R.fromBufferAttribute(i,P),I.copy(R);const D=o[P];E.copy(D),E.sub(R.multiplyScalar(R.dot(D))).normalize(),C.crossVectors(I,D);const F=C.dot(l[P])<0?-1:1;a.setXYZW(P,E.x,E.y,E.z,F)}for(let P=0,D=T.length;P<D;++P){const O=T[P],F=O.start,X=O.count;for(let q=F,J=F+X;q<J;q+=3)L(e.getX(q+0)),L(e.getX(q+1)),L(e.getX(q+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new us(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,g=n.count;d<g;d++)n.setXYZ(d,0,0,0);const i=new ae,r=new ae,a=new ae,o=new ae,l=new ae,u=new ae,c=new ae,f=new ae;if(e)for(let d=0,g=e.count;d<g;d+=3){const x=e.getX(d+0),S=e.getX(d+1),b=e.getX(d+2);i.fromBufferAttribute(t,x),r.fromBufferAttribute(t,S),a.fromBufferAttribute(t,b),c.subVectors(a,r),f.subVectors(i,r),c.cross(f),o.fromBufferAttribute(n,x),l.fromBufferAttribute(n,S),u.fromBufferAttribute(n,b),o.add(c),l.add(c),u.add(c),n.setXYZ(x,o.x,o.y,o.z),n.setXYZ(S,l.x,l.y,l.z),n.setXYZ(b,u.x,u.y,u.z)}else for(let d=0,g=t.count;d<g;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),a.fromBufferAttribute(t,d+2),c.subVectors(a,r),f.subVectors(i,r),c.cross(f),n.setXYZ(d+0,c.x,c.y,c.z),n.setXYZ(d+1,c.x,c.y,c.z),n.setXYZ(d+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Ir.fromBufferAttribute(e,t),Ir.normalize(),e.setXYZ(t,Ir.x,Ir.y,Ir.z)}toNonIndexed(){function e(o,l){const u=o.array,c=o.itemSize,f=o.normalized,d=new u.constructor(l.length*c);let g=0,x=0;for(let S=0,b=l.length;S<b;S++){o.isInterleavedBufferAttribute?g=l[S]*o.data.stride+o.offset:g=l[S]*c;for(let _=0;_<c;_++)d[x++]=u[g++]}return new us(d,c,f)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Tn,n=this.index.array,i=this.attributes;for(const o in i){const l=i[o],u=e(l,n);t.setAttribute(o,u)}const r=this.morphAttributes;for(const o in r){const l=[],u=r[o];for(let c=0,f=u.length;c<f;c++){const d=u[c],g=e(d,n);l.push(g)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const u=a[o];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const u=n[l];e.data.attributes[l]=u.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let f=0,d=u.length;f<d;f++){const g=u[f];c.push(g.toJSON(e.data))}c.length>0&&(i[l]=c,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone());const i=e.attributes;for(const u in i){const c=i[u];this.setAttribute(u,c.clone(t))}const r=e.morphAttributes;for(const u in r){const c=[],f=r[u];for(let d=0,g=f.length;d<g;d++)c.push(f[d].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let u=0,c=a.length;u<c;u++){const f=a[u];this.addGroup(f.start,f.count,f.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const s4=new rn,Cm=new Xg,yT=new ea,i4=new ae,xT=new ae,vT=new ae,bT=new ae,rR=new ae,_T=new ae,r4=new ae,ST=new ae;class zi extends ts{constructor(e=new Tn,t=new fl){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,a=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(r&&o){_T.set(0,0,0);for(let l=0,u=r.length;l<u;l++){const c=o[l],f=r[l];c!==0&&(rR.fromBufferAttribute(f,e),a?_T.addScaledVector(rR,c):_T.addScaledVector(rR.sub(t),c))}t.add(_T)}return t}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),yT.copy(n.boundingSphere),yT.applyMatrix4(r),Cm.copy(e.ray).recast(e.near),!(yT.containsPoint(Cm.origin)===!1&&(Cm.intersectSphere(yT,i4)===null||Cm.origin.distanceToSquared(i4)>(e.far-e.near)**2))&&(s4.copy(r).invert(),Cm.copy(e.ray).applyMatrix4(s4),!(n.boundingBox!==null&&Cm.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,Cm)))}_computeIntersections(e,t,n){let i;const r=this.geometry,a=this.material,o=r.index,l=r.attributes.position,u=r.attributes.uv,c=r.attributes.uv1,f=r.attributes.normal,d=r.groups,g=r.drawRange;if(o!==null)if(Array.isArray(a))for(let x=0,S=d.length;x<S;x++){const b=d[x],_=a[b.materialIndex],T=Math.max(b.start,g.start),E=Math.min(o.count,Math.min(b.start+b.count,g.start+g.count));for(let C=T,R=E;C<R;C+=3){const I=o.getX(C),L=o.getX(C+1),P=o.getX(C+2);i=AT(this,_,e,n,u,c,f,I,L,P),i&&(i.faceIndex=Math.floor(C/3),i.face.materialIndex=b.materialIndex,t.push(i))}}else{const x=Math.max(0,g.start),S=Math.min(o.count,g.start+g.count);for(let b=x,_=S;b<_;b+=3){const T=o.getX(b),E=o.getX(b+1),C=o.getX(b+2);i=AT(this,a,e,n,u,c,f,T,E,C),i&&(i.faceIndex=Math.floor(b/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let x=0,S=d.length;x<S;x++){const b=d[x],_=a[b.materialIndex],T=Math.max(b.start,g.start),E=Math.min(l.count,Math.min(b.start+b.count,g.start+g.count));for(let C=T,R=E;C<R;C+=3){const I=C,L=C+1,P=C+2;i=AT(this,_,e,n,u,c,f,I,L,P),i&&(i.faceIndex=Math.floor(C/3),i.face.materialIndex=b.materialIndex,t.push(i))}}else{const x=Math.max(0,g.start),S=Math.min(l.count,g.start+g.count);for(let b=x,_=S;b<_;b+=3){const T=b,E=b+1,C=b+2;i=AT(this,a,e,n,u,c,f,T,E,C),i&&(i.faceIndex=Math.floor(b/3),t.push(i))}}}}function aJ(s,e,t,n,i,r,a,o){let l;if(e.side===so?l=n.intersectTriangle(a,r,i,!0,o):l=n.intersectTriangle(i,r,a,e.side===ch,o),l===null)return null;ST.copy(o),ST.applyMatrix4(s.matrixWorld);const u=t.ray.origin.distanceTo(ST);return u<t.near||u>t.far?null:{distance:u,point:ST.clone(),object:s}}function AT(s,e,t,n,i,r,a,o,l,u){s.getVertexPosition(o,xT),s.getVertexPosition(l,vT),s.getVertexPosition(u,bT);const c=aJ(s,e,t,n,xT,vT,bT,r4);if(c){const f=new ae;wo.getBarycoord(r4,xT,vT,bT,f),i&&(c.uv=wo.getInterpolatedAttribute(i,o,l,u,f,new tt)),r&&(c.uv1=wo.getInterpolatedAttribute(r,o,l,u,f,new tt)),a&&(c.normal=wo.getInterpolatedAttribute(a,o,l,u,f,new ae),c.normal.dot(n.direction)>0&&c.normal.multiplyScalar(-1));const d={a:o,b:l,c:u,normal:new ae,materialIndex:0};wo.getNormal(xT,vT,bT,d.normal),c.face=d,c.barycoord=f}return c}class qg extends Tn{constructor(e=1,t=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};const o=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const l=[],u=[],c=[],f=[];let d=0,g=0;x("z","y","x",-1,-1,n,t,e,a,r,0),x("z","y","x",1,-1,n,t,-e,a,r,1),x("x","z","y",1,1,e,n,t,i,a,2),x("x","z","y",1,-1,e,n,-t,i,a,3),x("x","y","z",1,-1,e,t,n,i,r,4),x("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new Vt(u,3)),this.setAttribute("normal",new Vt(c,3)),this.setAttribute("uv",new Vt(f,2));function x(S,b,_,T,E,C,R,I,L,P,D){const O=C/L,F=R/P,X=C/2,q=R/2,J=I/2,Y=L+1,$=P+1;let W=0,V=0;const se=new ae;for(let G=0;G<$;G++){const ne=G*F-q;for(let oe=0;oe<Y;oe++){const ue=oe*O-X;se[S]=ue*T,se[b]=ne*E,se[_]=J,u.push(se.x,se.y,se.z),se[S]=0,se[b]=0,se[_]=I>0?1:-1,c.push(se.x,se.y,se.z),f.push(oe/L),f.push(1-G/P),W+=1}}for(let G=0;G<P;G++)for(let ne=0;ne<L;ne++){const oe=d+ne+Y*G,ue=d+ne+Y*(G+1),re=d+(ne+1)+Y*(G+1),ce=d+(ne+1)+Y*G;l.push(oe,ue,ce),l.push(ue,re,ce),V+=6}o.addGroup(g,V,D),g+=V,d+=W}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new qg(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function cx(s){const e={};for(const t in s){e[t]={};for(const n in s[t]){const i=s[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][n]=null):e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function Ya(s){const e={};for(let t=0;t<s.length;t++){const n=cx(s[t]);for(const i in n)e[i]=n[i]}return e}function oJ(s){const e=[];for(let t=0;t<s.length;t++)e.push(s[t].clone());return e}function D9(s){const e=s.getRenderTarget();return e===null?s.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:Qn.workingColorSpace}const O9={clone:cx,merge:Ya};var lJ=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,uJ=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class sc extends br{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=lJ,this.fragmentShader=uJ,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cx(e.uniforms),this.uniformsGroups=oJ(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class DC extends ts{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new rn,this.projectionMatrix=new rn,this.projectionMatrixInverse=new rn,this.coordinateSystem=Zu}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Id=new ae,a4=new tt,o4=new tt;class Ci extends DC{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=lx*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(fg*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return lx*2*Math.atan(Math.tan(fg*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,n){Id.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(Id.x,Id.y).multiplyScalar(-e/Id.z),Id.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Id.x,Id.y).multiplyScalar(-e/Id.z)}getViewSize(e,t){return this.getViewBounds(e,a4,o4),t.subVectors(o4,a4)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(fg*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,u=a.fullHeight;r+=a.offsetX*i/l,t-=a.offsetY*n/u,i*=a.width/l,n*=a.height/u}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const vy=-90,by=1;class B9 extends ts{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Ci(vy,by,e,t);i.layers=this.layers,this.add(i);const r=new Ci(vy,by,e,t);r.layers=this.layers,this.add(r);const a=new Ci(vy,by,e,t);a.layers=this.layers,this.add(a);const o=new Ci(vy,by,e,t);o.layers=this.layers,this.add(o);const l=new Ci(vy,by,e,t);l.layers=this.layers,this.add(l);const u=new Ci(vy,by,e,t);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,i,r,a,o,l]=t;for(const u of t)this.remove(u);if(e===Zu)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===yb)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of t)this.add(u),u.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,a,o,l,u,c]=this.children,f=e.getRenderTarget(),d=e.getActiveCubeFace(),g=e.getActiveMipmapLevel(),x=e.xr.enabled;e.xr.enabled=!1;const S=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0,i),e.render(t,r),e.setRenderTarget(n,1,i),e.render(t,a),e.setRenderTarget(n,2,i),e.render(t,o),e.setRenderTarget(n,3,i),e.render(t,l),e.setRenderTarget(n,4,i),e.render(t,u),n.texture.generateMipmaps=S,e.setRenderTarget(n,5,i),e.render(t,c),e.setRenderTarget(f,d,g),e.xr.enabled=x,n.texture.needsPMREMUpdate=!0}}class t_ extends ii{constructor(e=[],t=yf,n,i,r,a,o,l,u,c){super(e,t,n,i,r,a,o,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class k9 extends hh{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new t_(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:$i}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new qg(5,5,5),r=new sc({name:"CubemapFromEquirect",uniforms:cx(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:so,blending:cf});r.uniforms.tEquirect.value=t;const a=new zi(i,r),o=t.minFilter;return t.minFilter===tu&&(t.minFilter=$i),new B9(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t=!0,n=!0,i=!0){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(r)}}class of extends ts{constructor(){super(),this.isGroup=!0,this.type="Group"}}const cJ={type:"move"};class Tw{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new of,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new of,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ae,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ae),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new of,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ae,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ae),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,a=null;const o=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){a=!0;for(const S of e.hand.values()){const b=t.getJointPose(S,n),_=this._getHandJoint(u,S);b!==null&&(_.matrix.fromArray(b.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.matrixWorldNeedsUpdate=!0,_.jointRadius=b.radius),_.visible=b!==null}const c=u.joints["index-finger-tip"],f=u.joints["thumb-tip"],d=c.position.distanceTo(f.position),g=.02,x=.005;u.inputState.pinching&&d>g+x?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&d<=g-x&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&r!==null&&(i=r),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(cJ)))}return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),u!==null&&(u.visible=a!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new of;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class OC{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Nt(e),this.density=t}clone(){return new OC(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class BC{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new Nt(e),this.near=t,this.far=n}clone(){return new BC(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class U3 extends ts{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new xl,this.environmentIntensity=1,this.environmentRotation=new xl,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class n_{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=gb,this.updateRanges=[],this.version=0,this.uuid=gl()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=gl()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=gl()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ka=new ae;class sp{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Ka.fromBufferAttribute(this,t),Ka.applyMatrix4(e),this.setXYZ(t,Ka.x,Ka.y,Ka.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Ka.fromBufferAttribute(this,t),Ka.applyNormalMatrix(e),this.setXYZ(t,Ka.x,Ka.y,Ka.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Ka.fromBufferAttribute(this,t),Ka.transformDirection(e),this.setXYZ(t,Ka.x,Ka.y,Ka.z);return this}getComponent(e,t){let n=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(n=eo(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=Cn(n,this.array)),this.data.array[e*this.data.stride+this.offset+t]=n,this}setX(e,t){return this.normalized&&(t=Cn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Cn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Cn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Cn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=eo(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=eo(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=eo(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=eo(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Cn(t,this.array),n=Cn(n,this.array),i=Cn(i,this.array),r=Cn(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new us(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new sp(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class $3 extends br{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Nt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let _y;const C1=new ae,Sy=new ae,Ay=new ae,Ty=new tt,E1=new tt,L9=new rn,TT=new ae,M1=new ae,wT=new ae,l4=new tt,aR=new tt,u4=new tt;class F9 extends ts{constructor(e=new $3){if(super(),this.isSprite=!0,this.type="Sprite",_y===void 0){_y=new Tn;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new n_(t,5);_y.setIndex([0,1,2,0,2,3]),_y.setAttribute("position",new sp(n,3,0,!1)),_y.setAttribute("uv",new sp(n,2,3,!1))}this.geometry=_y,this.material=e,this.center=new tt(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Sy.setFromMatrixScale(this.matrixWorld),L9.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ay.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Sy.multiplyScalar(-Ay.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const a=this.center;CT(TT.set(-.5,-.5,0),Ay,a,Sy,i,r),CT(M1.set(.5,-.5,0),Ay,a,Sy,i,r),CT(wT.set(.5,.5,0),Ay,a,Sy,i,r),l4.set(0,0),aR.set(1,0),u4.set(1,1);let o=e.ray.intersectTriangle(TT,M1,wT,!1,C1);if(o===null&&(CT(M1.set(-.5,.5,0),Ay,a,Sy,i,r),aR.set(0,1),o=e.ray.intersectTriangle(TT,wT,M1,!1,C1),o===null))return;const l=e.ray.origin.distanceTo(C1);l<e.near||l>e.far||t.push({distance:l,point:C1.clone(),uv:wo.getInterpolation(C1,TT,M1,wT,l4,aR,u4,new tt),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function CT(s,e,t,n,i,r){Ty.subVectors(s,t).addScalar(.5).multiply(n),i!==void 0?(E1.x=r*Ty.x-i*Ty.y,E1.y=i*Ty.x+r*Ty.y):E1.copy(Ty),s.copy(e),s.x+=E1.x,s.y+=E1.y,s.applyMatrix4(L9)}const ET=new ae,c4=new ae;class P9 extends ts{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,n=0){t=Math.abs(t);const i=this.levels;let r;for(r=0;r<i.length&&!(t<i[r].distance);r++);return i.splice(r,0,{distance:t,hysteresis:n,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let n=0;n<t.length;n++)if(t[n].distance===e){const i=t.splice(n,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i;n++){let r=t[n].distance;if(t[n].object.visible&&(r-=r*t[n].hysteresis),e<r)break}return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){ET.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(ET);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){ET.setFromMatrixPosition(e.matrixWorld),c4.setFromMatrixPosition(this.matrixWorld);const n=ET.distanceTo(c4)/e.zoom;t[0].object.visible=!0;let i,r;for(i=1,r=t.length;i<r;i++){let a=t[i].distance;if(t[i].object.visible&&(a-=a*t[i].hysteresis),n>=a)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const a=n[i];t.object.levels.push({object:a.object.uuid,distance:a.distance,hysteresis:a.hysteresis})}return t}}const h4=new ae,f4=new os,d4=new os,hJ=new ae,p4=new rn,MT=new ae,oR=new ea,m4=new rn,lR=new Xg;class z3 extends zi{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=kI,this.bindMatrix=new rn,this.bindMatrixInverse=new rn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Ea),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,MT),this.boundingBox.expandByPoint(MT)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ea),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,MT),this.boundingSphere.expandByPoint(MT)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),oR.copy(this.boundingSphere),oR.applyMatrix4(i),e.ray.intersectsSphere(oR)!==!1&&(m4.copy(i).invert(),lR.copy(e.ray).applyMatrix4(m4),!(this.boundingBox!==null&&lR.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,lR)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new os,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===kI?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===f9?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,i=this.geometry;f4.fromBufferAttribute(i.attributes.skinIndex,e),d4.fromBufferAttribute(i.attributes.skinWeight,e),h4.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const a=d4.getComponent(r);if(a!==0){const o=f4.getComponent(r);p4.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(hJ.copy(h4).applyMatrix4(p4),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}class kC extends ts{constructor(){super(),this.isBone=!0,this.type="Bone"}}class nh extends ii{constructor(e=null,t=1,n=1,i,r,a,o,l,u=Br,c=Br,f,d){super(null,a,o,l,u,c,i,r,f,d),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const g4=new rn,fJ=new rn;class s_{constructor(e=[],t=[]){this.uuid=gl(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new rn)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new rn;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){const o=e[r]?e[r].matrixWorld:fJ;g4.multiplyMatrices(o,t[r]),g4.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new s_(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new nh(t,e,e,wa,Eo);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let a=t[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new kC),this.bones.push(a),this.boneInverses.push(new rn().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const a=t[i];e.bones.push(a.uuid);const o=n[i];e.boneInverses.push(o.toArray())}return e}}class Ag extends us{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const wy=new rn,y4=new rn,NT=[],x4=new Ea,dJ=new rn,N1=new zi,R1=new ea;class G3 extends zi{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Ag(new Float32Array(n*16),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,dJ)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new Ea),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,wy),x4.copy(e.boundingBox).applyMatrix4(wy),this.boundingBox.union(x4)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new ea),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,wy),R1.copy(e.boundingSphere).applyMatrix4(wy),this.boundingSphere.union(R1)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const n=t.morphTargetInfluences,i=this.morphTexture.source.data.data,r=n.length+1,a=e*r+1;for(let o=0;o<n.length;o++)n[o]=i[a+o]}raycast(e,t){const n=this.matrixWorld,i=this.count;if(N1.geometry=this.geometry,N1.material=this.material,N1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),R1.copy(this.boundingSphere),R1.applyMatrix4(n),e.ray.intersectsSphere(R1)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,wy),y4.multiplyMatrices(n,wy),N1.matrixWorld=y4,N1.raycast(e,NT);for(let a=0,o=NT.length;a<o;a++){const l=NT[a];l.instanceId=r,l.object=this,t.push(l)}NT.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Ag(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const n=t.morphTargetInfluences,i=n.length+1;this.morphTexture===null&&(this.morphTexture=new nh(new Float32Array(i*this.count),i,this.count,CC,Eo));const r=this.morphTexture.source.data.data;let a=0;for(let u=0;u<n.length;u++)a+=n[u];const o=this.geometry.morphTargetsRelative?1:1-a,l=i*e;r[l]=o,r.set(n,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const uR=new ae,pJ=new ae,mJ=new An;class Zh{constructor(e=new ae(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=uR.subVectors(n,t).cross(pJ.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(uR),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(n,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||mJ.getNormalMatrix(e),i=this.coplanarPoint(uR).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Em=new ea,RT=new ae;class i_{constructor(e=new Zh,t=new Zh,n=new Zh,i=new Zh,r=new Zh,a=new Zh){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=Zu){const n=this.planes,i=e.elements,r=i[0],a=i[1],o=i[2],l=i[3],u=i[4],c=i[5],f=i[6],d=i[7],g=i[8],x=i[9],S=i[10],b=i[11],_=i[12],T=i[13],E=i[14],C=i[15];if(n[0].setComponents(l-r,d-u,b-g,C-_).normalize(),n[1].setComponents(l+r,d+u,b+g,C+_).normalize(),n[2].setComponents(l+a,d+c,b+x,C+T).normalize(),n[3].setComponents(l-a,d-c,b-x,C-T).normalize(),n[4].setComponents(l-o,d-f,b-S,C-E).normalize(),t===Zu)n[5].setComponents(l+o,d+f,b+S,C+E).normalize();else if(t===yb)n[5].setComponents(o,f,S,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Em.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Em.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Em)}intersectsSprite(e){return Em.center.set(0,0,0),Em.radius=.7071067811865476,Em.applyMatrix4(e.matrixWorld),this.intersectsSphere(Em)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(RT.x=i.normal.x>0?e.max.x:e.min.x,RT.y=i.normal.y>0?e.max.y:e.min.y,RT.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(RT)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function cR(s,e){return s-e}function gJ(s,e){return s.z-e.z}function yJ(s,e){return e.z-s.z}class xJ{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t,n,i){const r=this.pool,a=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const o=r[this.index];a.push(o),this.index++,o.start=e,o.count=t,o.z=n,o.index=i}reset(){this.list.length=0,this.index=0}}const bo=new rn,vJ=new Nt(1,1,1),hR=new i_,IT=new Ea,Mm=new ea,I1=new ae,v4=new ae,bJ=new ae,fR=new xJ,xa=new zi,DT=[];function _J(s,e,t=0){const n=e.itemSize;if(s.isInterleavedBufferAttribute||s.array.constructor!==e.array.constructor){const i=s.count;for(let r=0;r<i;r++)for(let a=0;a<n;a++)e.setComponent(r+t,a,s.getComponent(r,a))}else e.array.set(s.array,t*n);e.needsUpdate=!0}function Nm(s,e){if(s.constructor!==e.constructor){const t=Math.min(s.length,e.length);for(let n=0;n<t;n++)e[n]=s[n]}else{const t=Math.min(s.length,e.length);e.set(new s.constructor(s.buffer,0,t))}}class U9 extends zi{constructor(e,t,n=t*2,i){super(new Tn,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=t,this._maxIndexCount=n,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),n=new nh(t,e,e,wa,Eo);this._matricesTexture=n}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Uint32Array(e*e),n=new nh(t,e,e,Qb,xf);this._indirectTexture=n}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Float32Array(e*e*4).fill(1),n=new nh(t,e,e,wa,Eo);n.colorSpace=Qn.workingColorSpace,this._colorsTexture=n}_initializeGeometry(e){const t=this.geometry,n=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const r in e.attributes){const a=e.getAttribute(r),{array:o,itemSize:l,normalized:u}=a,c=new o.constructor(n*l),f=new us(c,l,u);t.setAttribute(r,f)}if(e.getIndex()!==null){const r=n>65535?new Uint32Array(i):new Uint16Array(i);t.setIndex(new us(r,1))}this._geometryInitialized=!0}}_validateGeometry(e){const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const n in t.attributes){if(!e.hasAttribute(n))throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);const i=e.getAttribute(n),r=t.getAttribute(n);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const t=this._instanceInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const t=this._geometryInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ea);const e=this.boundingBox,t=this._instanceInfo;e.makeEmpty();for(let n=0,i=t.length;n<i;n++){if(t[n].active===!1)continue;const r=t[n].geometryIndex;this.getMatrixAt(n,bo),this.getBoundingBoxAt(r,IT).applyMatrix4(bo),e.union(IT)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ea);const e=this.boundingSphere,t=this._instanceInfo;e.makeEmpty();for(let n=0,i=t.length;n<i;n++){if(t[n].active===!1)continue;const r=t[n].geometryIndex;this.getMatrixAt(n,bo),this.getBoundingSphereAt(r,Mm).applyMatrix4(bo),e.union(Mm)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const n={visible:!0,active:!0,geometryIndex:e};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(cR),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=n):(i=this._instanceInfo.length,this._instanceInfo.push(n));const r=this._matricesTexture;bo.identity().toArray(r.image.data,i*16),r.needsUpdate=!0;const a=this._colorsTexture;return a&&(vJ.toArray(a.image.data,i*4),a.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(e,t=-1,n=-1){this._initializeGeometry(e),this._validateGeometry(e);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=t===-1?e.getAttribute("position").count:t;const a=e.getIndex();if(a!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=n===-1?a.count:n),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(cR),l=this._availableGeometryIds.shift(),r[l]=i):(l=this._geometryCount,this._geometryCount++,r.push(i)),this.setGeometryAt(l,e),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,l}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const n=this.geometry,i=n.getIndex()!==null,r=n.getIndex(),a=t.getIndex(),o=this._geometryInfo[e];if(i&&a.count>o.reservedIndexCount||t.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=o.vertexStart,u=o.reservedVertexCount;o.vertexCount=t.getAttribute("position").count;for(const c in n.attributes){const f=t.getAttribute(c),d=n.getAttribute(c);_J(f,d,l);const g=f.itemSize;for(let x=f.count,S=u;x<S;x++){const b=l+x;for(let _=0;_<g;_++)d.setComponent(b,_,0)}d.needsUpdate=!0,d.addUpdateRange(l*g,u*g)}if(i){const c=o.indexStart,f=o.reservedIndexCount;o.indexCount=t.getIndex().count;for(let d=0;d<a.count;d++)r.setX(c+d,l+a.getX(d));for(let d=a.count,g=f;d<g;d++)r.setX(c+d,l);r.needsUpdate=!0,r.addUpdateRange(c,o.reservedIndexCount)}return o.start=i?o.indexStart:o.vertexStart,o.count=i?o.indexCount:o.vertexCount,o.boundingBox=null,t.boundingBox!==null&&(o.boundingBox=t.boundingBox.clone()),o.boundingSphere=null,t.boundingSphere!==null&&(o.boundingSphere=t.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._geometryInfo;if(e>=t.length||t[e].active===!1)return this;const n=this._instanceInfo;for(let i=0,r=n.length;i<r;i++)n[i].active&&n[i].geometryIndex===e&&this.deleteInstance(i);return t[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,t=0;const n=this._geometryInfo,i=n.map((a,o)=>o).sort((a,o)=>n[a].vertexStart-n[o].vertexStart),r=this.geometry;for(let a=0,o=n.length;a<o;a++){const l=i[a],u=n[l];if(u.active!==!1){if(r.index!==null){if(u.indexStart!==t){const{indexStart:c,vertexStart:f,reservedIndexCount:d}=u,g=r.index,x=g.array,S=e-f;for(let b=c;b<c+d;b++)x[b]=x[b]+S;g.array.copyWithin(t,c,c+d),g.addUpdateRange(t,d),u.indexStart=t}t+=u.reservedIndexCount}if(u.vertexStart!==e){const{vertexStart:c,reservedVertexCount:f}=u,d=r.attributes;for(const g in d){const x=d[g],{array:S,itemSize:b}=x;S.copyWithin(e*b,c*b,(c+f)*b),x.addUpdateRange(e*b,f*b)}u.vertexStart=e}e+=u.reservedVertexCount,u.start=r.index?u.indexStart:u.vertexStart,this._nextIndexStart=r.index?u.indexStart+u.reservedIndexCount:0,this._nextVertexStart=u.vertexStart+u.reservedVertexCount}}return this}getBoundingBoxAt(e,t){if(e>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[e];if(i.boundingBox===null){const r=new Ea,a=n.index,o=n.attributes.position;for(let l=i.start,u=i.start+i.count;l<u;l++){let c=l;a&&(c=a.getX(c)),r.expandByPoint(I1.fromBufferAttribute(o,c))}i.boundingBox=r}return t.copy(i.boundingBox),t}getBoundingSphereAt(e,t){if(e>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[e];if(i.boundingSphere===null){const r=new ea;this.getBoundingBoxAt(e,IT),IT.getCenter(r.center);const a=n.index,o=n.attributes.position;let l=0;for(let u=i.start,c=i.start+i.count;u<c;u++){let f=u;a&&(f=a.getX(f)),I1.fromBufferAttribute(o,f),l=Math.max(l,r.center.distanceToSquared(I1))}r.radius=Math.sqrt(l),i.boundingSphere=r}return t.copy(i.boundingSphere),t}setMatrixAt(e,t){this.validateInstanceId(e);const n=this._matricesTexture,i=this._matricesTexture.image.data;return t.toArray(i,e*16),n.needsUpdate=!0,this}getMatrixAt(e,t){return this.validateInstanceId(e),t.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,t){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),t.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,t){return this.validateInstanceId(e),t.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,t){return this.validateInstanceId(e),this._instanceInfo[e].visible===t?this:(this._instanceInfo[e].visible=t,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,t){return this.validateInstanceId(e),this.validateGeometryId(t),this._instanceInfo[e].geometryIndex=t,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,t={}){this.validateGeometryId(e);const n=this._geometryInfo[e];return t.vertexStart=n.vertexStart,t.vertexCount=n.vertexCount,t.reservedVertexCount=n.reservedVertexCount,t.indexStart=n.indexStart,t.indexCount=n.indexCount,t.reservedIndexCount=n.reservedIndexCount,t.start=n.start,t.count=n.count,t}setInstanceCount(e){const t=this._availableInstanceIds,n=this._instanceInfo;for(t.sort(cR);t[t.length-1]===n.length;)n.pop(),t.pop();if(e<n.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const i=new Int32Array(e),r=new Int32Array(e);Nm(this._multiDrawCounts,i),Nm(this._multiDrawStarts,r),this._multiDrawCounts=i,this._multiDrawStarts=r,this._maxInstanceCount=e;const a=this._indirectTexture,o=this._matricesTexture,l=this._colorsTexture;a.dispose(),this._initIndirectTexture(),Nm(a.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),Nm(o.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),Nm(l.image.data,this._colorsTexture.image.data))}setGeometrySize(e,t){const n=[...this._geometryInfo].filter(o=>o.active);if(Math.max(...n.map(o=>o.vertexStart+o.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...n.map(l=>l.indexStart+l.reservedIndexCount))>t)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);const r=this.geometry;r.dispose(),this._maxVertexCount=e,this._maxIndexCount=t,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Tn,this._initializeGeometry(r));const a=this.geometry;r.index&&Nm(r.index.array,a.index.array);for(const o in r.attributes)Nm(r.attributes[o].array,a.attributes[o].array)}raycast(e,t){const n=this._instanceInfo,i=this._geometryInfo,r=this.matrixWorld,a=this.geometry;xa.material=this.material,xa.geometry.index=a.index,xa.geometry.attributes=a.attributes,xa.geometry.boundingBox===null&&(xa.geometry.boundingBox=new Ea),xa.geometry.boundingSphere===null&&(xa.geometry.boundingSphere=new ea);for(let o=0,l=n.length;o<l;o++){if(!n[o].visible||!n[o].active)continue;const u=n[o].geometryIndex,c=i[u];xa.geometry.setDrawRange(c.start,c.count),this.getMatrixAt(o,xa.matrixWorld).premultiply(r),this.getBoundingBoxAt(u,xa.geometry.boundingBox),this.getBoundingSphereAt(u,xa.geometry.boundingSphere),xa.raycast(e,DT);for(let f=0,d=DT.length;f<d;f++){const g=DT[f];g.object=this,g.batchId=o,t.push(g)}DT.length=0}xa.material=null,xa.geometry.index=null,xa.geometry.attributes={},xa.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox!==null?t.boundingBox.clone():null,boundingSphere:t.boundingSphere!==null?t.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(t=>({...t})),this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(e,t,n,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const a=i.getIndex(),o=a===null?1:a.array.BYTES_PER_ELEMENT,l=this._instanceInfo,u=this._multiDrawStarts,c=this._multiDrawCounts,f=this._geometryInfo,d=this.perObjectFrustumCulled,g=this._indirectTexture,x=g.image.data;d&&(bo.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse).multiply(this.matrixWorld),hR.setFromProjectionMatrix(bo,e.coordinateSystem));let S=0;if(this.sortObjects){bo.copy(this.matrixWorld).invert(),I1.setFromMatrixPosition(n.matrixWorld).applyMatrix4(bo),v4.set(0,0,-1).transformDirection(n.matrixWorld).transformDirection(bo);for(let T=0,E=l.length;T<E;T++)if(l[T].visible&&l[T].active){const C=l[T].geometryIndex;this.getMatrixAt(T,bo),this.getBoundingSphereAt(C,Mm).applyMatrix4(bo);let R=!1;if(d&&(R=!hR.intersectsSphere(Mm)),!R){const I=f[C],L=bJ.subVectors(Mm.center,I1).dot(v4);fR.push(I.start,I.count,L,T)}}const b=fR.list,_=this.customSort;_===null?b.sort(r.transparent?yJ:gJ):_.call(this,b,n);for(let T=0,E=b.length;T<E;T++){const C=b[T];u[S]=C.start*o,c[S]=C.count,x[S]=C.index,S++}fR.reset()}else for(let b=0,_=l.length;b<_;b++)if(l[b].visible&&l[b].active){const T=l[b].geometryIndex;let E=!1;if(d&&(this.getMatrixAt(b,bo),this.getBoundingSphereAt(T,Mm).applyMatrix4(bo),E=!hR.intersectsSphere(Mm)),!E){const C=f[T];u[S]=C.start*o,c[S]=C.count,x[S]=b,S++}}g.needsUpdate=!0,this._multiDrawCount=S,this._visibilityChanged=!1}onBeforeShadow(e,t,n,i,r,a){this.onBeforeRender(e,null,i,r,a)}}class Ra extends br{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Nt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const w2=new ae,C2=new ae,b4=new rn,D1=new Xg,OT=new ea,dR=new ae,_4=new ae;class vf extends ts{constructor(e=new Tn,t=new Ra){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)w2.fromBufferAttribute(t,i-1),C2.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=w2.distanceTo(C2);e.setAttribute("lineDistance",new Vt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),OT.copy(n.boundingSphere),OT.applyMatrix4(i),OT.radius+=r,e.ray.intersectsSphere(OT)===!1)return;b4.copy(i).invert(),D1.copy(e.ray).applyMatrix4(b4);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,u=this.isLineSegments?2:1,c=n.index,d=n.attributes.position;if(c!==null){const g=Math.max(0,a.start),x=Math.min(c.count,a.start+a.count);for(let S=g,b=x-1;S<b;S+=u){const _=c.getX(S),T=c.getX(S+1),E=BT(this,e,D1,l,_,T,S);E&&t.push(E)}if(this.isLineLoop){const S=c.getX(x-1),b=c.getX(g),_=BT(this,e,D1,l,S,b,x-1);_&&t.push(_)}}else{const g=Math.max(0,a.start),x=Math.min(d.count,a.start+a.count);for(let S=g,b=x-1;S<b;S+=u){const _=BT(this,e,D1,l,S,S+1,S);_&&t.push(_)}if(this.isLineLoop){const S=BT(this,e,D1,l,x-1,g,x-1);S&&t.push(S)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}function BT(s,e,t,n,i,r,a){const o=s.geometry.attributes.position;if(w2.fromBufferAttribute(o,i),C2.fromBufferAttribute(o,r),t.distanceSqToSegment(w2,C2,dR,_4)>n)return;dR.applyMatrix4(s.matrixWorld);const u=e.ray.origin.distanceTo(dR);if(!(u<e.near||u>e.far))return{distance:u,point:_4.clone().applyMatrix4(s.matrixWorld),index:a,face:null,faceIndex:null,barycoord:null,object:s}}const S4=new ae,A4=new ae;class lc extends vf{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)S4.fromBufferAttribute(t,i),A4.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+S4.distanceTo(A4);e.setAttribute("lineDistance",new Vt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class H3 extends vf{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class LC extends br{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Nt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const T4=new rn,PI=new Xg,kT=new ea,LT=new ae;class V3 extends ts{constructor(e=new Tn,t=new LC){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),kT.copy(n.boundingSphere),kT.applyMatrix4(i),kT.radius+=r,e.ray.intersectsSphere(kT)===!1)return;T4.copy(i).invert(),PI.copy(e.ray).applyMatrix4(T4);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,u=n.index,f=n.attributes.position;if(u!==null){const d=Math.max(0,a.start),g=Math.min(u.count,a.start+a.count);for(let x=d,S=g;x<S;x++){const b=u.getX(x);LT.fromBufferAttribute(f,b),w4(LT,b,l,i,e,t,this)}}else{const d=Math.max(0,a.start),g=Math.min(f.count,a.start+a.count);for(let x=d,S=g;x<S;x++)LT.fromBufferAttribute(f,x),w4(LT,x,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}function w4(s,e,t,n,i,r,a){const o=PI.distanceSqToPoint(s);if(o<t){const l=new ae;PI.closestPointToPoint(s,l),l.applyMatrix4(n);const u=i.ray.origin.distanceTo(l);if(u<i.near||u>i.far)return;r.push({distance:u,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,faceIndex:null,barycoord:null,object:a})}}class $9 extends ii{constructor(e,t,n,i,r=$i,a=$i,o,l,u){super(e,t,n,i,r,a,o,l,u),this.isVideoTexture=!0,this.generateMipmaps=!1;const c=this;function f(){c.needsUpdate=!0,e.requestVideoFrameCallback(f)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(f)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class SJ extends $9{constructor(e,t,n,i,r,a,o,l){super({},e,t,n,i,r,a,o,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class AJ extends ii{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=Br,this.minFilter=Br,this.generateMipmaps=!1,this.needsUpdate=!0}}class FC extends ii{constructor(e,t,n,i,r,a,o,l,u,c,f,d){super(null,a,o,l,u,c,i,r,f,d),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class TJ extends FC{constructor(e,t,n,i,r,a){super(e,t,n,r,a),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=hl,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class wJ extends FC{constructor(e,t,n){super(void 0,e[0].width,e[0].height,t,n,yf),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class CJ extends ii{constructor(e,t,n,i,r,a,o,l,u){super(e,t,n,i,r,a,o,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class W3 extends ii{constructor(e,t,n=xf,i,r,a,o=Br,l=Br,u,c=ix){if(c!==ix&&c!==rx)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super(null,i,r,a,o,l,c,n,u),this.isDepthTexture=!0,this.image={width:e,height:t},this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new Pd(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class uc{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t=null){const n=this.getLengths();let i=0;const r=n.length;let a;t?a=t:a=e*n[r-1];let o=0,l=r-1,u;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),u=n[i]-a,u<0)o=i+1;else if(u>0)l=i-1;else{l=i;break}if(i=l,n[i]===a)return i/(r-1);const c=n[i],d=n[i+1]-c,g=(a-c)/d;return(i+g)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),o=this.getPoint(r),l=t||(a.isVector2?new tt:new ae);return l.copy(o).sub(a).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t=!1){const n=new ae,i=[],r=[],a=[],o=new ae,l=new rn;for(let g=0;g<=e;g++){const x=g/e;i[g]=this.getTangentAt(x,new ae)}r[0]=new ae,a[0]=new ae;let u=Number.MAX_VALUE;const c=Math.abs(i[0].x),f=Math.abs(i[0].y),d=Math.abs(i[0].z);c<=u&&(u=c,n.set(1,0,0)),f<=u&&(u=f,n.set(0,1,0)),d<=u&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),a[0].crossVectors(i[0],r[0]);for(let g=1;g<=e;g++){if(r[g]=r[g-1].clone(),a[g]=a[g-1].clone(),o.crossVectors(i[g-1],i[g]),o.length()>Number.EPSILON){o.normalize();const x=Math.acos(vn(i[g-1].dot(i[g]),-1,1));r[g].applyMatrix4(l.makeRotationAxis(o,x))}a[g].crossVectors(i[g],r[g])}if(t===!0){let g=Math.acos(vn(r[0].dot(r[e]),-1,1));g/=e,i[0].dot(o.crossVectors(r[0],r[e]))>0&&(g=-g);for(let x=1;x<=e;x++)r[x].applyMatrix4(l.makeRotationAxis(i[x],g*x)),a[x].crossVectors(i[x],r[x])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class PC extends uc{constructor(e=0,t=0,n=1,i=1,r=0,a=Math.PI*2,o=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(e,t=new tt){const n=t,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(a?r=0:r=i),this.aClockwise===!0&&!a&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(o),u=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),f=Math.sin(this.aRotation),d=l-this.aX,g=u-this.aY;l=d*c-g*f+this.aX,u=d*f+g*c+this.aY}return n.set(l,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class z9 extends PC{constructor(e,t,n,i,r,a){super(e,t,n,n,i,r,a),this.isArcCurve=!0,this.type="ArcCurve"}}function X3(){let s=0,e=0,t=0,n=0;function i(r,a,o,l){s=r,e=o,t=-3*r+3*a-2*o-l,n=2*r-2*a+o+l}return{initCatmullRom:function(r,a,o,l,u){i(a,o,u*(o-r),u*(l-a))},initNonuniformCatmullRom:function(r,a,o,l,u,c,f){let d=(a-r)/u-(o-r)/(u+c)+(o-a)/c,g=(o-a)/c-(l-a)/(c+f)+(l-o)/f;d*=c,g*=c,i(a,o,d,g)},calc:function(r){const a=r*r,o=a*r;return s+e*r+t*a+n*o}}}const FT=new ae,pR=new X3,mR=new X3,gR=new X3;class G9 extends uc{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new ae){const n=t,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:l===0&&o===r-1&&(o=r-2,l=1);let u,c;this.closed||o>0?u=i[(o-1)%r]:(FT.subVectors(i[0],i[1]).add(i[0]),u=FT);const f=i[o%r],d=i[(o+1)%r];if(this.closed||o+2<r?c=i[(o+2)%r]:(FT.subVectors(i[r-1],i[r-2]).add(i[r-1]),c=FT),this.curveType==="centripetal"||this.curveType==="chordal"){const g=this.curveType==="chordal"?.5:.25;let x=Math.pow(u.distanceToSquared(f),g),S=Math.pow(f.distanceToSquared(d),g),b=Math.pow(d.distanceToSquared(c),g);S<1e-4&&(S=1),x<1e-4&&(x=S),b<1e-4&&(b=S),pR.initNonuniformCatmullRom(u.x,f.x,d.x,c.x,x,S,b),mR.initNonuniformCatmullRom(u.y,f.y,d.y,c.y,x,S,b),gR.initNonuniformCatmullRom(u.z,f.z,d.z,c.z,x,S,b)}else this.curveType==="catmullrom"&&(pR.initCatmullRom(u.x,f.x,d.x,c.x,this.tension),mR.initCatmullRom(u.y,f.y,d.y,c.y,this.tension),gR.initCatmullRom(u.z,f.z,d.z,c.z,this.tension));return n.set(pR.calc(l),mR.calc(l),gR.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new ae().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function C4(s,e,t,n,i){const r=(n-e)*.5,a=(i-t)*.5,o=s*s,l=s*o;return(2*t-2*n+r+a)*l+(-3*t+3*n-2*r-a)*o+r*s+t}function EJ(s,e){const t=1-s;return t*t*e}function MJ(s,e){return 2*(1-s)*s*e}function NJ(s,e){return s*s*e}function ib(s,e,t,n){return EJ(s,e)+MJ(s,t)+NJ(s,n)}function RJ(s,e){const t=1-s;return t*t*t*e}function IJ(s,e){const t=1-s;return 3*t*t*s*e}function DJ(s,e){return 3*(1-s)*s*s*e}function OJ(s,e){return s*s*s*e}function rb(s,e,t,n,i){return RJ(s,e)+IJ(s,t)+DJ(s,n)+OJ(s,i)}class q3 extends uc{constructor(e=new tt,t=new tt,n=new tt,i=new tt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new tt){const n=t,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(rb(e,i.x,r.x,a.x,o.x),rb(e,i.y,r.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class H9 extends uc{constructor(e=new ae,t=new ae,n=new ae,i=new ae){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new ae){const n=t,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(rb(e,i.x,r.x,a.x,o.x),rb(e,i.y,r.y,a.y,o.y),rb(e,i.z,r.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class j3 extends uc{constructor(e=new tt,t=new tt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new tt){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new tt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class V9 extends uc{constructor(e=new ae,t=new ae){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new ae){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new ae){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class K3 extends uc{constructor(e=new tt,t=new tt,n=new tt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new tt){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(ib(e,i.x,r.x,a.x),ib(e,i.y,r.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Y3 extends uc{constructor(e=new ae,t=new ae,n=new ae){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new ae){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(ib(e,i.x,r.x,a.x),ib(e,i.y,r.y,a.y),ib(e,i.z,r.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class J3 extends uc{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new tt){const n=t,i=this.points,r=(i.length-1)*e,a=Math.floor(r),o=r-a,l=i[a===0?a:a-1],u=i[a],c=i[a>i.length-2?i.length-1:a+1],f=i[a>i.length-3?i.length-1:a+2];return n.set(C4(o,l.x,u.x,c.x,f.x),C4(o,l.y,u.y,c.y,f.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new tt().fromArray(i))}return this}}var E2=Object.freeze({__proto__:null,ArcCurve:z9,CatmullRomCurve3:G9,CubicBezierCurve:q3,CubicBezierCurve3:H9,EllipseCurve:PC,LineCurve:j3,LineCurve3:V9,QuadraticBezierCurve:K3,QuadraticBezierCurve3:Y3,SplineCurve:J3});class W9 extends uc{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const n=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new E2[n](t,e))}return this}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const a=i[r]-n,o=this.curves[r],l=o.getLength(),u=l===0?0:1-a/l;return o.getPointAt(u,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],o=a.isEllipseCurve?e*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,l=a.getPoints(o);for(let u=0;u<l.length;u++){const c=l[u];n&&n.equals(c)||(t.push(c),n=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new E2[i.type]().fromJSON(i))}return this}}class vb extends W9{constructor(e){super(),this.type="Path",this.currentPoint=new tt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new j3(this.currentPoint.clone(),new tt(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const r=new K3(this.currentPoint.clone(),new tt(e,t),new tt(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,a){const o=new q3(this.currentPoint.clone(),new tt(e,t),new tt(n,i),new tt(r,a));return this.curves.push(o),this.currentPoint.set(r,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new J3(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,t+l,n,i,r,a),this}absarc(e,t,n,i,r,a){return this.absellipse(e,t,n,n,i,r,a),this}ellipse(e,t,n,i,r,a,o,l){const u=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+u,t+c,n,i,r,a,o,l),this}absellipse(e,t,n,i,r,a,o,l){const u=new PC(e,t,n,i,r,a,o,l);if(this.curves.length>0){const f=u.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(u);const c=u.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class r_ extends Tn{constructor(e=[new tt(0,-.5),new tt(.5,0),new tt(0,.5)],t=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=vn(i,0,Math.PI*2);const r=[],a=[],o=[],l=[],u=[],c=1/t,f=new ae,d=new tt,g=new ae,x=new ae,S=new ae;let b=0,_=0;for(let T=0;T<=e.length-1;T++)switch(T){case 0:b=e[T+1].x-e[T].x,_=e[T+1].y-e[T].y,g.x=_*1,g.y=-b,g.z=_*0,S.copy(g),g.normalize(),l.push(g.x,g.y,g.z);break;case e.length-1:l.push(S.x,S.y,S.z);break;default:b=e[T+1].x-e[T].x,_=e[T+1].y-e[T].y,g.x=_*1,g.y=-b,g.z=_*0,x.copy(g),g.x+=S.x,g.y+=S.y,g.z+=S.z,g.normalize(),l.push(g.x,g.y,g.z),S.copy(x)}for(let T=0;T<=t;T++){const E=n+T*c*i,C=Math.sin(E),R=Math.cos(E);for(let I=0;I<=e.length-1;I++){f.x=e[I].x*C,f.y=e[I].y,f.z=e[I].x*R,a.push(f.x,f.y,f.z),d.x=T/t,d.y=I/(e.length-1),o.push(d.x,d.y);const L=l[3*I+0]*C,P=l[3*I+1],D=l[3*I+0]*R;u.push(L,P,D)}}for(let T=0;T<t;T++)for(let E=0;E<e.length-1;E++){const C=E+T*e.length,R=C,I=C+e.length,L=C+e.length+1,P=C+1;r.push(R,I,P),r.push(L,P,I)}this.setIndex(r),this.setAttribute("position",new Vt(a,3)),this.setAttribute("uv",new Vt(o,2)),this.setAttribute("normal",new Vt(u,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new r_(e.points,e.segments,e.phiStart,e.phiLength)}}class UC extends r_{constructor(e=1,t=1,n=4,i=8){const r=new vb;r.absarc(0,-t/2,e,Math.PI*1.5,0),r.absarc(0,t/2,e,0,Math.PI*.5),super(r.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new UC(e.radius,e.length,e.capSegments,e.radialSegments)}}class $C extends Tn{constructor(e=1,t=32,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const r=[],a=[],o=[],l=[],u=new ae,c=new tt;a.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let f=0,d=3;f<=t;f++,d+=3){const g=n+f/t*i;u.x=e*Math.cos(g),u.y=e*Math.sin(g),a.push(u.x,u.y,u.z),o.push(0,0,1),c.x=(a[d]/e+1)/2,c.y=(a[d+1]/e+1)/2,l.push(c.x,c.y)}for(let f=1;f<=t;f++)r.push(f,f+1,0);this.setIndex(r),this.setAttribute("position",new Vt(a,3)),this.setAttribute("normal",new Vt(o,3)),this.setAttribute("uv",new Vt(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new $C(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Lx extends Tn{constructor(e=1,t=1,n=1,i=32,r=1,a=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:l};const u=this;i=Math.floor(i),r=Math.floor(r);const c=[],f=[],d=[],g=[];let x=0;const S=[],b=n/2;let _=0;T(),a===!1&&(e>0&&E(!0),t>0&&E(!1)),this.setIndex(c),this.setAttribute("position",new Vt(f,3)),this.setAttribute("normal",new Vt(d,3)),this.setAttribute("uv",new Vt(g,2));function T(){const C=new ae,R=new ae;let I=0;const L=(t-e)/n;for(let P=0;P<=r;P++){const D=[],O=P/r,F=O*(t-e)+e;for(let X=0;X<=i;X++){const q=X/i,J=q*l+o,Y=Math.sin(J),$=Math.cos(J);R.x=F*Y,R.y=-O*n+b,R.z=F*$,f.push(R.x,R.y,R.z),C.set(Y,L,$).normalize(),d.push(C.x,C.y,C.z),g.push(q,1-O),D.push(x++)}S.push(D)}for(let P=0;P<i;P++)for(let D=0;D<r;D++){const O=S[D][P],F=S[D+1][P],X=S[D+1][P+1],q=S[D][P+1];(e>0||D!==0)&&(c.push(O,F,q),I+=3),(t>0||D!==r-1)&&(c.push(F,X,q),I+=3)}u.addGroup(_,I,0),_+=I}function E(C){const R=x,I=new tt,L=new ae;let P=0;const D=C===!0?e:t,O=C===!0?1:-1;for(let X=1;X<=i;X++)f.push(0,b*O,0),d.push(0,O,0),g.push(.5,.5),x++;const F=x;for(let X=0;X<=i;X++){const J=X/i*l+o,Y=Math.cos(J),$=Math.sin(J);L.x=D*$,L.y=b*O,L.z=D*Y,f.push(L.x,L.y,L.z),d.push(0,O,0),I.x=Y*.5+.5,I.y=$*.5*O+.5,g.push(I.x,I.y),x++}for(let X=0;X<i;X++){const q=R+X,J=F+X;C===!0?c.push(J,J+1,q):c.push(J+1,J,q),P+=3}u.addGroup(_,P,C===!0?1:2),_+=P}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Lx(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class zC extends Lx{constructor(e=1,t=1,n=32,i=1,r=!1,a=0,o=Math.PI*2){super(0,e,t,n,i,r,a,o),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:o}}static fromJSON(e){return new zC(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class yp extends Tn{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const r=[],a=[];o(i),u(n),c(),this.setAttribute("position",new Vt(r,3)),this.setAttribute("normal",new Vt(r.slice(),3)),this.setAttribute("uv",new Vt(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(T){const E=new ae,C=new ae,R=new ae;for(let I=0;I<t.length;I+=3)g(t[I+0],E),g(t[I+1],C),g(t[I+2],R),l(E,C,R,T)}function l(T,E,C,R){const I=R+1,L=[];for(let P=0;P<=I;P++){L[P]=[];const D=T.clone().lerp(C,P/I),O=E.clone().lerp(C,P/I),F=I-P;for(let X=0;X<=F;X++)X===0&&P===I?L[P][X]=D:L[P][X]=D.clone().lerp(O,X/F)}for(let P=0;P<I;P++)for(let D=0;D<2*(I-P)-1;D++){const O=Math.floor(D/2);D%2===0?(d(L[P][O+1]),d(L[P+1][O]),d(L[P][O])):(d(L[P][O+1]),d(L[P+1][O+1]),d(L[P+1][O]))}}function u(T){const E=new ae;for(let C=0;C<r.length;C+=3)E.x=r[C+0],E.y=r[C+1],E.z=r[C+2],E.normalize().multiplyScalar(T),r[C+0]=E.x,r[C+1]=E.y,r[C+2]=E.z}function c(){const T=new ae;for(let E=0;E<r.length;E+=3){T.x=r[E+0],T.y=r[E+1],T.z=r[E+2];const C=b(T)/2/Math.PI+.5,R=_(T)/Math.PI+.5;a.push(C,1-R)}x(),f()}function f(){for(let T=0;T<a.length;T+=6){const E=a[T+0],C=a[T+2],R=a[T+4],I=Math.max(E,C,R),L=Math.min(E,C,R);I>.9&&L<.1&&(E<.2&&(a[T+0]+=1),C<.2&&(a[T+2]+=1),R<.2&&(a[T+4]+=1))}}function d(T){r.push(T.x,T.y,T.z)}function g(T,E){const C=T*3;E.x=e[C+0],E.y=e[C+1],E.z=e[C+2]}function x(){const T=new ae,E=new ae,C=new ae,R=new ae,I=new tt,L=new tt,P=new tt;for(let D=0,O=0;D<r.length;D+=9,O+=6){T.set(r[D+0],r[D+1],r[D+2]),E.set(r[D+3],r[D+4],r[D+5]),C.set(r[D+6],r[D+7],r[D+8]),I.set(a[O+0],a[O+1]),L.set(a[O+2],a[O+3]),P.set(a[O+4],a[O+5]),R.copy(T).add(E).add(C).divideScalar(3);const F=b(R);S(I,O+0,T,F),S(L,O+2,E,F),S(P,O+4,C,F)}}function S(T,E,C,R){R<0&&T.x===1&&(a[E]=T.x-1),C.x===0&&C.z===0&&(a[E]=R/2/Math.PI+.5)}function b(T){return Math.atan2(T.z,-T.x)}function _(T){return Math.atan2(-T.y,Math.sqrt(T.x*T.x+T.z*T.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new yp(e.vertices,e.indices,e.radius,e.details)}}class GC extends yp{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,a,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new GC(e.radius,e.detail)}}const PT=new ae,UT=new ae,yR=new ae,$T=new wo;class X9 extends Tn{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),r=Math.cos(fg*t),a=e.getIndex(),o=e.getAttribute("position"),l=a?a.count:o.count,u=[0,0,0],c=["a","b","c"],f=new Array(3),d={},g=[];for(let x=0;x<l;x+=3){a?(u[0]=a.getX(x),u[1]=a.getX(x+1),u[2]=a.getX(x+2)):(u[0]=x,u[1]=x+1,u[2]=x+2);const{a:S,b,c:_}=$T;if(S.fromBufferAttribute(o,u[0]),b.fromBufferAttribute(o,u[1]),_.fromBufferAttribute(o,u[2]),$T.getNormal(yR),f[0]=`${Math.round(S.x*i)},${Math.round(S.y*i)},${Math.round(S.z*i)}`,f[1]=`${Math.round(b.x*i)},${Math.round(b.y*i)},${Math.round(b.z*i)}`,f[2]=`${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`,!(f[0]===f[1]||f[1]===f[2]||f[2]===f[0]))for(let T=0;T<3;T++){const E=(T+1)%3,C=f[T],R=f[E],I=$T[c[T]],L=$T[c[E]],P=`${C}_${R}`,D=`${R}_${C}`;D in d&&d[D]?(yR.dot(d[D].normal)<=r&&(g.push(I.x,I.y,I.z),g.push(L.x,L.y,L.z)),d[D]=null):P in d||(d[P]={index0:u[T],index1:u[E],normal:yR.clone()})}}for(const x in d)if(d[x]){const{index0:S,index1:b}=d[x];PT.fromBufferAttribute(o,S),UT.fromBufferAttribute(o,b),g.push(PT.x,PT.y,PT.z),g.push(UT.x,UT.y,UT.z)}this.setAttribute("position",new Vt(g,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class dg extends vb{constructor(e){super(e),this.uuid=gl(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new vb().fromJSON(i))}return this}}function BJ(s,e,t=2){const n=e&&e.length,i=n?e[0]*t:s.length;let r=q9(s,0,i,t,!0);const a=[];if(!r||r.next===r.prev)return a;let o,l,u;if(n&&(r=UJ(s,e,r,t)),s.length>80*t){o=1/0,l=1/0;let c=-1/0,f=-1/0;for(let d=t;d<i;d+=t){const g=s[d],x=s[d+1];g<o&&(o=g),x<l&&(l=x),g>c&&(c=g),x>f&&(f=x)}u=Math.max(c-o,f-l),u=u!==0?32767/u:0}return bb(r,a,t,o,l,u,0),a}function q9(s,e,t,n,i){let r;if(i===YJ(s,e,t,n)>0)for(let a=e;a<t;a+=n)r=E4(a/n|0,s[a],s[a+1],r);else for(let a=t-n;a>=e;a-=n)r=E4(a/n|0,s[a],s[a+1],r);return r&&hx(r,r.next)&&(Sb(r),r=r.next),r}function Tg(s,e){if(!s)return s;e||(e=s);let t=s,n;do if(n=!1,!t.steiner&&(hx(t,t.next)||fi(t.prev,t,t.next)===0)){if(Sb(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function bb(s,e,t,n,i,r,a){if(!s)return;!a&&r&&VJ(s,n,i,r);let o=s;for(;s.prev!==s.next;){const l=s.prev,u=s.next;if(r?LJ(s,n,i,r):kJ(s)){e.push(l.i,s.i,u.i),Sb(s),s=u.next,o=u.next;continue}if(s=u,s===o){a?a===1?(s=FJ(Tg(s),e),bb(s,e,t,n,i,r,2)):a===2&&PJ(s,e,t,n,i,r):bb(Tg(s),e,t,n,i,r,1);break}}}function kJ(s){const e=s.prev,t=s,n=s.next;if(fi(e,t,n)>=0)return!1;const i=e.x,r=t.x,a=n.x,o=e.y,l=t.y,u=n.y,c=Math.min(i,r,a),f=Math.min(o,l,u),d=Math.max(i,r,a),g=Math.max(o,l,u);let x=n.next;for(;x!==e;){if(x.x>=c&&x.x<=d&&x.y>=f&&x.y<=g&&z1(i,o,r,l,a,u,x.x,x.y)&&fi(x.prev,x,x.next)>=0)return!1;x=x.next}return!0}function LJ(s,e,t,n){const i=s.prev,r=s,a=s.next;if(fi(i,r,a)>=0)return!1;const o=i.x,l=r.x,u=a.x,c=i.y,f=r.y,d=a.y,g=Math.min(o,l,u),x=Math.min(c,f,d),S=Math.max(o,l,u),b=Math.max(c,f,d),_=UI(g,x,e,t,n),T=UI(S,b,e,t,n);let E=s.prevZ,C=s.nextZ;for(;E&&E.z>=_&&C&&C.z<=T;){if(E.x>=g&&E.x<=S&&E.y>=x&&E.y<=b&&E!==i&&E!==a&&z1(o,c,l,f,u,d,E.x,E.y)&&fi(E.prev,E,E.next)>=0||(E=E.prevZ,C.x>=g&&C.x<=S&&C.y>=x&&C.y<=b&&C!==i&&C!==a&&z1(o,c,l,f,u,d,C.x,C.y)&&fi(C.prev,C,C.next)>=0))return!1;C=C.nextZ}for(;E&&E.z>=_;){if(E.x>=g&&E.x<=S&&E.y>=x&&E.y<=b&&E!==i&&E!==a&&z1(o,c,l,f,u,d,E.x,E.y)&&fi(E.prev,E,E.next)>=0)return!1;E=E.prevZ}for(;C&&C.z<=T;){if(C.x>=g&&C.x<=S&&C.y>=x&&C.y<=b&&C!==i&&C!==a&&z1(o,c,l,f,u,d,C.x,C.y)&&fi(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function FJ(s,e){let t=s;do{const n=t.prev,i=t.next.next;!hx(n,i)&&K9(n,t,t.next,i)&&_b(n,i)&&_b(i,n)&&(e.push(n.i,t.i,i.i),Sb(t),Sb(t.next),t=s=i),t=t.next}while(t!==s);return Tg(t)}function PJ(s,e,t,n,i,r){let a=s;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&qJ(a,o)){let l=Y9(a,o);a=Tg(a,a.next),l=Tg(l,l.next),bb(a,e,t,n,i,r,0),bb(l,e,t,n,i,r,0);return}o=o.next}a=a.next}while(a!==s)}function UJ(s,e,t,n){const i=[];for(let r=0,a=e.length;r<a;r++){const o=e[r]*n,l=r<a-1?e[r+1]*n:s.length,u=q9(s,o,l,n,!1);u===u.next&&(u.steiner=!0),i.push(XJ(u))}i.sort($J);for(let r=0;r<i.length;r++)t=zJ(i[r],t);return t}function $J(s,e){let t=s.x-e.x;if(t===0&&(t=s.y-e.y,t===0)){const n=(s.next.y-s.y)/(s.next.x-s.x),i=(e.next.y-e.y)/(e.next.x-e.x);t=n-i}return t}function zJ(s,e){const t=GJ(s,e);if(!t)return e;const n=Y9(t,s);return Tg(n,n.next),Tg(t,t.next)}function GJ(s,e){let t=e;const n=s.x,i=s.y;let r=-1/0,a;if(hx(s,t))return t;do{if(hx(s,t.next))return t.next;if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const f=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=n&&f>r&&(r=f,a=t.x<t.next.x?t:t.next,f===n))return a}t=t.next}while(t!==e);if(!a)return null;const o=a,l=a.x,u=a.y;let c=1/0;t=a;do{if(n>=t.x&&t.x>=l&&n!==t.x&&j9(i<u?n:r,i,l,u,i<u?r:n,i,t.x,t.y)){const f=Math.abs(i-t.y)/(n-t.x);_b(t,s)&&(f<c||f===c&&(t.x>a.x||t.x===a.x&&HJ(a,t)))&&(a=t,c=f)}t=t.next}while(t!==o);return a}function HJ(s,e){return fi(s.prev,s,e.prev)<0&&fi(e.next,s,s.next)<0}function VJ(s,e,t,n){let i=s;do i.z===0&&(i.z=UI(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==s);i.prevZ.nextZ=null,i.prevZ=null,WJ(i)}function WJ(s){let e,t=1;do{let n=s,i;s=null;let r=null;for(e=0;n;){e++;let a=n,o=0;for(let u=0;u<t&&(o++,a=a.nextZ,!!a);u++);let l=t;for(;o>0||l>0&&a;)o!==0&&(l===0||!a||n.z<=a.z)?(i=n,n=n.nextZ,o--):(i=a,a=a.nextZ,l--),r?r.nextZ=i:s=i,i.prevZ=r,r=i;n=a}r.nextZ=null,t*=2}while(e>1);return s}function UI(s,e,t,n,i){return s=(s-t)*i|0,e=(e-n)*i|0,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,s|e<<1}function XJ(s){let e=s,t=s;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==s);return t}function j9(s,e,t,n,i,r,a,o){return(i-a)*(e-o)>=(s-a)*(r-o)&&(s-a)*(n-o)>=(t-a)*(e-o)&&(t-a)*(r-o)>=(i-a)*(n-o)}function z1(s,e,t,n,i,r,a,o){return!(s===a&&e===o)&&j9(s,e,t,n,i,r,a,o)}function qJ(s,e){return s.next.i!==e.i&&s.prev.i!==e.i&&!jJ(s,e)&&(_b(s,e)&&_b(e,s)&&KJ(s,e)&&(fi(s.prev,s,e.prev)||fi(s,e.prev,e))||hx(s,e)&&fi(s.prev,s,s.next)>0&&fi(e.prev,e,e.next)>0)}function fi(s,e,t){return(e.y-s.y)*(t.x-e.x)-(e.x-s.x)*(t.y-e.y)}function hx(s,e){return s.x===e.x&&s.y===e.y}function K9(s,e,t,n){const i=GT(fi(s,e,t)),r=GT(fi(s,e,n)),a=GT(fi(t,n,s)),o=GT(fi(t,n,e));return!!(i!==r&&a!==o||i===0&&zT(s,t,e)||r===0&&zT(s,n,e)||a===0&&zT(t,s,n)||o===0&&zT(t,e,n))}function zT(s,e,t){return e.x<=Math.max(s.x,t.x)&&e.x>=Math.min(s.x,t.x)&&e.y<=Math.max(s.y,t.y)&&e.y>=Math.min(s.y,t.y)}function GT(s){return s>0?1:s<0?-1:0}function jJ(s,e){let t=s;do{if(t.i!==s.i&&t.next.i!==s.i&&t.i!==e.i&&t.next.i!==e.i&&K9(t,t.next,s,e))return!0;t=t.next}while(t!==s);return!1}function _b(s,e){return fi(s.prev,s,s.next)<0?fi(s,e,s.next)>=0&&fi(s,s.prev,e)>=0:fi(s,e,s.prev)<0||fi(s,s.next,e)<0}function KJ(s,e){let t=s,n=!1;const i=(s.x+e.x)/2,r=(s.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==s);return n}function Y9(s,e){const t=$I(s.i,s.x,s.y),n=$I(e.i,e.x,e.y),i=s.next,r=e.prev;return s.next=e,e.prev=s,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function E4(s,e,t,n){const i=$I(s,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Sb(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function $I(s,e,t){return{i:s,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function YJ(s,e,t,n){let i=0;for(let r=e,a=t-n;r<t;r+=n)i+=(s[a]-s[r])*(s[r+1]+s[a+1]),a=r;return i}class JJ{static triangulate(e,t,n=2){return BJ(e,t,n)}}class sh{static area(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return n*.5}static isClockWise(e){return sh.area(e)<0}static triangulateShape(e,t){const n=[],i=[],r=[];M4(e),N4(n,e);let a=e.length;t.forEach(M4);for(let l=0;l<t.length;l++)i.push(a),a+=t[l].length,N4(n,t[l]);const o=JJ.triangulate(n,i);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function M4(s){const e=s.length;e>2&&s[e-1].equals(s[0])&&s.pop()}function N4(s,e){for(let t=0;t<e.length;t++)s.push(e[t].x),s.push(e[t].y)}class HC extends Tn{constructor(e=new dg([new tt(.5,.5),new tt(-.5,.5),new tt(-.5,-.5),new tt(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],r=[];for(let o=0,l=e.length;o<l;o++){const u=e[o];a(u)}this.setAttribute("position",new Vt(i,3)),this.setAttribute("uv",new Vt(r,2)),this.computeVertexNormals();function a(o){const l=[],u=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1,f=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,g=t.bevelThickness!==void 0?t.bevelThickness:.2,x=t.bevelSize!==void 0?t.bevelSize:g-.1,S=t.bevelOffset!==void 0?t.bevelOffset:0,b=t.bevelSegments!==void 0?t.bevelSegments:3;const _=t.extrudePath,T=t.UVGenerator!==void 0?t.UVGenerator:ZJ;let E,C=!1,R,I,L,P;_&&(E=_.getSpacedPoints(c),C=!0,d=!1,R=_.computeFrenetFrames(c,!1),I=new ae,L=new ae,P=new ae),d||(b=0,g=0,x=0,S=0);const D=o.extractPoints(u);let O=D.shape;const F=D.holes;if(!sh.isClockWise(O)){O=O.reverse();for(let ze=0,Fe=F.length;ze<Fe;ze++){const Pe=F[ze];sh.isClockWise(Pe)&&(F[ze]=Pe.reverse())}}function q(ze){const Pe=10000000000000001e-36;let ht=ze[0];for(let ke=1;ke<=ze.length;ke++){const ie=ke%ze.length,j=ze[ie],Ae=j.x-ht.x,Ue=j.y-ht.y,Ye=Ae*Ae+Ue*Ue,qe=Math.max(Math.abs(j.x),Math.abs(j.y),Math.abs(ht.x),Math.abs(ht.y)),mt=Pe*qe*qe;if(Ye<=mt){ze.splice(ie,1),ke--;continue}ht=j}}q(O),F.forEach(q);const J=F.length,Y=O;for(let ze=0;ze<J;ze++){const Fe=F[ze];O=O.concat(Fe)}function $(ze,Fe,Pe){return Fe||console.error("THREE.ExtrudeGeometry: vec does not exist"),ze.clone().addScaledVector(Fe,Pe)}const W=O.length;function V(ze,Fe,Pe){let ht,ke,ie;const j=ze.x-Fe.x,Ae=ze.y-Fe.y,Ue=Pe.x-ze.x,Ye=Pe.y-ze.y,qe=j*j+Ae*Ae,mt=j*Ye-Ae*Ue;if(Math.abs(mt)>Number.EPSILON){const at=Math.sqrt(qe),gt=Math.sqrt(Ue*Ue+Ye*Ye),dn=Fe.x-Ae/at,lt=Fe.y+j/at,Dt=Pe.x-Ye/gt,Ft=Pe.y+Ue/gt,Pt=((Dt-dn)*Ye-(Ft-lt)*Ue)/(j*Ye-Ae*Ue);ht=dn+j*Pt-ze.x,ke=lt+Ae*Pt-ze.y;const vt=ht*ht+ke*ke;if(vt<=2)return new tt(ht,ke);ie=Math.sqrt(vt/2)}else{let at=!1;j>Number.EPSILON?Ue>Number.EPSILON&&(at=!0):j<-Number.EPSILON?Ue<-Number.EPSILON&&(at=!0):Math.sign(Ae)===Math.sign(Ye)&&(at=!0),at?(ht=-Ae,ke=j,ie=Math.sqrt(qe)):(ht=j,ke=Ae,ie=Math.sqrt(qe/2))}return new tt(ht/ie,ke/ie)}const se=[];for(let ze=0,Fe=Y.length,Pe=Fe-1,ht=ze+1;ze<Fe;ze++,Pe++,ht++)Pe===Fe&&(Pe=0),ht===Fe&&(ht=0),se[ze]=V(Y[ze],Y[Pe],Y[ht]);const G=[];let ne,oe=se.concat();for(let ze=0,Fe=J;ze<Fe;ze++){const Pe=F[ze];ne=[];for(let ht=0,ke=Pe.length,ie=ke-1,j=ht+1;ht<ke;ht++,ie++,j++)ie===ke&&(ie=0),j===ke&&(j=0),ne[ht]=V(Pe[ht],Pe[ie],Pe[j]);G.push(ne),oe=oe.concat(ne)}const ue=[],re=[];for(let ze=0;ze<b;ze++){const Fe=ze/b,Pe=g*Math.cos(Fe*Math.PI/2),ht=x*Math.sin(Fe*Math.PI/2)+S;for(let ke=0,ie=Y.length;ke<ie;ke++){const j=$(Y[ke],se[ke],ht);xt(j.x,j.y,-Pe),Fe==0&&ue.push(j)}for(let ke=0,ie=J;ke<ie;ke++){const j=F[ke];ne=G[ke];const Ae=[];for(let Ue=0,Ye=j.length;Ue<Ye;Ue++){const qe=$(j[Ue],ne[Ue],ht);xt(qe.x,qe.y,-Pe),Fe==0&&Ae.push(qe)}Fe==0&&re.push(Ae)}}const ce=sh.triangulateShape(ue,re),Te=ce.length,Be=x+S;for(let ze=0;ze<W;ze++){const Fe=d?$(O[ze],oe[ze],Be):O[ze];C?(L.copy(R.normals[0]).multiplyScalar(Fe.x),I.copy(R.binormals[0]).multiplyScalar(Fe.y),P.copy(E[0]).add(L).add(I),xt(P.x,P.y,P.z)):xt(Fe.x,Fe.y,0)}for(let ze=1;ze<=c;ze++)for(let Fe=0;Fe<W;Fe++){const Pe=d?$(O[Fe],oe[Fe],Be):O[Fe];C?(L.copy(R.normals[ze]).multiplyScalar(Pe.x),I.copy(R.binormals[ze]).multiplyScalar(Pe.y),P.copy(E[ze]).add(L).add(I),xt(P.x,P.y,P.z)):xt(Pe.x,Pe.y,f/c*ze)}for(let ze=b-1;ze>=0;ze--){const Fe=ze/b,Pe=g*Math.cos(Fe*Math.PI/2),ht=x*Math.sin(Fe*Math.PI/2)+S;for(let ke=0,ie=Y.length;ke<ie;ke++){const j=$(Y[ke],se[ke],ht);xt(j.x,j.y,f+Pe)}for(let ke=0,ie=F.length;ke<ie;ke++){const j=F[ke];ne=G[ke];for(let Ae=0,Ue=j.length;Ae<Ue;Ae++){const Ye=$(j[Ae],ne[Ae],ht);C?xt(Ye.x,Ye.y+E[c-1].y,E[c-1].x+Pe):xt(Ye.x,Ye.y,f+Pe)}}}Ke(),ut();function Ke(){const ze=i.length/3;if(d){let Fe=0,Pe=W*Fe;for(let ht=0;ht<Te;ht++){const ke=ce[ht];kt(ke[2]+Pe,ke[1]+Pe,ke[0]+Pe)}Fe=c+b*2,Pe=W*Fe;for(let ht=0;ht<Te;ht++){const ke=ce[ht];kt(ke[0]+Pe,ke[1]+Pe,ke[2]+Pe)}}else{for(let Fe=0;Fe<Te;Fe++){const Pe=ce[Fe];kt(Pe[2],Pe[1],Pe[0])}for(let Fe=0;Fe<Te;Fe++){const Pe=ce[Fe];kt(Pe[0]+W*c,Pe[1]+W*c,Pe[2]+W*c)}}n.addGroup(ze,i.length/3-ze,0)}function ut(){const ze=i.length/3;let Fe=0;ct(Y,Fe),Fe+=Y.length;for(let Pe=0,ht=F.length;Pe<ht;Pe++){const ke=F[Pe];ct(ke,Fe),Fe+=ke.length}n.addGroup(ze,i.length/3-ze,1)}function ct(ze,Fe){let Pe=ze.length;for(;--Pe>=0;){const ht=Pe;let ke=Pe-1;ke<0&&(ke=ze.length-1);for(let ie=0,j=c+b*2;ie<j;ie++){const Ae=W*ie,Ue=W*(ie+1),Ye=Fe+ht+Ae,qe=Fe+ke+Ae,mt=Fe+ke+Ue,at=Fe+ht+Ue;Et(Ye,qe,mt,at)}}}function xt(ze,Fe,Pe){l.push(ze),l.push(Fe),l.push(Pe)}function kt(ze,Fe,Pe){le(ze),le(Fe),le(Pe);const ht=i.length/3,ke=T.generateTopUV(n,i,ht-3,ht-2,ht-1);Wt(ke[0]),Wt(ke[1]),Wt(ke[2])}function Et(ze,Fe,Pe,ht){le(ze),le(Fe),le(ht),le(Fe),le(Pe),le(ht);const ke=i.length/3,ie=T.generateSideWallUV(n,i,ke-6,ke-3,ke-2,ke-1);Wt(ie[0]),Wt(ie[1]),Wt(ie[3]),Wt(ie[1]),Wt(ie[2]),Wt(ie[3])}function le(ze){i.push(l[ze*3+0]),i.push(l[ze*3+1]),i.push(l[ze*3+2])}function Wt(ze){r.push(ze.x),r.push(ze.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return QJ(t,n,e)}static fromJSON(e,t){const n=[];for(let r=0,a=e.shapes.length;r<a;r++){const o=t[e.shapes[r]];n.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new E2[i.type]().fromJSON(i)),new HC(n,e.options)}}const ZJ={generateTopUV:function(s,e,t,n,i){const r=e[t*3],a=e[t*3+1],o=e[n*3],l=e[n*3+1],u=e[i*3],c=e[i*3+1];return[new tt(r,a),new tt(o,l),new tt(u,c)]},generateSideWallUV:function(s,e,t,n,i,r){const a=e[t*3],o=e[t*3+1],l=e[t*3+2],u=e[n*3],c=e[n*3+1],f=e[n*3+2],d=e[i*3],g=e[i*3+1],x=e[i*3+2],S=e[r*3],b=e[r*3+1],_=e[r*3+2];return Math.abs(o-c)<Math.abs(a-u)?[new tt(a,1-l),new tt(u,1-f),new tt(d,1-x),new tt(S,1-_)]:[new tt(o,1-l),new tt(c,1-f),new tt(g,1-x),new tt(b,1-_)]}};function QJ(s,e,t){if(t.shapes=[],Array.isArray(s))for(let n=0,i=s.length;n<i;n++){const r=s[n];t.shapes.push(r.uuid)}else t.shapes.push(s.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class VC extends yp{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new VC(e.radius,e.detail)}}class a_ extends yp{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new a_(e.radius,e.detail)}}class Fx extends Tn{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const r=e/2,a=t/2,o=Math.floor(n),l=Math.floor(i),u=o+1,c=l+1,f=e/o,d=t/l,g=[],x=[],S=[],b=[];for(let _=0;_<c;_++){const T=_*d-a;for(let E=0;E<u;E++){const C=E*f-r;x.push(C,-T,0),S.push(0,0,1),b.push(E/o),b.push(1-_/l)}}for(let _=0;_<l;_++)for(let T=0;T<o;T++){const E=T+u*_,C=T+u*(_+1),R=T+1+u*(_+1),I=T+1+u*_;g.push(E,C,I),g.push(C,R,I)}this.setIndex(g),this.setAttribute("position",new Vt(x,3)),this.setAttribute("normal",new Vt(S,3)),this.setAttribute("uv",new Vt(b,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Fx(e.width,e.height,e.widthSegments,e.heightSegments)}}class WC extends Tn{constructor(e=.5,t=1,n=32,i=1,r=0,a=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:a},n=Math.max(3,n),i=Math.max(1,i);const o=[],l=[],u=[],c=[];let f=e;const d=(t-e)/i,g=new ae,x=new tt;for(let S=0;S<=i;S++){for(let b=0;b<=n;b++){const _=r+b/n*a;g.x=f*Math.cos(_),g.y=f*Math.sin(_),l.push(g.x,g.y,g.z),u.push(0,0,1),x.x=(g.x/t+1)/2,x.y=(g.y/t+1)/2,c.push(x.x,x.y)}f+=d}for(let S=0;S<i;S++){const b=S*(n+1);for(let _=0;_<n;_++){const T=_+b,E=T,C=T+n+1,R=T+n+2,I=T+1;o.push(E,C,I),o.push(C,R,I)}}this.setIndex(o),this.setAttribute("position",new Vt(l,3)),this.setAttribute("normal",new Vt(u,3)),this.setAttribute("uv",new Vt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new WC(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class XC extends Tn{constructor(e=new dg([new tt(0,.5),new tt(-.5,-.5),new tt(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],r=[],a=[];let o=0,l=0;if(Array.isArray(e)===!1)u(e);else for(let c=0;c<e.length;c++)u(e[c]),this.addGroup(o,l,c),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new Vt(i,3)),this.setAttribute("normal",new Vt(r,3)),this.setAttribute("uv",new Vt(a,2));function u(c){const f=i.length/3,d=c.extractPoints(t);let g=d.shape;const x=d.holes;sh.isClockWise(g)===!1&&(g=g.reverse());for(let b=0,_=x.length;b<_;b++){const T=x[b];sh.isClockWise(T)===!0&&(x[b]=T.reverse())}const S=sh.triangulateShape(g,x);for(let b=0,_=x.length;b<_;b++){const T=x[b];g=g.concat(T)}for(let b=0,_=g.length;b<_;b++){const T=g[b];i.push(T.x,T.y,0),r.push(0,0,1),a.push(T.x,T.y)}for(let b=0,_=S.length;b<_;b++){const T=S[b],E=T[0]+f,C=T[1]+f,R=T[2]+f;n.push(E,C,R),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return eZ(t,e)}static fromJSON(e,t){const n=[];for(let i=0,r=e.shapes.length;i<r;i++){const a=t[e.shapes[i]];n.push(a)}return new XC(n,e.curveSegments)}}function eZ(s,e){if(e.shapes=[],Array.isArray(s))for(let t=0,n=s.length;t<n;t++){const i=s[t];e.shapes.push(i.uuid)}else e.shapes.push(s.uuid);return e}class o_ extends Tn{constructor(e=1,t=32,n=16,i=0,r=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:r,thetaStart:a,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(a+o,Math.PI);let u=0;const c=[],f=new ae,d=new ae,g=[],x=[],S=[],b=[];for(let _=0;_<=n;_++){const T=[],E=_/n;let C=0;_===0&&a===0?C=.5/t:_===n&&l===Math.PI&&(C=-.5/t);for(let R=0;R<=t;R++){const I=R/t;f.x=-e*Math.cos(i+I*r)*Math.sin(a+E*o),f.y=e*Math.cos(a+E*o),f.z=e*Math.sin(i+I*r)*Math.sin(a+E*o),x.push(f.x,f.y,f.z),d.copy(f).normalize(),S.push(d.x,d.y,d.z),b.push(I+C,1-E),T.push(u++)}c.push(T)}for(let _=0;_<n;_++)for(let T=0;T<t;T++){const E=c[_][T+1],C=c[_][T],R=c[_+1][T],I=c[_+1][T+1];(_!==0||a>0)&&g.push(E,C,I),(_!==n-1||l<Math.PI)&&g.push(C,R,I)}this.setIndex(g),this.setAttribute("position",new Vt(x,3)),this.setAttribute("normal",new Vt(S,3)),this.setAttribute("uv",new Vt(b,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new o_(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class qC extends yp{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new qC(e.radius,e.detail)}}class jC extends Tn{constructor(e=1,t=.4,n=12,i=48,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const a=[],o=[],l=[],u=[],c=new ae,f=new ae,d=new ae;for(let g=0;g<=n;g++)for(let x=0;x<=i;x++){const S=x/i*r,b=g/n*Math.PI*2;f.x=(e+t*Math.cos(b))*Math.cos(S),f.y=(e+t*Math.cos(b))*Math.sin(S),f.z=t*Math.sin(b),o.push(f.x,f.y,f.z),c.x=e*Math.cos(S),c.y=e*Math.sin(S),d.subVectors(f,c).normalize(),l.push(d.x,d.y,d.z),u.push(x/i),u.push(g/n)}for(let g=1;g<=n;g++)for(let x=1;x<=i;x++){const S=(i+1)*g+x-1,b=(i+1)*(g-1)+x-1,_=(i+1)*(g-1)+x,T=(i+1)*g+x;a.push(S,b,T),a.push(b,_,T)}this.setIndex(a),this.setAttribute("position",new Vt(o,3)),this.setAttribute("normal",new Vt(l,3)),this.setAttribute("uv",new Vt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jC(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class KC extends Tn{constructor(e=1,t=.4,n=64,i=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:r,q:a},n=Math.floor(n),i=Math.floor(i);const o=[],l=[],u=[],c=[],f=new ae,d=new ae,g=new ae,x=new ae,S=new ae,b=new ae,_=new ae;for(let E=0;E<=n;++E){const C=E/n*r*Math.PI*2;T(C,r,a,e,g),T(C+.01,r,a,e,x),b.subVectors(x,g),_.addVectors(x,g),S.crossVectors(b,_),_.crossVectors(S,b),S.normalize(),_.normalize();for(let R=0;R<=i;++R){const I=R/i*Math.PI*2,L=-t*Math.cos(I),P=t*Math.sin(I);f.x=g.x+(L*_.x+P*S.x),f.y=g.y+(L*_.y+P*S.y),f.z=g.z+(L*_.z+P*S.z),l.push(f.x,f.y,f.z),d.subVectors(f,g).normalize(),u.push(d.x,d.y,d.z),c.push(E/n),c.push(R/i)}}for(let E=1;E<=n;E++)for(let C=1;C<=i;C++){const R=(i+1)*(E-1)+(C-1),I=(i+1)*E+(C-1),L=(i+1)*E+C,P=(i+1)*(E-1)+C;o.push(R,I,P),o.push(I,L,P)}this.setIndex(o),this.setAttribute("position",new Vt(l,3)),this.setAttribute("normal",new Vt(u,3)),this.setAttribute("uv",new Vt(c,2));function T(E,C,R,I,L){const P=Math.cos(E),D=Math.sin(E),O=R/C*E,F=Math.cos(O);L.x=I*(2+F)*.5*P,L.y=I*(2+F)*D*.5,L.z=I*Math.sin(O)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new KC(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class YC extends Tn{constructor(e=new Y3(new ae(-1,-1,0),new ae(-1,1,0),new ae(1,1,0)),t=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:r};const a=e.computeFrenetFrames(t,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const o=new ae,l=new ae,u=new tt;let c=new ae;const f=[],d=[],g=[],x=[];S(),this.setIndex(x),this.setAttribute("position",new Vt(f,3)),this.setAttribute("normal",new Vt(d,3)),this.setAttribute("uv",new Vt(g,2));function S(){for(let E=0;E<t;E++)b(E);b(r===!1?t:0),T(),_()}function b(E){c=e.getPointAt(E/t,c);const C=a.normals[E],R=a.binormals[E];for(let I=0;I<=i;I++){const L=I/i*Math.PI*2,P=Math.sin(L),D=-Math.cos(L);l.x=D*C.x+P*R.x,l.y=D*C.y+P*R.y,l.z=D*C.z+P*R.z,l.normalize(),d.push(l.x,l.y,l.z),o.x=c.x+n*l.x,o.y=c.y+n*l.y,o.z=c.z+n*l.z,f.push(o.x,o.y,o.z)}}function _(){for(let E=1;E<=t;E++)for(let C=1;C<=i;C++){const R=(i+1)*(E-1)+(C-1),I=(i+1)*E+(C-1),L=(i+1)*E+C,P=(i+1)*(E-1)+C;x.push(R,I,P),x.push(I,L,P)}}function T(){for(let E=0;E<=t;E++)for(let C=0;C<=i;C++)u.x=E/t,u.y=C/i,g.push(u.x,u.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new YC(new E2[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class J9 extends Tn{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new ae,r=new ae;if(e.index!==null){const a=e.attributes.position,o=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let u=0,c=l.length;u<c;++u){const f=l[u],d=f.start,g=f.count;for(let x=d,S=d+g;x<S;x+=3)for(let b=0;b<3;b++){const _=o.getX(x+b),T=o.getX(x+(b+1)%3);i.fromBufferAttribute(a,_),r.fromBufferAttribute(a,T),R4(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const a=e.attributes.position;for(let o=0,l=a.count/3;o<l;o++)for(let u=0;u<3;u++){const c=3*o+u,f=3*o+(u+1)%3;i.fromBufferAttribute(a,c),r.fromBufferAttribute(a,f),R4(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new Vt(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function R4(s,e,t){const n=`${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}var I4=Object.freeze({__proto__:null,BoxGeometry:qg,CapsuleGeometry:UC,CircleGeometry:$C,ConeGeometry:zC,CylinderGeometry:Lx,DodecahedronGeometry:GC,EdgesGeometry:X9,ExtrudeGeometry:HC,IcosahedronGeometry:VC,LatheGeometry:r_,OctahedronGeometry:a_,PlaneGeometry:Fx,PolyhedronGeometry:yp,RingGeometry:WC,ShapeGeometry:XC,SphereGeometry:o_,TetrahedronGeometry:qC,TorusGeometry:jC,TorusKnotGeometry:KC,TubeGeometry:YC,WireframeGeometry:J9});class Z9 extends br{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Nt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Q9 extends sc{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class l_ extends br{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Nt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xl,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class fu extends l_{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new tt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return vn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Nt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Nt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Nt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class e6 extends br{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Nt(16777215),this.specular=new Nt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xl,this.combine=Zb,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class t6 extends br{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Nt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class n6 extends br{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class s6 extends br{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new xl,this.combine=Zb,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Z3 extends br{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=y9,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Q3 extends br{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class i6 extends br{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Nt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gp,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class r6 extends Ra{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function rg(s,e){return!s||s.constructor===e?s:typeof e.BYTES_PER_ELEMENT=="number"?new e(s):Array.prototype.slice.call(s)}function a6(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function o6(s){function e(i,r){return s[i]-s[r]}const t=s.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function zI(s,e,t){const n=s.length,i=new s.constructor(n);for(let r=0,a=0;a!==n;++r){const o=t[r]*e;for(let l=0;l!==e;++l)i[a++]=s[o+l]}return i}function eO(s,e,t,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let a=r[n];if(a!==void 0)if(Array.isArray(a))do a=r[n],a!==void 0&&(e.push(r.time),t.push(...a)),r=s[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[n],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=s[i++];while(r!==void 0);else do a=r[n],a!==void 0&&(e.push(r.time),t.push(a)),r=s[i++];while(r!==void 0)}function tZ(s,e,t,n,i=30){const r=s.clone();r.name=e;const a=[];for(let l=0;l<r.tracks.length;++l){const u=r.tracks[l],c=u.getValueSize(),f=[],d=[];for(let g=0;g<u.times.length;++g){const x=u.times[g]*i;if(!(x<t||x>=n)){f.push(u.times[g]);for(let S=0;S<c;++S)d.push(u.values[g*c+S])}}f.length!==0&&(u.times=rg(f,u.times.constructor),u.values=rg(d,u.values.constructor),a.push(u))}r.tracks=a;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r}function nZ(s,e=0,t=s,n=30){n<=0&&(n=30);const i=t.tracks.length,r=e/n;for(let a=0;a<i;++a){const o=t.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const u=s.tracks.find(function(_){return _.name===o.name&&_.ValueTypeName===l});if(u===void 0)continue;let c=0;const f=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=f/3);let d=0;const g=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=g/3);const x=o.times.length-1;let S;if(r<=o.times[0]){const _=c,T=f-c;S=o.values.slice(_,T)}else if(r>=o.times[x]){const _=x*f+c,T=_+f-c;S=o.values.slice(_,T)}else{const _=o.createInterpolant(),T=c,E=f-c;_.evaluate(r),S=_.resultBuffer.slice(T,E)}l==="quaternion"&&new kr().fromArray(S).normalize().conjugate().toArray(S);const b=u.times.length;for(let _=0;_<b;++_){const T=_*g+d;if(l==="quaternion")kr.multiplyQuaternionsFlat(u.values,T,S,0,u.values,T);else{const E=g-d*2;for(let C=0;C<E;++C)u.values[T+C]-=S[C]}}}return s.blendMode=O3,s}class sZ{static convertArray(e,t){return rg(e,t)}static isTypedArray(e){return a6(e)}static getKeyframeOrder(e){return o6(e)}static sortedArray(e,t,n){return zI(e,t,n)}static flattenJSON(e,t,n,i){eO(e,t,n,i)}static subclip(e,t,n,i,r=30){return tZ(e,t,n,i,r)}static makeClipAdditive(e,t=0,n=e,i=30){return nZ(e,t,n,i)}}class Px{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let a;n:{s:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<r)break s;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===o)break;if(r=i,i=t[++n],e<i)break t}a=t.length;break n}if(!(e>=r)){const o=t[1];e<o&&(n=2,r=o);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===l)break;if(i=r,r=t[--n-1],e>=r)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=n[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class l6 extends Px{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:sg,endingEnd:sg}}intervalChanged_(e,t,n){const i=this.parameterPositions;let r=e-2,a=e+1,o=i[r],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case ig:r=e,o=2*t-n;break;case pb:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=e,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case ig:a=e,l=2*n-t;break;case pb:a=1,l=n+i[1]-i[0];break;default:a=e-1,l=t}const u=(n-t)*.5,c=this.valueSize;this._weightPrev=u/(t-o),this._weightNext=u/(l-n),this._offsetPrev=r*c,this._offsetNext=a*c}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,u=l-o,c=this._offsetPrev,f=this._offsetNext,d=this._weightPrev,g=this._weightNext,x=(n-t)/(i-t),S=x*x,b=S*x,_=-d*b+2*d*S-d*x,T=(1+d)*b+(-1.5-2*d)*S+(-.5+d)*x+1,E=(-1-g)*b+(1.5+g)*S+.5*x,C=g*b-g*S;for(let R=0;R!==o;++R)r[R]=_*a[c+R]+T*a[u+R]+E*a[l+R]+C*a[f+R];return r}}class tO extends Px{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,u=l-o,c=(n-t)/(i-t),f=1-c;for(let d=0;d!==o;++d)r[d]=a[u+d]*f+a[l+d]*c;return r}}class u6 extends Px{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class du{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=rg(t,this.TimeBufferType),this.values=rg(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:rg(e.times,Array),values:rg(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new u6(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new tO(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new l6(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case ax:t=this.InterpolantFactoryMethodDiscrete;break;case ox:t=this.InterpolantFactoryMethodLinear;break;case Sw:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ax;case this.InterpolantFactoryMethodLinear:return ox;case this.InterpolantFactoryMethodSmooth:return Sw}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let r=0,a=i-1;for(;r!==i&&n[r]<e;)++r;for(;a!==-1&&n[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=n.slice(r,a),this.values=this.values.slice(r*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==r;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),e=!1;break}a=l}if(i!==void 0&&a6(i))for(let o=0,l=i.length;o!==l;++o){const u=i[o];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,u),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===Sw,r=e.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const u=e[o],c=e[o+1];if(u!==c&&(o!==1||u!==e[0]))if(i)l=!0;else{const f=o*n,d=f-n,g=f+n;for(let x=0;x!==n;++x){const S=t[f+x];if(S!==t[d+x]||S!==t[g+x]){l=!0;break}}}if(l){if(o!==a){e[a]=e[o];const f=o*n,d=a*n;for(let g=0;g!==n;++g)t[d+g]=t[f+g]}++a}}if(r>0){e[a]=e[r];for(let o=r*n,l=a*n,u=0;u!==n;++u)t[l+u]=t[o+u];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=t.slice(0,a*n)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}du.prototype.ValueTypeName="";du.prototype.TimeBufferType=Float32Array;du.prototype.ValueBufferType=Float32Array;du.prototype.DefaultInterpolation=ox;class jg extends du{constructor(e,t,n){super(e,t,n)}}jg.prototype.ValueTypeName="bool";jg.prototype.ValueBufferType=Array;jg.prototype.DefaultInterpolation=ax;jg.prototype.InterpolantFactoryMethodLinear=void 0;jg.prototype.InterpolantFactoryMethodSmooth=void 0;class nO extends du{constructor(e,t,n,i){super(e,t,n,i)}}nO.prototype.ValueTypeName="color";class wg extends du{constructor(e,t,n,i){super(e,t,n,i)}}wg.prototype.ValueTypeName="number";class c6 extends Px{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(n-t)/(i-t);let u=e*o;for(let c=u+o;u!==c;u+=4)kr.slerpFlat(r,0,a,u-o,a,u,l);return r}}class Cg extends du{constructor(e,t,n,i){super(e,t,n,i)}InterpolantFactoryMethodLinear(e){return new c6(this.times,this.values,this.getValueSize(),e)}}Cg.prototype.ValueTypeName="quaternion";Cg.prototype.InterpolantFactoryMethodSmooth=void 0;class Kg extends du{constructor(e,t,n){super(e,t,n)}}Kg.prototype.ValueTypeName="string";Kg.prototype.ValueBufferType=Array;Kg.prototype.DefaultInterpolation=ax;Kg.prototype.InterpolantFactoryMethodLinear=void 0;Kg.prototype.InterpolantFactoryMethodSmooth=void 0;class Eg extends du{constructor(e,t,n,i){super(e,t,n,i)}}Eg.prototype.ValueTypeName="vector";class fx{constructor(e="",t=-1,n=[],i=NC){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=gl(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(rZ(n[a]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=n.length;r!==a;++r)t.push(du.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const r=t.length,a=[];for(let o=0;o<r;o++){let l=[],u=[];l.push((o+r-1)%r,o,(o+1)%r),u.push(0,1,0);const c=o6(l);l=zI(l,1,c),u=zI(u,1,c),!i&&l[0]===0&&(l.push(r),u.push(u[0])),a.push(new wg(".morphTargetInfluences["+t[o].name+"]",l,u).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const u=e[o],c=u.name.match(r);if(c&&c.length>1){const f=c[1];let d=i[f];d||(i[f]=d=[]),d.push(u)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,n));return a}static parseAnimation(e,t){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(f,d,g,x,S){if(g.length!==0){const b=[],_=[];eO(g,b,_,x),b.length!==0&&S.push(new f(d,b,_))}},i=[],r=e.name||"default",a=e.fps||30,o=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let f=0;f<u.length;f++){const d=u[f].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const g={};let x;for(x=0;x<d.length;x++)if(d[x].morphTargets)for(let S=0;S<d[x].morphTargets.length;S++)g[d[x].morphTargets[S]]=-1;for(const S in g){const b=[],_=[];for(let T=0;T!==d[x].morphTargets.length;++T){const E=d[x];b.push(E.time),_.push(E.morphTarget===S?1:0)}i.push(new wg(".morphTargetInfluence["+S+"]",b,_))}l=g.length*a}else{const g=".bones["+t[f].name+"]";n(Eg,g+".position",d,"pos",i),n(Cg,g+".quaternion",d,"rot",i),n(Eg,g+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function iZ(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return wg;case"vector":case"vector2":case"vector3":case"vector4":return Eg;case"color":return nO;case"quaternion":return Cg;case"bool":case"boolean":return jg;case"string":return Kg}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function rZ(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=iZ(s.type);if(s.times===void 0){const t=[],n=[];eO(s.keys,t,n,"value"),s.times=t,s.values=n}return e.parse!==void 0?e.parse(s):new e(s.name,s.times,s.values,s.interpolation)}const lf={enabled:!1,files:{},add:function(s,e){this.enabled!==!1&&(this.files[s]=e)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class sO{constructor(e,t,n){const i=this;let r=!1,a=0,o=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){o++,r===!1&&i.onStart!==void 0&&i.onStart(c,a,o),r=!0},this.itemEnd=function(c){a++,i.onProgress!==void 0&&i.onProgress(c,a,o),a===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,f){return u.push(c,f),this},this.removeHandler=function(c){const f=u.indexOf(c);return f!==-1&&u.splice(f,2),this},this.getHandler=function(c){for(let f=0,d=u.length;f<d;f+=2){const g=u[f],x=u[f+1];if(g.global&&(g.lastIndex=0),g.test(c))return x}return null}}}const h6=new sO;class Ia{constructor(e){this.manager=e!==void 0?e:h6,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Ia.DEFAULT_MATERIAL_NAME="__DEFAULT";const jh={};class aZ extends Error{constructor(e,t){super(e),this.response=t}}class vl extends Ia{constructor(e){super(e),this.mimeType="",this.responseType=""}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=lf.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(jh[e]!==void 0){jh[e].push({onLoad:t,onProgress:n,onError:i});return}jh[e]=[],jh[e].push({onLoad:t,onProgress:n,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=jh[e],f=u.body.getReader(),d=u.headers.get("X-File-Size")||u.headers.get("Content-Length"),g=d?parseInt(d):0,x=g!==0;let S=0;const b=new ReadableStream({start(_){T();function T(){f.read().then(({done:E,value:C})=>{if(E)_.close();else{S+=C.byteLength;const R=new ProgressEvent("progress",{lengthComputable:x,loaded:S,total:g});for(let I=0,L=c.length;I<L;I++){const P=c[I];P.onProgress&&P.onProgress(R)}_.enqueue(C),T()}},E=>{_.error(E)})}}});return new Response(b)}else throw new aZ(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,o));case"json":return u.json();default:if(o==="")return u.text();{const f=/charset="?([^;"\s]*)"?/i.exec(o),d=f&&f[1]?f[1].toLowerCase():void 0,g=new TextDecoder(d);return u.arrayBuffer().then(x=>g.decode(x))}}}).then(u=>{lf.add(e,u);const c=jh[e];delete jh[e];for(let f=0,d=c.length;f<d;f++){const g=c[f];g.onLoad&&g.onLoad(u)}}).catch(u=>{const c=jh[e];if(c===void 0)throw this.manager.itemError(e),u;delete jh[e];for(let f=0,d=c.length;f<d;f++){const g=c[f];g.onError&&g.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class oZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new vl(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=fx.parse(e[n]);t.push(i)}return t}}class lZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=[],o=new FC,l=new vl(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let u=0;function c(f){l.load(e[f],function(d){const g=r.parse(d,!0);a[f]={width:g.width,height:g.height,format:g.format,mipmaps:g.mipmaps},u+=1,u===6&&(g.mipmapCount===1&&(o.minFilter=$i),o.image=a,o.format=g.format,o.needsUpdate=!0,t&&t(o))},n,i)}if(Array.isArray(e))for(let f=0,d=e.length;f<d;++f)c(f);else l.load(e,function(f){const d=r.parse(f,!0);if(d.isCubemap){const g=d.mipmaps.length/d.mipmapCount;for(let x=0;x<g;x++){a[x]={mipmaps:[]};for(let S=0;S<d.mipmapCount;S++)a[x].mipmaps.push(d.mipmaps[x*d.mipmapCount+S]),a[x].format=d.format,a[x].width=d.width,a[x].height=d.height}o.image=a}else o.image.width=d.width,o.image.height=d.height,o.mipmaps=d.mipmaps;d.mipmapCount===1&&(o.minFilter=$i),o.format=d.format,o.needsUpdate=!0,t&&t(o)},n,i);return o}}class Ab extends Ia{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=lf.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const o=xb("img");function l(){c(),lf.add(e,this),t&&t(this),r.manager.itemEnd(e)}function u(f){c(),i&&i(f),r.manager.itemError(e),r.manager.itemEnd(e)}function c(){o.removeEventListener("load",l,!1),o.removeEventListener("error",u,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o}}class uZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=new t_;r.colorSpace=va;const a=new Ab(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(u){a.load(e[u],function(c){r.images[u]=c,o++,o===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let u=0;u<e.length;++u)l(u);return r}}class cZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new nh,o=new vl(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(e,function(l){let u;try{u=r.parse(l)}catch(c){if(i!==void 0)i(c);else{console.error(c);return}}u.image!==void 0?a.image=u.image:u.data!==void 0&&(a.image.width=u.width,a.image.height=u.height,a.image.data=u.data),a.wrapS=u.wrapS!==void 0?u.wrapS:hl,a.wrapT=u.wrapT!==void 0?u.wrapT:hl,a.magFilter=u.magFilter!==void 0?u.magFilter:$i,a.minFilter=u.minFilter!==void 0?u.minFilter:$i,a.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.colorSpace!==void 0&&(a.colorSpace=u.colorSpace),u.flipY!==void 0&&(a.flipY=u.flipY),u.format!==void 0&&(a.format=u.format),u.type!==void 0&&(a.type=u.type),u.mipmaps!==void 0&&(a.mipmaps=u.mipmaps,a.minFilter=tu),u.mipmapCount===1&&(a.minFilter=$i),u.generateMipmaps!==void 0&&(a.generateMipmaps=u.generateMipmaps),a.needsUpdate=!0,t&&t(a,u)},n,i),a}}class f6 extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=new ii,a=new Ab(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){r.image=o,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class xp extends ts{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Nt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class d6 extends xp{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(ts.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Nt(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const xR=new rn,D4=new ae,O4=new ae;class iO{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new tt(512,512),this.map=null,this.mapPass=null,this.matrix=new rn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new i_,this._frameExtents=new tt(1,1),this._viewportCount=1,this._viewports=[new os(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;D4.setFromMatrixPosition(e.matrixWorld),t.position.copy(D4),O4.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(O4),t.updateMatrixWorld(),xR.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xR),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(xR)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class hZ extends iO{constructor(){super(new Ci(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=lx*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class rO extends xp{constructor(e,t,n=0,i=Math.PI/3,r=0,a=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(ts.DEFAULT_UP),this.updateMatrix(),this.target=new ts,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.map=null,this.shadow=new hZ}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const B4=new rn,O1=new ae,vR=new ae;class fZ extends iO{constructor(){super(new Ci(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new tt(4,2),this._viewportCount=6,this._viewports=[new os(2,1,1,1),new os(0,1,1,1),new os(3,1,1,1),new os(1,1,1,1),new os(3,0,1,1),new os(1,0,1,1)],this._cubeDirections=[new ae(1,0,0),new ae(-1,0,0),new ae(0,0,1),new ae(0,0,-1),new ae(0,1,0),new ae(0,-1,0)],this._cubeUps=[new ae(0,1,0),new ae(0,1,0),new ae(0,1,0),new ae(0,1,0),new ae(0,0,1),new ae(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),O1.setFromMatrixPosition(e.matrixWorld),n.position.copy(O1),vR.copy(n.position),vR.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(vR),n.updateMatrixWorld(),i.makeTranslation(-O1.x,-O1.y,-O1.z),B4.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(B4)}}class aO extends xp{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new fZ}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class ff extends DC{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,a=n+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=u*this.view.offsetX,a=r+u*this.view.width,o-=c*this.view.offsetY,l=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class dZ extends iO{constructor(){super(new ff(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class oO extends xp{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(ts.DEFAULT_UP),this.updateMatrix(),this.target=new ts,this.shadow=new dZ}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class p6 extends xp{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class m6 extends xp{constructor(e,t,n=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class g6{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new ae)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*i),t.addScaledVector(a[2],.488603*r),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*i)),t.addScaledVector(a[5],1.092548*(i*r)),t.addScaledVector(a[6],.315392*(3*r*r-1)),t.addScaledVector(a[7],1.092548*(n*r)),t.addScaledVector(a[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,r=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*i),t.addScaledVector(a[2],2*.511664*r),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*i),t.addScaledVector(a[5],2*.429043*i*r),t.addScaledVector(a[6],.743125*r*r-.247708),t.addScaledVector(a[7],2*.429043*n*r),t.addScaledVector(a[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*n*r,t[8]=.546274*(n*n-i*i)}}class y6 extends xp{constructor(e=new g6,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class JC extends Ia{constructor(e){super(e),this.textures={}}load(e,t,n,i){const r=this,a=new vl(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new Nt().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(i.dispersion=e.dispersion),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const a=e.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=n(a.value);break;case"c":i.uniforms[r].value=new Nt().setHex(a.value);break;case"v2":i.uniforms[r].value=new tt().fromArray(a.value);break;case"v3":i.uniforms[r].value=new ae().fromArray(a.value);break;case"v4":i.uniforms[r].value=new os().fromArray(a.value);break;case"m3":i.uniforms[r].value=new An().fromArray(a.value);break;case"m4":i.uniforms[r].value=new rn().fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new tt().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapRotation!==void 0&&i.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new tt().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=n(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=n(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return JC.createMaterialFromType(e)}static createMaterialFromType(e){const t={ShadowMaterial:Z9,SpriteMaterial:$3,RawShaderMaterial:Q9,ShaderMaterial:sc,PointsMaterial:LC,MeshPhysicalMaterial:fu,MeshStandardMaterial:l_,MeshPhongMaterial:e6,MeshToonMaterial:t6,MeshNormalMaterial:n6,MeshLambertMaterial:s6,MeshDepthMaterial:Z3,MeshDistanceMaterial:Q3,MeshBasicMaterial:fl,MeshMatcapMaterial:i6,LineDashedMaterial:r6,LineBasicMaterial:Ra,Material:br};return new t[e]}}class Xd{static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class x6 extends Tn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class v6 extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new vl(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(g,x){if(t[x]!==void 0)return t[x];const b=g.interleavedBuffers[x],_=r(g,b.buffer),T=Py(b.type,_),E=new n_(T,b.stride);return E.uuid=b.uuid,t[x]=E,E}function r(g,x){if(n[x]!==void 0)return n[x];const b=g.arrayBuffers[x],_=new Uint32Array(b).buffer;return n[x]=_,_}const a=e.isInstancedBufferGeometry?new x6:new Tn,o=e.data.index;if(o!==void 0){const g=Py(o.type,o.array);a.setIndex(new us(g,1))}const l=e.data.attributes;for(const g in l){const x=l[g];let S;if(x.isInterleavedBufferAttribute){const b=i(e.data,x.data);S=new sp(b,x.itemSize,x.offset,x.normalized)}else{const b=Py(x.type,x.array),_=x.isInstancedBufferAttribute?Ag:us;S=new _(b,x.itemSize,x.normalized)}x.name!==void 0&&(S.name=x.name),x.usage!==void 0&&S.setUsage(x.usage),a.setAttribute(g,S)}const u=e.data.morphAttributes;if(u)for(const g in u){const x=u[g],S=[];for(let b=0,_=x.length;b<_;b++){const T=x[b];let E;if(T.isInterleavedBufferAttribute){const C=i(e.data,T.data);E=new sp(C,T.itemSize,T.offset,T.normalized)}else{const C=Py(T.type,T.array);E=new us(C,T.itemSize,T.normalized)}T.name!==void 0&&(E.name=T.name),S.push(E)}a.morphAttributes[g]=S}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const f=e.data.groups||e.data.drawcalls||e.data.offsets;if(f!==void 0)for(let g=0,x=f.length;g!==x;++g){const S=f[g];a.addGroup(S.start,S.count,S.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const g=new ae;d.center!==void 0&&g.fromArray(d.center),a.boundingSphere=new ea(g,d.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}}class pZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=this.path===""?Xd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const o=new vl(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){let u=null;try{u=JSON.parse(l)}catch(f){i!==void 0&&i(f),console.error("THREE:ObjectLoader: Can't parse "+e+".",f.message);return}const c=u.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(u,t)},n,i)}async loadAsync(e,t){const n=this,i=this.path===""?Xd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new vl(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const a=await r.loadAsync(e,t),o=JSON.parse(a),l=o.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(o)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),a=this.parseImages(e.images,function(){t!==void 0&&t(u)}),o=this.parseTextures(e.textures,a),l=this.parseMaterials(e.materials,o),u=this.parseObject(e.object,r,l,o,n),c=this.parseSkeletons(e.skeletons,u);if(this.bindSkeletons(u,c),this.bindLightTargets(u),t!==void 0){let f=!1;for(const d in a)if(a[d].data instanceof HTMLImageElement){f=!0;break}f===!1&&t(u)}return u}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),r=await this.parseImagesAsync(e.images),a=this.parseTextures(e.textures,r),o=this.parseMaterials(e.materials,a),l=this.parseObject(e.object,i,o,a,t),u=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,u),this.bindLightTargets(l),l}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const r=new dg().fromJSON(e[n]);t[r.uuid]=r}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),e!==void 0)for(let r=0,a=e.length;r<a;r++){const o=new s_().fromJSON(e[r],i);n[o.uuid]=o}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new v6;for(let r=0,a=e.length;r<a;r++){let o;const l=e[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(l);break;default:l.type in I4?o=I4[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,l.name!==void 0&&(o.name=l.name),l.userData!==void 0&&(o.userData=l.userData),n[l.uuid]=o}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const r=new JC;r.setTextures(t);for(let a=0,o=e.length;a<o;a++){const l=e[a];n[l.uuid]===void 0&&(n[l.uuid]=r.parse(l)),i[l.uuid]=n[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],r=fx.parse(i);t[r.uuid]=r}return t}parseImages(e,t){const n=this,i={};let r;function a(l){return n.manager.itemStart(l),r.load(l,function(){n.manager.itemEnd(l)},void 0,function(){n.manager.itemError(l),n.manager.itemEnd(l)})}function o(l){if(typeof l=="string"){const u=l,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:n.resourcePath+u;return a(c)}else return l.data?{data:Py(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new sO(t);r=new Ab(l),r.setCrossOrigin(this.crossOrigin);for(let u=0,c=e.length;u<c;u++){const f=e[u],d=f.url;if(Array.isArray(d)){const g=[];for(let x=0,S=d.length;x<S;x++){const b=d[x],_=o(b);_!==null&&(_ instanceof HTMLImageElement?g.push(_):g.push(new nh(_.data,_.width,_.height)))}i[f.uuid]=new Pd(g)}else{const g=o(f.url);i[f.uuid]=new Pd(g)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function r(a){if(typeof a=="string"){const o=a,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:t.resourcePath+o;return await i.loadAsync(l)}else return a.data?{data:Py(a.type,a.data),width:a.width,height:a.height}:null}if(e!==void 0&&e.length>0){i=new Ab(this.manager),i.setCrossOrigin(this.crossOrigin);for(let a=0,o=e.length;a<o;a++){const l=e[a],u=l.url;if(Array.isArray(u)){const c=[];for(let f=0,d=u.length;f<d;f++){const g=u[f],x=await r(g);x!==null&&(x instanceof HTMLImageElement?c.push(x):c.push(new nh(x.data,x.width,x.height)))}n[l.uuid]=new Pd(c)}else{const c=await r(l.url);n[l.uuid]=new Pd(c)}}}return n}parseTextures(e,t){function n(r,a){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),a[r])}const i={};if(e!==void 0)for(let r=0,a=e.length;r<a;r++){const o=e[r];o.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),t[o.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",o.image);const l=t[o.image],u=l.data;let c;Array.isArray(u)?(c=new t_,u.length===6&&(c.needsUpdate=!0)):(u&&u.data?c=new nh:c=new ii,u&&(c.needsUpdate=!0)),c.source=l,c.uuid=o.uuid,o.name!==void 0&&(c.name=o.name),o.mapping!==void 0&&(c.mapping=n(o.mapping,mZ)),o.channel!==void 0&&(c.channel=o.channel),o.offset!==void 0&&c.offset.fromArray(o.offset),o.repeat!==void 0&&c.repeat.fromArray(o.repeat),o.center!==void 0&&c.center.fromArray(o.center),o.rotation!==void 0&&(c.rotation=o.rotation),o.wrap!==void 0&&(c.wrapS=n(o.wrap[0],k4),c.wrapT=n(o.wrap[1],k4)),o.format!==void 0&&(c.format=o.format),o.internalFormat!==void 0&&(c.internalFormat=o.internalFormat),o.type!==void 0&&(c.type=o.type),o.colorSpace!==void 0&&(c.colorSpace=o.colorSpace),o.minFilter!==void 0&&(c.minFilter=n(o.minFilter,L4)),o.magFilter!==void 0&&(c.magFilter=n(o.magFilter,L4)),o.anisotropy!==void 0&&(c.anisotropy=o.anisotropy),o.flipY!==void 0&&(c.flipY=o.flipY),o.generateMipmaps!==void 0&&(c.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(c.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(c.compareFunction=o.compareFunction),o.userData!==void 0&&(c.userData=o.userData),i[o.uuid]=c}return i}parseObject(e,t,n,i,r){let a;function o(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const g=[];for(let x=0,S=d.length;x<S;x++){const b=d[x];n[b]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",b),g.push(n[b])}return g}return n[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),n[d]}}function u(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let c,f;switch(e.type){case"Scene":a=new U3,e.background!==void 0&&(Number.isInteger(e.background)?a.background=new Nt(e.background):a.background=u(e.background)),e.environment!==void 0&&(a.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?a.fog=new BC(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(a.fog=new OC(e.fog.color,e.fog.density)),e.fog.name!==""&&(a.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(a.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(a.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&a.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(a.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&a.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":a=new Ci(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(a.focus=e.focus),e.zoom!==void 0&&(a.zoom=e.zoom),e.filmGauge!==void 0&&(a.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(a.filmOffset=e.filmOffset),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"OrthographicCamera":a=new ff(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(a.zoom=e.zoom),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"AmbientLight":a=new p6(e.color,e.intensity);break;case"DirectionalLight":a=new oO(e.color,e.intensity),a.target=e.target||"";break;case"PointLight":a=new aO(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":a=new m6(e.color,e.intensity,e.width,e.height);break;case"SpotLight":a=new rO(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),a.target=e.target||"";break;case"HemisphereLight":a=new d6(e.color,e.groundColor,e.intensity);break;case"LightProbe":a=new y6().fromJSON(e);break;case"SkinnedMesh":c=o(e.geometry),f=l(e.material),a=new z3(c,f),e.bindMode!==void 0&&(a.bindMode=e.bindMode),e.bindMatrix!==void 0&&a.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(a.skeleton=e.skeleton);break;case"Mesh":c=o(e.geometry),f=l(e.material),a=new zi(c,f);break;case"InstancedMesh":c=o(e.geometry),f=l(e.material);const d=e.count,g=e.instanceMatrix,x=e.instanceColor;a=new G3(c,f,d),a.instanceMatrix=new Ag(new Float32Array(g.array),16),x!==void 0&&(a.instanceColor=new Ag(new Float32Array(x.array),x.itemSize));break;case"BatchedMesh":c=o(e.geometry),f=l(e.material),a=new U9(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,f),a.geometry=c,a.perObjectFrustumCulled=e.perObjectFrustumCulled,a.sortObjects=e.sortObjects,a._drawRanges=e.drawRanges,a._reservedRanges=e.reservedRanges,a._visibility=e.visibility,a._active=e.active,a._bounds=e.bounds.map(S=>{const b=new Ea;b.min.fromArray(S.boxMin),b.max.fromArray(S.boxMax);const _=new ea;return _.radius=S.sphereRadius,_.center.fromArray(S.sphereCenter),{boxInitialized:S.boxInitialized,box:b,sphereInitialized:S.sphereInitialized,sphere:_}}),a._maxInstanceCount=e.maxInstanceCount,a._maxVertexCount=e.maxVertexCount,a._maxIndexCount=e.maxIndexCount,a._geometryInitialized=e.geometryInitialized,a._geometryCount=e.geometryCount,a._matricesTexture=u(e.matricesTexture.uuid),e.colorsTexture!==void 0&&(a._colorsTexture=u(e.colorsTexture.uuid));break;case"LOD":a=new P9;break;case"Line":a=new vf(o(e.geometry),l(e.material));break;case"LineLoop":a=new H3(o(e.geometry),l(e.material));break;case"LineSegments":a=new lc(o(e.geometry),l(e.material));break;case"PointCloud":case"Points":a=new V3(o(e.geometry),l(e.material));break;case"Sprite":a=new F9(l(e.material));break;case"Group":a=new of;break;case"Bone":a=new kC;break;default:a=new ts}if(a.uuid=e.uuid,e.name!==void 0&&(a.name=e.name),e.matrix!==void 0?(a.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(a.matrixAutoUpdate=e.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(e.position!==void 0&&a.position.fromArray(e.position),e.rotation!==void 0&&a.rotation.fromArray(e.rotation),e.quaternion!==void 0&&a.quaternion.fromArray(e.quaternion),e.scale!==void 0&&a.scale.fromArray(e.scale)),e.up!==void 0&&a.up.fromArray(e.up),e.castShadow!==void 0&&(a.castShadow=e.castShadow),e.receiveShadow!==void 0&&(a.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(a.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(a.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(a.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(a.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&a.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(a.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(a.visible=e.visible),e.frustumCulled!==void 0&&(a.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(a.renderOrder=e.renderOrder),e.userData!==void 0&&(a.userData=e.userData),e.layers!==void 0&&(a.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let g=0;g<d.length;g++)a.add(this.parseObject(d[g],t,n,i,r))}if(e.animations!==void 0){const d=e.animations;for(let g=0;g<d.length;g++){const x=d[g];a.animations.push(r[x])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(a.autoUpdate=e.autoUpdate);const d=e.levels;for(let g=0;g<d.length;g++){const x=d[g],S=a.getObjectByProperty("uuid",x.object);S!==void 0&&a.addLevel(S,x.distance,x.hysteresis)}}return a}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}bindLightTargets(e){e.traverse(function(t){if(t.isDirectionalLight||t.isSpotLight){const n=t.target,i=e.getObjectByProperty("uuid",n);i!==void 0?t.target=i:t.target=new ts}})}}const mZ={UVMapping:_C,CubeReflectionMapping:yf,CubeRefractionMapping:ep,EquirectangularReflectionMapping:fb,EquirectangularRefractionMapping:db,CubeUVReflectionMapping:Bx},k4={RepeatWrapping:tp,ClampToEdgeWrapping:hl,MirroredRepeatWrapping:tx},L4={NearestFilter:Br,NearestMipmapNearestFilter:SC,NearestMipmapLinearFilter:ng,LinearFilter:$i,LinearMipmapNearestFilter:Gy,LinearMipmapLinearFilter:tu};class b6 extends Ia{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=lf.get(e);if(a!==void 0){if(r.manager.itemStart(e),a.then){a.then(u=>{t&&t(u),r.manager.itemEnd(e)}).catch(u=>{i&&i(u)});return}return setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader;const l=fetch(e,o).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(u){return lf.add(e,u),t&&t(u),r.manager.itemEnd(e),u}).catch(function(u){i&&i(u),lf.remove(e),r.manager.itemError(e),r.manager.itemEnd(e)});lf.add(e,l),r.manager.itemStart(e)}}let HT;class lO{static getContext(){return HT===void 0&&(HT=new(window.AudioContext||window.webkitAudioContext)),HT}static setContext(e){HT=e}}class gZ extends Ia{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new vl(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{const u=l.slice(0);lO.getContext().decodeAudioData(u,function(f){t(f)}).catch(o)}catch(u){o(u)}},n,i);function o(l){i?i(l):console.error(l),r.manager.itemError(e)}}}const F4=new rn,P4=new rn,Rm=new rn;class yZ{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Ci,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Ci,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Rm.copy(e.projectionMatrix);const i=t.eyeSep/2,r=i*t.near/t.focus,a=t.near*Math.tan(fg*t.fov*.5)/t.zoom;let o,l;P4.elements[12]=-i,F4.elements[12]=i,o=-a*t.aspect+r,l=a*t.aspect+r,Rm.elements[0]=2*t.near/(l-o),Rm.elements[8]=(l+o)/(l-o),this.cameraL.projectionMatrix.copy(Rm),o=-a*t.aspect-r,l=a*t.aspect-r,Rm.elements[0]=2*t.near/(l-o),Rm.elements[8]=(l+o)/(l-o),this.cameraR.projectionMatrix.copy(Rm)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(P4),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(F4)}}class _6 extends Ci{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e,this.index=0}}class uO{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=U4(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=U4();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function U4(){return performance.now()}const Im=new ae,$4=new kr,xZ=new ae,Dm=new ae;class vZ extends ts{constructor(){super(),this.type="AudioListener",this.context=lO.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new uO}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Im,$4,xZ),Dm.set(0,0,-1).applyQuaternion($4),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Im.x,i),t.positionY.linearRampToValueAtTime(Im.y,i),t.positionZ.linearRampToValueAtTime(Im.z,i),t.forwardX.linearRampToValueAtTime(Dm.x,i),t.forwardY.linearRampToValueAtTime(Dm.y,i),t.forwardZ.linearRampToValueAtTime(Dm.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(Im.x,Im.y,Im.z),t.setOrientation(Dm.x,Dm.y,Dm.z,n.x,n.y,n.z)}}class S6 extends ts{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,t){return super.copy(e,t),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const Om=new ae,z4=new kr,bZ=new ae,Bm=new ae;class _Z extends S6{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Om,z4,bZ),Bm.set(0,0,1).applyQuaternion(z4);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Om.x,n),t.positionY.linearRampToValueAtTime(Om.y,n),t.positionZ.linearRampToValueAtTime(Om.z,n),t.orientationX.linearRampToValueAtTime(Bm.x,n),t.orientationY.linearRampToValueAtTime(Bm.y,n),t.orientationZ.linearRampToValueAtTime(Bm.z,n)}else t.setPosition(Om.x,Om.y,Om.z),t.setOrientation(Bm.x,Bm.y,Bm.z)}}class SZ{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class A6{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,r,a;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)n[r+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,r,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-r,t)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,u=t+t;l!==u;++l)if(n[l]!==n[l+t]){o.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,a=i;r!==a;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[t+a]=e[n+a]}_slerp(e,t,n,i){kr.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,r){const a=this._workIndex*r;kr.multiplyQuaternionsFlat(e,a,e,t,e,n),kr.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,n,i,r){const a=1-i;for(let o=0;o!==r;++o){const l=t+o;e[l]=e[l]*a+e[n+o]*i}}_lerpAdditive(e,t,n,i,r){for(let a=0;a!==r;++a){const o=t+a;e[o]=e[o]+e[n+a]*i}}}const cO="\\[\\]\\.:\\/",AZ=new RegExp("["+cO+"]","g"),hO="[^"+cO+"]",TZ="[^"+cO.replace("\\.","")+"]",wZ=/((?:WC+[\/:])*)/.source.replace("WC",hO),CZ=/(WCOD+)?/.source.replace("WCOD",TZ),EZ=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",hO),MZ=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",hO),NZ=new RegExp("^"+wZ+CZ+EZ+MZ+"$"),RZ=["material","materials","bones","map"];class IZ{constructor(e,t,n){const i=n||rs.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class rs{constructor(e,t,n){this.path=t,this.parsedPath=n||rs.parseTrackName(t),this.node=rs.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new rs.Composite(e,t,n):new rs(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(AZ,"")}static parseTrackName(e){const t=NZ.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);RZ.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===t||o.uuid===t)return o;const l=n(o.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=rs.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(n){let u=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const a=e[i];if(a===void 0){const u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?o=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}rs.Composite=IZ;rs.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};rs.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};rs.prototype.GetterByBindingType=[rs.prototype._getValue_direct,rs.prototype._getValue_array,rs.prototype._getValue_arrayElement,rs.prototype._getValue_toArray];rs.prototype.SetterByBindingTypeAndVersioning=[[rs.prototype._setValue_direct,rs.prototype._setValue_direct_setNeedsUpdate,rs.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[rs.prototype._setValue_array,rs.prototype._setValue_array_setNeedsUpdate,rs.prototype._setValue_array_setMatrixWorldNeedsUpdate],[rs.prototype._setValue_arrayElement,rs.prototype._setValue_arrayElement_setNeedsUpdate,rs.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[rs.prototype._setValue_fromArray,rs.prototype._setValue_fromArray_setNeedsUpdate,rs.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class DZ{constructor(){this.isAnimationObjectGroup=!0,this.uuid=gl(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length;let o,l=e.length,u=this.nCachedObjects_;for(let c=0,f=arguments.length;c!==f;++c){const d=arguments[c],g=d.uuid;let x=t[g];if(x===void 0){x=l++,t[g]=x,e.push(d);for(let S=0,b=a;S!==b;++S)r[S].push(new rs(d,n[S],i[S]))}else if(x<u){o=e[x];const S=--u,b=e[S];t[b.uuid]=x,e[x]=b,t[g]=S,e[S]=d;for(let _=0,T=a;_!==T;++_){const E=r[_],C=E[S];let R=E[x];E[x]=C,R===void 0&&(R=new rs(d,n[_],i[_])),E[S]=R}}else e[x]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let a=0,o=arguments.length;a!==o;++a){const l=arguments[a],u=l.uuid,c=t[u];if(c!==void 0&&c>=r){const f=r++,d=e[f];t[d.uuid]=c,e[c]=d,t[u]=f,e[f]=l;for(let g=0,x=i;g!==x;++g){const S=n[g],b=S[f],_=S[c];S[c]=b,S[f]=_}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,a=e.length;for(let o=0,l=arguments.length;o!==l;++o){const u=arguments[o],c=u.uuid,f=t[c];if(f!==void 0)if(delete t[c],f<r){const d=--r,g=e[d],x=--a,S=e[x];t[g.uuid]=f,e[f]=g,t[S.uuid]=d,e[d]=S,e.pop();for(let b=0,_=i;b!==_;++b){const T=n[b],E=T[d],C=T[x];T[f]=E,T[d]=C,T.pop()}}else{const d=--a,g=e[d];d>0&&(t[g.uuid]=f),e[f]=g,e.pop();for(let x=0,S=i;x!==S;++x){const b=n[x];b[f]=b[d],b.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const r=this._bindings;if(i!==void 0)return r[i];const a=this._paths,o=this._parsedPaths,l=this._objects,u=l.length,c=this.nCachedObjects_,f=new Array(u);i=r.length,n[e]=i,a.push(e),o.push(t),r.push(f);for(let d=c,g=l.length;d!==g;++d){const x=l[d];f[d]=new rs(x,e,t)}return f}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,r=this._parsedPaths,a=this._bindings,o=a.length-1,l=a[o],u=e[o];t[u]=n,a[n]=l,a.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}}class T6{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const r=t.tracks,a=r.length,o=new Array(a),l={endingStart:sg,endingEnd:sg};for(let u=0;u!==a;++u){const c=r[u].createInterpolant(null);o[u]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=p9,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n=!1){if(e.fadeOut(t),this.fadeIn(t),n===!0){const i=this._clip.duration,r=e._clip.duration,a=r/i,o=i/r;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n=!1){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,r=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,u=o.sampleValues;return l[0]=r,l[1]=r+n,u[0]=e/a,u[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*n;l<0||n===0?t=0:(this._startTime=null,t=n*l)}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case O3:for(let c=0,f=l.length;c!==f;++c)l[c].evaluate(a),u[c].accumulateAdditive(o);break;case NC:default:for(let c=0,f=l.length;c!==f;++c)l[c].evaluate(a),u[c].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,r=this._loopCount;const a=n===m9;if(e===0)return r===-1?i:a&&(r&1)===1?t-i:i;if(n===d9){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const u=e<0;this._setEndings(u,!u,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(r&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=ig,i.endingEnd=ig):(e?i.endingStart=this.zeroSlopeAtStart?ig:sg:i.endingStart=pb,t?i.endingEnd=this.zeroSlopeAtEnd?ig:sg:i.endingEnd=pb)}_scheduleFading(e,t,n){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=t,o[1]=r+e,l[1]=n,this}}const OZ=new Float32Array(1);class BZ extends yh{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,o=e._interpolants,l=n.uuid,u=this._bindingsByRootAndName;let c=u[l];c===void 0&&(c={},u[l]=c);for(let f=0;f!==r;++f){const d=i[f],g=d.name;let x=c[g];if(x!==void 0)++x.referenceCount,a[f]=x;else{if(x=a[f],x!==void 0){x._cacheIndex===null&&(++x.referenceCount,this._addInactiveBinding(x,l,g));continue}const S=t&&t._propertyBindings[f].binding.parsedPath;x=new A6(rs.create(n,g,S),d.ValueTypeName,d.getValueSize()),++x.referenceCount,this._addInactiveBinding(x,l,g),a[f]=x}o[f].resultBuffer=x.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,r=this._actionsByClip;let a=r[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,a=this._actionsByClip,o=a[r],l=o.knownActions,u=l[l.length-1],c=e._byClipCacheIndex;u._byClipCacheIndex=c,l[c]=u,l.pop(),e._byClipCacheIndex=null;const f=o.actionByRoot,d=(e._localRoot||this._root).uuid;delete f[d],l.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[n]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,a=this._bindingsByRootAndName,o=a[i],l=t[t.length-1],u=e._cacheIndex;l._cacheIndex=u,t[u]=l,t.pop(),delete o[r],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new tO(new Float32Array(2),new Float32Array(2),1,OZ),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r}clipAction(e,t,n){const i=t||this._root,r=i.uuid;let a=typeof e=="string"?fx.findByName(i,e):e;const o=a!==null?a.uuid:e,l=this._actionsByClip[o];let u=null;if(n===void 0&&(a!==null?n=a.blendMode:n=NC),l!==void 0){const f=l.actionByRoot[r];if(f!==void 0&&f.blendMode===n)return f;u=l.knownActions[0],a===null&&(a=u._clip)}if(a===null)return null;const c=new T6(this,a,t,n);return this._bindAction(c,u),this._addInactiveAction(c,o,r),c}existingAction(e,t){const n=t||this._root,i=n.uuid,r=typeof e=="string"?fx.findByName(n,e):e,a=r?r.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let u=0;u!==n;++u)t[u]._update(i,e,r,a);const o=this._bindings,l=this._nActiveBindings;for(let u=0;u!==l;++u)o[u].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const a=r.knownActions;for(let o=0,l=a.length;o!==l;++o){const u=a[o];this._deactivateAction(u);const c=u._cacheIndex,f=t[t.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,f._cacheIndex=c,t[c]=f,t.pop(),this._removeInactiveBindingsForAction(u)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const a in r){const o=r[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class kZ extends RC{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isRenderTarget3D=!0,this.depth=n,this.texture=new IC(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class LZ extends RC{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isRenderTargetArray=!0,this.depth=n,this.texture=new e_(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class fO{constructor(e){this.value=e}clone(){return new fO(this.value.clone===void 0?this.value:this.value.clone())}}let FZ=0;class PZ extends yh{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:FZ++}),this.name="",this.usage=gb,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let n=0,i=t.length;n<i;n++){const r=Array.isArray(t[n])?t[n]:[t[n]];for(let a=0;a<r.length;a++)this.uniforms.push(r[a].clone())}return this}clone(){return new this.constructor().copy(this)}}class UZ extends n_{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class $Z{constructor(e,t,n,i,r){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const G4=new rn;class w6{constructor(e,t,n=0,i=1/0){this.ray=new Xg(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new ux,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return G4.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(G4),this}intersectObject(e,t=!0,n=[]){return GI(e,this,n,t),n.sort(H4),n}intersectObjects(e,t=!0,n=[]){for(let i=0,r=e.length;i<r;i++)GI(e[i],this,n,t);return n.sort(H4),n}}function H4(s,e){return s.distance-e.distance}function GI(s,e,t,n){let i=!0;if(s.layers.test(e.layers)&&s.raycast(e,t)===!1&&(i=!1),i===!0&&n===!0){const r=s.children;for(let a=0,o=r.length;a<o;a++)GI(r[a],e,t,!0)}}class HI{constructor(e=1,t=0,n=0){this.radius=e,this.phi=t,this.theta=n}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=vn(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(vn(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class zZ{constructor(e=1,t=0,n=0){this.radius=e,this.theta=t,this.y=n}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}class dO{constructor(e,t,n,i){dO.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,n,i)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let n=0;n<4;n++)this.elements[n]=e[n+t];return this}set(e,t,n,i){const r=this.elements;return r[0]=e,r[2]=t,r[1]=n,r[3]=i,this}}const V4=new tt;class GZ{constructor(e=new tt(1/0,1/0),t=new tt(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=V4.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,V4).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const W4=new ae,VT=new ae;class HZ{constructor(e=new ae,t=new ae){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){W4.subVectors(e,this.start),VT.subVectors(this.end,this.start);const n=VT.dot(VT);let r=VT.dot(W4)/n;return t&&(r=vn(r,0,1)),r}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const X4=new ae;class VZ extends ts{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const n=new Tn,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,o=1,l=32;a<l;a++,o++){const u=a/l*Math.PI*2,c=o/l*Math.PI*2;i.push(Math.cos(u),Math.sin(u),1,Math.cos(c),Math.sin(c),1)}n.setAttribute("position",new Vt(i,3));const r=new Ra({fog:!1,toneMapped:!1});this.cone=new lc(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),X4.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(X4),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Dd=new ae,WT=new rn,bR=new rn;class WZ extends lc{constructor(e){const t=C6(e),n=new Tn,i=[],r=[],a=new Nt(0,0,1),o=new Nt(0,1,0);for(let u=0;u<t.length;u++){const c=t[u];c.parent&&c.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new Vt(i,3)),n.setAttribute("color",new Vt(r,3));const l=new Ra({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");bR.copy(this.root.matrixWorld).invert();for(let r=0,a=0;r<t.length;r++){const o=t[r];o.parent&&o.parent.isBone&&(WT.multiplyMatrices(bR,o.matrixWorld),Dd.setFromMatrixPosition(WT),i.setXYZ(a,Dd.x,Dd.y,Dd.z),WT.multiplyMatrices(bR,o.parent.matrixWorld),Dd.setFromMatrixPosition(WT),i.setXYZ(a+1,Dd.x,Dd.y,Dd.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function C6(s){const e=[];s.isBone===!0&&e.push(s);for(let t=0;t<s.children.length;t++)e.push(...C6(s.children[t]));return e}class XZ extends zi{constructor(e,t,n){const i=new o_(t,4,2),r=new fl({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=e,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const qZ=new ae,q4=new Nt,j4=new Nt;class jZ extends ts{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new a_(t);i.rotateY(Math.PI*.5),this.material=new fl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),a=new Float32Array(r.count*3);i.setAttribute("color",new us(a,3)),this.add(new zi(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");q4.copy(this.light.color),j4.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const r=n<i/2?q4:j4;t.setXYZ(n,r.r,r.g,r.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(qZ.setFromMatrixPosition(this.light.matrixWorld).negate())}}class KZ extends lc{constructor(e=10,t=10,n=4473924,i=8947848){n=new Nt(n),i=new Nt(i);const r=t/2,a=e/t,o=e/2,l=[],u=[];for(let d=0,g=0,x=-o;d<=t;d++,x+=a){l.push(-o,0,x,o,0,x),l.push(x,0,-o,x,0,o);const S=d===r?n:i;S.toArray(u,g),g+=3,S.toArray(u,g),g+=3,S.toArray(u,g),g+=3,S.toArray(u,g),g+=3}const c=new Tn;c.setAttribute("position",new Vt(l,3)),c.setAttribute("color",new Vt(u,3));const f=new Ra({vertexColors:!0,toneMapped:!1});super(c,f),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class YZ extends lc{constructor(e=10,t=16,n=8,i=64,r=4473924,a=8947848){r=new Nt(r),a=new Nt(a);const o=[],l=[];if(t>1)for(let f=0;f<t;f++){const d=f/t*(Math.PI*2),g=Math.sin(d)*e,x=Math.cos(d)*e;o.push(0,0,0),o.push(g,0,x);const S=f&1?r:a;l.push(S.r,S.g,S.b),l.push(S.r,S.g,S.b)}for(let f=0;f<n;f++){const d=f&1?r:a,g=e-e/n*f;for(let x=0;x<i;x++){let S=x/i*(Math.PI*2),b=Math.sin(S)*g,_=Math.cos(S)*g;o.push(b,0,_),l.push(d.r,d.g,d.b),S=(x+1)/i*(Math.PI*2),b=Math.sin(S)*g,_=Math.cos(S)*g,o.push(b,0,_),l.push(d.r,d.g,d.b)}}const u=new Tn;u.setAttribute("position",new Vt(o,3)),u.setAttribute("color",new Vt(l,3));const c=new Ra({vertexColors:!0,toneMapped:!1});super(u,c),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const K4=new ae,XT=new ae,Y4=new ae;class JZ extends ts{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Tn;i.setAttribute("position",new Vt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new Ra({fog:!1,toneMapped:!1});this.lightPlane=new vf(i,r),this.add(this.lightPlane),i=new Tn,i.setAttribute("position",new Vt([0,0,0,0,0,1],3)),this.targetLine=new vf(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),K4.setFromMatrixPosition(this.light.matrixWorld),XT.setFromMatrixPosition(this.light.target.matrixWorld),Y4.subVectors(XT,K4),this.lightPlane.lookAt(XT),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(XT),this.targetLine.scale.z=Y4.length()}}const qT=new ae,wi=new DC;class ZZ extends lc{constructor(e){const t=new Tn,n=new Ra({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],a={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(x,S){l(x),l(S)}function l(x){i.push(0,0,0),r.push(0,0,0),a[x]===void 0&&(a[x]=[]),a[x].push(i.length/3-1)}t.setAttribute("position",new Vt(i,3)),t.setAttribute("color",new Vt(r,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const u=new Nt(16755200),c=new Nt(16711680),f=new Nt(43775),d=new Nt(16777215),g=new Nt(3355443);this.setColors(u,c,f,d,g)}setColors(e,t,n,i,r){const o=this.geometry.getAttribute("color");o.setXYZ(0,e.r,e.g,e.b),o.setXYZ(1,e.r,e.g,e.b),o.setXYZ(2,e.r,e.g,e.b),o.setXYZ(3,e.r,e.g,e.b),o.setXYZ(4,e.r,e.g,e.b),o.setXYZ(5,e.r,e.g,e.b),o.setXYZ(6,e.r,e.g,e.b),o.setXYZ(7,e.r,e.g,e.b),o.setXYZ(8,e.r,e.g,e.b),o.setXYZ(9,e.r,e.g,e.b),o.setXYZ(10,e.r,e.g,e.b),o.setXYZ(11,e.r,e.g,e.b),o.setXYZ(12,e.r,e.g,e.b),o.setXYZ(13,e.r,e.g,e.b),o.setXYZ(14,e.r,e.g,e.b),o.setXYZ(15,e.r,e.g,e.b),o.setXYZ(16,e.r,e.g,e.b),o.setXYZ(17,e.r,e.g,e.b),o.setXYZ(18,e.r,e.g,e.b),o.setXYZ(19,e.r,e.g,e.b),o.setXYZ(20,e.r,e.g,e.b),o.setXYZ(21,e.r,e.g,e.b),o.setXYZ(22,e.r,e.g,e.b),o.setXYZ(23,e.r,e.g,e.b),o.setXYZ(24,t.r,t.g,t.b),o.setXYZ(25,t.r,t.g,t.b),o.setXYZ(26,t.r,t.g,t.b),o.setXYZ(27,t.r,t.g,t.b),o.setXYZ(28,t.r,t.g,t.b),o.setXYZ(29,t.r,t.g,t.b),o.setXYZ(30,t.r,t.g,t.b),o.setXYZ(31,t.r,t.g,t.b),o.setXYZ(32,n.r,n.g,n.b),o.setXYZ(33,n.r,n.g,n.b),o.setXYZ(34,n.r,n.g,n.b),o.setXYZ(35,n.r,n.g,n.b),o.setXYZ(36,n.r,n.g,n.b),o.setXYZ(37,n.r,n.g,n.b),o.setXYZ(38,i.r,i.g,i.b),o.setXYZ(39,i.r,i.g,i.b),o.setXYZ(40,r.r,r.g,r.b),o.setXYZ(41,r.r,r.g,r.b),o.setXYZ(42,r.r,r.g,r.b),o.setXYZ(43,r.r,r.g,r.b),o.setXYZ(44,r.r,r.g,r.b),o.setXYZ(45,r.r,r.g,r.b),o.setXYZ(46,r.r,r.g,r.b),o.setXYZ(47,r.r,r.g,r.b),o.setXYZ(48,r.r,r.g,r.b),o.setXYZ(49,r.r,r.g,r.b),o.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;wi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const r=this.camera.coordinateSystem===Zu?-1:0;Pi("c",t,e,wi,0,0,r),Pi("t",t,e,wi,0,0,1),Pi("n1",t,e,wi,-1,-1,r),Pi("n2",t,e,wi,n,-1,r),Pi("n3",t,e,wi,-1,i,r),Pi("n4",t,e,wi,n,i,r),Pi("f1",t,e,wi,-1,-1,1),Pi("f2",t,e,wi,n,-1,1),Pi("f3",t,e,wi,-1,i,1),Pi("f4",t,e,wi,n,i,1),Pi("u1",t,e,wi,n*.7,i*1.1,r),Pi("u2",t,e,wi,-1*.7,i*1.1,r),Pi("u3",t,e,wi,0,i*2,r),Pi("cf1",t,e,wi,-1,0,1),Pi("cf2",t,e,wi,n,0,1),Pi("cf3",t,e,wi,0,-1,1),Pi("cf4",t,e,wi,0,i,1),Pi("cn1",t,e,wi,-1,0,r),Pi("cn2",t,e,wi,n,0,r),Pi("cn3",t,e,wi,0,-1,r),Pi("cn4",t,e,wi,0,i,r),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Pi(s,e,t,n,i,r,a){qT.set(i,r,a).unproject(n);const o=e[s];if(o!==void 0){const l=t.getAttribute("position");for(let u=0,c=o.length;u<c;u++)l.setXYZ(o[u],qT.x,qT.y,qT.z)}}const jT=new Ea;class QZ extends lc{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),r=new Tn;r.setIndex(new us(n,1)),r.setAttribute("position",new us(i,3)),super(r,new Ra({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&jT.setFromObject(this.object),jT.isEmpty())return;const e=jT.min,t=jT.max,n=this.geometry.attributes.position,i=n.array;i[0]=t.x,i[1]=t.y,i[2]=t.z,i[3]=e.x,i[4]=t.y,i[5]=t.z,i[6]=e.x,i[7]=e.y,i[8]=t.z,i[9]=t.x,i[10]=e.y,i[11]=t.z,i[12]=t.x,i[13]=t.y,i[14]=e.z,i[15]=e.x,i[16]=t.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=t.x,i[22]=e.y,i[23]=e.z,n.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class eQ extends lc{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Tn;r.setIndex(new us(n,1)),r.setAttribute("position",new Vt(i,3)),super(r,new Ra({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class tQ extends vf{constructor(e,t=1,n=16776960){const i=n,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],a=new Tn;a.setAttribute("position",new Vt(r,3)),a.computeBoundingSphere(),super(a,new Ra({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Tn;l.setAttribute("position",new Vt(o,3)),l.computeBoundingSphere(),this.add(new zi(l,new fl({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const J4=new ae;let KT,_R;class nQ extends ts{constructor(e=new ae(0,0,1),t=new ae(0,0,0),n=1,i=16776960,r=n*.2,a=r*.2){super(),this.type="ArrowHelper",KT===void 0&&(KT=new Tn,KT.setAttribute("position",new Vt([0,0,0,0,1,0],3)),_R=new Lx(0,.5,1,5,1),_R.translate(0,-.5,0)),this.position.copy(t),this.line=new vf(KT,new Ra({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new zi(_R,new fl({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,r,a)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{J4.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(J4,t)}}setLength(e,t=e*.2,n=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class sQ extends lc{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Tn;i.setAttribute("position",new Vt(t,3)),i.setAttribute("color",new Vt(n,3));const r=new Ra({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(e,t,n){const i=new Nt,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class iQ{constructor(){this.type="ShapePath",this.color=new Nt,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new vb,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,a){return this.currentPath.bezierCurveTo(e,t,n,i,r,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(_){const T=[];for(let E=0,C=_.length;E<C;E++){const R=_[E],I=new dg;I.curves=R.curves,T.push(I)}return T}function n(_,T){const E=T.length;let C=!1;for(let R=E-1,I=0;I<E;R=I++){let L=T[R],P=T[I],D=P.x-L.x,O=P.y-L.y;if(Math.abs(O)>Number.EPSILON){if(O<0&&(L=T[I],D=-D,P=T[R],O=-O),_.y<L.y||_.y>P.y)continue;if(_.y===L.y){if(_.x===L.x)return!0}else{const F=O*(_.x-L.x)-D*(_.y-L.y);if(F===0)return!0;if(F<0)continue;C=!C}}else{if(_.y!==L.y)continue;if(P.x<=_.x&&_.x<=L.x||L.x<=_.x&&_.x<=P.x)return!0}}return C}const i=sh.isClockWise,r=this.subPaths;if(r.length===0)return[];let a,o,l;const u=[];if(r.length===1)return o=r[0],l=new dg,l.curves=o.curves,u.push(l),u;let c=!i(r[0].getPoints());c=e?!c:c;const f=[],d=[];let g=[],x=0,S;d[x]=void 0,g[x]=[];for(let _=0,T=r.length;_<T;_++)o=r[_],S=o.getPoints(),a=i(S),a=e?!a:a,a?(!c&&d[x]&&x++,d[x]={s:new dg,p:S},d[x].s.curves=o.curves,c&&x++,g[x]=[]):g[x].push({h:o,p:S[0]});if(!d[0])return t(r);if(d.length>1){let _=!1,T=0;for(let E=0,C=d.length;E<C;E++)f[E]=[];for(let E=0,C=d.length;E<C;E++){const R=g[E];for(let I=0;I<R.length;I++){const L=R[I];let P=!0;for(let D=0;D<d.length;D++)n(L.p,d[D].p)&&(E!==D&&T++,P?(P=!1,f[D].push(L)):_=!0);P&&f[E].push(L)}}T>0&&_===!1&&(g=f)}let b;for(let _=0,T=d.length;_<T;_++){l=d[_].s,u.push(l),b=g[_];for(let E=0,C=b.length;E<C;E++)l.holes.push(b[E].h)}return u}}class rQ extends yh{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){console.warn("THREE.Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}function aQ(s,e){const t=s.image&&s.image.width?s.image.width/s.image.height:1;return t>e?(s.repeat.x=1,s.repeat.y=t/e,s.offset.x=0,s.offset.y=(1-s.repeat.y)/2):(s.repeat.x=e/t,s.repeat.y=1,s.offset.x=(1-s.repeat.x)/2,s.offset.y=0),s}function oQ(s,e){const t=s.image&&s.image.width?s.image.width/s.image.height:1;return t>e?(s.repeat.x=e/t,s.repeat.y=1,s.offset.x=(1-s.repeat.x)/2,s.offset.y=0):(s.repeat.x=1,s.repeat.y=t/e,s.offset.x=0,s.offset.y=(1-s.repeat.y)/2),s}function lQ(s){return s.repeat.x=1,s.repeat.y=1,s.offset.x=0,s.offset.y=0,s}function VI(s,e,t,n){const i=uQ(n);switch(t){case E3:return s*e;case N3:return s*e;case R3:return s*e*2;case CC:return s*e/i.components*i.byteLength;case Qb:return s*e/i.components*i.byteLength;case I3:return s*e*2/i.components*i.byteLength;case EC:return s*e*2/i.components*i.byteLength;case M3:return s*e*3/i.components*i.byteLength;case wa:return s*e*4/i.components*i.byteLength;case MC:return s*e*4/i.components*i.byteLength;case Z1:case Q1:return Math.floor((s+3)/4)*Math.floor((e+3)/4)*8;case eb:case tb:return Math.floor((s+3)/4)*Math.floor((e+3)/4)*16;case Qw:case t2:return Math.max(s,16)*Math.max(e,8)/4;case Zw:case e2:return Math.max(s,8)*Math.max(e,8)/2;case n2:case s2:return Math.floor((s+3)/4)*Math.floor((e+3)/4)*8;case i2:return Math.floor((s+3)/4)*Math.floor((e+3)/4)*16;case r2:return Math.floor((s+3)/4)*Math.floor((e+3)/4)*16;case a2:return Math.floor((s+4)/5)*Math.floor((e+3)/4)*16;case o2:return Math.floor((s+4)/5)*Math.floor((e+4)/5)*16;case l2:return Math.floor((s+5)/6)*Math.floor((e+4)/5)*16;case u2:return Math.floor((s+5)/6)*Math.floor((e+5)/6)*16;case c2:return Math.floor((s+7)/8)*Math.floor((e+4)/5)*16;case h2:return Math.floor((s+7)/8)*Math.floor((e+5)/6)*16;case f2:return Math.floor((s+7)/8)*Math.floor((e+7)/8)*16;case d2:return Math.floor((s+9)/10)*Math.floor((e+4)/5)*16;case p2:return Math.floor((s+9)/10)*Math.floor((e+5)/6)*16;case m2:return Math.floor((s+9)/10)*Math.floor((e+7)/8)*16;case g2:return Math.floor((s+9)/10)*Math.floor((e+9)/10)*16;case y2:return Math.floor((s+11)/12)*Math.floor((e+9)/10)*16;case x2:return Math.floor((s+11)/12)*Math.floor((e+11)/12)*16;case nb:case v2:case b2:return Math.ceil(s/4)*Math.ceil(e/4)*16;case D3:case _2:return Math.ceil(s/4)*Math.ceil(e/4)*8;case S2:case A2:return Math.ceil(s/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function uQ(s){switch(s){case nc:case T3:return{byteLength:1,components:1};case nx:case w3:case kx:return{byteLength:2,components:1};case TC:case wC:return{byteLength:2,components:4};case xf:case AC:case Eo:return{byteLength:4,components:1};case C3:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${s}.`)}class cQ{static contain(e,t){return aQ(e,t)}static cover(e,t){return oQ(e,t)}static fill(e){return lQ(e)}static getByteLength(e,t,n,i){return VI(e,t,n,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Jb}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Jb);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function E6(){let s=null,e=!1,t=null,n=null;function i(r,a){t(r,a),n=s.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=s.requestAnimationFrame(i),e=!0)},stop:function(){s.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){s=r}}}function hQ(s){const e=new WeakMap;function t(o,l){const u=o.array,c=o.usage,f=u.byteLength,d=s.createBuffer();s.bindBuffer(l,d),s.bufferData(l,u,c),o.onUploadCallback();let g;if(u instanceof Float32Array)g=s.FLOAT;else if(u instanceof Uint16Array)o.isFloat16BufferAttribute?g=s.HALF_FLOAT:g=s.UNSIGNED_SHORT;else if(u instanceof Int16Array)g=s.SHORT;else if(u instanceof Uint32Array)g=s.UNSIGNED_INT;else if(u instanceof Int32Array)g=s.INT;else if(u instanceof Int8Array)g=s.BYTE;else if(u instanceof Uint8Array)g=s.UNSIGNED_BYTE;else if(u instanceof Uint8ClampedArray)g=s.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+u);return{buffer:d,type:g,bytesPerElement:u.BYTES_PER_ELEMENT,version:o.version,size:f}}function n(o,l,u){const c=l.array,f=l.updateRanges;if(s.bindBuffer(u,o),f.length===0)s.bufferSubData(u,0,c);else{f.sort((g,x)=>g.start-x.start);let d=0;for(let g=1;g<f.length;g++){const x=f[d],S=f[g];S.start<=x.start+x.count+1?x.count=Math.max(x.count,S.start+S.count-x.start):(++d,f[d]=S)}f.length=d+1;for(let g=0,x=f.length;g<x;g++){const S=f[g];s.bufferSubData(u,S.start*c.BYTES_PER_ELEMENT,c,S.start,S.count)}l.clearUpdateRanges()}l.onUploadCallback()}function i(o){return o.isInterleavedBufferAttribute&&(o=o.data),e.get(o)}function r(o){o.isInterleavedBufferAttribute&&(o=o.data);const l=e.get(o);l&&(s.deleteBuffer(l.buffer),e.delete(o))}function a(o,l){if(o.isInterleavedBufferAttribute&&(o=o.data),o.isGLBufferAttribute){const c=e.get(o);(!c||c.version<o.version)&&e.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}const u=e.get(o);if(u===void 0)e.set(o,t(o,l));else if(u.version<o.version){if(u.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(u.buffer,o,l),u.version=o.version}}return{get:i,remove:r,update:a}}var fQ=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,dQ=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,pQ=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,mQ=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,gQ=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,yQ=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,xQ=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,vQ=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,bQ=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,_Q=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,SQ=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,AQ=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,TQ=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,wQ=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,CQ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,EQ=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,MQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,NQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,RQ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,IQ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,DQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,OQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,BQ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,kQ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,LQ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,FQ=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,PQ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,UQ=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,$Q=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,zQ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,GQ="gl_FragColor = linearToOutputTexel( gl_FragColor );",HQ=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,VQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,WQ=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,XQ=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,qQ=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,jQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,KQ=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,YQ=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,JQ=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,ZQ=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,QQ=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,eee=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,tee=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,nee=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,see=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,iee=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,ree=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,aee=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,oee=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lee=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,uee=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,cee=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,hee=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,fee=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,dee=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,pee=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,mee=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,gee=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,yee=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,xee=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,vee=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,bee=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,_ee=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,See=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Aee=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Tee=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,wee=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Cee=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,Eee=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,Mee=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,Nee=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,Ree=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Iee=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Dee=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Oee=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Bee=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,kee=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Lee=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Fee=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Pee=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Uee=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,$ee=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,zee=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Gee=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Hee=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Vee=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Wee=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Xee=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,qee=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,jee=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Kee=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Yee=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Jee=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Zee=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Qee=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,ete=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,tte=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,nte=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,ste=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,ite=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,rte=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,ate=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,ote=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,lte=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,ute=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,cte=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const hte=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fte=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,dte=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,pte=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,mte=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,gte=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,yte=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,xte=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,vte=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,bte=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,_te=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Ste=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Ate=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Tte=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,wte=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Cte=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ete=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Mte=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Nte=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Rte=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ite=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Dte=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Ote=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Bte=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,kte=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Lte=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Fte=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Pte=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ute=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,$te=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,zte=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Gte=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Hte=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Vte=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,In={alphahash_fragment:fQ,alphahash_pars_fragment:dQ,alphamap_fragment:pQ,alphamap_pars_fragment:mQ,alphatest_fragment:gQ,alphatest_pars_fragment:yQ,aomap_fragment:xQ,aomap_pars_fragment:vQ,batching_pars_vertex:bQ,batching_vertex:_Q,begin_vertex:SQ,beginnormal_vertex:AQ,bsdfs:TQ,iridescence_fragment:wQ,bumpmap_pars_fragment:CQ,clipping_planes_fragment:EQ,clipping_planes_pars_fragment:MQ,clipping_planes_pars_vertex:NQ,clipping_planes_vertex:RQ,color_fragment:IQ,color_pars_fragment:DQ,color_pars_vertex:OQ,color_vertex:BQ,common:kQ,cube_uv_reflection_fragment:LQ,defaultnormal_vertex:FQ,displacementmap_pars_vertex:PQ,displacementmap_vertex:UQ,emissivemap_fragment:$Q,emissivemap_pars_fragment:zQ,colorspace_fragment:GQ,colorspace_pars_fragment:HQ,envmap_fragment:VQ,envmap_common_pars_fragment:WQ,envmap_pars_fragment:XQ,envmap_pars_vertex:qQ,envmap_physical_pars_fragment:iee,envmap_vertex:jQ,fog_vertex:KQ,fog_pars_vertex:YQ,fog_fragment:JQ,fog_pars_fragment:ZQ,gradientmap_pars_fragment:QQ,lightmap_pars_fragment:eee,lights_lambert_fragment:tee,lights_lambert_pars_fragment:nee,lights_pars_begin:see,lights_toon_fragment:ree,lights_toon_pars_fragment:aee,lights_phong_fragment:oee,lights_phong_pars_fragment:lee,lights_physical_fragment:uee,lights_physical_pars_fragment:cee,lights_fragment_begin:hee,lights_fragment_maps:fee,lights_fragment_end:dee,logdepthbuf_fragment:pee,logdepthbuf_pars_fragment:mee,logdepthbuf_pars_vertex:gee,logdepthbuf_vertex:yee,map_fragment:xee,map_pars_fragment:vee,map_particle_fragment:bee,map_particle_pars_fragment:_ee,metalnessmap_fragment:See,metalnessmap_pars_fragment:Aee,morphinstance_vertex:Tee,morphcolor_vertex:wee,morphnormal_vertex:Cee,morphtarget_pars_vertex:Eee,morphtarget_vertex:Mee,normal_fragment_begin:Nee,normal_fragment_maps:Ree,normal_pars_fragment:Iee,normal_pars_vertex:Dee,normal_vertex:Oee,normalmap_pars_fragment:Bee,clearcoat_normal_fragment_begin:kee,clearcoat_normal_fragment_maps:Lee,clearcoat_pars_fragment:Fee,iridescence_pars_fragment:Pee,opaque_fragment:Uee,packing:$ee,premultiplied_alpha_fragment:zee,project_vertex:Gee,dithering_fragment:Hee,dithering_pars_fragment:Vee,roughnessmap_fragment:Wee,roughnessmap_pars_fragment:Xee,shadowmap_pars_fragment:qee,shadowmap_pars_vertex:jee,shadowmap_vertex:Kee,shadowmask_pars_fragment:Yee,skinbase_vertex:Jee,skinning_pars_vertex:Zee,skinning_vertex:Qee,skinnormal_vertex:ete,specularmap_fragment:tte,specularmap_pars_fragment:nte,tonemapping_fragment:ste,tonemapping_pars_fragment:ite,transmission_fragment:rte,transmission_pars_fragment:ate,uv_pars_fragment:ote,uv_pars_vertex:lte,uv_vertex:ute,worldpos_vertex:cte,background_vert:hte,background_frag:fte,backgroundCube_vert:dte,backgroundCube_frag:pte,cube_vert:mte,cube_frag:gte,depth_vert:yte,depth_frag:xte,distanceRGBA_vert:vte,distanceRGBA_frag:bte,equirect_vert:_te,equirect_frag:Ste,linedashed_vert:Ate,linedashed_frag:Tte,meshbasic_vert:wte,meshbasic_frag:Cte,meshlambert_vert:Ete,meshlambert_frag:Mte,meshmatcap_vert:Nte,meshmatcap_frag:Rte,meshnormal_vert:Ite,meshnormal_frag:Dte,meshphong_vert:Ote,meshphong_frag:Bte,meshphysical_vert:kte,meshphysical_frag:Lte,meshtoon_vert:Fte,meshtoon_frag:Pte,points_vert:Ute,points_frag:$te,shadow_vert:zte,shadow_frag:Gte,sprite_vert:Hte,sprite_frag:Vte},It={common:{diffuse:{value:new Nt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new An},alphaMap:{value:null},alphaMapTransform:{value:new An},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new An}},envmap:{envMap:{value:null},envMapRotation:{value:new An},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new An}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new An}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new An},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new An},normalScale:{value:new tt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new An},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new An}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new An}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new An}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Nt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Nt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new An},alphaTest:{value:0},uvTransform:{value:new An}},sprite:{diffuse:{value:new Nt(16777215)},opacity:{value:1},center:{value:new tt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new An},alphaMap:{value:null},alphaMapTransform:{value:new An},alphaTest:{value:0}}},ju={basic:{uniforms:Ya([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.fog]),vertexShader:In.meshbasic_vert,fragmentShader:In.meshbasic_frag},lambert:{uniforms:Ya([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.fog,It.lights,{emissive:{value:new Nt(0)}}]),vertexShader:In.meshlambert_vert,fragmentShader:In.meshlambert_frag},phong:{uniforms:Ya([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.fog,It.lights,{emissive:{value:new Nt(0)},specular:{value:new Nt(1118481)},shininess:{value:30}}]),vertexShader:In.meshphong_vert,fragmentShader:In.meshphong_frag},standard:{uniforms:Ya([It.common,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.roughnessmap,It.metalnessmap,It.fog,It.lights,{emissive:{value:new Nt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:In.meshphysical_vert,fragmentShader:In.meshphysical_frag},toon:{uniforms:Ya([It.common,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.gradientmap,It.fog,It.lights,{emissive:{value:new Nt(0)}}]),vertexShader:In.meshtoon_vert,fragmentShader:In.meshtoon_frag},matcap:{uniforms:Ya([It.common,It.bumpmap,It.normalmap,It.displacementmap,It.fog,{matcap:{value:null}}]),vertexShader:In.meshmatcap_vert,fragmentShader:In.meshmatcap_frag},points:{uniforms:Ya([It.points,It.fog]),vertexShader:In.points_vert,fragmentShader:In.points_frag},dashed:{uniforms:Ya([It.common,It.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:In.linedashed_vert,fragmentShader:In.linedashed_frag},depth:{uniforms:Ya([It.common,It.displacementmap]),vertexShader:In.depth_vert,fragmentShader:In.depth_frag},normal:{uniforms:Ya([It.common,It.bumpmap,It.normalmap,It.displacementmap,{opacity:{value:1}}]),vertexShader:In.meshnormal_vert,fragmentShader:In.meshnormal_frag},sprite:{uniforms:Ya([It.sprite,It.fog]),vertexShader:In.sprite_vert,fragmentShader:In.sprite_frag},background:{uniforms:{uvTransform:{value:new An},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:In.background_vert,fragmentShader:In.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new An}},vertexShader:In.backgroundCube_vert,fragmentShader:In.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:In.cube_vert,fragmentShader:In.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:In.equirect_vert,fragmentShader:In.equirect_frag},distanceRGBA:{uniforms:Ya([It.common,It.displacementmap,{referencePosition:{value:new ae},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:In.distanceRGBA_vert,fragmentShader:In.distanceRGBA_frag},shadow:{uniforms:Ya([It.lights,It.fog,{color:{value:new Nt(0)},opacity:{value:1}}]),vertexShader:In.shadow_vert,fragmentShader:In.shadow_frag}};ju.physical={uniforms:Ya([ju.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new An},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new An},clearcoatNormalScale:{value:new tt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new An},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new An},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new An},sheen:{value:0},sheenColor:{value:new Nt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new An},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new An},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new An},transmissionSamplerSize:{value:new tt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new An},attenuationDistance:{value:0},attenuationColor:{value:new Nt(0)},specularColor:{value:new Nt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new An},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new An},anisotropyVector:{value:new tt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new An}}]),vertexShader:In.meshphysical_vert,fragmentShader:In.meshphysical_frag};const YT={r:0,b:0,g:0},km=new xl,Wte=new rn;function Xte(s,e,t,n,i,r,a){const o=new Nt(0);let l=r===!0?0:1,u,c,f=null,d=0,g=null;function x(E){let C=E.isScene===!0?E.background:null;return C&&C.isTexture&&(C=(E.backgroundBlurriness>0?t:e).get(C)),C}function S(E){let C=!1;const R=x(E);R===null?_(o,l):R&&R.isColor&&(_(R,1),C=!0);const I=s.xr.getEnvironmentBlendMode();I==="additive"?n.buffers.color.setClear(0,0,0,1,a):I==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(s.autoClear||C)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil))}function b(E,C){const R=x(C);R&&(R.isCubeTexture||R.mapping===Bx)?(c===void 0&&(c=new zi(new qg(1,1,1),new sc({name:"BackgroundCubeMaterial",uniforms:cx(ju.backgroundCube.uniforms),vertexShader:ju.backgroundCube.vertexShader,fragmentShader:ju.backgroundCube.fragmentShader,side:so,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(I,L,P){this.matrixWorld.copyPosition(P.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),km.copy(C.backgroundRotation),km.x*=-1,km.y*=-1,km.z*=-1,R.isCubeTexture&&R.isRenderTargetTexture===!1&&(km.y*=-1,km.z*=-1),c.material.uniforms.envMap.value=R,c.material.uniforms.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=C.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=C.backgroundIntensity,c.material.uniforms.backgroundRotation.value.setFromMatrix4(Wte.makeRotationFromEuler(km)),c.material.toneMapped=Qn.getTransfer(R.colorSpace)!==Cs,(f!==R||d!==R.version||g!==s.toneMapping)&&(c.material.needsUpdate=!0,f=R,d=R.version,g=s.toneMapping),c.layers.enableAll(),E.unshift(c,c.geometry,c.material,0,0,null)):R&&R.isTexture&&(u===void 0&&(u=new zi(new Fx(2,2),new sc({name:"BackgroundMaterial",uniforms:cx(ju.background.uniforms),vertexShader:ju.background.vertexShader,fragmentShader:ju.background.fragmentShader,side:ch,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(u)),u.material.uniforms.t2D.value=R,u.material.uniforms.backgroundIntensity.value=C.backgroundIntensity,u.material.toneMapped=Qn.getTransfer(R.colorSpace)!==Cs,R.matrixAutoUpdate===!0&&R.updateMatrix(),u.material.uniforms.uvTransform.value.copy(R.matrix),(f!==R||d!==R.version||g!==s.toneMapping)&&(u.material.needsUpdate=!0,f=R,d=R.version,g=s.toneMapping),u.layers.enableAll(),E.unshift(u,u.geometry,u.material,0,0,null))}function _(E,C){E.getRGB(YT,D9(s)),n.buffers.color.setClear(YT.r,YT.g,YT.b,C,a)}function T(){c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0),u!==void 0&&(u.geometry.dispose(),u.material.dispose(),u=void 0)}return{getClearColor:function(){return o},setClearColor:function(E,C=1){o.set(E),l=C,_(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(E){l=E,_(o,l)},render:S,addToRenderList:b,dispose:T}}function qte(s,e){const t=s.getParameter(s.MAX_VERTEX_ATTRIBS),n={},i=d(null);let r=i,a=!1;function o(O,F,X,q,J){let Y=!1;const $=f(q,X,F);r!==$&&(r=$,u(r.object)),Y=g(O,q,X,J),Y&&x(O,q,X,J),J!==null&&e.update(J,s.ELEMENT_ARRAY_BUFFER),(Y||a)&&(a=!1,C(O,F,X,q),J!==null&&s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e.get(J).buffer))}function l(){return s.createVertexArray()}function u(O){return s.bindVertexArray(O)}function c(O){return s.deleteVertexArray(O)}function f(O,F,X){const q=X.wireframe===!0;let J=n[O.id];J===void 0&&(J={},n[O.id]=J);let Y=J[F.id];Y===void 0&&(Y={},J[F.id]=Y);let $=Y[q];return $===void 0&&($=d(l()),Y[q]=$),$}function d(O){const F=[],X=[],q=[];for(let J=0;J<t;J++)F[J]=0,X[J]=0,q[J]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:F,enabledAttributes:X,attributeDivisors:q,object:O,attributes:{},index:null}}function g(O,F,X,q){const J=r.attributes,Y=F.attributes;let $=0;const W=X.getAttributes();for(const V in W)if(W[V].location>=0){const G=J[V];let ne=Y[V];if(ne===void 0&&(V==="instanceMatrix"&&O.instanceMatrix&&(ne=O.instanceMatrix),V==="instanceColor"&&O.instanceColor&&(ne=O.instanceColor)),G===void 0||G.attribute!==ne||ne&&G.data!==ne.data)return!0;$++}return r.attributesNum!==$||r.index!==q}function x(O,F,X,q){const J={},Y=F.attributes;let $=0;const W=X.getAttributes();for(const V in W)if(W[V].location>=0){let G=Y[V];G===void 0&&(V==="instanceMatrix"&&O.instanceMatrix&&(G=O.instanceMatrix),V==="instanceColor"&&O.instanceColor&&(G=O.instanceColor));const ne={};ne.attribute=G,G&&G.data&&(ne.data=G.data),J[V]=ne,$++}r.attributes=J,r.attributesNum=$,r.index=q}function S(){const O=r.newAttributes;for(let F=0,X=O.length;F<X;F++)O[F]=0}function b(O){_(O,0)}function _(O,F){const X=r.newAttributes,q=r.enabledAttributes,J=r.attributeDivisors;X[O]=1,q[O]===0&&(s.enableVertexAttribArray(O),q[O]=1),J[O]!==F&&(s.vertexAttribDivisor(O,F),J[O]=F)}function T(){const O=r.newAttributes,F=r.enabledAttributes;for(let X=0,q=F.length;X<q;X++)F[X]!==O[X]&&(s.disableVertexAttribArray(X),F[X]=0)}function E(O,F,X,q,J,Y,$){$===!0?s.vertexAttribIPointer(O,F,X,J,Y):s.vertexAttribPointer(O,F,X,q,J,Y)}function C(O,F,X,q){S();const J=q.attributes,Y=X.getAttributes(),$=F.defaultAttributeValues;for(const W in Y){const V=Y[W];if(V.location>=0){let se=J[W];if(se===void 0&&(W==="instanceMatrix"&&O.instanceMatrix&&(se=O.instanceMatrix),W==="instanceColor"&&O.instanceColor&&(se=O.instanceColor)),se!==void 0){const G=se.normalized,ne=se.itemSize,oe=e.get(se);if(oe===void 0)continue;const ue=oe.buffer,re=oe.type,ce=oe.bytesPerElement,Te=re===s.INT||re===s.UNSIGNED_INT||se.gpuType===AC;if(se.isInterleavedBufferAttribute){const Be=se.data,Ke=Be.stride,ut=se.offset;if(Be.isInstancedInterleavedBuffer){for(let ct=0;ct<V.locationSize;ct++)_(V.location+ct,Be.meshPerAttribute);O.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=Be.meshPerAttribute*Be.count)}else for(let ct=0;ct<V.locationSize;ct++)b(V.location+ct);s.bindBuffer(s.ARRAY_BUFFER,ue);for(let ct=0;ct<V.locationSize;ct++)E(V.location+ct,ne/V.locationSize,re,G,Ke*ce,(ut+ne/V.locationSize*ct)*ce,Te)}else{if(se.isInstancedBufferAttribute){for(let Be=0;Be<V.locationSize;Be++)_(V.location+Be,se.meshPerAttribute);O.isInstancedMesh!==!0&&q._maxInstanceCount===void 0&&(q._maxInstanceCount=se.meshPerAttribute*se.count)}else for(let Be=0;Be<V.locationSize;Be++)b(V.location+Be);s.bindBuffer(s.ARRAY_BUFFER,ue);for(let Be=0;Be<V.locationSize;Be++)E(V.location+Be,ne/V.locationSize,re,G,ne*ce,ne/V.locationSize*Be*ce,Te)}}else if($!==void 0){const G=$[W];if(G!==void 0)switch(G.length){case 2:s.vertexAttrib2fv(V.location,G);break;case 3:s.vertexAttrib3fv(V.location,G);break;case 4:s.vertexAttrib4fv(V.location,G);break;default:s.vertexAttrib1fv(V.location,G)}}}}T()}function R(){P();for(const O in n){const F=n[O];for(const X in F){const q=F[X];for(const J in q)c(q[J].object),delete q[J];delete F[X]}delete n[O]}}function I(O){if(n[O.id]===void 0)return;const F=n[O.id];for(const X in F){const q=F[X];for(const J in q)c(q[J].object),delete q[J];delete F[X]}delete n[O.id]}function L(O){for(const F in n){const X=n[F];if(X[O.id]===void 0)continue;const q=X[O.id];for(const J in q)c(q[J].object),delete q[J];delete X[O.id]}}function P(){D(),a=!0,r!==i&&(r=i,u(r.object))}function D(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:o,reset:P,resetDefaultState:D,dispose:R,releaseStatesOfGeometry:I,releaseStatesOfProgram:L,initAttributes:S,enableAttribute:b,disableUnusedAttributes:T}}function jte(s,e,t){let n;function i(u){n=u}function r(u,c){s.drawArrays(n,u,c),t.update(c,n,1)}function a(u,c,f){f!==0&&(s.drawArraysInstanced(n,u,c,f),t.update(c,n,f))}function o(u,c,f){if(f===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,u,0,c,0,f);let g=0;for(let x=0;x<f;x++)g+=c[x];t.update(g,n,1)}function l(u,c,f,d){if(f===0)return;const g=e.get("WEBGL_multi_draw");if(g===null)for(let x=0;x<u.length;x++)a(u[x],c[x],d[x]);else{g.multiDrawArraysInstancedWEBGL(n,u,0,c,0,d,0,f);let x=0;for(let S=0;S<f;S++)x+=c[S]*d[S];t.update(x,n,1)}}this.setMode=i,this.render=r,this.renderInstances=a,this.renderMultiDraw=o,this.renderMultiDrawInstances=l}function Kte(s,e,t,n){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const L=e.get("EXT_texture_filter_anisotropic");i=s.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(L){return!(L!==wa&&n.convert(L)!==s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(L){const P=L===kx&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(L!==nc&&n.convert(L)!==s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE)&&L!==Eo&&!P)}function l(L){if(L==="highp"){if(s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.HIGH_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision>0)return"highp";L="mediump"}return L==="mediump"&&s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.MEDIUM_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let u=t.precision!==void 0?t.precision:"highp";const c=l(u);c!==u&&(console.warn("THREE.WebGLRenderer:",u,"not supported, using",c,"instead."),u=c);const f=t.logarithmicDepthBuffer===!0,d=t.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),g=s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),x=s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),S=s.getParameter(s.MAX_TEXTURE_SIZE),b=s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),_=s.getParameter(s.MAX_VERTEX_ATTRIBS),T=s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),E=s.getParameter(s.MAX_VARYING_VECTORS),C=s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),R=x>0,I=s.getParameter(s.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:l,textureFormatReadable:a,textureTypeReadable:o,precision:u,logarithmicDepthBuffer:f,reverseDepthBuffer:d,maxTextures:g,maxVertexTextures:x,maxTextureSize:S,maxCubemapSize:b,maxAttributes:_,maxVertexUniforms:T,maxVaryings:E,maxFragmentUniforms:C,vertexTextures:R,maxSamples:I}}function Yte(s){const e=this;let t=null,n=0,i=!1,r=!1;const a=new Zh,o=new An,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(f,d){const g=f.length!==0||d||n!==0||i;return i=d,n=f.length,g},this.beginShadows=function(){r=!0,c(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(f,d){t=c(f,d,0)},this.setState=function(f,d,g){const x=f.clippingPlanes,S=f.clipIntersection,b=f.clipShadows,_=s.get(f);if(!i||x===null||x.length===0||r&&!b)r?c(null):u();else{const T=r?0:n,E=T*4;let C=_.clippingState||null;l.value=C,C=c(x,d,E,g);for(let R=0;R!==E;++R)C[R]=t[R];_.clippingState=C,this.numIntersection=S?this.numPlanes:0,this.numPlanes+=T}};function u(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function c(f,d,g,x){const S=f!==null?f.length:0;let b=null;if(S!==0){if(b=l.value,x!==!0||b===null){const _=g+S*4,T=d.matrixWorldInverse;o.getNormalMatrix(T),(b===null||b.length<_)&&(b=new Float32Array(_));for(let E=0,C=g;E!==S;++E,C+=4)a.copy(f[E]).applyMatrix4(T,o),a.normal.toArray(b,C),b[C+3]=a.constant}l.value=b,l.needsUpdate=!0}return e.numPlanes=S,e.numIntersection=0,b}}function Jte(s){let e=new WeakMap;function t(a,o){return o===fb?a.mapping=yf:o===db&&(a.mapping=ep),a}function n(a){if(a&&a.isTexture){const o=a.mapping;if(o===fb||o===db)if(e.has(a)){const l=e.get(a).texture;return t(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const u=new k9(l.height);return u.fromEquirectangularTexture(s,a),e.set(a,u),a.addEventListener("dispose",i),t(u.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function r(){e=new WeakMap}return{get:n,dispose:r}}const Uy=4,Z4=[.125,.215,.35,.446,.526,.582],Jm=20,SR=new ff,Q4=new Nt;let AR=null,TR=0,wR=0,CR=!1;const qm=(1+Math.sqrt(5))/2,Cy=1/qm,eP=[new ae(-qm,Cy,0),new ae(qm,Cy,0),new ae(-Cy,0,qm),new ae(Cy,0,qm),new ae(0,qm,-Cy),new ae(0,qm,Cy),new ae(-1,1,-1),new ae(1,1,-1),new ae(-1,1,1),new ae(1,1,1)],Zte=new ae;class WI{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100,r={}){const{size:a=256,position:o=Zte}=r;AR=this._renderer.getRenderTarget(),TR=this._renderer.getActiveCubeFace(),wR=this._renderer.getActiveMipmapLevel(),CR=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,n,i,l,o),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=sP(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=nP(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(AR,TR,wR),this._renderer.xr.enabled=CR,e.scissorTest=!1,JT(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===yf||e.mapping===ep?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),AR=this._renderer.getRenderTarget(),TR=this._renderer.getActiveCubeFace(),wR=this._renderer.getActiveMipmapLevel(),CR=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:$i,minFilter:$i,generateMipmaps:!1,type:kx,format:wa,colorSpace:np,depthBuffer:!1},i=tP(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=tP(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Qte(r)),this._blurMaterial=ene(r,e,t)}return i}_compileMaterial(e){const t=new zi(this._lodPlanes[0],e);this._renderer.compile(t,SR)}_sceneToCubeUV(e,t,n,i,r){const l=new Ci(90,1,t,n),u=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],f=this._renderer,d=f.autoClear,g=f.toneMapping;f.getClearColor(Q4),f.toneMapping=th,f.autoClear=!1;const x=new fl({name:"PMREM.Background",side:so,depthWrite:!1,depthTest:!1}),S=new zi(new qg,x);let b=!1;const _=e.background;_?_.isColor&&(x.color.copy(_),e.background=null,b=!0):(x.color.copy(Q4),b=!0);for(let T=0;T<6;T++){const E=T%3;E===0?(l.up.set(0,u[T],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x+c[T],r.y,r.z)):E===1?(l.up.set(0,0,u[T]),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y+c[T],r.z)):(l.up.set(0,u[T],0),l.position.set(r.x,r.y,r.z),l.lookAt(r.x,r.y,r.z+c[T]));const C=this._cubeSize;JT(i,E*C,T>2?C:0,C,C),f.setRenderTarget(i),b&&f.render(S,l),f.render(e,l)}S.geometry.dispose(),S.material.dispose(),f.toneMapping=g,f.autoClear=d,e.background=_}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===yf||e.mapping===ep;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=sP()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=nP());const r=i?this._cubemapMaterial:this._equirectMaterial,a=new zi(this._lodPlanes[0],r),o=r.uniforms;o.envMap.value=e;const l=this._cubeSize;JT(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(a,SR)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let r=1;r<i;r++){const a=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),o=eP[(i-r-1)%eP.length];this._blur(e,r-1,r,a,o)}t.autoClear=n}_blur(e,t,n,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",r),this._halfBlur(a,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,a,o){const l=this._renderer,u=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,f=new zi(this._lodPlanes[i],u),d=u.uniforms,g=this._sizeLods[n]-1,x=isFinite(r)?Math.PI/(2*g):2*Math.PI/(2*Jm-1),S=r/x,b=isFinite(r)?1+Math.floor(c*S):Jm;b>Jm&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${Jm}`);const _=[];let T=0;for(let L=0;L<Jm;++L){const P=L/S,D=Math.exp(-P*P/2);_.push(D),L===0?T+=D:L<b&&(T+=2*D)}for(let L=0;L<_.length;L++)_[L]=_[L]/T;d.envMap.value=e.texture,d.samples.value=b,d.weights.value=_,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:E}=this;d.dTheta.value=x,d.mipInt.value=E-n;const C=this._sizeLods[i],R=3*C*(i>E-Uy?i-E+Uy:0),I=4*(this._cubeSize-C);JT(t,R,I,3*C,2*C),l.setRenderTarget(t),l.render(f,SR)}}function Qte(s){const e=[],t=[],n=[];let i=s;const r=s-Uy+1+Z4.length;for(let a=0;a<r;a++){const o=Math.pow(2,i);t.push(o);let l=1/o;a>s-Uy?l=Z4[a-s+Uy-1]:a===0&&(l=0),n.push(l);const u=1/(o-2),c=-u,f=1+u,d=[c,c,f,c,f,f,c,c,f,f,c,f],g=6,x=6,S=3,b=2,_=1,T=new Float32Array(S*x*g),E=new Float32Array(b*x*g),C=new Float32Array(_*x*g);for(let I=0;I<g;I++){const L=I%3*2/3-1,P=I>2?0:-1,D=[L,P,0,L+2/3,P,0,L+2/3,P+1,0,L,P,0,L+2/3,P+1,0,L,P+1,0];T.set(D,S*x*I),E.set(d,b*x*I);const O=[I,I,I,I,I,I];C.set(O,_*x*I)}const R=new Tn;R.setAttribute("position",new us(T,S)),R.setAttribute("uv",new us(E,b)),R.setAttribute("faceIndex",new us(C,_)),e.push(R),i>Uy&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function tP(s,e,t){const n=new hh(s,e,t);return n.texture.mapping=Bx,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function JT(s,e,t,n,i){s.viewport.set(e,t,n,i),s.scissor.set(e,t,n,i)}function ene(s,e,t){const n=new Float32Array(Jm),i=new ae(0,1,0);return new sc({name:"SphericalGaussianBlur",defines:{n:Jm,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:pO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:cf,depthTest:!1,depthWrite:!1})}function nP(){return new sc({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:pO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:cf,depthTest:!1,depthWrite:!1})}function sP(){return new sc({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:pO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:cf,depthTest:!1,depthWrite:!1})}function pO(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function tne(s){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture){const l=o.mapping,u=l===fb||l===db,c=l===yf||l===ep;if(u||c){let f=e.get(o);const d=f!==void 0?f.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==d)return t===null&&(t=new WI(s)),f=u?t.fromEquirectangular(o,f):t.fromCubemap(o,f),f.texture.pmremVersion=o.pmremVersion,e.set(o,f),f.texture;if(f!==void 0)return f.texture;{const g=o.image;return u&&g&&g.height>0||c&&g&&i(g)?(t===null&&(t=new WI(s)),f=u?t.fromEquirectangular(o):t.fromCubemap(o),f.texture.pmremVersion=o.pmremVersion,e.set(o,f),o.addEventListener("dispose",r),f.texture):null}}}return o}function i(o){let l=0;const u=6;for(let c=0;c<u;c++)o[c]!==void 0&&l++;return l===u}function r(o){const l=o.target;l.removeEventListener("dispose",r);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function nne(s){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=s.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(n){const i=t(n);return i===null&&Aw("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function sne(s,e,t,n){const i={},r=new WeakMap;function a(f){const d=f.target;d.index!==null&&e.remove(d.index);for(const x in d.attributes)e.remove(d.attributes[x]);d.removeEventListener("dispose",a),delete i[d.id];const g=r.get(d);g&&(e.remove(g),r.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(f,d){return i[d.id]===!0||(d.addEventListener("dispose",a),i[d.id]=!0,t.memory.geometries++),d}function l(f){const d=f.attributes;for(const g in d)e.update(d[g],s.ARRAY_BUFFER)}function u(f){const d=[],g=f.index,x=f.attributes.position;let S=0;if(g!==null){const T=g.array;S=g.version;for(let E=0,C=T.length;E<C;E+=3){const R=T[E+0],I=T[E+1],L=T[E+2];d.push(R,I,I,L,L,R)}}else if(x!==void 0){const T=x.array;S=x.version;for(let E=0,C=T.length/3-1;E<C;E+=3){const R=E+0,I=E+1,L=E+2;d.push(R,I,I,L,L,R)}}else return;const b=new(M9(d)?P3:F3)(d,1);b.version=S;const _=r.get(f);_&&e.remove(_),r.set(f,b)}function c(f){const d=r.get(f);if(d){const g=f.index;g!==null&&d.version<g.version&&u(f)}else u(f);return r.get(f)}return{get:o,update:l,getWireframeAttribute:c}}function ine(s,e,t){let n;function i(d){n=d}let r,a;function o(d){r=d.type,a=d.bytesPerElement}function l(d,g){s.drawElements(n,g,r,d*a),t.update(g,n,1)}function u(d,g,x){x!==0&&(s.drawElementsInstanced(n,g,r,d*a,x),t.update(g,n,x))}function c(d,g,x){if(x===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,g,0,r,d,0,x);let b=0;for(let _=0;_<x;_++)b+=g[_];t.update(b,n,1)}function f(d,g,x,S){if(x===0)return;const b=e.get("WEBGL_multi_draw");if(b===null)for(let _=0;_<d.length;_++)u(d[_]/a,g[_],S[_]);else{b.multiDrawElementsInstancedWEBGL(n,g,0,r,d,0,S,0,x);let _=0;for(let T=0;T<x;T++)_+=g[T]*S[T];t.update(_,n,1)}}this.setMode=i,this.setIndex=o,this.render=l,this.renderInstances=u,this.renderMultiDraw=c,this.renderMultiDrawInstances=f}function rne(s){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,a,o){switch(t.calls++,a){case s.TRIANGLES:t.triangles+=o*(r/3);break;case s.LINES:t.lines+=o*(r/2);break;case s.LINE_STRIP:t.lines+=o*(r-1);break;case s.LINE_LOOP:t.lines+=o*r;break;case s.POINTS:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function ane(s,e,t){const n=new WeakMap,i=new os;function r(a,o,l){const u=a.morphTargetInfluences,c=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,f=c!==void 0?c.length:0;let d=n.get(o);if(d===void 0||d.count!==f){let O=function(){P.dispose(),n.delete(o),o.removeEventListener("dispose",O)};var g=O;d!==void 0&&d.texture.dispose();const x=o.morphAttributes.position!==void 0,S=o.morphAttributes.normal!==void 0,b=o.morphAttributes.color!==void 0,_=o.morphAttributes.position||[],T=o.morphAttributes.normal||[],E=o.morphAttributes.color||[];let C=0;x===!0&&(C=1),S===!0&&(C=2),b===!0&&(C=3);let R=o.attributes.position.count*C,I=1;R>e.maxTextureSize&&(I=Math.ceil(R/e.maxTextureSize),R=e.maxTextureSize);const L=new Float32Array(R*I*4*f),P=new e_(L,R,I,f);P.type=Eo,P.needsUpdate=!0;const D=C*4;for(let F=0;F<f;F++){const X=_[F],q=T[F],J=E[F],Y=R*I*4*F;for(let $=0;$<X.count;$++){const W=$*D;x===!0&&(i.fromBufferAttribute(X,$),L[Y+W+0]=i.x,L[Y+W+1]=i.y,L[Y+W+2]=i.z,L[Y+W+3]=0),S===!0&&(i.fromBufferAttribute(q,$),L[Y+W+4]=i.x,L[Y+W+5]=i.y,L[Y+W+6]=i.z,L[Y+W+7]=0),b===!0&&(i.fromBufferAttribute(J,$),L[Y+W+8]=i.x,L[Y+W+9]=i.y,L[Y+W+10]=i.z,L[Y+W+11]=J.itemSize===4?i.w:1)}}d={count:f,texture:P,size:new tt(R,I)},n.set(o,d),o.addEventListener("dispose",O)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)l.getUniforms().setValue(s,"morphTexture",a.morphTexture,t);else{let x=0;for(let b=0;b<u.length;b++)x+=u[b];const S=o.morphTargetsRelative?1:1-x;l.getUniforms().setValue(s,"morphTargetBaseInfluence",S),l.getUniforms().setValue(s,"morphTargetInfluences",u)}l.getUniforms().setValue(s,"morphTargetsTexture",d.texture,t),l.getUniforms().setValue(s,"morphTargetsTextureSize",d.size)}return{update:r}}function one(s,e,t,n){let i=new WeakMap;function r(l){const u=n.render.frame,c=l.geometry,f=e.get(l,c);if(i.get(f)!==u&&(e.update(f),i.set(f,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),i.get(l)!==u&&(t.update(l.instanceMatrix,s.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,s.ARRAY_BUFFER),i.set(l,u))),l.isSkinnedMesh){const d=l.skeleton;i.get(d)!==u&&(d.update(),i.set(d,u))}return f}function a(){i=new WeakMap}function o(l){const u=l.target;u.removeEventListener("dispose",o),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:r,dispose:a}}const M6=new ii,iP=new W3(1,1),N6=new e_,R6=new IC,I6=new t_,rP=[],aP=[],oP=new Float32Array(16),lP=new Float32Array(9),uP=new Float32Array(4);function Ux(s,e,t){const n=s[0];if(n<=0||n>0)return s;const i=e*t;let r=rP[i];if(r===void 0&&(r=new Float32Array(i),rP[i]=r),e!==0){n.toArray(r,0);for(let a=1,o=0;a!==e;++a)o+=t,s[a].toArray(r,o)}return r}function _r(s,e){if(s.length!==e.length)return!1;for(let t=0,n=s.length;t<n;t++)if(s[t]!==e[t])return!1;return!0}function Sr(s,e){for(let t=0,n=e.length;t<n;t++)s[t]=e[t]}function ZC(s,e){let t=aP[e];t===void 0&&(t=new Int32Array(e),aP[e]=t);for(let n=0;n!==e;++n)t[n]=s.allocateTextureUnit();return t}function lne(s,e){const t=this.cache;t[0]!==e&&(s.uniform1f(this.addr,e),t[0]=e)}function une(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(s.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_r(t,e))return;s.uniform2fv(this.addr,e),Sr(t,e)}}function cne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(s.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(s.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(_r(t,e))return;s.uniform3fv(this.addr,e),Sr(t,e)}}function hne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(s.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_r(t,e))return;s.uniform4fv(this.addr,e),Sr(t,e)}}function fne(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(_r(t,e))return;s.uniformMatrix2fv(this.addr,!1,e),Sr(t,e)}else{if(_r(t,n))return;uP.set(n),s.uniformMatrix2fv(this.addr,!1,uP),Sr(t,n)}}function dne(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(_r(t,e))return;s.uniformMatrix3fv(this.addr,!1,e),Sr(t,e)}else{if(_r(t,n))return;lP.set(n),s.uniformMatrix3fv(this.addr,!1,lP),Sr(t,n)}}function pne(s,e){const t=this.cache,n=e.elements;if(n===void 0){if(_r(t,e))return;s.uniformMatrix4fv(this.addr,!1,e),Sr(t,e)}else{if(_r(t,n))return;oP.set(n),s.uniformMatrix4fv(this.addr,!1,oP),Sr(t,n)}}function mne(s,e){const t=this.cache;t[0]!==e&&(s.uniform1i(this.addr,e),t[0]=e)}function gne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(s.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_r(t,e))return;s.uniform2iv(this.addr,e),Sr(t,e)}}function yne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(s.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(_r(t,e))return;s.uniform3iv(this.addr,e),Sr(t,e)}}function xne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(s.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_r(t,e))return;s.uniform4iv(this.addr,e),Sr(t,e)}}function vne(s,e){const t=this.cache;t[0]!==e&&(s.uniform1ui(this.addr,e),t[0]=e)}function bne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(s.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(_r(t,e))return;s.uniform2uiv(this.addr,e),Sr(t,e)}}function _ne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(s.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(_r(t,e))return;s.uniform3uiv(this.addr,e),Sr(t,e)}}function Sne(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(s.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(_r(t,e))return;s.uniform4uiv(this.addr,e),Sr(t,e)}}function Ane(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i);let r;this.type===s.SAMPLER_2D_SHADOW?(iP.compareFunction=k3,r=iP):r=M6,t.setTexture2D(e||r,i)}function Tne(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||R6,i)}function wne(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||I6,i)}function Cne(s,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||N6,i)}function Ene(s){switch(s){case 5126:return lne;case 35664:return une;case 35665:return cne;case 35666:return hne;case 35674:return fne;case 35675:return dne;case 35676:return pne;case 5124:case 35670:return mne;case 35667:case 35671:return gne;case 35668:case 35672:return yne;case 35669:case 35673:return xne;case 5125:return vne;case 36294:return bne;case 36295:return _ne;case 36296:return Sne;case 35678:case 36198:case 36298:case 36306:case 35682:return Ane;case 35679:case 36299:case 36307:return Tne;case 35680:case 36300:case 36308:case 36293:return wne;case 36289:case 36303:case 36311:case 36292:return Cne}}function Mne(s,e){s.uniform1fv(this.addr,e)}function Nne(s,e){const t=Ux(e,this.size,2);s.uniform2fv(this.addr,t)}function Rne(s,e){const t=Ux(e,this.size,3);s.uniform3fv(this.addr,t)}function Ine(s,e){const t=Ux(e,this.size,4);s.uniform4fv(this.addr,t)}function Dne(s,e){const t=Ux(e,this.size,4);s.uniformMatrix2fv(this.addr,!1,t)}function One(s,e){const t=Ux(e,this.size,9);s.uniformMatrix3fv(this.addr,!1,t)}function Bne(s,e){const t=Ux(e,this.size,16);s.uniformMatrix4fv(this.addr,!1,t)}function kne(s,e){s.uniform1iv(this.addr,e)}function Lne(s,e){s.uniform2iv(this.addr,e)}function Fne(s,e){s.uniform3iv(this.addr,e)}function Pne(s,e){s.uniform4iv(this.addr,e)}function Une(s,e){s.uniform1uiv(this.addr,e)}function $ne(s,e){s.uniform2uiv(this.addr,e)}function zne(s,e){s.uniform3uiv(this.addr,e)}function Gne(s,e){s.uniform4uiv(this.addr,e)}function Hne(s,e,t){const n=this.cache,i=e.length,r=ZC(t,i);_r(n,r)||(s.uniform1iv(this.addr,r),Sr(n,r));for(let a=0;a!==i;++a)t.setTexture2D(e[a]||M6,r[a])}function Vne(s,e,t){const n=this.cache,i=e.length,r=ZC(t,i);_r(n,r)||(s.uniform1iv(this.addr,r),Sr(n,r));for(let a=0;a!==i;++a)t.setTexture3D(e[a]||R6,r[a])}function Wne(s,e,t){const n=this.cache,i=e.length,r=ZC(t,i);_r(n,r)||(s.uniform1iv(this.addr,r),Sr(n,r));for(let a=0;a!==i;++a)t.setTextureCube(e[a]||I6,r[a])}function Xne(s,e,t){const n=this.cache,i=e.length,r=ZC(t,i);_r(n,r)||(s.uniform1iv(this.addr,r),Sr(n,r));for(let a=0;a!==i;++a)t.setTexture2DArray(e[a]||N6,r[a])}function qne(s){switch(s){case 5126:return Mne;case 35664:return Nne;case 35665:return Rne;case 35666:return Ine;case 35674:return Dne;case 35675:return One;case 35676:return Bne;case 5124:case 35670:return kne;case 35667:case 35671:return Lne;case 35668:case 35672:return Fne;case 35669:case 35673:return Pne;case 5125:return Une;case 36294:return $ne;case 36295:return zne;case 36296:return Gne;case 35678:case 36198:case 36298:case 36306:case 35682:return Hne;case 35679:case 36299:case 36307:return Vne;case 35680:case 36300:case 36308:case 36293:return Wne;case 36289:case 36303:case 36311:case 36292:return Xne}}class jne{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.setValue=Ene(t.type)}}class Kne{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=qne(t.type)}}class Yne{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const o=i[r];o.setValue(e,t[o.id],n)}}}const ER=/(\w+)(\])?(\[|\.)?/g;function cP(s,e){s.seq.push(e),s.map[e.id]=e}function Jne(s,e,t){const n=s.name,i=n.length;for(ER.lastIndex=0;;){const r=ER.exec(n),a=ER.lastIndex;let o=r[1];const l=r[2]==="]",u=r[3];if(l&&(o=o|0),u===void 0||u==="["&&a+2===i){cP(t,u===void 0?new jne(o,s,e):new Kne(o,s,e));break}else{let f=t.map[o];f===void 0&&(f=new Yne(o),cP(t,f)),t=f}}}class ww{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const r=e.getActiveUniform(t,i),a=e.getUniformLocation(t,r.name);Jne(r,a,this)}}setValue(e,t,n,i){const r=this.map[t];r!==void 0&&r.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let r=0,a=t.length;r!==a;++r){const o=t[r],l=n[o.id];l.needsUpdate!==!1&&o.setValue(e,l.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,r=e.length;i!==r;++i){const a=e[i];a.id in t&&n.push(a)}return n}}function hP(s,e,t){const n=s.createShader(e);return s.shaderSource(n,t),s.compileShader(n),n}const Zne=37297;let Qne=0;function ese(s,e){const t=s.split(`
`),n=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let a=i;a<r;a++){const o=a+1;n.push(`${o===e?">":" "} ${o}: ${t[a]}`)}return n.join(`
`)}const fP=new An;function tse(s){Qn._getMatrix(fP,Qn.workingColorSpace,s);const e=`mat3( ${fP.elements.map(t=>t.toFixed(4))} )`;switch(Qn.getTransfer(s)){case mb:return[e,"LinearTransferOETF"];case Cs:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",s),[e,"LinearTransferOETF"]}}function dP(s,e,t){const n=s.getShaderParameter(e,s.COMPILE_STATUS),i=s.getShaderInfoLog(e).trim();if(n&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const a=parseInt(r[1]);return t.toUpperCase()+`

`+i+`

`+ese(s.getShaderSource(e),a)}else return i}function nse(s,e){const t=tse(e);return[`vec4 ${s}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function sse(s,e){let t;switch(e){case a9:t="Linear";break;case o9:t="Reinhard";break;case l9:t="Cineon";break;case A3:t="ACESFilmic";break;case c9:t="AgX";break;case h9:t="Neutral";break;case u9:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+s+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const ZT=new ae;function ise(){Qn.getLuminanceCoefficients(ZT);const s=ZT.x.toFixed(4),e=ZT.y.toFixed(4),t=ZT.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function rse(s){return[s.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",s.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(G1).join(`
`)}function ase(s){const e=[];for(const t in s){const n=s[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function ose(s,e){const t={},n=s.getProgramParameter(e,s.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const r=s.getActiveAttrib(e,i),a=r.name;let o=1;r.type===s.FLOAT_MAT2&&(o=2),r.type===s.FLOAT_MAT3&&(o=3),r.type===s.FLOAT_MAT4&&(o=4),t[a]={type:r.type,location:s.getAttribLocation(e,a),locationSize:o}}return t}function G1(s){return s!==""}function pP(s,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return s.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function mP(s,e){return s.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const lse=/^[ \t]*#include +<([\w\d./]+)>/gm;function XI(s){return s.replace(lse,cse)}const use=new Map;function cse(s,e){let t=In[e];if(t===void 0){const n=use.get(e);if(n!==void 0)t=In[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,n);else throw new Error("Can not resolve #include <"+e+">")}return XI(t)}const hse=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function gP(s){return s.replace(hse,fse)}function fse(s,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function yP(s){let e=`precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;return s.precision==="highp"?e+=`
#define HIGH_PRECISION`:s.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function dse(s){let e="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===bC?e="SHADOWMAP_TYPE_PCF":s.shadowMapType===J1?e="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===qu&&(e="SHADOWMAP_TYPE_VSM"),e}function pse(s){let e="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case yf:case ep:e="ENVMAP_TYPE_CUBE";break;case Bx:e="ENVMAP_TYPE_CUBE_UV";break}return e}function mse(s){let e="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case ep:e="ENVMAP_MODE_REFRACTION";break}return e}function gse(s){let e="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case Zb:e="ENVMAP_BLENDING_MULTIPLY";break;case i9:e="ENVMAP_BLENDING_MIX";break;case r9:e="ENVMAP_BLENDING_ADD";break}return e}function yse(s){const e=s.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:n,maxMip:t}}function xse(s,e,t,n){const i=s.getContext(),r=t.defines;let a=t.vertexShader,o=t.fragmentShader;const l=dse(t),u=pse(t),c=mse(t),f=gse(t),d=yse(t),g=rse(t),x=ase(r),S=i.createProgram();let b,_,T=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(b=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,x].filter(G1).join(`
`),b.length>0&&(b+=`
`),_=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,x].filter(G1).join(`
`),_.length>0&&(_+=`
`)):(b=[yP(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,x,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(G1).join(`
`),_=[yP(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,x,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+c:"",t.envMap?"#define "+f:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==th?"#define TONE_MAPPING":"",t.toneMapping!==th?In.tonemapping_pars_fragment:"",t.toneMapping!==th?sse("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",In.colorspace_pars_fragment,nse("linearToOutputTexel",t.outputColorSpace),ise(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(G1).join(`
`)),a=XI(a),a=pP(a,t),a=mP(a,t),o=XI(o),o=pP(o,t),o=mP(o,t),a=gP(a),o=gP(o),t.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,b=[g,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+b,_=["#define varying in",t.glslVersion===FI?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===FI?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const E=T+b+a,C=T+_+o,R=hP(i,i.VERTEX_SHADER,E),I=hP(i,i.FRAGMENT_SHADER,C);i.attachShader(S,R),i.attachShader(S,I),t.index0AttributeName!==void 0?i.bindAttribLocation(S,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(S,0,"position"),i.linkProgram(S);function L(F){if(s.debug.checkShaderErrors){const X=i.getProgramInfoLog(S).trim(),q=i.getShaderInfoLog(R).trim(),J=i.getShaderInfoLog(I).trim();let Y=!0,$=!0;if(i.getProgramParameter(S,i.LINK_STATUS)===!1)if(Y=!1,typeof s.debug.onShaderError=="function")s.debug.onShaderError(i,S,R,I);else{const W=dP(i,R,"vertex"),V=dP(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(S,i.VALIDATE_STATUS)+`

Material Name: `+F.name+`
Material Type: `+F.type+`

Program Info Log: `+X+`
`+W+`
`+V)}else X!==""?console.warn("THREE.WebGLProgram: Program Info Log:",X):(q===""||J==="")&&($=!1);$&&(F.diagnostics={runnable:Y,programLog:X,vertexShader:{log:q,prefix:b},fragmentShader:{log:J,prefix:_}})}i.deleteShader(R),i.deleteShader(I),P=new ww(i,S),D=ose(i,S)}let P;this.getUniforms=function(){return P===void 0&&L(this),P};let D;this.getAttributes=function(){return D===void 0&&L(this),D};let O=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return O===!1&&(O=i.getProgramParameter(S,Zne)),O},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(S),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=Qne++,this.cacheKey=e,this.usedTimes=1,this.program=S,this.vertexShader=R,this.fragmentShader=I,this}let vse=0;class bse{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new _se(e),t.set(e,n)),n}}class _se{constructor(e){this.id=vse++,this.code=e,this.usedTimes=0}}function Sse(s,e,t,n,i,r,a){const o=new ux,l=new bse,u=new Set,c=[],f=i.logarithmicDepthBuffer,d=i.vertexTextures;let g=i.precision;const x={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function S(D){return u.add(D),D===0?"uv":`uv${D}`}function b(D,O,F,X,q){const J=X.fog,Y=q.geometry,$=D.isMeshStandardMaterial?X.environment:null,W=(D.isMeshStandardMaterial?t:e).get(D.envMap||$),V=W&&W.mapping===Bx?W.image.height:null,se=x[D.type];D.precision!==null&&(g=i.getMaxPrecision(D.precision),g!==D.precision&&console.warn("THREE.WebGLProgram.getParameters:",D.precision,"not supported, using",g,"instead."));const G=Y.morphAttributes.position||Y.morphAttributes.normal||Y.morphAttributes.color,ne=G!==void 0?G.length:0;let oe=0;Y.morphAttributes.position!==void 0&&(oe=1),Y.morphAttributes.normal!==void 0&&(oe=2),Y.morphAttributes.color!==void 0&&(oe=3);let ue,re,ce,Te;if(se){const _n=ju[se];ue=_n.vertexShader,re=_n.fragmentShader}else ue=D.vertexShader,re=D.fragmentShader,l.update(D),ce=l.getVertexShaderID(D),Te=l.getFragmentShaderID(D);const Be=s.getRenderTarget(),Ke=s.state.buffers.depth.getReversed(),ut=q.isInstancedMesh===!0,ct=q.isBatchedMesh===!0,xt=!!D.map,kt=!!D.matcap,Et=!!W,le=!!D.aoMap,Wt=!!D.lightMap,ze=!!D.bumpMap,Fe=!!D.normalMap,Pe=!!D.displacementMap,ht=!!D.emissiveMap,ke=!!D.metalnessMap,ie=!!D.roughnessMap,j=D.anisotropy>0,Ae=D.clearcoat>0,Ue=D.dispersion>0,Ye=D.iridescence>0,qe=D.sheen>0,mt=D.transmission>0,at=j&&!!D.anisotropyMap,gt=Ae&&!!D.clearcoatMap,dn=Ae&&!!D.clearcoatNormalMap,lt=Ae&&!!D.clearcoatRoughnessMap,Dt=Ye&&!!D.iridescenceMap,Ft=Ye&&!!D.iridescenceThicknessMap,Pt=qe&&!!D.sheenColorMap,vt=qe&&!!D.sheenRoughnessMap,ye=!!D.specularMap,Je=!!D.specularColorMap,_t=!!D.specularIntensityMap,ge=mt&&!!D.transmissionMap,dt=mt&&!!D.thicknessMap,We=!!D.gradientMap,Ze=!!D.alphaMap,Mt=D.alphaTest>0,At=!!D.alphaHash,Kt=!!D.extensions;let Nn=th;D.toneMapped&&(Be===null||Be.isXRRenderTarget===!0)&&(Nn=s.toneMapping);const cs={shaderID:se,shaderType:D.type,shaderName:D.name,vertexShader:ue,fragmentShader:re,defines:D.defines,customVertexShaderID:ce,customFragmentShaderID:Te,isRawShaderMaterial:D.isRawShaderMaterial===!0,glslVersion:D.glslVersion,precision:g,batching:ct,batchingColor:ct&&q._colorsTexture!==null,instancing:ut,instancingColor:ut&&q.instanceColor!==null,instancingMorph:ut&&q.morphTexture!==null,supportsVertexTextures:d,outputColorSpace:Be===null?s.outputColorSpace:Be.isXRRenderTarget===!0?Be.texture.colorSpace:np,alphaToCoverage:!!D.alphaToCoverage,map:xt,matcap:kt,envMap:Et,envMapMode:Et&&W.mapping,envMapCubeUVHeight:V,aoMap:le,lightMap:Wt,bumpMap:ze,normalMap:Fe,displacementMap:d&&Pe,emissiveMap:ht,normalMapObjectSpace:Fe&&D.normalMapType===v9,normalMapTangentSpace:Fe&&D.normalMapType===gp,metalnessMap:ke,roughnessMap:ie,anisotropy:j,anisotropyMap:at,clearcoat:Ae,clearcoatMap:gt,clearcoatNormalMap:dn,clearcoatRoughnessMap:lt,dispersion:Ue,iridescence:Ye,iridescenceMap:Dt,iridescenceThicknessMap:Ft,sheen:qe,sheenColorMap:Pt,sheenRoughnessMap:vt,specularMap:ye,specularColorMap:Je,specularIntensityMap:_t,transmission:mt,transmissionMap:ge,thicknessMap:dt,gradientMap:We,opaque:D.transparent===!1&&D.blending===hg&&D.alphaToCoverage===!1,alphaMap:Ze,alphaTest:Mt,alphaHash:At,combine:D.combine,mapUv:xt&&S(D.map.channel),aoMapUv:le&&S(D.aoMap.channel),lightMapUv:Wt&&S(D.lightMap.channel),bumpMapUv:ze&&S(D.bumpMap.channel),normalMapUv:Fe&&S(D.normalMap.channel),displacementMapUv:Pe&&S(D.displacementMap.channel),emissiveMapUv:ht&&S(D.emissiveMap.channel),metalnessMapUv:ke&&S(D.metalnessMap.channel),roughnessMapUv:ie&&S(D.roughnessMap.channel),anisotropyMapUv:at&&S(D.anisotropyMap.channel),clearcoatMapUv:gt&&S(D.clearcoatMap.channel),clearcoatNormalMapUv:dn&&S(D.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:lt&&S(D.clearcoatRoughnessMap.channel),iridescenceMapUv:Dt&&S(D.iridescenceMap.channel),iridescenceThicknessMapUv:Ft&&S(D.iridescenceThicknessMap.channel),sheenColorMapUv:Pt&&S(D.sheenColorMap.channel),sheenRoughnessMapUv:vt&&S(D.sheenRoughnessMap.channel),specularMapUv:ye&&S(D.specularMap.channel),specularColorMapUv:Je&&S(D.specularColorMap.channel),specularIntensityMapUv:_t&&S(D.specularIntensityMap.channel),transmissionMapUv:ge&&S(D.transmissionMap.channel),thicknessMapUv:dt&&S(D.thicknessMap.channel),alphaMapUv:Ze&&S(D.alphaMap.channel),vertexTangents:!!Y.attributes.tangent&&(Fe||j),vertexColors:D.vertexColors,vertexAlphas:D.vertexColors===!0&&!!Y.attributes.color&&Y.attributes.color.itemSize===4,pointsUvs:q.isPoints===!0&&!!Y.attributes.uv&&(xt||Ze),fog:!!J,useFog:D.fog===!0,fogExp2:!!J&&J.isFogExp2,flatShading:D.flatShading===!0,sizeAttenuation:D.sizeAttenuation===!0,logarithmicDepthBuffer:f,reverseDepthBuffer:Ke,skinning:q.isSkinnedMesh===!0,morphTargets:Y.morphAttributes.position!==void 0,morphNormals:Y.morphAttributes.normal!==void 0,morphColors:Y.morphAttributes.color!==void 0,morphTargetsCount:ne,morphTextureStride:oe,numDirLights:O.directional.length,numPointLights:O.point.length,numSpotLights:O.spot.length,numSpotLightMaps:O.spotLightMap.length,numRectAreaLights:O.rectArea.length,numHemiLights:O.hemi.length,numDirLightShadows:O.directionalShadowMap.length,numPointLightShadows:O.pointShadowMap.length,numSpotLightShadows:O.spotShadowMap.length,numSpotLightShadowsWithMaps:O.numSpotLightShadowsWithMaps,numLightProbes:O.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:D.dithering,shadowMapEnabled:s.shadowMap.enabled&&F.length>0,shadowMapType:s.shadowMap.type,toneMapping:Nn,decodeVideoTexture:xt&&D.map.isVideoTexture===!0&&Qn.getTransfer(D.map.colorSpace)===Cs,decodeVideoTextureEmissive:ht&&D.emissiveMap.isVideoTexture===!0&&Qn.getTransfer(D.emissiveMap.colorSpace)===Cs,premultipliedAlpha:D.premultipliedAlpha,doubleSided:D.side===Ju,flipSided:D.side===so,useDepthPacking:D.depthPacking>=0,depthPacking:D.depthPacking||0,index0AttributeName:D.index0AttributeName,extensionClipCullDistance:Kt&&D.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Kt&&D.extensions.multiDraw===!0||ct)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:D.customProgramCacheKey()};return cs.vertexUv1s=u.has(1),cs.vertexUv2s=u.has(2),cs.vertexUv3s=u.has(3),u.clear(),cs}function _(D){const O=[];if(D.shaderID?O.push(D.shaderID):(O.push(D.customVertexShaderID),O.push(D.customFragmentShaderID)),D.defines!==void 0)for(const F in D.defines)O.push(F),O.push(D.defines[F]);return D.isRawShaderMaterial===!1&&(T(O,D),E(O,D),O.push(s.outputColorSpace)),O.push(D.customProgramCacheKey),O.join()}function T(D,O){D.push(O.precision),D.push(O.outputColorSpace),D.push(O.envMapMode),D.push(O.envMapCubeUVHeight),D.push(O.mapUv),D.push(O.alphaMapUv),D.push(O.lightMapUv),D.push(O.aoMapUv),D.push(O.bumpMapUv),D.push(O.normalMapUv),D.push(O.displacementMapUv),D.push(O.emissiveMapUv),D.push(O.metalnessMapUv),D.push(O.roughnessMapUv),D.push(O.anisotropyMapUv),D.push(O.clearcoatMapUv),D.push(O.clearcoatNormalMapUv),D.push(O.clearcoatRoughnessMapUv),D.push(O.iridescenceMapUv),D.push(O.iridescenceThicknessMapUv),D.push(O.sheenColorMapUv),D.push(O.sheenRoughnessMapUv),D.push(O.specularMapUv),D.push(O.specularColorMapUv),D.push(O.specularIntensityMapUv),D.push(O.transmissionMapUv),D.push(O.thicknessMapUv),D.push(O.combine),D.push(O.fogExp2),D.push(O.sizeAttenuation),D.push(O.morphTargetsCount),D.push(O.morphAttributeCount),D.push(O.numDirLights),D.push(O.numPointLights),D.push(O.numSpotLights),D.push(O.numSpotLightMaps),D.push(O.numHemiLights),D.push(O.numRectAreaLights),D.push(O.numDirLightShadows),D.push(O.numPointLightShadows),D.push(O.numSpotLightShadows),D.push(O.numSpotLightShadowsWithMaps),D.push(O.numLightProbes),D.push(O.shadowMapType),D.push(O.toneMapping),D.push(O.numClippingPlanes),D.push(O.numClipIntersection),D.push(O.depthPacking)}function E(D,O){o.disableAll(),O.supportsVertexTextures&&o.enable(0),O.instancing&&o.enable(1),O.instancingColor&&o.enable(2),O.instancingMorph&&o.enable(3),O.matcap&&o.enable(4),O.envMap&&o.enable(5),O.normalMapObjectSpace&&o.enable(6),O.normalMapTangentSpace&&o.enable(7),O.clearcoat&&o.enable(8),O.iridescence&&o.enable(9),O.alphaTest&&o.enable(10),O.vertexColors&&o.enable(11),O.vertexAlphas&&o.enable(12),O.vertexUv1s&&o.enable(13),O.vertexUv2s&&o.enable(14),O.vertexUv3s&&o.enable(15),O.vertexTangents&&o.enable(16),O.anisotropy&&o.enable(17),O.alphaHash&&o.enable(18),O.batching&&o.enable(19),O.dispersion&&o.enable(20),O.batchingColor&&o.enable(21),D.push(o.mask),o.disableAll(),O.fog&&o.enable(0),O.useFog&&o.enable(1),O.flatShading&&o.enable(2),O.logarithmicDepthBuffer&&o.enable(3),O.reverseDepthBuffer&&o.enable(4),O.skinning&&o.enable(5),O.morphTargets&&o.enable(6),O.morphNormals&&o.enable(7),O.morphColors&&o.enable(8),O.premultipliedAlpha&&o.enable(9),O.shadowMapEnabled&&o.enable(10),O.doubleSided&&o.enable(11),O.flipSided&&o.enable(12),O.useDepthPacking&&o.enable(13),O.dithering&&o.enable(14),O.transmission&&o.enable(15),O.sheen&&o.enable(16),O.opaque&&o.enable(17),O.pointsUvs&&o.enable(18),O.decodeVideoTexture&&o.enable(19),O.decodeVideoTextureEmissive&&o.enable(20),O.alphaToCoverage&&o.enable(21),D.push(o.mask)}function C(D){const O=x[D.type];let F;if(O){const X=ju[O];F=O9.clone(X.uniforms)}else F=D.uniforms;return F}function R(D,O){let F;for(let X=0,q=c.length;X<q;X++){const J=c[X];if(J.cacheKey===O){F=J,++F.usedTimes;break}}return F===void 0&&(F=new xse(s,O,D,r),c.push(F)),F}function I(D){if(--D.usedTimes===0){const O=c.indexOf(D);c[O]=c[c.length-1],c.pop(),D.destroy()}}function L(D){l.remove(D)}function P(){l.dispose()}return{getParameters:b,getProgramCacheKey:_,getUniforms:C,acquireProgram:R,releaseProgram:I,releaseShaderCache:L,programs:c,dispose:P}}function Ase(){let s=new WeakMap;function e(a){return s.has(a)}function t(a){let o=s.get(a);return o===void 0&&(o={},s.set(a,o)),o}function n(a){s.delete(a)}function i(a,o,l){s.get(a)[o]=l}function r(){s=new WeakMap}return{has:e,get:t,remove:n,update:i,dispose:r}}function Tse(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.material.id!==e.material.id?s.material.id-e.material.id:s.z!==e.z?s.z-e.z:s.id-e.id}function xP(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.z!==e.z?e.z-s.z:s.id-e.id}function vP(){const s=[];let e=0;const t=[],n=[],i=[];function r(){e=0,t.length=0,n.length=0,i.length=0}function a(f,d,g,x,S,b){let _=s[e];return _===void 0?(_={id:f.id,object:f,geometry:d,material:g,groupOrder:x,renderOrder:f.renderOrder,z:S,group:b},s[e]=_):(_.id=f.id,_.object=f,_.geometry=d,_.material=g,_.groupOrder=x,_.renderOrder=f.renderOrder,_.z=S,_.group=b),e++,_}function o(f,d,g,x,S,b){const _=a(f,d,g,x,S,b);g.transmission>0?n.push(_):g.transparent===!0?i.push(_):t.push(_)}function l(f,d,g,x,S,b){const _=a(f,d,g,x,S,b);g.transmission>0?n.unshift(_):g.transparent===!0?i.unshift(_):t.unshift(_)}function u(f,d){t.length>1&&t.sort(f||Tse),n.length>1&&n.sort(d||xP),i.length>1&&i.sort(d||xP)}function c(){for(let f=e,d=s.length;f<d;f++){const g=s[f];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.group=null}}return{opaque:t,transmissive:n,transparent:i,init:r,push:o,unshift:l,finish:c,sort:u}}function wse(){let s=new WeakMap;function e(n,i){const r=s.get(n);let a;return r===void 0?(a=new vP,s.set(n,[a])):i>=r.length?(a=new vP,r.push(a)):a=r[i],a}function t(){s=new WeakMap}return{get:e,dispose:t}}function Cse(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new ae,color:new Nt};break;case"SpotLight":t={position:new ae,direction:new ae,color:new Nt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new ae,color:new Nt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new ae,skyColor:new Nt,groundColor:new Nt};break;case"RectAreaLight":t={color:new Nt,position:new ae,halfWidth:new ae,halfHeight:new ae};break}return s[e.id]=t,t}}}function Ese(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[e.id]=t,t}}}let Mse=0;function Nse(s,e){return(e.castShadow?2:0)-(s.castShadow?2:0)+(e.map?1:0)-(s.map?1:0)}function Rse(s){const e=new Cse,t=Ese(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)n.probe.push(new ae);const i=new ae,r=new rn,a=new rn;function o(u){let c=0,f=0,d=0;for(let D=0;D<9;D++)n.probe[D].set(0,0,0);let g=0,x=0,S=0,b=0,_=0,T=0,E=0,C=0,R=0,I=0,L=0;u.sort(Nse);for(let D=0,O=u.length;D<O;D++){const F=u[D],X=F.color,q=F.intensity,J=F.distance,Y=F.shadow&&F.shadow.map?F.shadow.map.texture:null;if(F.isAmbientLight)c+=X.r*q,f+=X.g*q,d+=X.b*q;else if(F.isLightProbe){for(let $=0;$<9;$++)n.probe[$].addScaledVector(F.sh.coefficients[$],q);L++}else if(F.isDirectionalLight){const $=e.get(F);if($.color.copy(F.color).multiplyScalar(F.intensity),F.castShadow){const W=F.shadow,V=t.get(F);V.shadowIntensity=W.intensity,V.shadowBias=W.bias,V.shadowNormalBias=W.normalBias,V.shadowRadius=W.radius,V.shadowMapSize=W.mapSize,n.directionalShadow[g]=V,n.directionalShadowMap[g]=Y,n.directionalShadowMatrix[g]=F.shadow.matrix,T++}n.directional[g]=$,g++}else if(F.isSpotLight){const $=e.get(F);$.position.setFromMatrixPosition(F.matrixWorld),$.color.copy(X).multiplyScalar(q),$.distance=J,$.coneCos=Math.cos(F.angle),$.penumbraCos=Math.cos(F.angle*(1-F.penumbra)),$.decay=F.decay,n.spot[S]=$;const W=F.shadow;if(F.map&&(n.spotLightMap[R]=F.map,R++,W.updateMatrices(F),F.castShadow&&I++),n.spotLightMatrix[S]=W.matrix,F.castShadow){const V=t.get(F);V.shadowIntensity=W.intensity,V.shadowBias=W.bias,V.shadowNormalBias=W.normalBias,V.shadowRadius=W.radius,V.shadowMapSize=W.mapSize,n.spotShadow[S]=V,n.spotShadowMap[S]=Y,C++}S++}else if(F.isRectAreaLight){const $=e.get(F);$.color.copy(X).multiplyScalar(q),$.halfWidth.set(F.width*.5,0,0),$.halfHeight.set(0,F.height*.5,0),n.rectArea[b]=$,b++}else if(F.isPointLight){const $=e.get(F);if($.color.copy(F.color).multiplyScalar(F.intensity),$.distance=F.distance,$.decay=F.decay,F.castShadow){const W=F.shadow,V=t.get(F);V.shadowIntensity=W.intensity,V.shadowBias=W.bias,V.shadowNormalBias=W.normalBias,V.shadowRadius=W.radius,V.shadowMapSize=W.mapSize,V.shadowCameraNear=W.camera.near,V.shadowCameraFar=W.camera.far,n.pointShadow[x]=V,n.pointShadowMap[x]=Y,n.pointShadowMatrix[x]=F.shadow.matrix,E++}n.point[x]=$,x++}else if(F.isHemisphereLight){const $=e.get(F);$.skyColor.copy(F.color).multiplyScalar(q),$.groundColor.copy(F.groundColor).multiplyScalar(q),n.hemi[_]=$,_++}}b>0&&(s.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=It.LTC_FLOAT_1,n.rectAreaLTC2=It.LTC_FLOAT_2):(n.rectAreaLTC1=It.LTC_HALF_1,n.rectAreaLTC2=It.LTC_HALF_2)),n.ambient[0]=c,n.ambient[1]=f,n.ambient[2]=d;const P=n.hash;(P.directionalLength!==g||P.pointLength!==x||P.spotLength!==S||P.rectAreaLength!==b||P.hemiLength!==_||P.numDirectionalShadows!==T||P.numPointShadows!==E||P.numSpotShadows!==C||P.numSpotMaps!==R||P.numLightProbes!==L)&&(n.directional.length=g,n.spot.length=S,n.rectArea.length=b,n.point.length=x,n.hemi.length=_,n.directionalShadow.length=T,n.directionalShadowMap.length=T,n.pointShadow.length=E,n.pointShadowMap.length=E,n.spotShadow.length=C,n.spotShadowMap.length=C,n.directionalShadowMatrix.length=T,n.pointShadowMatrix.length=E,n.spotLightMatrix.length=C+R-I,n.spotLightMap.length=R,n.numSpotLightShadowsWithMaps=I,n.numLightProbes=L,P.directionalLength=g,P.pointLength=x,P.spotLength=S,P.rectAreaLength=b,P.hemiLength=_,P.numDirectionalShadows=T,P.numPointShadows=E,P.numSpotShadows=C,P.numSpotMaps=R,P.numLightProbes=L,n.version=Mse++)}function l(u,c){let f=0,d=0,g=0,x=0,S=0;const b=c.matrixWorldInverse;for(let _=0,T=u.length;_<T;_++){const E=u[_];if(E.isDirectionalLight){const C=n.directional[f];C.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),C.direction.sub(i),C.direction.transformDirection(b),f++}else if(E.isSpotLight){const C=n.spot[g];C.position.setFromMatrixPosition(E.matrixWorld),C.position.applyMatrix4(b),C.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),C.direction.sub(i),C.direction.transformDirection(b),g++}else if(E.isRectAreaLight){const C=n.rectArea[x];C.position.setFromMatrixPosition(E.matrixWorld),C.position.applyMatrix4(b),a.identity(),r.copy(E.matrixWorld),r.premultiply(b),a.extractRotation(r),C.halfWidth.set(E.width*.5,0,0),C.halfHeight.set(0,E.height*.5,0),C.halfWidth.applyMatrix4(a),C.halfHeight.applyMatrix4(a),x++}else if(E.isPointLight){const C=n.point[d];C.position.setFromMatrixPosition(E.matrixWorld),C.position.applyMatrix4(b),d++}else if(E.isHemisphereLight){const C=n.hemi[S];C.direction.setFromMatrixPosition(E.matrixWorld),C.direction.transformDirection(b),S++}}}return{setup:o,setupView:l,state:n}}function bP(s){const e=new Rse(s),t=[],n=[];function i(c){u.camera=c,t.length=0,n.length=0}function r(c){t.push(c)}function a(c){n.push(c)}function o(){e.setup(t)}function l(c){e.setupView(t,c)}const u={lightsArray:t,shadowsArray:n,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:u,setupLights:o,setupLightsView:l,pushLight:r,pushShadow:a}}function Ise(s){let e=new WeakMap;function t(i,r=0){const a=e.get(i);let o;return a===void 0?(o=new bP(s),e.set(i,[o])):r>=a.length?(o=new bP(s),a.push(o)):o=a[r],o}function n(){e=new WeakMap}return{get:t,dispose:n}}const Dse=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Ose=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Bse(s,e,t){let n=new i_;const i=new tt,r=new tt,a=new os,o=new Z3({depthPacking:x9}),l=new Q3,u={},c=t.maxTextureSize,f={[ch]:so,[so]:ch,[Ju]:Ju},d=new sc({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new tt},radius:{value:4}},vertexShader:Dse,fragmentShader:Ose}),g=d.clone();g.defines.HORIZONTAL_PASS=1;const x=new Tn;x.setAttribute("position",new us(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const S=new zi(x,d),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=bC;let _=this.type;this.render=function(I,L,P){if(b.enabled===!1||b.autoUpdate===!1&&b.needsUpdate===!1||I.length===0)return;const D=s.getRenderTarget(),O=s.getActiveCubeFace(),F=s.getActiveMipmapLevel(),X=s.state;X.setBlending(cf),X.buffers.color.setClear(1,1,1,1),X.buffers.depth.setTest(!0),X.setScissorTest(!1);const q=_!==qu&&this.type===qu,J=_===qu&&this.type!==qu;for(let Y=0,$=I.length;Y<$;Y++){const W=I[Y],V=W.shadow;if(V===void 0){console.warn("THREE.WebGLShadowMap:",W,"has no shadow.");continue}if(V.autoUpdate===!1&&V.needsUpdate===!1)continue;i.copy(V.mapSize);const se=V.getFrameExtents();if(i.multiply(se),r.copy(V.mapSize),(i.x>c||i.y>c)&&(i.x>c&&(r.x=Math.floor(c/se.x),i.x=r.x*se.x,V.mapSize.x=r.x),i.y>c&&(r.y=Math.floor(c/se.y),i.y=r.y*se.y,V.mapSize.y=r.y)),V.map===null||q===!0||J===!0){const ne=this.type!==qu?{minFilter:Br,magFilter:Br}:{};V.map!==null&&V.map.dispose(),V.map=new hh(i.x,i.y,ne),V.map.texture.name=W.name+".shadowMap",V.camera.updateProjectionMatrix()}s.setRenderTarget(V.map),s.clear();const G=V.getViewportCount();for(let ne=0;ne<G;ne++){const oe=V.getViewport(ne);a.set(r.x*oe.x,r.y*oe.y,r.x*oe.z,r.y*oe.w),X.viewport(a),V.updateMatrices(W,ne),n=V.getFrustum(),C(L,P,V.camera,W,this.type)}V.isPointLightShadow!==!0&&this.type===qu&&T(V,P),V.needsUpdate=!1}_=this.type,b.needsUpdate=!1,s.setRenderTarget(D,O,F)};function T(I,L){const P=e.update(S);d.defines.VSM_SAMPLES!==I.blurSamples&&(d.defines.VSM_SAMPLES=I.blurSamples,g.defines.VSM_SAMPLES=I.blurSamples,d.needsUpdate=!0,g.needsUpdate=!0),I.mapPass===null&&(I.mapPass=new hh(i.x,i.y)),d.uniforms.shadow_pass.value=I.map.texture,d.uniforms.resolution.value=I.mapSize,d.uniforms.radius.value=I.radius,s.setRenderTarget(I.mapPass),s.clear(),s.renderBufferDirect(L,null,P,d,S,null),g.uniforms.shadow_pass.value=I.mapPass.texture,g.uniforms.resolution.value=I.mapSize,g.uniforms.radius.value=I.radius,s.setRenderTarget(I.map),s.clear(),s.renderBufferDirect(L,null,P,g,S,null)}function E(I,L,P,D){let O=null;const F=P.isPointLight===!0?I.customDistanceMaterial:I.customDepthMaterial;if(F!==void 0)O=F;else if(O=P.isPointLight===!0?l:o,s.localClippingEnabled&&L.clipShadows===!0&&Array.isArray(L.clippingPlanes)&&L.clippingPlanes.length!==0||L.displacementMap&&L.displacementScale!==0||L.alphaMap&&L.alphaTest>0||L.map&&L.alphaTest>0){const X=O.uuid,q=L.uuid;let J=u[X];J===void 0&&(J={},u[X]=J);let Y=J[q];Y===void 0&&(Y=O.clone(),J[q]=Y,L.addEventListener("dispose",R)),O=Y}if(O.visible=L.visible,O.wireframe=L.wireframe,D===qu?O.side=L.shadowSide!==null?L.shadowSide:L.side:O.side=L.shadowSide!==null?L.shadowSide:f[L.side],O.alphaMap=L.alphaMap,O.alphaTest=L.alphaTest,O.map=L.map,O.clipShadows=L.clipShadows,O.clippingPlanes=L.clippingPlanes,O.clipIntersection=L.clipIntersection,O.displacementMap=L.displacementMap,O.displacementScale=L.displacementScale,O.displacementBias=L.displacementBias,O.wireframeLinewidth=L.wireframeLinewidth,O.linewidth=L.linewidth,P.isPointLight===!0&&O.isMeshDistanceMaterial===!0){const X=s.properties.get(O);X.light=P}return O}function C(I,L,P,D,O){if(I.visible===!1)return;if(I.layers.test(L.layers)&&(I.isMesh||I.isLine||I.isPoints)&&(I.castShadow||I.receiveShadow&&O===qu)&&(!I.frustumCulled||n.intersectsObject(I))){I.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse,I.matrixWorld);const q=e.update(I),J=I.material;if(Array.isArray(J)){const Y=q.groups;for(let $=0,W=Y.length;$<W;$++){const V=Y[$],se=J[V.materialIndex];if(se&&se.visible){const G=E(I,se,D,O);I.onBeforeShadow(s,I,L,P,q,G,V),s.renderBufferDirect(P,null,q,G,I,V),I.onAfterShadow(s,I,L,P,q,G,V)}}}else if(J.visible){const Y=E(I,J,D,O);I.onBeforeShadow(s,I,L,P,q,Y,null),s.renderBufferDirect(P,null,q,Y,I,null),I.onAfterShadow(s,I,L,P,q,Y,null)}}const X=I.children;for(let q=0,J=X.length;q<J;q++)C(X[q],L,P,D,O)}function R(I){I.target.removeEventListener("dispose",R);for(const P in u){const D=u[P],O=I.target.uuid;O in D&&(D[O].dispose(),delete D[O])}}}const kse={[Ww]:Xw,[qw]:Yw,[jw]:Jw,[Sg]:Kw,[Xw]:Ww,[Yw]:qw,[Jw]:jw,[Kw]:Sg};function Lse(s,e){function t(){let ge=!1;const dt=new os;let We=null;const Ze=new os(0,0,0,0);return{setMask:function(Mt){We!==Mt&&!ge&&(s.colorMask(Mt,Mt,Mt,Mt),We=Mt)},setLocked:function(Mt){ge=Mt},setClear:function(Mt,At,Kt,Nn,cs){cs===!0&&(Mt*=Nn,At*=Nn,Kt*=Nn),dt.set(Mt,At,Kt,Nn),Ze.equals(dt)===!1&&(s.clearColor(Mt,At,Kt,Nn),Ze.copy(dt))},reset:function(){ge=!1,We=null,Ze.set(-1,0,0,0)}}}function n(){let ge=!1,dt=!1,We=null,Ze=null,Mt=null;return{setReversed:function(At){if(dt!==At){const Kt=e.get("EXT_clip_control");At?Kt.clipControlEXT(Kt.LOWER_LEFT_EXT,Kt.ZERO_TO_ONE_EXT):Kt.clipControlEXT(Kt.LOWER_LEFT_EXT,Kt.NEGATIVE_ONE_TO_ONE_EXT),dt=At;const Nn=Mt;Mt=null,this.setClear(Nn)}},getReversed:function(){return dt},setTest:function(At){At?Be(s.DEPTH_TEST):Ke(s.DEPTH_TEST)},setMask:function(At){We!==At&&!ge&&(s.depthMask(At),We=At)},setFunc:function(At){if(dt&&(At=kse[At]),Ze!==At){switch(At){case Ww:s.depthFunc(s.NEVER);break;case Xw:s.depthFunc(s.ALWAYS);break;case qw:s.depthFunc(s.LESS);break;case Sg:s.depthFunc(s.LEQUAL);break;case jw:s.depthFunc(s.EQUAL);break;case Kw:s.depthFunc(s.GEQUAL);break;case Yw:s.depthFunc(s.GREATER);break;case Jw:s.depthFunc(s.NOTEQUAL);break;default:s.depthFunc(s.LEQUAL)}Ze=At}},setLocked:function(At){ge=At},setClear:function(At){Mt!==At&&(dt&&(At=1-At),s.clearDepth(At),Mt=At)},reset:function(){ge=!1,We=null,Ze=null,Mt=null,dt=!1}}}function i(){let ge=!1,dt=null,We=null,Ze=null,Mt=null,At=null,Kt=null,Nn=null,cs=null;return{setTest:function(_n){ge||(_n?Be(s.STENCIL_TEST):Ke(s.STENCIL_TEST))},setMask:function(_n){dt!==_n&&!ge&&(s.stencilMask(_n),dt=_n)},setFunc:function(_n,xi,$s){(We!==_n||Ze!==xi||Mt!==$s)&&(s.stencilFunc(_n,xi,$s),We=_n,Ze=xi,Mt=$s)},setOp:function(_n,xi,$s){(At!==_n||Kt!==xi||Nn!==$s)&&(s.stencilOp(_n,xi,$s),At=_n,Kt=xi,Nn=$s)},setLocked:function(_n){ge=_n},setClear:function(_n){cs!==_n&&(s.clearStencil(_n),cs=_n)},reset:function(){ge=!1,dt=null,We=null,Ze=null,Mt=null,At=null,Kt=null,Nn=null,cs=null}}}const r=new t,a=new n,o=new i,l=new WeakMap,u=new WeakMap;let c={},f={},d=new WeakMap,g=[],x=null,S=!1,b=null,_=null,T=null,E=null,C=null,R=null,I=null,L=new Nt(0,0,0),P=0,D=!1,O=null,F=null,X=null,q=null,J=null;const Y=s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let $=!1,W=0;const V=s.getParameter(s.VERSION);V.indexOf("WebGL")!==-1?(W=parseFloat(/^WebGL (\d)/.exec(V)[1]),$=W>=1):V.indexOf("OpenGL ES")!==-1&&(W=parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),$=W>=2);let se=null,G={};const ne=s.getParameter(s.SCISSOR_BOX),oe=s.getParameter(s.VIEWPORT),ue=new os().fromArray(ne),re=new os().fromArray(oe);function ce(ge,dt,We,Ze){const Mt=new Uint8Array(4),At=s.createTexture();s.bindTexture(ge,At),s.texParameteri(ge,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(ge,s.TEXTURE_MAG_FILTER,s.NEAREST);for(let Kt=0;Kt<We;Kt++)ge===s.TEXTURE_3D||ge===s.TEXTURE_2D_ARRAY?s.texImage3D(dt,0,s.RGBA,1,1,Ze,0,s.RGBA,s.UNSIGNED_BYTE,Mt):s.texImage2D(dt+Kt,0,s.RGBA,1,1,0,s.RGBA,s.UNSIGNED_BYTE,Mt);return At}const Te={};Te[s.TEXTURE_2D]=ce(s.TEXTURE_2D,s.TEXTURE_2D,1),Te[s.TEXTURE_CUBE_MAP]=ce(s.TEXTURE_CUBE_MAP,s.TEXTURE_CUBE_MAP_POSITIVE_X,6),Te[s.TEXTURE_2D_ARRAY]=ce(s.TEXTURE_2D_ARRAY,s.TEXTURE_2D_ARRAY,1,1),Te[s.TEXTURE_3D]=ce(s.TEXTURE_3D,s.TEXTURE_3D,1,1),r.setClear(0,0,0,1),a.setClear(1),o.setClear(0),Be(s.DEPTH_TEST),a.setFunc(Sg),ze(!1),Fe(II),Be(s.CULL_FACE),le(cf);function Be(ge){c[ge]!==!0&&(s.enable(ge),c[ge]=!0)}function Ke(ge){c[ge]!==!1&&(s.disable(ge),c[ge]=!1)}function ut(ge,dt){return f[ge]!==dt?(s.bindFramebuffer(ge,dt),f[ge]=dt,ge===s.DRAW_FRAMEBUFFER&&(f[s.FRAMEBUFFER]=dt),ge===s.FRAMEBUFFER&&(f[s.DRAW_FRAMEBUFFER]=dt),!0):!1}function ct(ge,dt){let We=g,Ze=!1;if(ge){We=d.get(dt),We===void 0&&(We=[],d.set(dt,We));const Mt=ge.textures;if(We.length!==Mt.length||We[0]!==s.COLOR_ATTACHMENT0){for(let At=0,Kt=Mt.length;At<Kt;At++)We[At]=s.COLOR_ATTACHMENT0+At;We.length=Mt.length,Ze=!0}}else We[0]!==s.BACK&&(We[0]=s.BACK,Ze=!0);Ze&&s.drawBuffers(We)}function xt(ge){return x!==ge?(s.useProgram(ge),x=ge,!0):!1}const kt={[Ld]:s.FUNC_ADD,[zz]:s.FUNC_SUBTRACT,[Gz]:s.FUNC_REVERSE_SUBTRACT};kt[Hz]=s.MIN,kt[Vz]=s.MAX;const Et={[Wz]:s.ZERO,[Xz]:s.ONE,[qz]:s.SRC_COLOR,[Hw]:s.SRC_ALPHA,[Qz]:s.SRC_ALPHA_SATURATE,[Jz]:s.DST_COLOR,[Kz]:s.DST_ALPHA,[jz]:s.ONE_MINUS_SRC_COLOR,[Vw]:s.ONE_MINUS_SRC_ALPHA,[Zz]:s.ONE_MINUS_DST_COLOR,[Yz]:s.ONE_MINUS_DST_ALPHA,[e9]:s.CONSTANT_COLOR,[t9]:s.ONE_MINUS_CONSTANT_COLOR,[n9]:s.CONSTANT_ALPHA,[s9]:s.ONE_MINUS_CONSTANT_ALPHA};function le(ge,dt,We,Ze,Mt,At,Kt,Nn,cs,_n){if(ge===cf){S===!0&&(Ke(s.BLEND),S=!1);return}if(S===!1&&(Be(s.BLEND),S=!0),ge!==$z){if(ge!==b||_n!==D){if((_!==Ld||C!==Ld)&&(s.blendEquation(s.FUNC_ADD),_=Ld,C=Ld),_n)switch(ge){case hg:s.blendFuncSeparate(s.ONE,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case DI:s.blendFunc(s.ONE,s.ONE);break;case OI:s.blendFuncSeparate(s.ZERO,s.ONE_MINUS_SRC_COLOR,s.ZERO,s.ONE);break;case BI:s.blendFuncSeparate(s.ZERO,s.SRC_COLOR,s.ZERO,s.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ge);break}else switch(ge){case hg:s.blendFuncSeparate(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case DI:s.blendFunc(s.SRC_ALPHA,s.ONE);break;case OI:s.blendFuncSeparate(s.ZERO,s.ONE_MINUS_SRC_COLOR,s.ZERO,s.ONE);break;case BI:s.blendFunc(s.ZERO,s.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ge);break}T=null,E=null,R=null,I=null,L.set(0,0,0),P=0,b=ge,D=_n}return}Mt=Mt||dt,At=At||We,Kt=Kt||Ze,(dt!==_||Mt!==C)&&(s.blendEquationSeparate(kt[dt],kt[Mt]),_=dt,C=Mt),(We!==T||Ze!==E||At!==R||Kt!==I)&&(s.blendFuncSeparate(Et[We],Et[Ze],Et[At],Et[Kt]),T=We,E=Ze,R=At,I=Kt),(Nn.equals(L)===!1||cs!==P)&&(s.blendColor(Nn.r,Nn.g,Nn.b,cs),L.copy(Nn),P=cs),b=ge,D=!1}function Wt(ge,dt){ge.side===Ju?Ke(s.CULL_FACE):Be(s.CULL_FACE);let We=ge.side===so;dt&&(We=!We),ze(We),ge.blending===hg&&ge.transparent===!1?le(cf):le(ge.blending,ge.blendEquation,ge.blendSrc,ge.blendDst,ge.blendEquationAlpha,ge.blendSrcAlpha,ge.blendDstAlpha,ge.blendColor,ge.blendAlpha,ge.premultipliedAlpha),a.setFunc(ge.depthFunc),a.setTest(ge.depthTest),a.setMask(ge.depthWrite),r.setMask(ge.colorWrite);const Ze=ge.stencilWrite;o.setTest(Ze),Ze&&(o.setMask(ge.stencilWriteMask),o.setFunc(ge.stencilFunc,ge.stencilRef,ge.stencilFuncMask),o.setOp(ge.stencilFail,ge.stencilZFail,ge.stencilZPass)),ht(ge.polygonOffset,ge.polygonOffsetFactor,ge.polygonOffsetUnits),ge.alphaToCoverage===!0?Be(s.SAMPLE_ALPHA_TO_COVERAGE):Ke(s.SAMPLE_ALPHA_TO_COVERAGE)}function ze(ge){O!==ge&&(ge?s.frontFace(s.CW):s.frontFace(s.CCW),O=ge)}function Fe(ge){ge!==Fz?(Be(s.CULL_FACE),ge!==F&&(ge===II?s.cullFace(s.BACK):ge===Pz?s.cullFace(s.FRONT):s.cullFace(s.FRONT_AND_BACK))):Ke(s.CULL_FACE),F=ge}function Pe(ge){ge!==X&&($&&s.lineWidth(ge),X=ge)}function ht(ge,dt,We){ge?(Be(s.POLYGON_OFFSET_FILL),(q!==dt||J!==We)&&(s.polygonOffset(dt,We),q=dt,J=We)):Ke(s.POLYGON_OFFSET_FILL)}function ke(ge){ge?Be(s.SCISSOR_TEST):Ke(s.SCISSOR_TEST)}function ie(ge){ge===void 0&&(ge=s.TEXTURE0+Y-1),se!==ge&&(s.activeTexture(ge),se=ge)}function j(ge,dt,We){We===void 0&&(se===null?We=s.TEXTURE0+Y-1:We=se);let Ze=G[We];Ze===void 0&&(Ze={type:void 0,texture:void 0},G[We]=Ze),(Ze.type!==ge||Ze.texture!==dt)&&(se!==We&&(s.activeTexture(We),se=We),s.bindTexture(ge,dt||Te[ge]),Ze.type=ge,Ze.texture=dt)}function Ae(){const ge=G[se];ge!==void 0&&ge.type!==void 0&&(s.bindTexture(ge.type,null),ge.type=void 0,ge.texture=void 0)}function Ue(){try{s.compressedTexImage2D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Ye(){try{s.compressedTexImage3D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function qe(){try{s.texSubImage2D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function mt(){try{s.texSubImage3D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function at(){try{s.compressedTexSubImage2D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function gt(){try{s.compressedTexSubImage3D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function dn(){try{s.texStorage2D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function lt(){try{s.texStorage3D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Dt(){try{s.texImage2D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Ft(){try{s.texImage3D(...arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Pt(ge){ue.equals(ge)===!1&&(s.scissor(ge.x,ge.y,ge.z,ge.w),ue.copy(ge))}function vt(ge){re.equals(ge)===!1&&(s.viewport(ge.x,ge.y,ge.z,ge.w),re.copy(ge))}function ye(ge,dt){let We=u.get(dt);We===void 0&&(We=new WeakMap,u.set(dt,We));let Ze=We.get(ge);Ze===void 0&&(Ze=s.getUniformBlockIndex(dt,ge.name),We.set(ge,Ze))}function Je(ge,dt){const Ze=u.get(dt).get(ge);l.get(dt)!==Ze&&(s.uniformBlockBinding(dt,Ze,ge.__bindingPointIndex),l.set(dt,Ze))}function _t(){s.disable(s.BLEND),s.disable(s.CULL_FACE),s.disable(s.DEPTH_TEST),s.disable(s.POLYGON_OFFSET_FILL),s.disable(s.SCISSOR_TEST),s.disable(s.STENCIL_TEST),s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),s.blendEquation(s.FUNC_ADD),s.blendFunc(s.ONE,s.ZERO),s.blendFuncSeparate(s.ONE,s.ZERO,s.ONE,s.ZERO),s.blendColor(0,0,0,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(s.LESS),a.setReversed(!1),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(s.ALWAYS,0,4294967295),s.stencilOp(s.KEEP,s.KEEP,s.KEEP),s.clearStencil(0),s.cullFace(s.BACK),s.frontFace(s.CCW),s.polygonOffset(0,0),s.activeTexture(s.TEXTURE0),s.bindFramebuffer(s.FRAMEBUFFER,null),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),s.bindFramebuffer(s.READ_FRAMEBUFFER,null),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),c={},se=null,G={},f={},d=new WeakMap,g=[],x=null,S=!1,b=null,_=null,T=null,E=null,C=null,R=null,I=null,L=new Nt(0,0,0),P=0,D=!1,O=null,F=null,X=null,q=null,J=null,ue.set(0,0,s.canvas.width,s.canvas.height),re.set(0,0,s.canvas.width,s.canvas.height),r.reset(),a.reset(),o.reset()}return{buffers:{color:r,depth:a,stencil:o},enable:Be,disable:Ke,bindFramebuffer:ut,drawBuffers:ct,useProgram:xt,setBlending:le,setMaterial:Wt,setFlipSided:ze,setCullFace:Fe,setLineWidth:Pe,setPolygonOffset:ht,setScissorTest:ke,activeTexture:ie,bindTexture:j,unbindTexture:Ae,compressedTexImage2D:Ue,compressedTexImage3D:Ye,texImage2D:Dt,texImage3D:Ft,updateUBOMapping:ye,uniformBlockBinding:Je,texStorage2D:dn,texStorage3D:lt,texSubImage2D:qe,texSubImage3D:mt,compressedTexSubImage2D:at,compressedTexSubImage3D:gt,scissor:Pt,viewport:vt,reset:_t}}function Fse(s,e,t,n,i,r,a){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),u=new tt,c=new WeakMap;let f;const d=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function x(ie,j){return g?new OffscreenCanvas(ie,j):xb("canvas")}function S(ie,j,Ae){let Ue=1;const Ye=ke(ie);if((Ye.width>Ae||Ye.height>Ae)&&(Ue=Ae/Math.max(Ye.width,Ye.height)),Ue<1)if(typeof HTMLImageElement<"u"&&ie instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ie instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ie instanceof ImageBitmap||typeof VideoFrame<"u"&&ie instanceof VideoFrame){const qe=Math.floor(Ue*Ye.width),mt=Math.floor(Ue*Ye.height);f===void 0&&(f=x(qe,mt));const at=j?x(qe,mt):f;return at.width=qe,at.height=mt,at.getContext("2d").drawImage(ie,0,0,qe,mt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Ye.width+"x"+Ye.height+") to ("+qe+"x"+mt+")."),at}else return"data"in ie&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Ye.width+"x"+Ye.height+")."),ie;return ie}function b(ie){return ie.generateMipmaps}function _(ie){s.generateMipmap(ie)}function T(ie){return ie.isWebGLCubeRenderTarget?s.TEXTURE_CUBE_MAP:ie.isWebGL3DRenderTarget?s.TEXTURE_3D:ie.isWebGLArrayRenderTarget||ie.isCompressedArrayTexture?s.TEXTURE_2D_ARRAY:s.TEXTURE_2D}function E(ie,j,Ae,Ue,Ye=!1){if(ie!==null){if(s[ie]!==void 0)return s[ie];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ie+"'")}let qe=j;if(j===s.RED&&(Ae===s.FLOAT&&(qe=s.R32F),Ae===s.HALF_FLOAT&&(qe=s.R16F),Ae===s.UNSIGNED_BYTE&&(qe=s.R8)),j===s.RED_INTEGER&&(Ae===s.UNSIGNED_BYTE&&(qe=s.R8UI),Ae===s.UNSIGNED_SHORT&&(qe=s.R16UI),Ae===s.UNSIGNED_INT&&(qe=s.R32UI),Ae===s.BYTE&&(qe=s.R8I),Ae===s.SHORT&&(qe=s.R16I),Ae===s.INT&&(qe=s.R32I)),j===s.RG&&(Ae===s.FLOAT&&(qe=s.RG32F),Ae===s.HALF_FLOAT&&(qe=s.RG16F),Ae===s.UNSIGNED_BYTE&&(qe=s.RG8)),j===s.RG_INTEGER&&(Ae===s.UNSIGNED_BYTE&&(qe=s.RG8UI),Ae===s.UNSIGNED_SHORT&&(qe=s.RG16UI),Ae===s.UNSIGNED_INT&&(qe=s.RG32UI),Ae===s.BYTE&&(qe=s.RG8I),Ae===s.SHORT&&(qe=s.RG16I),Ae===s.INT&&(qe=s.RG32I)),j===s.RGB_INTEGER&&(Ae===s.UNSIGNED_BYTE&&(qe=s.RGB8UI),Ae===s.UNSIGNED_SHORT&&(qe=s.RGB16UI),Ae===s.UNSIGNED_INT&&(qe=s.RGB32UI),Ae===s.BYTE&&(qe=s.RGB8I),Ae===s.SHORT&&(qe=s.RGB16I),Ae===s.INT&&(qe=s.RGB32I)),j===s.RGBA_INTEGER&&(Ae===s.UNSIGNED_BYTE&&(qe=s.RGBA8UI),Ae===s.UNSIGNED_SHORT&&(qe=s.RGBA16UI),Ae===s.UNSIGNED_INT&&(qe=s.RGBA32UI),Ae===s.BYTE&&(qe=s.RGBA8I),Ae===s.SHORT&&(qe=s.RGBA16I),Ae===s.INT&&(qe=s.RGBA32I)),j===s.RGB&&Ae===s.UNSIGNED_INT_5_9_9_9_REV&&(qe=s.RGB9_E5),j===s.RGBA){const mt=Ye?mb:Qn.getTransfer(Ue);Ae===s.FLOAT&&(qe=s.RGBA32F),Ae===s.HALF_FLOAT&&(qe=s.RGBA16F),Ae===s.UNSIGNED_BYTE&&(qe=mt===Cs?s.SRGB8_ALPHA8:s.RGBA8),Ae===s.UNSIGNED_SHORT_4_4_4_4&&(qe=s.RGBA4),Ae===s.UNSIGNED_SHORT_5_5_5_1&&(qe=s.RGB5_A1)}return(qe===s.R16F||qe===s.R32F||qe===s.RG16F||qe===s.RG32F||qe===s.RGBA16F||qe===s.RGBA32F)&&e.get("EXT_color_buffer_float"),qe}function C(ie,j){let Ae;return ie?j===null||j===xf||j===sx?Ae=s.DEPTH24_STENCIL8:j===Eo?Ae=s.DEPTH32F_STENCIL8:j===nx&&(Ae=s.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):j===null||j===xf||j===sx?Ae=s.DEPTH_COMPONENT24:j===Eo?Ae=s.DEPTH_COMPONENT32F:j===nx&&(Ae=s.DEPTH_COMPONENT16),Ae}function R(ie,j){return b(ie)===!0||ie.isFramebufferTexture&&ie.minFilter!==Br&&ie.minFilter!==$i?Math.log2(Math.max(j.width,j.height))+1:ie.mipmaps!==void 0&&ie.mipmaps.length>0?ie.mipmaps.length:ie.isCompressedTexture&&Array.isArray(ie.image)?j.mipmaps.length:1}function I(ie){const j=ie.target;j.removeEventListener("dispose",I),P(j),j.isVideoTexture&&c.delete(j)}function L(ie){const j=ie.target;j.removeEventListener("dispose",L),O(j)}function P(ie){const j=n.get(ie);if(j.__webglInit===void 0)return;const Ae=ie.source,Ue=d.get(Ae);if(Ue){const Ye=Ue[j.__cacheKey];Ye.usedTimes--,Ye.usedTimes===0&&D(ie),Object.keys(Ue).length===0&&d.delete(Ae)}n.remove(ie)}function D(ie){const j=n.get(ie);s.deleteTexture(j.__webglTexture);const Ae=ie.source,Ue=d.get(Ae);delete Ue[j.__cacheKey],a.memory.textures--}function O(ie){const j=n.get(ie);if(ie.depthTexture&&(ie.depthTexture.dispose(),n.remove(ie.depthTexture)),ie.isWebGLCubeRenderTarget)for(let Ue=0;Ue<6;Ue++){if(Array.isArray(j.__webglFramebuffer[Ue]))for(let Ye=0;Ye<j.__webglFramebuffer[Ue].length;Ye++)s.deleteFramebuffer(j.__webglFramebuffer[Ue][Ye]);else s.deleteFramebuffer(j.__webglFramebuffer[Ue]);j.__webglDepthbuffer&&s.deleteRenderbuffer(j.__webglDepthbuffer[Ue])}else{if(Array.isArray(j.__webglFramebuffer))for(let Ue=0;Ue<j.__webglFramebuffer.length;Ue++)s.deleteFramebuffer(j.__webglFramebuffer[Ue]);else s.deleteFramebuffer(j.__webglFramebuffer);if(j.__webglDepthbuffer&&s.deleteRenderbuffer(j.__webglDepthbuffer),j.__webglMultisampledFramebuffer&&s.deleteFramebuffer(j.__webglMultisampledFramebuffer),j.__webglColorRenderbuffer)for(let Ue=0;Ue<j.__webglColorRenderbuffer.length;Ue++)j.__webglColorRenderbuffer[Ue]&&s.deleteRenderbuffer(j.__webglColorRenderbuffer[Ue]);j.__webglDepthRenderbuffer&&s.deleteRenderbuffer(j.__webglDepthRenderbuffer)}const Ae=ie.textures;for(let Ue=0,Ye=Ae.length;Ue<Ye;Ue++){const qe=n.get(Ae[Ue]);qe.__webglTexture&&(s.deleteTexture(qe.__webglTexture),a.memory.textures--),n.remove(Ae[Ue])}n.remove(ie)}let F=0;function X(){F=0}function q(){const ie=F;return ie>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+ie+" texture units while this GPU supports only "+i.maxTextures),F+=1,ie}function J(ie){const j=[];return j.push(ie.wrapS),j.push(ie.wrapT),j.push(ie.wrapR||0),j.push(ie.magFilter),j.push(ie.minFilter),j.push(ie.anisotropy),j.push(ie.internalFormat),j.push(ie.format),j.push(ie.type),j.push(ie.generateMipmaps),j.push(ie.premultiplyAlpha),j.push(ie.flipY),j.push(ie.unpackAlignment),j.push(ie.colorSpace),j.join()}function Y(ie,j){const Ae=n.get(ie);if(ie.isVideoTexture&&Pe(ie),ie.isRenderTargetTexture===!1&&ie.version>0&&Ae.__version!==ie.version){const Ue=ie.image;if(Ue===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ue.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{re(Ae,ie,j);return}}t.bindTexture(s.TEXTURE_2D,Ae.__webglTexture,s.TEXTURE0+j)}function $(ie,j){const Ae=n.get(ie);if(ie.version>0&&Ae.__version!==ie.version){re(Ae,ie,j);return}t.bindTexture(s.TEXTURE_2D_ARRAY,Ae.__webglTexture,s.TEXTURE0+j)}function W(ie,j){const Ae=n.get(ie);if(ie.version>0&&Ae.__version!==ie.version){re(Ae,ie,j);return}t.bindTexture(s.TEXTURE_3D,Ae.__webglTexture,s.TEXTURE0+j)}function V(ie,j){const Ae=n.get(ie);if(ie.version>0&&Ae.__version!==ie.version){ce(Ae,ie,j);return}t.bindTexture(s.TEXTURE_CUBE_MAP,Ae.__webglTexture,s.TEXTURE0+j)}const se={[tp]:s.REPEAT,[hl]:s.CLAMP_TO_EDGE,[tx]:s.MIRRORED_REPEAT},G={[Br]:s.NEAREST,[SC]:s.NEAREST_MIPMAP_NEAREST,[ng]:s.NEAREST_MIPMAP_LINEAR,[$i]:s.LINEAR,[Gy]:s.LINEAR_MIPMAP_NEAREST,[tu]:s.LINEAR_MIPMAP_LINEAR},ne={[b9]:s.NEVER,[C9]:s.ALWAYS,[_9]:s.LESS,[k3]:s.LEQUAL,[S9]:s.EQUAL,[w9]:s.GEQUAL,[A9]:s.GREATER,[T9]:s.NOTEQUAL};function oe(ie,j){if(j.type===Eo&&e.has("OES_texture_float_linear")===!1&&(j.magFilter===$i||j.magFilter===Gy||j.magFilter===ng||j.magFilter===tu||j.minFilter===$i||j.minFilter===Gy||j.minFilter===ng||j.minFilter===tu)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),s.texParameteri(ie,s.TEXTURE_WRAP_S,se[j.wrapS]),s.texParameteri(ie,s.TEXTURE_WRAP_T,se[j.wrapT]),(ie===s.TEXTURE_3D||ie===s.TEXTURE_2D_ARRAY)&&s.texParameteri(ie,s.TEXTURE_WRAP_R,se[j.wrapR]),s.texParameteri(ie,s.TEXTURE_MAG_FILTER,G[j.magFilter]),s.texParameteri(ie,s.TEXTURE_MIN_FILTER,G[j.minFilter]),j.compareFunction&&(s.texParameteri(ie,s.TEXTURE_COMPARE_MODE,s.COMPARE_REF_TO_TEXTURE),s.texParameteri(ie,s.TEXTURE_COMPARE_FUNC,ne[j.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(j.magFilter===Br||j.minFilter!==ng&&j.minFilter!==tu||j.type===Eo&&e.has("OES_texture_float_linear")===!1)return;if(j.anisotropy>1||n.get(j).__currentAnisotropy){const Ae=e.get("EXT_texture_filter_anisotropic");s.texParameterf(ie,Ae.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(j.anisotropy,i.getMaxAnisotropy())),n.get(j).__currentAnisotropy=j.anisotropy}}}function ue(ie,j){let Ae=!1;ie.__webglInit===void 0&&(ie.__webglInit=!0,j.addEventListener("dispose",I));const Ue=j.source;let Ye=d.get(Ue);Ye===void 0&&(Ye={},d.set(Ue,Ye));const qe=J(j);if(qe!==ie.__cacheKey){Ye[qe]===void 0&&(Ye[qe]={texture:s.createTexture(),usedTimes:0},a.memory.textures++,Ae=!0),Ye[qe].usedTimes++;const mt=Ye[ie.__cacheKey];mt!==void 0&&(Ye[ie.__cacheKey].usedTimes--,mt.usedTimes===0&&D(j)),ie.__cacheKey=qe,ie.__webglTexture=Ye[qe].texture}return Ae}function re(ie,j,Ae){let Ue=s.TEXTURE_2D;(j.isDataArrayTexture||j.isCompressedArrayTexture)&&(Ue=s.TEXTURE_2D_ARRAY),j.isData3DTexture&&(Ue=s.TEXTURE_3D);const Ye=ue(ie,j),qe=j.source;t.bindTexture(Ue,ie.__webglTexture,s.TEXTURE0+Ae);const mt=n.get(qe);if(qe.version!==mt.__version||Ye===!0){t.activeTexture(s.TEXTURE0+Ae);const at=Qn.getPrimaries(Qn.workingColorSpace),gt=j.colorSpace===sf?null:Qn.getPrimaries(j.colorSpace),dn=j.colorSpace===sf||at===gt?s.NONE:s.BROWSER_DEFAULT_WEBGL;s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,j.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,j.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,j.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,dn);let lt=S(j.image,!1,i.maxTextureSize);lt=ht(j,lt);const Dt=r.convert(j.format,j.colorSpace),Ft=r.convert(j.type);let Pt=E(j.internalFormat,Dt,Ft,j.colorSpace,j.isVideoTexture);oe(Ue,j);let vt;const ye=j.mipmaps,Je=j.isVideoTexture!==!0,_t=mt.__version===void 0||Ye===!0,ge=qe.dataReady,dt=R(j,lt);if(j.isDepthTexture)Pt=C(j.format===rx,j.type),_t&&(Je?t.texStorage2D(s.TEXTURE_2D,1,Pt,lt.width,lt.height):t.texImage2D(s.TEXTURE_2D,0,Pt,lt.width,lt.height,0,Dt,Ft,null));else if(j.isDataTexture)if(ye.length>0){Je&&_t&&t.texStorage2D(s.TEXTURE_2D,dt,Pt,ye[0].width,ye[0].height);for(let We=0,Ze=ye.length;We<Ze;We++)vt=ye[We],Je?ge&&t.texSubImage2D(s.TEXTURE_2D,We,0,0,vt.width,vt.height,Dt,Ft,vt.data):t.texImage2D(s.TEXTURE_2D,We,Pt,vt.width,vt.height,0,Dt,Ft,vt.data);j.generateMipmaps=!1}else Je?(_t&&t.texStorage2D(s.TEXTURE_2D,dt,Pt,lt.width,lt.height),ge&&t.texSubImage2D(s.TEXTURE_2D,0,0,0,lt.width,lt.height,Dt,Ft,lt.data)):t.texImage2D(s.TEXTURE_2D,0,Pt,lt.width,lt.height,0,Dt,Ft,lt.data);else if(j.isCompressedTexture)if(j.isCompressedArrayTexture){Je&&_t&&t.texStorage3D(s.TEXTURE_2D_ARRAY,dt,Pt,ye[0].width,ye[0].height,lt.depth);for(let We=0,Ze=ye.length;We<Ze;We++)if(vt=ye[We],j.format!==wa)if(Dt!==null)if(Je){if(ge)if(j.layerUpdates.size>0){const Mt=VI(vt.width,vt.height,j.format,j.type);for(const At of j.layerUpdates){const Kt=vt.data.subarray(At*Mt/vt.data.BYTES_PER_ELEMENT,(At+1)*Mt/vt.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,We,0,0,At,vt.width,vt.height,1,Dt,Kt)}j.clearLayerUpdates()}else t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,We,0,0,0,vt.width,vt.height,lt.depth,Dt,vt.data)}else t.compressedTexImage3D(s.TEXTURE_2D_ARRAY,We,Pt,vt.width,vt.height,lt.depth,0,vt.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Je?ge&&t.texSubImage3D(s.TEXTURE_2D_ARRAY,We,0,0,0,vt.width,vt.height,lt.depth,Dt,Ft,vt.data):t.texImage3D(s.TEXTURE_2D_ARRAY,We,Pt,vt.width,vt.height,lt.depth,0,Dt,Ft,vt.data)}else{Je&&_t&&t.texStorage2D(s.TEXTURE_2D,dt,Pt,ye[0].width,ye[0].height);for(let We=0,Ze=ye.length;We<Ze;We++)vt=ye[We],j.format!==wa?Dt!==null?Je?ge&&t.compressedTexSubImage2D(s.TEXTURE_2D,We,0,0,vt.width,vt.height,Dt,vt.data):t.compressedTexImage2D(s.TEXTURE_2D,We,Pt,vt.width,vt.height,0,vt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Je?ge&&t.texSubImage2D(s.TEXTURE_2D,We,0,0,vt.width,vt.height,Dt,Ft,vt.data):t.texImage2D(s.TEXTURE_2D,We,Pt,vt.width,vt.height,0,Dt,Ft,vt.data)}else if(j.isDataArrayTexture)if(Je){if(_t&&t.texStorage3D(s.TEXTURE_2D_ARRAY,dt,Pt,lt.width,lt.height,lt.depth),ge)if(j.layerUpdates.size>0){const We=VI(lt.width,lt.height,j.format,j.type);for(const Ze of j.layerUpdates){const Mt=lt.data.subarray(Ze*We/lt.data.BYTES_PER_ELEMENT,(Ze+1)*We/lt.data.BYTES_PER_ELEMENT);t.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,Ze,lt.width,lt.height,1,Dt,Ft,Mt)}j.clearLayerUpdates()}else t.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,0,lt.width,lt.height,lt.depth,Dt,Ft,lt.data)}else t.texImage3D(s.TEXTURE_2D_ARRAY,0,Pt,lt.width,lt.height,lt.depth,0,Dt,Ft,lt.data);else if(j.isData3DTexture)Je?(_t&&t.texStorage3D(s.TEXTURE_3D,dt,Pt,lt.width,lt.height,lt.depth),ge&&t.texSubImage3D(s.TEXTURE_3D,0,0,0,0,lt.width,lt.height,lt.depth,Dt,Ft,lt.data)):t.texImage3D(s.TEXTURE_3D,0,Pt,lt.width,lt.height,lt.depth,0,Dt,Ft,lt.data);else if(j.isFramebufferTexture){if(_t)if(Je)t.texStorage2D(s.TEXTURE_2D,dt,Pt,lt.width,lt.height);else{let We=lt.width,Ze=lt.height;for(let Mt=0;Mt<dt;Mt++)t.texImage2D(s.TEXTURE_2D,Mt,Pt,We,Ze,0,Dt,Ft,null),We>>=1,Ze>>=1}}else if(ye.length>0){if(Je&&_t){const We=ke(ye[0]);t.texStorage2D(s.TEXTURE_2D,dt,Pt,We.width,We.height)}for(let We=0,Ze=ye.length;We<Ze;We++)vt=ye[We],Je?ge&&t.texSubImage2D(s.TEXTURE_2D,We,0,0,Dt,Ft,vt):t.texImage2D(s.TEXTURE_2D,We,Pt,Dt,Ft,vt);j.generateMipmaps=!1}else if(Je){if(_t){const We=ke(lt);t.texStorage2D(s.TEXTURE_2D,dt,Pt,We.width,We.height)}ge&&t.texSubImage2D(s.TEXTURE_2D,0,0,0,Dt,Ft,lt)}else t.texImage2D(s.TEXTURE_2D,0,Pt,Dt,Ft,lt);b(j)&&_(Ue),mt.__version=qe.version,j.onUpdate&&j.onUpdate(j)}ie.__version=j.version}function ce(ie,j,Ae){if(j.image.length!==6)return;const Ue=ue(ie,j),Ye=j.source;t.bindTexture(s.TEXTURE_CUBE_MAP,ie.__webglTexture,s.TEXTURE0+Ae);const qe=n.get(Ye);if(Ye.version!==qe.__version||Ue===!0){t.activeTexture(s.TEXTURE0+Ae);const mt=Qn.getPrimaries(Qn.workingColorSpace),at=j.colorSpace===sf?null:Qn.getPrimaries(j.colorSpace),gt=j.colorSpace===sf||mt===at?s.NONE:s.BROWSER_DEFAULT_WEBGL;s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,j.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,j.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,j.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,gt);const dn=j.isCompressedTexture||j.image[0].isCompressedTexture,lt=j.image[0]&&j.image[0].isDataTexture,Dt=[];for(let Ze=0;Ze<6;Ze++)!dn&&!lt?Dt[Ze]=S(j.image[Ze],!0,i.maxCubemapSize):Dt[Ze]=lt?j.image[Ze].image:j.image[Ze],Dt[Ze]=ht(j,Dt[Ze]);const Ft=Dt[0],Pt=r.convert(j.format,j.colorSpace),vt=r.convert(j.type),ye=E(j.internalFormat,Pt,vt,j.colorSpace),Je=j.isVideoTexture!==!0,_t=qe.__version===void 0||Ue===!0,ge=Ye.dataReady;let dt=R(j,Ft);oe(s.TEXTURE_CUBE_MAP,j);let We;if(dn){Je&&_t&&t.texStorage2D(s.TEXTURE_CUBE_MAP,dt,ye,Ft.width,Ft.height);for(let Ze=0;Ze<6;Ze++){We=Dt[Ze].mipmaps;for(let Mt=0;Mt<We.length;Mt++){const At=We[Mt];j.format!==wa?Pt!==null?Je?ge&&t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt,0,0,At.width,At.height,Pt,At.data):t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt,ye,At.width,At.height,0,At.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Je?ge&&t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt,0,0,At.width,At.height,Pt,vt,At.data):t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt,ye,At.width,At.height,0,Pt,vt,At.data)}}}else{if(We=j.mipmaps,Je&&_t){We.length>0&&dt++;const Ze=ke(Dt[0]);t.texStorage2D(s.TEXTURE_CUBE_MAP,dt,ye,Ze.width,Ze.height)}for(let Ze=0;Ze<6;Ze++)if(lt){Je?ge&&t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,Dt[Ze].width,Dt[Ze].height,Pt,vt,Dt[Ze].data):t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,ye,Dt[Ze].width,Dt[Ze].height,0,Pt,vt,Dt[Ze].data);for(let Mt=0;Mt<We.length;Mt++){const Kt=We[Mt].image[Ze].image;Je?ge&&t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt+1,0,0,Kt.width,Kt.height,Pt,vt,Kt.data):t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt+1,ye,Kt.width,Kt.height,0,Pt,vt,Kt.data)}}else{Je?ge&&t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,Pt,vt,Dt[Ze]):t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,ye,Pt,vt,Dt[Ze]);for(let Mt=0;Mt<We.length;Mt++){const At=We[Mt];Je?ge&&t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt+1,0,0,Pt,vt,At.image[Ze]):t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,Mt+1,ye,Pt,vt,At.image[Ze])}}}b(j)&&_(s.TEXTURE_CUBE_MAP),qe.__version=Ye.version,j.onUpdate&&j.onUpdate(j)}ie.__version=j.version}function Te(ie,j,Ae,Ue,Ye,qe){const mt=r.convert(Ae.format,Ae.colorSpace),at=r.convert(Ae.type),gt=E(Ae.internalFormat,mt,at,Ae.colorSpace),dn=n.get(j),lt=n.get(Ae);if(lt.__renderTarget=j,!dn.__hasExternalTextures){const Dt=Math.max(1,j.width>>qe),Ft=Math.max(1,j.height>>qe);Ye===s.TEXTURE_3D||Ye===s.TEXTURE_2D_ARRAY?t.texImage3D(Ye,qe,gt,Dt,Ft,j.depth,0,mt,at,null):t.texImage2D(Ye,qe,gt,Dt,Ft,0,mt,at,null)}t.bindFramebuffer(s.FRAMEBUFFER,ie),Fe(j)?o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,Ue,Ye,lt.__webglTexture,0,ze(j)):(Ye===s.TEXTURE_2D||Ye>=s.TEXTURE_CUBE_MAP_POSITIVE_X&&Ye<=s.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&s.framebufferTexture2D(s.FRAMEBUFFER,Ue,Ye,lt.__webglTexture,qe),t.bindFramebuffer(s.FRAMEBUFFER,null)}function Be(ie,j,Ae){if(s.bindRenderbuffer(s.RENDERBUFFER,ie),j.depthBuffer){const Ue=j.depthTexture,Ye=Ue&&Ue.isDepthTexture?Ue.type:null,qe=C(j.stencilBuffer,Ye),mt=j.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,at=ze(j);Fe(j)?o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,at,qe,j.width,j.height):Ae?s.renderbufferStorageMultisample(s.RENDERBUFFER,at,qe,j.width,j.height):s.renderbufferStorage(s.RENDERBUFFER,qe,j.width,j.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,mt,s.RENDERBUFFER,ie)}else{const Ue=j.textures;for(let Ye=0;Ye<Ue.length;Ye++){const qe=Ue[Ye],mt=r.convert(qe.format,qe.colorSpace),at=r.convert(qe.type),gt=E(qe.internalFormat,mt,at,qe.colorSpace),dn=ze(j);Ae&&Fe(j)===!1?s.renderbufferStorageMultisample(s.RENDERBUFFER,dn,gt,j.width,j.height):Fe(j)?o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,dn,gt,j.width,j.height):s.renderbufferStorage(s.RENDERBUFFER,gt,j.width,j.height)}}s.bindRenderbuffer(s.RENDERBUFFER,null)}function Ke(ie,j){if(j&&j.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(s.FRAMEBUFFER,ie),!(j.depthTexture&&j.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Ue=n.get(j.depthTexture);Ue.__renderTarget=j,(!Ue.__webglTexture||j.depthTexture.image.width!==j.width||j.depthTexture.image.height!==j.height)&&(j.depthTexture.image.width=j.width,j.depthTexture.image.height=j.height,j.depthTexture.needsUpdate=!0),Y(j.depthTexture,0);const Ye=Ue.__webglTexture,qe=ze(j);if(j.depthTexture.format===ix)Fe(j)?o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,Ye,0,qe):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,Ye,0);else if(j.depthTexture.format===rx)Fe(j)?o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,Ye,0,qe):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,Ye,0);else throw new Error("Unknown depthTexture format")}function ut(ie){const j=n.get(ie),Ae=ie.isWebGLCubeRenderTarget===!0;if(j.__boundDepthTexture!==ie.depthTexture){const Ue=ie.depthTexture;if(j.__depthDisposeCallback&&j.__depthDisposeCallback(),Ue){const Ye=()=>{delete j.__boundDepthTexture,delete j.__depthDisposeCallback,Ue.removeEventListener("dispose",Ye)};Ue.addEventListener("dispose",Ye),j.__depthDisposeCallback=Ye}j.__boundDepthTexture=Ue}if(ie.depthTexture&&!j.__autoAllocateDepthBuffer){if(Ae)throw new Error("target.depthTexture not supported in Cube render targets");Ke(j.__webglFramebuffer,ie)}else if(Ae){j.__webglDepthbuffer=[];for(let Ue=0;Ue<6;Ue++)if(t.bindFramebuffer(s.FRAMEBUFFER,j.__webglFramebuffer[Ue]),j.__webglDepthbuffer[Ue]===void 0)j.__webglDepthbuffer[Ue]=s.createRenderbuffer(),Be(j.__webglDepthbuffer[Ue],ie,!1);else{const Ye=ie.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,qe=j.__webglDepthbuffer[Ue];s.bindRenderbuffer(s.RENDERBUFFER,qe),s.framebufferRenderbuffer(s.FRAMEBUFFER,Ye,s.RENDERBUFFER,qe)}}else if(t.bindFramebuffer(s.FRAMEBUFFER,j.__webglFramebuffer),j.__webglDepthbuffer===void 0)j.__webglDepthbuffer=s.createRenderbuffer(),Be(j.__webglDepthbuffer,ie,!1);else{const Ue=ie.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,Ye=j.__webglDepthbuffer;s.bindRenderbuffer(s.RENDERBUFFER,Ye),s.framebufferRenderbuffer(s.FRAMEBUFFER,Ue,s.RENDERBUFFER,Ye)}t.bindFramebuffer(s.FRAMEBUFFER,null)}function ct(ie,j,Ae){const Ue=n.get(ie);j!==void 0&&Te(Ue.__webglFramebuffer,ie,ie.texture,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,0),Ae!==void 0&&ut(ie)}function xt(ie){const j=ie.texture,Ae=n.get(ie),Ue=n.get(j);ie.addEventListener("dispose",L);const Ye=ie.textures,qe=ie.isWebGLCubeRenderTarget===!0,mt=Ye.length>1;if(mt||(Ue.__webglTexture===void 0&&(Ue.__webglTexture=s.createTexture()),Ue.__version=j.version,a.memory.textures++),qe){Ae.__webglFramebuffer=[];for(let at=0;at<6;at++)if(j.mipmaps&&j.mipmaps.length>0){Ae.__webglFramebuffer[at]=[];for(let gt=0;gt<j.mipmaps.length;gt++)Ae.__webglFramebuffer[at][gt]=s.createFramebuffer()}else Ae.__webglFramebuffer[at]=s.createFramebuffer()}else{if(j.mipmaps&&j.mipmaps.length>0){Ae.__webglFramebuffer=[];for(let at=0;at<j.mipmaps.length;at++)Ae.__webglFramebuffer[at]=s.createFramebuffer()}else Ae.__webglFramebuffer=s.createFramebuffer();if(mt)for(let at=0,gt=Ye.length;at<gt;at++){const dn=n.get(Ye[at]);dn.__webglTexture===void 0&&(dn.__webglTexture=s.createTexture(),a.memory.textures++)}if(ie.samples>0&&Fe(ie)===!1){Ae.__webglMultisampledFramebuffer=s.createFramebuffer(),Ae.__webglColorRenderbuffer=[],t.bindFramebuffer(s.FRAMEBUFFER,Ae.__webglMultisampledFramebuffer);for(let at=0;at<Ye.length;at++){const gt=Ye[at];Ae.__webglColorRenderbuffer[at]=s.createRenderbuffer(),s.bindRenderbuffer(s.RENDERBUFFER,Ae.__webglColorRenderbuffer[at]);const dn=r.convert(gt.format,gt.colorSpace),lt=r.convert(gt.type),Dt=E(gt.internalFormat,dn,lt,gt.colorSpace,ie.isXRRenderTarget===!0),Ft=ze(ie);s.renderbufferStorageMultisample(s.RENDERBUFFER,Ft,Dt,ie.width,ie.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+at,s.RENDERBUFFER,Ae.__webglColorRenderbuffer[at])}s.bindRenderbuffer(s.RENDERBUFFER,null),ie.depthBuffer&&(Ae.__webglDepthRenderbuffer=s.createRenderbuffer(),Be(Ae.__webglDepthRenderbuffer,ie,!0)),t.bindFramebuffer(s.FRAMEBUFFER,null)}}if(qe){t.bindTexture(s.TEXTURE_CUBE_MAP,Ue.__webglTexture),oe(s.TEXTURE_CUBE_MAP,j);for(let at=0;at<6;at++)if(j.mipmaps&&j.mipmaps.length>0)for(let gt=0;gt<j.mipmaps.length;gt++)Te(Ae.__webglFramebuffer[at][gt],ie,j,s.COLOR_ATTACHMENT0,s.TEXTURE_CUBE_MAP_POSITIVE_X+at,gt);else Te(Ae.__webglFramebuffer[at],ie,j,s.COLOR_ATTACHMENT0,s.TEXTURE_CUBE_MAP_POSITIVE_X+at,0);b(j)&&_(s.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(mt){for(let at=0,gt=Ye.length;at<gt;at++){const dn=Ye[at],lt=n.get(dn);t.bindTexture(s.TEXTURE_2D,lt.__webglTexture),oe(s.TEXTURE_2D,dn),Te(Ae.__webglFramebuffer,ie,dn,s.COLOR_ATTACHMENT0+at,s.TEXTURE_2D,0),b(dn)&&_(s.TEXTURE_2D)}t.unbindTexture()}else{let at=s.TEXTURE_2D;if((ie.isWebGL3DRenderTarget||ie.isWebGLArrayRenderTarget)&&(at=ie.isWebGL3DRenderTarget?s.TEXTURE_3D:s.TEXTURE_2D_ARRAY),t.bindTexture(at,Ue.__webglTexture),oe(at,j),j.mipmaps&&j.mipmaps.length>0)for(let gt=0;gt<j.mipmaps.length;gt++)Te(Ae.__webglFramebuffer[gt],ie,j,s.COLOR_ATTACHMENT0,at,gt);else Te(Ae.__webglFramebuffer,ie,j,s.COLOR_ATTACHMENT0,at,0);b(j)&&_(at),t.unbindTexture()}ie.depthBuffer&&ut(ie)}function kt(ie){const j=ie.textures;for(let Ae=0,Ue=j.length;Ae<Ue;Ae++){const Ye=j[Ae];if(b(Ye)){const qe=T(ie),mt=n.get(Ye).__webglTexture;t.bindTexture(qe,mt),_(qe),t.unbindTexture()}}}const Et=[],le=[];function Wt(ie){if(ie.samples>0){if(Fe(ie)===!1){const j=ie.textures,Ae=ie.width,Ue=ie.height;let Ye=s.COLOR_BUFFER_BIT;const qe=ie.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,mt=n.get(ie),at=j.length>1;if(at)for(let gt=0;gt<j.length;gt++)t.bindFramebuffer(s.FRAMEBUFFER,mt.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+gt,s.RENDERBUFFER,null),t.bindFramebuffer(s.FRAMEBUFFER,mt.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+gt,s.TEXTURE_2D,null,0);t.bindFramebuffer(s.READ_FRAMEBUFFER,mt.__webglMultisampledFramebuffer),t.bindFramebuffer(s.DRAW_FRAMEBUFFER,mt.__webglFramebuffer);for(let gt=0;gt<j.length;gt++){if(ie.resolveDepthBuffer&&(ie.depthBuffer&&(Ye|=s.DEPTH_BUFFER_BIT),ie.stencilBuffer&&ie.resolveStencilBuffer&&(Ye|=s.STENCIL_BUFFER_BIT)),at){s.framebufferRenderbuffer(s.READ_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.RENDERBUFFER,mt.__webglColorRenderbuffer[gt]);const dn=n.get(j[gt]).__webglTexture;s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,dn,0)}s.blitFramebuffer(0,0,Ae,Ue,0,0,Ae,Ue,Ye,s.NEAREST),l===!0&&(Et.length=0,le.length=0,Et.push(s.COLOR_ATTACHMENT0+gt),ie.depthBuffer&&ie.resolveDepthBuffer===!1&&(Et.push(qe),le.push(qe),s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER,le)),s.invalidateFramebuffer(s.READ_FRAMEBUFFER,Et))}if(t.bindFramebuffer(s.READ_FRAMEBUFFER,null),t.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),at)for(let gt=0;gt<j.length;gt++){t.bindFramebuffer(s.FRAMEBUFFER,mt.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+gt,s.RENDERBUFFER,mt.__webglColorRenderbuffer[gt]);const dn=n.get(j[gt]).__webglTexture;t.bindFramebuffer(s.FRAMEBUFFER,mt.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+gt,s.TEXTURE_2D,dn,0)}t.bindFramebuffer(s.DRAW_FRAMEBUFFER,mt.__webglMultisampledFramebuffer)}else if(ie.depthBuffer&&ie.resolveDepthBuffer===!1&&l){const j=ie.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT;s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER,[j])}}}function ze(ie){return Math.min(i.maxSamples,ie.samples)}function Fe(ie){const j=n.get(ie);return ie.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&j.__useRenderToTexture!==!1}function Pe(ie){const j=a.render.frame;c.get(ie)!==j&&(c.set(ie,j),ie.update())}function ht(ie,j){const Ae=ie.colorSpace,Ue=ie.format,Ye=ie.type;return ie.isCompressedTexture===!0||ie.isVideoTexture===!0||Ae!==np&&Ae!==sf&&(Qn.getTransfer(Ae)===Cs?(Ue!==wa||Ye!==nc)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Ae)),j}function ke(ie){return typeof HTMLImageElement<"u"&&ie instanceof HTMLImageElement?(u.width=ie.naturalWidth||ie.width,u.height=ie.naturalHeight||ie.height):typeof VideoFrame<"u"&&ie instanceof VideoFrame?(u.width=ie.displayWidth,u.height=ie.displayHeight):(u.width=ie.width,u.height=ie.height),u}this.allocateTextureUnit=q,this.resetTextureUnits=X,this.setTexture2D=Y,this.setTexture2DArray=$,this.setTexture3D=W,this.setTextureCube=V,this.rebindTextures=ct,this.setupRenderTarget=xt,this.updateRenderTargetMipmap=kt,this.updateMultisampleRenderTarget=Wt,this.setupDepthRenderbuffer=ut,this.setupFrameBufferTexture=Te,this.useMultisampledRTT=Fe}function D6(s,e){function t(n,i=sf){let r;const a=Qn.getTransfer(i);if(n===nc)return s.UNSIGNED_BYTE;if(n===TC)return s.UNSIGNED_SHORT_4_4_4_4;if(n===wC)return s.UNSIGNED_SHORT_5_5_5_1;if(n===C3)return s.UNSIGNED_INT_5_9_9_9_REV;if(n===T3)return s.BYTE;if(n===w3)return s.SHORT;if(n===nx)return s.UNSIGNED_SHORT;if(n===AC)return s.INT;if(n===xf)return s.UNSIGNED_INT;if(n===Eo)return s.FLOAT;if(n===kx)return s.HALF_FLOAT;if(n===E3)return s.ALPHA;if(n===M3)return s.RGB;if(n===wa)return s.RGBA;if(n===N3)return s.LUMINANCE;if(n===R3)return s.LUMINANCE_ALPHA;if(n===ix)return s.DEPTH_COMPONENT;if(n===rx)return s.DEPTH_STENCIL;if(n===CC)return s.RED;if(n===Qb)return s.RED_INTEGER;if(n===I3)return s.RG;if(n===EC)return s.RG_INTEGER;if(n===MC)return s.RGBA_INTEGER;if(n===Z1||n===Q1||n===eb||n===tb)if(a===Cs)if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(n===Z1)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Q1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===eb)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===tb)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=e.get("WEBGL_compressed_texture_s3tc"),r!==null){if(n===Z1)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Q1)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===eb)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===tb)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===Zw||n===Qw||n===e2||n===t2)if(r=e.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(n===Zw)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===Qw)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===e2)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===t2)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===n2||n===s2||n===i2)if(r=e.get("WEBGL_compressed_texture_etc"),r!==null){if(n===n2||n===s2)return a===Cs?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(n===i2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===r2||n===a2||n===o2||n===l2||n===u2||n===c2||n===h2||n===f2||n===d2||n===p2||n===m2||n===g2||n===y2||n===x2)if(r=e.get("WEBGL_compressed_texture_astc"),r!==null){if(n===r2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===a2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===o2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===l2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===u2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===c2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===h2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===f2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===d2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===p2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===m2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===g2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===y2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===x2)return a===Cs?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===nb||n===v2||n===b2)if(r=e.get("EXT_texture_compression_bptc"),r!==null){if(n===nb)return a===Cs?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===v2)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===b2)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===D3||n===_2||n===S2||n===A2)if(r=e.get("EXT_texture_compression_rgtc"),r!==null){if(n===nb)return r.COMPRESSED_RED_RGTC1_EXT;if(n===_2)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===S2)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===A2)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===sx?s.UNSIGNED_INT_24_8:s[n]!==void 0?s[n]:null}return{convert:t}}const Pse=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Use=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class $se{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,n){if(this.texture===null){const i=new ii,r=e.properties.get(i);r.__webglTexture=t.texture,(t.depthNear!==n.depthNear||t.depthFar!==n.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=i}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,n=new sc({vertexShader:Pse,fragmentShader:Use,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new zi(new Fx(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class zse extends yh{constructor(e,t){super();const n=this;let i=null,r=1,a=null,o="local-floor",l=1,u=null,c=null,f=null,d=null,g=null,x=null;const S=new $se,b=t.getContextAttributes();let _=null,T=null;const E=[],C=[],R=new tt;let I=null;const L=new Ci;L.viewport=new os;const P=new Ci;P.viewport=new os;const D=[L,P],O=new _6;let F=null,X=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(re){let ce=E[re];return ce===void 0&&(ce=new Tw,E[re]=ce),ce.getTargetRaySpace()},this.getControllerGrip=function(re){let ce=E[re];return ce===void 0&&(ce=new Tw,E[re]=ce),ce.getGripSpace()},this.getHand=function(re){let ce=E[re];return ce===void 0&&(ce=new Tw,E[re]=ce),ce.getHandSpace()};function q(re){const ce=C.indexOf(re.inputSource);if(ce===-1)return;const Te=E[ce];Te!==void 0&&(Te.update(re.inputSource,re.frame,u||a),Te.dispatchEvent({type:re.type,data:re.inputSource}))}function J(){i.removeEventListener("select",q),i.removeEventListener("selectstart",q),i.removeEventListener("selectend",q),i.removeEventListener("squeeze",q),i.removeEventListener("squeezestart",q),i.removeEventListener("squeezeend",q),i.removeEventListener("end",J),i.removeEventListener("inputsourceschange",Y);for(let re=0;re<E.length;re++){const ce=C[re];ce!==null&&(C[re]=null,E[re].disconnect(ce))}F=null,X=null,S.reset(),e.setRenderTarget(_),g=null,d=null,f=null,i=null,T=null,ue.stop(),n.isPresenting=!1,e.setPixelRatio(I),e.setSize(R.width,R.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(re){r=re,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(re){o=re,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||a},this.setReferenceSpace=function(re){u=re},this.getBaseLayer=function(){return d!==null?d:g},this.getBinding=function(){return f},this.getFrame=function(){return x},this.getSession=function(){return i},this.setSession=async function(re){if(i=re,i!==null){if(_=e.getRenderTarget(),i.addEventListener("select",q),i.addEventListener("selectstart",q),i.addEventListener("selectend",q),i.addEventListener("squeeze",q),i.addEventListener("squeezestart",q),i.addEventListener("squeezeend",q),i.addEventListener("end",J),i.addEventListener("inputsourceschange",Y),b.xrCompatible!==!0&&await t.makeXRCompatible(),I=e.getPixelRatio(),e.getSize(R),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Te=null,Be=null,Ke=null;b.depth&&(Ke=b.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Te=b.stencil?rx:ix,Be=b.stencil?sx:xf);const ut={colorFormat:t.RGBA8,depthFormat:Ke,scaleFactor:r};f=new XRWebGLBinding(i,t),d=f.createProjectionLayer(ut),i.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),T=new hh(d.textureWidth,d.textureHeight,{format:wa,type:nc,depthTexture:new W3(d.textureWidth,d.textureHeight,Be,void 0,void 0,void 0,void 0,void 0,void 0,Te),stencilBuffer:b.stencil,colorSpace:e.outputColorSpace,samples:b.antialias?4:0,resolveDepthBuffer:d.ignoreDepthValues===!1,resolveStencilBuffer:d.ignoreDepthValues===!1})}else{const Te={antialias:b.antialias,alpha:!0,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:r};g=new XRWebGLLayer(i,t,Te),i.updateRenderState({baseLayer:g}),e.setPixelRatio(1),e.setSize(g.framebufferWidth,g.framebufferHeight,!1),T=new hh(g.framebufferWidth,g.framebufferHeight,{format:wa,type:nc,colorSpace:e.outputColorSpace,stencilBuffer:b.stencil,resolveDepthBuffer:g.ignoreDepthValues===!1,resolveStencilBuffer:g.ignoreDepthValues===!1})}T.isXRRenderTarget=!0,this.setFoveation(l),u=null,a=await i.requestReferenceSpace(o),ue.setContext(i),ue.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return S.getDepthTexture()};function Y(re){for(let ce=0;ce<re.removed.length;ce++){const Te=re.removed[ce],Be=C.indexOf(Te);Be>=0&&(C[Be]=null,E[Be].disconnect(Te))}for(let ce=0;ce<re.added.length;ce++){const Te=re.added[ce];let Be=C.indexOf(Te);if(Be===-1){for(let ut=0;ut<E.length;ut++)if(ut>=C.length){C.push(Te),Be=ut;break}else if(C[ut]===null){C[ut]=Te,Be=ut;break}if(Be===-1)break}const Ke=E[Be];Ke&&Ke.connect(Te)}}const $=new ae,W=new ae;function V(re,ce,Te){$.setFromMatrixPosition(ce.matrixWorld),W.setFromMatrixPosition(Te.matrixWorld);const Be=$.distanceTo(W),Ke=ce.projectionMatrix.elements,ut=Te.projectionMatrix.elements,ct=Ke[14]/(Ke[10]-1),xt=Ke[14]/(Ke[10]+1),kt=(Ke[9]+1)/Ke[5],Et=(Ke[9]-1)/Ke[5],le=(Ke[8]-1)/Ke[0],Wt=(ut[8]+1)/ut[0],ze=ct*le,Fe=ct*Wt,Pe=Be/(-le+Wt),ht=Pe*-le;if(ce.matrixWorld.decompose(re.position,re.quaternion,re.scale),re.translateX(ht),re.translateZ(Pe),re.matrixWorld.compose(re.position,re.quaternion,re.scale),re.matrixWorldInverse.copy(re.matrixWorld).invert(),Ke[10]===-1)re.projectionMatrix.copy(ce.projectionMatrix),re.projectionMatrixInverse.copy(ce.projectionMatrixInverse);else{const ke=ct+Pe,ie=xt+Pe,j=ze-ht,Ae=Fe+(Be-ht),Ue=kt*xt/ie*ke,Ye=Et*xt/ie*ke;re.projectionMatrix.makePerspective(j,Ae,Ue,Ye,ke,ie),re.projectionMatrixInverse.copy(re.projectionMatrix).invert()}}function se(re,ce){ce===null?re.matrixWorld.copy(re.matrix):re.matrixWorld.multiplyMatrices(ce.matrixWorld,re.matrix),re.matrixWorldInverse.copy(re.matrixWorld).invert()}this.updateCamera=function(re){if(i===null)return;let ce=re.near,Te=re.far;S.texture!==null&&(S.depthNear>0&&(ce=S.depthNear),S.depthFar>0&&(Te=S.depthFar)),O.near=P.near=L.near=ce,O.far=P.far=L.far=Te,(F!==O.near||X!==O.far)&&(i.updateRenderState({depthNear:O.near,depthFar:O.far}),F=O.near,X=O.far),L.layers.mask=re.layers.mask|2,P.layers.mask=re.layers.mask|4,O.layers.mask=L.layers.mask|P.layers.mask;const Be=re.parent,Ke=O.cameras;se(O,Be);for(let ut=0;ut<Ke.length;ut++)se(Ke[ut],Be);Ke.length===2?V(O,L,P):O.projectionMatrix.copy(L.projectionMatrix),G(re,O,Be)};function G(re,ce,Te){Te===null?re.matrix.copy(ce.matrixWorld):(re.matrix.copy(Te.matrixWorld),re.matrix.invert(),re.matrix.multiply(ce.matrixWorld)),re.matrix.decompose(re.position,re.quaternion,re.scale),re.updateMatrixWorld(!0),re.projectionMatrix.copy(ce.projectionMatrix),re.projectionMatrixInverse.copy(ce.projectionMatrixInverse),re.isPerspectiveCamera&&(re.fov=lx*2*Math.atan(1/re.projectionMatrix.elements[5]),re.zoom=1)}this.getCamera=function(){return O},this.getFoveation=function(){if(!(d===null&&g===null))return l},this.setFoveation=function(re){l=re,d!==null&&(d.fixedFoveation=re),g!==null&&g.fixedFoveation!==void 0&&(g.fixedFoveation=re)},this.hasDepthSensing=function(){return S.texture!==null},this.getDepthSensingMesh=function(){return S.getMesh(O)};let ne=null;function oe(re,ce){if(c=ce.getViewerPose(u||a),x=ce,c!==null){const Te=c.views;g!==null&&(e.setRenderTargetFramebuffer(T,g.framebuffer),e.setRenderTarget(T));let Be=!1;Te.length!==O.cameras.length&&(O.cameras.length=0,Be=!0);for(let ct=0;ct<Te.length;ct++){const xt=Te[ct];let kt=null;if(g!==null)kt=g.getViewport(xt);else{const le=f.getViewSubImage(d,xt);kt=le.viewport,ct===0&&(e.setRenderTargetTextures(T,le.colorTexture,le.depthStencilTexture),e.setRenderTarget(T))}let Et=D[ct];Et===void 0&&(Et=new Ci,Et.layers.enable(ct),Et.viewport=new os,D[ct]=Et),Et.matrix.fromArray(xt.transform.matrix),Et.matrix.decompose(Et.position,Et.quaternion,Et.scale),Et.projectionMatrix.fromArray(xt.projectionMatrix),Et.projectionMatrixInverse.copy(Et.projectionMatrix).invert(),Et.viewport.set(kt.x,kt.y,kt.width,kt.height),ct===0&&(O.matrix.copy(Et.matrix),O.matrix.decompose(O.position,O.quaternion,O.scale)),Be===!0&&O.cameras.push(Et)}const Ke=i.enabledFeatures;if(Ke&&Ke.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&f){const ct=f.getDepthInformation(Te[0]);ct&&ct.isValid&&ct.texture&&S.init(e,ct,i.renderState)}}for(let Te=0;Te<E.length;Te++){const Be=C[Te],Ke=E[Te];Be!==null&&Ke!==void 0&&Ke.update(Be,ce,u||a)}ne&&ne(re,ce),ce.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:ce}),x=null}const ue=new E6;ue.setAnimationLoop(oe),this.setAnimationLoop=function(re){ne=re},this.dispose=function(){}}}const Lm=new xl,Gse=new rn;function Hse(s,e){function t(b,_){b.matrixAutoUpdate===!0&&b.updateMatrix(),_.value.copy(b.matrix)}function n(b,_){_.color.getRGB(b.fogColor.value,D9(s)),_.isFog?(b.fogNear.value=_.near,b.fogFar.value=_.far):_.isFogExp2&&(b.fogDensity.value=_.density)}function i(b,_,T,E,C){_.isMeshBasicMaterial||_.isMeshLambertMaterial?r(b,_):_.isMeshToonMaterial?(r(b,_),f(b,_)):_.isMeshPhongMaterial?(r(b,_),c(b,_)):_.isMeshStandardMaterial?(r(b,_),d(b,_),_.isMeshPhysicalMaterial&&g(b,_,C)):_.isMeshMatcapMaterial?(r(b,_),x(b,_)):_.isMeshDepthMaterial?r(b,_):_.isMeshDistanceMaterial?(r(b,_),S(b,_)):_.isMeshNormalMaterial?r(b,_):_.isLineBasicMaterial?(a(b,_),_.isLineDashedMaterial&&o(b,_)):_.isPointsMaterial?l(b,_,T,E):_.isSpriteMaterial?u(b,_):_.isShadowMaterial?(b.color.value.copy(_.color),b.opacity.value=_.opacity):_.isShaderMaterial&&(_.uniformsNeedUpdate=!1)}function r(b,_){b.opacity.value=_.opacity,_.color&&b.diffuse.value.copy(_.color),_.emissive&&b.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),_.map&&(b.map.value=_.map,t(_.map,b.mapTransform)),_.alphaMap&&(b.alphaMap.value=_.alphaMap,t(_.alphaMap,b.alphaMapTransform)),_.bumpMap&&(b.bumpMap.value=_.bumpMap,t(_.bumpMap,b.bumpMapTransform),b.bumpScale.value=_.bumpScale,_.side===so&&(b.bumpScale.value*=-1)),_.normalMap&&(b.normalMap.value=_.normalMap,t(_.normalMap,b.normalMapTransform),b.normalScale.value.copy(_.normalScale),_.side===so&&b.normalScale.value.negate()),_.displacementMap&&(b.displacementMap.value=_.displacementMap,t(_.displacementMap,b.displacementMapTransform),b.displacementScale.value=_.displacementScale,b.displacementBias.value=_.displacementBias),_.emissiveMap&&(b.emissiveMap.value=_.emissiveMap,t(_.emissiveMap,b.emissiveMapTransform)),_.specularMap&&(b.specularMap.value=_.specularMap,t(_.specularMap,b.specularMapTransform)),_.alphaTest>0&&(b.alphaTest.value=_.alphaTest);const T=e.get(_),E=T.envMap,C=T.envMapRotation;E&&(b.envMap.value=E,Lm.copy(C),Lm.x*=-1,Lm.y*=-1,Lm.z*=-1,E.isCubeTexture&&E.isRenderTargetTexture===!1&&(Lm.y*=-1,Lm.z*=-1),b.envMapRotation.value.setFromMatrix4(Gse.makeRotationFromEuler(Lm)),b.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,b.reflectivity.value=_.reflectivity,b.ior.value=_.ior,b.refractionRatio.value=_.refractionRatio),_.lightMap&&(b.lightMap.value=_.lightMap,b.lightMapIntensity.value=_.lightMapIntensity,t(_.lightMap,b.lightMapTransform)),_.aoMap&&(b.aoMap.value=_.aoMap,b.aoMapIntensity.value=_.aoMapIntensity,t(_.aoMap,b.aoMapTransform))}function a(b,_){b.diffuse.value.copy(_.color),b.opacity.value=_.opacity,_.map&&(b.map.value=_.map,t(_.map,b.mapTransform))}function o(b,_){b.dashSize.value=_.dashSize,b.totalSize.value=_.dashSize+_.gapSize,b.scale.value=_.scale}function l(b,_,T,E){b.diffuse.value.copy(_.color),b.opacity.value=_.opacity,b.size.value=_.size*T,b.scale.value=E*.5,_.map&&(b.map.value=_.map,t(_.map,b.uvTransform)),_.alphaMap&&(b.alphaMap.value=_.alphaMap,t(_.alphaMap,b.alphaMapTransform)),_.alphaTest>0&&(b.alphaTest.value=_.alphaTest)}function u(b,_){b.diffuse.value.copy(_.color),b.opacity.value=_.opacity,b.rotation.value=_.rotation,_.map&&(b.map.value=_.map,t(_.map,b.mapTransform)),_.alphaMap&&(b.alphaMap.value=_.alphaMap,t(_.alphaMap,b.alphaMapTransform)),_.alphaTest>0&&(b.alphaTest.value=_.alphaTest)}function c(b,_){b.specular.value.copy(_.specular),b.shininess.value=Math.max(_.shininess,1e-4)}function f(b,_){_.gradientMap&&(b.gradientMap.value=_.gradientMap)}function d(b,_){b.metalness.value=_.metalness,_.metalnessMap&&(b.metalnessMap.value=_.metalnessMap,t(_.metalnessMap,b.metalnessMapTransform)),b.roughness.value=_.roughness,_.roughnessMap&&(b.roughnessMap.value=_.roughnessMap,t(_.roughnessMap,b.roughnessMapTransform)),_.envMap&&(b.envMapIntensity.value=_.envMapIntensity)}function g(b,_,T){b.ior.value=_.ior,_.sheen>0&&(b.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen),b.sheenRoughness.value=_.sheenRoughness,_.sheenColorMap&&(b.sheenColorMap.value=_.sheenColorMap,t(_.sheenColorMap,b.sheenColorMapTransform)),_.sheenRoughnessMap&&(b.sheenRoughnessMap.value=_.sheenRoughnessMap,t(_.sheenRoughnessMap,b.sheenRoughnessMapTransform))),_.clearcoat>0&&(b.clearcoat.value=_.clearcoat,b.clearcoatRoughness.value=_.clearcoatRoughness,_.clearcoatMap&&(b.clearcoatMap.value=_.clearcoatMap,t(_.clearcoatMap,b.clearcoatMapTransform)),_.clearcoatRoughnessMap&&(b.clearcoatRoughnessMap.value=_.clearcoatRoughnessMap,t(_.clearcoatRoughnessMap,b.clearcoatRoughnessMapTransform)),_.clearcoatNormalMap&&(b.clearcoatNormalMap.value=_.clearcoatNormalMap,t(_.clearcoatNormalMap,b.clearcoatNormalMapTransform),b.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),_.side===so&&b.clearcoatNormalScale.value.negate())),_.dispersion>0&&(b.dispersion.value=_.dispersion),_.iridescence>0&&(b.iridescence.value=_.iridescence,b.iridescenceIOR.value=_.iridescenceIOR,b.iridescenceThicknessMinimum.value=_.iridescenceThicknessRange[0],b.iridescenceThicknessMaximum.value=_.iridescenceThicknessRange[1],_.iridescenceMap&&(b.iridescenceMap.value=_.iridescenceMap,t(_.iridescenceMap,b.iridescenceMapTransform)),_.iridescenceThicknessMap&&(b.iridescenceThicknessMap.value=_.iridescenceThicknessMap,t(_.iridescenceThicknessMap,b.iridescenceThicknessMapTransform))),_.transmission>0&&(b.transmission.value=_.transmission,b.transmissionSamplerMap.value=T.texture,b.transmissionSamplerSize.value.set(T.width,T.height),_.transmissionMap&&(b.transmissionMap.value=_.transmissionMap,t(_.transmissionMap,b.transmissionMapTransform)),b.thickness.value=_.thickness,_.thicknessMap&&(b.thicknessMap.value=_.thicknessMap,t(_.thicknessMap,b.thicknessMapTransform)),b.attenuationDistance.value=_.attenuationDistance,b.attenuationColor.value.copy(_.attenuationColor)),_.anisotropy>0&&(b.anisotropyVector.value.set(_.anisotropy*Math.cos(_.anisotropyRotation),_.anisotropy*Math.sin(_.anisotropyRotation)),_.anisotropyMap&&(b.anisotropyMap.value=_.anisotropyMap,t(_.anisotropyMap,b.anisotropyMapTransform))),b.specularIntensity.value=_.specularIntensity,b.specularColor.value.copy(_.specularColor),_.specularColorMap&&(b.specularColorMap.value=_.specularColorMap,t(_.specularColorMap,b.specularColorMapTransform)),_.specularIntensityMap&&(b.specularIntensityMap.value=_.specularIntensityMap,t(_.specularIntensityMap,b.specularIntensityMapTransform))}function x(b,_){_.matcap&&(b.matcap.value=_.matcap)}function S(b,_){const T=e.get(_).light;b.referencePosition.value.setFromMatrixPosition(T.matrixWorld),b.nearDistance.value=T.shadow.camera.near,b.farDistance.value=T.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function Vse(s,e,t,n){let i={},r={},a=[];const o=s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);function l(T,E){const C=E.program;n.uniformBlockBinding(T,C)}function u(T,E){let C=i[T.id];C===void 0&&(x(T),C=c(T),i[T.id]=C,T.addEventListener("dispose",b));const R=E.program;n.updateUBOMapping(T,R);const I=e.render.frame;r[T.id]!==I&&(d(T),r[T.id]=I)}function c(T){const E=f();T.__bindingPointIndex=E;const C=s.createBuffer(),R=T.__size,I=T.usage;return s.bindBuffer(s.UNIFORM_BUFFER,C),s.bufferData(s.UNIFORM_BUFFER,R,I),s.bindBuffer(s.UNIFORM_BUFFER,null),s.bindBufferBase(s.UNIFORM_BUFFER,E,C),C}function f(){for(let T=0;T<o;T++)if(a.indexOf(T)===-1)return a.push(T),T;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(T){const E=i[T.id],C=T.uniforms,R=T.__cache;s.bindBuffer(s.UNIFORM_BUFFER,E);for(let I=0,L=C.length;I<L;I++){const P=Array.isArray(C[I])?C[I]:[C[I]];for(let D=0,O=P.length;D<O;D++){const F=P[D];if(g(F,I,D,R)===!0){const X=F.__offset,q=Array.isArray(F.value)?F.value:[F.value];let J=0;for(let Y=0;Y<q.length;Y++){const $=q[Y],W=S($);typeof $=="number"||typeof $=="boolean"?(F.__data[0]=$,s.bufferSubData(s.UNIFORM_BUFFER,X+J,F.__data)):$.isMatrix3?(F.__data[0]=$.elements[0],F.__data[1]=$.elements[1],F.__data[2]=$.elements[2],F.__data[3]=0,F.__data[4]=$.elements[3],F.__data[5]=$.elements[4],F.__data[6]=$.elements[5],F.__data[7]=0,F.__data[8]=$.elements[6],F.__data[9]=$.elements[7],F.__data[10]=$.elements[8],F.__data[11]=0):($.toArray(F.__data,J),J+=W.storage/Float32Array.BYTES_PER_ELEMENT)}s.bufferSubData(s.UNIFORM_BUFFER,X,F.__data)}}}s.bindBuffer(s.UNIFORM_BUFFER,null)}function g(T,E,C,R){const I=T.value,L=E+"_"+C;if(R[L]===void 0)return typeof I=="number"||typeof I=="boolean"?R[L]=I:R[L]=I.clone(),!0;{const P=R[L];if(typeof I=="number"||typeof I=="boolean"){if(P!==I)return R[L]=I,!0}else if(P.equals(I)===!1)return P.copy(I),!0}return!1}function x(T){const E=T.uniforms;let C=0;const R=16;for(let L=0,P=E.length;L<P;L++){const D=Array.isArray(E[L])?E[L]:[E[L]];for(let O=0,F=D.length;O<F;O++){const X=D[O],q=Array.isArray(X.value)?X.value:[X.value];for(let J=0,Y=q.length;J<Y;J++){const $=q[J],W=S($),V=C%R,se=V%W.boundary,G=V+se;C+=se,G!==0&&R-G<W.storage&&(C+=R-G),X.__data=new Float32Array(W.storage/Float32Array.BYTES_PER_ELEMENT),X.__offset=C,C+=W.storage}}}const I=C%R;return I>0&&(C+=R-I),T.__size=C,T.__cache={},this}function S(T){const E={boundary:0,storage:0};return typeof T=="number"||typeof T=="boolean"?(E.boundary=4,E.storage=4):T.isVector2?(E.boundary=8,E.storage=8):T.isVector3||T.isColor?(E.boundary=16,E.storage=12):T.isVector4?(E.boundary=16,E.storage=16):T.isMatrix3?(E.boundary=48,E.storage=48):T.isMatrix4?(E.boundary=64,E.storage=64):T.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",T),E}function b(T){const E=T.target;E.removeEventListener("dispose",b);const C=a.indexOf(E.__bindingPointIndex);a.splice(C,1),s.deleteBuffer(i[E.id]),delete i[E.id],delete r[E.id]}function _(){for(const T in i)s.deleteBuffer(i[T]);a=[],i={},r={}}return{bind:l,update:u,dispose:_}}class O6{constructor(e={}){const{canvas:t=N9(),context:n=null,depth:i=!0,stencil:r=!1,alpha:a=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:u=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:f=!1,reverseDepthBuffer:d=!1}=e;this.isWebGLRenderer=!0;let g;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");g=n.getContextAttributes().alpha}else g=a;const x=new Uint32Array(4),S=new Int32Array(4);let b=null,_=null;const T=[],E=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=th,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const C=this;let R=!1;this._outputColorSpace=va;let I=0,L=0,P=null,D=-1,O=null;const F=new os,X=new os;let q=null;const J=new Nt(0);let Y=0,$=t.width,W=t.height,V=1,se=null,G=null;const ne=new os(0,0,$,W),oe=new os(0,0,$,W);let ue=!1;const re=new i_;let ce=!1,Te=!1;const Be=new rn,Ke=new rn,ut=new ae,ct=new os,xt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let kt=!1;function Et(){return P===null?V:1}let le=n;function Wt(ee,Se){return t.getContext(ee,Se)}try{const ee={alpha:!0,depth:i,stencil:r,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:c,failIfMajorPerformanceCaveat:f};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Jb}`),t.addEventListener("webglcontextlost",Ze,!1),t.addEventListener("webglcontextrestored",Mt,!1),t.addEventListener("webglcontextcreationerror",At,!1),le===null){const Se="webgl2";if(le=Wt(Se,ee),le===null)throw Wt(Se)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(ee){throw console.error("THREE.WebGLRenderer: "+ee.message),ee}let ze,Fe,Pe,ht,ke,ie,j,Ae,Ue,Ye,qe,mt,at,gt,dn,lt,Dt,Ft,Pt,vt,ye,Je,_t,ge;function dt(){ze=new nne(le),ze.init(),Je=new D6(le,ze),Fe=new Kte(le,ze,e,Je),Pe=new Lse(le,ze),Fe.reverseDepthBuffer&&d&&Pe.buffers.depth.setReversed(!0),ht=new rne(le),ke=new Ase,ie=new Fse(le,ze,Pe,ke,Fe,Je,ht),j=new Jte(C),Ae=new tne(C),Ue=new hQ(le),_t=new qte(le,Ue),Ye=new sne(le,Ue,ht,_t),qe=new one(le,Ye,Ue,ht),Pt=new ane(le,Fe,ie),lt=new Yte(ke),mt=new Sse(C,j,Ae,ze,Fe,_t,lt),at=new Hse(C,ke),gt=new wse,dn=new Ise(ze),Ft=new Xte(C,j,Ae,Pe,qe,g,l),Dt=new Bse(C,qe,Fe),ge=new Vse(le,ht,Fe,Pe),vt=new jte(le,ze,ht),ye=new ine(le,ze,ht),ht.programs=mt.programs,C.capabilities=Fe,C.extensions=ze,C.properties=ke,C.renderLists=gt,C.shadowMap=Dt,C.state=Pe,C.info=ht}dt();const We=new zse(C,le);this.xr=We,this.getContext=function(){return le},this.getContextAttributes=function(){return le.getContextAttributes()},this.forceContextLoss=function(){const ee=ze.get("WEBGL_lose_context");ee&&ee.loseContext()},this.forceContextRestore=function(){const ee=ze.get("WEBGL_lose_context");ee&&ee.restoreContext()},this.getPixelRatio=function(){return V},this.setPixelRatio=function(ee){ee!==void 0&&(V=ee,this.setSize($,W,!1))},this.getSize=function(ee){return ee.set($,W)},this.setSize=function(ee,Se,$e=!0){if(We.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}$=ee,W=Se,t.width=Math.floor(ee*V),t.height=Math.floor(Se*V),$e===!0&&(t.style.width=ee+"px",t.style.height=Se+"px"),this.setViewport(0,0,ee,Se)},this.getDrawingBufferSize=function(ee){return ee.set($*V,W*V).floor()},this.setDrawingBufferSize=function(ee,Se,$e){$=ee,W=Se,V=$e,t.width=Math.floor(ee*$e),t.height=Math.floor(Se*$e),this.setViewport(0,0,ee,Se)},this.getCurrentViewport=function(ee){return ee.copy(F)},this.getViewport=function(ee){return ee.copy(ne)},this.setViewport=function(ee,Se,$e,Ge){ee.isVector4?ne.set(ee.x,ee.y,ee.z,ee.w):ne.set(ee,Se,$e,Ge),Pe.viewport(F.copy(ne).multiplyScalar(V).round())},this.getScissor=function(ee){return ee.copy(oe)},this.setScissor=function(ee,Se,$e,Ge){ee.isVector4?oe.set(ee.x,ee.y,ee.z,ee.w):oe.set(ee,Se,$e,Ge),Pe.scissor(X.copy(oe).multiplyScalar(V).round())},this.getScissorTest=function(){return ue},this.setScissorTest=function(ee){Pe.setScissorTest(ue=ee)},this.setOpaqueSort=function(ee){se=ee},this.setTransparentSort=function(ee){G=ee},this.getClearColor=function(ee){return ee.copy(Ft.getClearColor())},this.setClearColor=function(){Ft.setClearColor(...arguments)},this.getClearAlpha=function(){return Ft.getClearAlpha()},this.setClearAlpha=function(){Ft.setClearAlpha(...arguments)},this.clear=function(ee=!0,Se=!0,$e=!0){let Ge=0;if(ee){let Ee=!1;if(P!==null){const ot=P.texture.format;Ee=ot===MC||ot===EC||ot===Qb}if(Ee){const ot=P.texture.type,bt=ot===nc||ot===xf||ot===nx||ot===sx||ot===TC||ot===wC,Tt=Ft.getClearColor(),Lt=Ft.getClearAlpha(),an=Tt.r,Zt=Tt.g,Xt=Tt.b;bt?(x[0]=an,x[1]=Zt,x[2]=Xt,x[3]=Lt,le.clearBufferuiv(le.COLOR,0,x)):(S[0]=an,S[1]=Zt,S[2]=Xt,S[3]=Lt,le.clearBufferiv(le.COLOR,0,S))}else Ge|=le.COLOR_BUFFER_BIT}Se&&(Ge|=le.DEPTH_BUFFER_BIT),$e&&(Ge|=le.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),le.clear(Ge)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ze,!1),t.removeEventListener("webglcontextrestored",Mt,!1),t.removeEventListener("webglcontextcreationerror",At,!1),Ft.dispose(),gt.dispose(),dn.dispose(),ke.dispose(),j.dispose(),Ae.dispose(),qe.dispose(),_t.dispose(),ge.dispose(),mt.dispose(),We.dispose(),We.removeEventListener("sessionstart",vi),We.removeEventListener("sessionend",Oi),wr.stop()};function Ze(ee){ee.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),R=!0}function Mt(){console.log("THREE.WebGLRenderer: Context Restored."),R=!1;const ee=ht.autoReset,Se=Dt.enabled,$e=Dt.autoUpdate,Ge=Dt.needsUpdate,Ee=Dt.type;dt(),ht.autoReset=ee,Dt.enabled=Se,Dt.autoUpdate=$e,Dt.needsUpdate=Ge,Dt.type=Ee}function At(ee){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",ee.statusMessage)}function Kt(ee){const Se=ee.target;Se.removeEventListener("dispose",Kt),Nn(Se)}function Nn(ee){cs(ee),ke.remove(ee)}function cs(ee){const Se=ke.get(ee).programs;Se!==void 0&&(Se.forEach(function($e){mt.releaseProgram($e)}),ee.isShaderMaterial&&mt.releaseShaderCache(ee))}this.renderBufferDirect=function(ee,Se,$e,Ge,Ee,ot){Se===null&&(Se=xt);const bt=Ee.isMesh&&Ee.matrixWorld.determinant()<0,Tt=fc(ee,Se,$e,Ge,Ee);Pe.setMaterial(Ge,bt);let Lt=$e.index,an=1;if(Ge.wireframe===!0){if(Lt=Ye.getWireframeAttribute($e),Lt===void 0)return;an=2}const Zt=$e.drawRange,Xt=$e.attributes.position;let Dn=Zt.start*an,Yn=(Zt.start+Zt.count)*an;ot!==null&&(Dn=Math.max(Dn,ot.start*an),Yn=Math.min(Yn,(ot.start+ot.count)*an)),Lt!==null?(Dn=Math.max(Dn,0),Yn=Math.min(Yn,Lt.count)):Xt!=null&&(Dn=Math.max(Dn,0),Yn=Math.min(Yn,Xt.count));const zs=Yn-Dn;if(zs<0||zs===1/0)return;_t.setup(Ee,Ge,Tt,$e,Lt);let Fn,$n=vt;if(Lt!==null&&(Fn=Ue.get(Lt),$n=ye,$n.setIndex(Fn)),Ee.isMesh)Ge.wireframe===!0?(Pe.setLineWidth(Ge.wireframeLinewidth*Et()),$n.setMode(le.LINES)):$n.setMode(le.TRIANGLES);else if(Ee.isLine){let Qt=Ge.linewidth;Qt===void 0&&(Qt=1),Pe.setLineWidth(Qt*Et()),Ee.isLineSegments?$n.setMode(le.LINES):Ee.isLineLoop?$n.setMode(le.LINE_LOOP):$n.setMode(le.LINE_STRIP)}else Ee.isPoints?$n.setMode(le.POINTS):Ee.isSprite&&$n.setMode(le.TRIANGLES);if(Ee.isBatchedMesh)if(Ee._multiDrawInstances!==null)Aw("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),$n.renderMultiDrawInstances(Ee._multiDrawStarts,Ee._multiDrawCounts,Ee._multiDrawCount,Ee._multiDrawInstances);else if(ze.get("WEBGL_multi_draw"))$n.renderMultiDraw(Ee._multiDrawStarts,Ee._multiDrawCounts,Ee._multiDrawCount);else{const Qt=Ee._multiDrawStarts,Vs=Ee._multiDrawCounts,Xn=Ee._multiDrawCount,or=Lt?Ue.get(Lt).bytesPerElement:1,Cl=ke.get(Ge).currentProgram.getUniforms();for(let _s=0;_s<Xn;_s++)Cl.setValue(le,"_gl_DrawID",_s),$n.render(Qt[_s]/or,Vs[_s])}else if(Ee.isInstancedMesh)$n.renderInstances(Dn,zs,Ee.count);else if($e.isInstancedBufferGeometry){const Qt=$e._maxInstanceCount!==void 0?$e._maxInstanceCount:1/0,Vs=Math.min($e.instanceCount,Qt);$n.renderInstances(Dn,zs,Vs)}else $n.render(Dn,zs)};function _n(ee,Se,$e){ee.transparent===!0&&ee.side===Ju&&ee.forceSinglePass===!1?(ee.side=so,ee.needsUpdate=!0,gs(ee,Se,$e),ee.side=ch,ee.needsUpdate=!0,gs(ee,Se,$e),ee.side=Ju):gs(ee,Se,$e)}this.compile=function(ee,Se,$e=null){$e===null&&($e=ee),_=dn.get($e),_.init(Se),E.push(_),$e.traverseVisible(function(Ee){Ee.isLight&&Ee.layers.test(Se.layers)&&(_.pushLight(Ee),Ee.castShadow&&_.pushShadow(Ee))}),ee!==$e&&ee.traverseVisible(function(Ee){Ee.isLight&&Ee.layers.test(Se.layers)&&(_.pushLight(Ee),Ee.castShadow&&_.pushShadow(Ee))}),_.setupLights();const Ge=new Set;return ee.traverse(function(Ee){if(!(Ee.isMesh||Ee.isPoints||Ee.isLine||Ee.isSprite))return;const ot=Ee.material;if(ot)if(Array.isArray(ot))for(let bt=0;bt<ot.length;bt++){const Tt=ot[bt];_n(Tt,$e,Ee),Ge.add(Tt)}else _n(ot,$e,Ee),Ge.add(ot)}),_=E.pop(),Ge},this.compileAsync=function(ee,Se,$e=null){const Ge=this.compile(ee,Se,$e);return new Promise(Ee=>{function ot(){if(Ge.forEach(function(bt){ke.get(bt).currentProgram.isReady()&&Ge.delete(bt)}),Ge.size===0){Ee(ee);return}setTimeout(ot,10)}ze.get("KHR_parallel_shader_compile")!==null?ot():setTimeout(ot,10)})};let xi=null;function $s(ee){xi&&xi(ee)}function vi(){wr.stop()}function Oi(){wr.start()}const wr=new E6;wr.setAnimationLoop($s),typeof self<"u"&&wr.setContext(self),this.setAnimationLoop=function(ee){xi=ee,We.setAnimationLoop(ee),ee===null?wr.stop():wr.start()},We.addEventListener("sessionstart",vi),We.addEventListener("sessionend",Oi),this.render=function(ee,Se){if(Se!==void 0&&Se.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(R===!0)return;if(ee.matrixWorldAutoUpdate===!0&&ee.updateMatrixWorld(),Se.parent===null&&Se.matrixWorldAutoUpdate===!0&&Se.updateMatrixWorld(),We.enabled===!0&&We.isPresenting===!0&&(We.cameraAutoUpdate===!0&&We.updateCamera(Se),Se=We.getCamera()),ee.isScene===!0&&ee.onBeforeRender(C,ee,Se,P),_=dn.get(ee,E.length),_.init(Se),E.push(_),Ke.multiplyMatrices(Se.projectionMatrix,Se.matrixWorldInverse),re.setFromProjectionMatrix(Ke),Te=this.localClippingEnabled,ce=lt.init(this.clippingPlanes,Te),b=gt.get(ee,T.length),b.init(),T.push(b),We.enabled===!0&&We.isPresenting===!0){const ot=C.xr.getDepthSensingMesh();ot!==null&&aa(ot,Se,-1/0,C.sortObjects)}aa(ee,Se,0,C.sortObjects),b.finish(),C.sortObjects===!0&&b.sort(se,G),kt=We.enabled===!1||We.isPresenting===!1||We.hasDepthSensing()===!1,kt&&Ft.addToRenderList(b,ee),this.info.render.frame++,ce===!0&&lt.beginShadows();const $e=_.state.shadowsArray;Dt.render($e,ee,Se),ce===!0&&lt.endShadows(),this.info.autoReset===!0&&this.info.reset();const Ge=b.opaque,Ee=b.transmissive;if(_.setupLights(),Se.isArrayCamera){const ot=Se.cameras;if(Ee.length>0)for(let bt=0,Tt=ot.length;bt<Tt;bt++){const Lt=ot[bt];Ho(Ge,Ee,ee,Lt)}kt&&Ft.render(ee);for(let bt=0,Tt=ot.length;bt<Tt;bt++){const Lt=ot[bt];Dp(b,ee,Lt,Lt.viewport)}}else Ee.length>0&&Ho(Ge,Ee,ee,Se),kt&&Ft.render(ee),Dp(b,ee,Se);P!==null&&L===0&&(ie.updateMultisampleRenderTarget(P),ie.updateRenderTargetMipmap(P)),ee.isScene===!0&&ee.onAfterRender(C,ee,Se),_t.resetDefaultState(),D=-1,O=null,E.pop(),E.length>0?(_=E[E.length-1],ce===!0&&lt.setGlobalState(C.clippingPlanes,_.state.camera)):_=null,T.pop(),T.length>0?b=T[T.length-1]:b=null};function aa(ee,Se,$e,Ge){if(ee.visible===!1)return;if(ee.layers.test(Se.layers)){if(ee.isGroup)$e=ee.renderOrder;else if(ee.isLOD)ee.autoUpdate===!0&&ee.update(Se);else if(ee.isLight)_.pushLight(ee),ee.castShadow&&_.pushShadow(ee);else if(ee.isSprite){if(!ee.frustumCulled||re.intersectsSprite(ee)){Ge&&ct.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(Ke);const bt=qe.update(ee),Tt=ee.material;Tt.visible&&b.push(ee,bt,Tt,$e,ct.z,null)}}else if((ee.isMesh||ee.isLine||ee.isPoints)&&(!ee.frustumCulled||re.intersectsObject(ee))){const bt=qe.update(ee),Tt=ee.material;if(Ge&&(ee.boundingSphere!==void 0?(ee.boundingSphere===null&&ee.computeBoundingSphere(),ct.copy(ee.boundingSphere.center)):(bt.boundingSphere===null&&bt.computeBoundingSphere(),ct.copy(bt.boundingSphere.center)),ct.applyMatrix4(ee.matrixWorld).applyMatrix4(Ke)),Array.isArray(Tt)){const Lt=bt.groups;for(let an=0,Zt=Lt.length;an<Zt;an++){const Xt=Lt[an],Dn=Tt[Xt.materialIndex];Dn&&Dn.visible&&b.push(ee,bt,Dn,$e,ct.z,Xt)}}else Tt.visible&&b.push(ee,bt,Tt,$e,ct.z,null)}}const ot=ee.children;for(let bt=0,Tt=ot.length;bt<Tt;bt++)aa(ot[bt],Se,$e,Ge)}function Dp(ee,Se,$e,Ge){const Ee=ee.opaque,ot=ee.transmissive,bt=ee.transparent;_.setupLightsView($e),ce===!0&&lt.setGlobalState(C.clippingPlanes,$e),Ge&&Pe.viewport(F.copy(Ge)),Ee.length>0&&Hr(Ee,Se,$e),ot.length>0&&Hr(ot,Se,$e),bt.length>0&&Hr(bt,Se,$e),Pe.buffers.depth.setTest(!0),Pe.buffers.depth.setMask(!0),Pe.buffers.color.setMask(!0),Pe.setPolygonOffset(!1)}function Ho(ee,Se,$e,Ge){if(($e.isScene===!0?$e.overrideMaterial:null)!==null)return;_.state.transmissionRenderTarget[Ge.id]===void 0&&(_.state.transmissionRenderTarget[Ge.id]=new hh(1,1,{generateMipmaps:!0,type:ze.has("EXT_color_buffer_half_float")||ze.has("EXT_color_buffer_float")?kx:nc,minFilter:tu,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Qn.workingColorSpace}));const ot=_.state.transmissionRenderTarget[Ge.id],bt=Ge.viewport||F;ot.setSize(bt.z*C.transmissionResolutionScale,bt.w*C.transmissionResolutionScale);const Tt=C.getRenderTarget();C.setRenderTarget(ot),C.getClearColor(J),Y=C.getClearAlpha(),Y<1&&C.setClearColor(16777215,.5),C.clear(),kt&&Ft.render($e);const Lt=C.toneMapping;C.toneMapping=th;const an=Ge.viewport;if(Ge.viewport!==void 0&&(Ge.viewport=void 0),_.setupLightsView(Ge),ce===!0&&lt.setGlobalState(C.clippingPlanes,Ge),Hr(ee,$e,Ge),ie.updateMultisampleRenderTarget(ot),ie.updateRenderTargetMipmap(ot),ze.has("WEBGL_multisampled_render_to_texture")===!1){let Zt=!1;for(let Xt=0,Dn=Se.length;Xt<Dn;Xt++){const Yn=Se[Xt],zs=Yn.object,Fn=Yn.geometry,$n=Yn.material,Qt=Yn.group;if($n.side===Ju&&zs.layers.test(Ge.layers)){const Vs=$n.side;$n.side=so,$n.needsUpdate=!0,Vo(zs,$e,Ge,Fn,$n,Qt),$n.side=Vs,$n.needsUpdate=!0,Zt=!0}}Zt===!0&&(ie.updateMultisampleRenderTarget(ot),ie.updateRenderTargetMipmap(ot))}C.setRenderTarget(Tt),C.setClearColor(J,Y),an!==void 0&&(Ge.viewport=an),C.toneMapping=Lt}function Hr(ee,Se,$e){const Ge=Se.isScene===!0?Se.overrideMaterial:null;for(let Ee=0,ot=ee.length;Ee<ot;Ee++){const bt=ee[Ee],Tt=bt.object,Lt=bt.geometry,an=bt.group;let Zt=bt.material;Zt.allowOverride===!0&&Ge!==null&&(Zt=Ge),Tt.layers.test($e.layers)&&Vo(Tt,Se,$e,Lt,Zt,an)}}function Vo(ee,Se,$e,Ge,Ee,ot){ee.onBeforeRender(C,Se,$e,Ge,Ee,ot),ee.modelViewMatrix.multiplyMatrices($e.matrixWorldInverse,ee.matrixWorld),ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix),Ee.onBeforeRender(C,Se,$e,Ge,ee,ot),Ee.transparent===!0&&Ee.side===Ju&&Ee.forceSinglePass===!1?(Ee.side=so,Ee.needsUpdate=!0,C.renderBufferDirect($e,Se,Ge,Ee,ee,ot),Ee.side=ch,Ee.needsUpdate=!0,C.renderBufferDirect($e,Se,Ge,Ee,ee,ot),Ee.side=Ju):C.renderBufferDirect($e,Se,Ge,Ee,ee,ot),ee.onAfterRender(C,Se,$e,Ge,Ee,ot)}function gs(ee,Se,$e){Se.isScene!==!0&&(Se=xt);const Ge=ke.get(ee),Ee=_.state.lights,ot=_.state.shadowsArray,bt=Ee.state.version,Tt=mt.getParameters(ee,Ee.state,ot,Se,$e),Lt=mt.getProgramCacheKey(Tt);let an=Ge.programs;Ge.environment=ee.isMeshStandardMaterial?Se.environment:null,Ge.fog=Se.fog,Ge.envMap=(ee.isMeshStandardMaterial?Ae:j).get(ee.envMap||Ge.environment),Ge.envMapRotation=Ge.environment!==null&&ee.envMap===null?Se.environmentRotation:ee.envMapRotation,an===void 0&&(ee.addEventListener("dispose",Kt),an=new Map,Ge.programs=an);let Zt=an.get(Lt);if(Zt!==void 0){if(Ge.currentProgram===Zt&&Ge.lightsStateVersion===bt)return Xo(ee,Tt),Zt}else Tt.uniforms=mt.getUniforms(ee),ee.onBeforeCompile(Tt,C),Zt=mt.acquireProgram(Tt,Lt),an.set(Lt,Zt),Ge.uniforms=Tt.uniforms;const Xt=Ge.uniforms;return(!ee.isShaderMaterial&&!ee.isRawShaderMaterial||ee.clipping===!0)&&(Xt.clippingPlanes=lt.uniform),Xo(ee,Tt),Ge.needsLights=bi(ee),Ge.lightsStateVersion=bt,Ge.needsLights&&(Xt.ambientLightColor.value=Ee.state.ambient,Xt.lightProbe.value=Ee.state.probe,Xt.directionalLights.value=Ee.state.directional,Xt.directionalLightShadows.value=Ee.state.directionalShadow,Xt.spotLights.value=Ee.state.spot,Xt.spotLightShadows.value=Ee.state.spotShadow,Xt.rectAreaLights.value=Ee.state.rectArea,Xt.ltc_1.value=Ee.state.rectAreaLTC1,Xt.ltc_2.value=Ee.state.rectAreaLTC2,Xt.pointLights.value=Ee.state.point,Xt.pointLightShadows.value=Ee.state.pointShadow,Xt.hemisphereLights.value=Ee.state.hemi,Xt.directionalShadowMap.value=Ee.state.directionalShadowMap,Xt.directionalShadowMatrix.value=Ee.state.directionalShadowMatrix,Xt.spotShadowMap.value=Ee.state.spotShadowMap,Xt.spotLightMatrix.value=Ee.state.spotLightMatrix,Xt.spotLightMap.value=Ee.state.spotLightMap,Xt.pointShadowMap.value=Ee.state.pointShadowMap,Xt.pointShadowMatrix.value=Ee.state.pointShadowMatrix),Ge.currentProgram=Zt,Ge.uniformsList=null,Zt}function Wo(ee){if(ee.uniformsList===null){const Se=ee.currentProgram.getUniforms();ee.uniformsList=ww.seqWithValue(Se.seq,ee.uniforms)}return ee.uniformsList}function Xo(ee,Se){const $e=ke.get(ee);$e.outputColorSpace=Se.outputColorSpace,$e.batching=Se.batching,$e.batchingColor=Se.batchingColor,$e.instancing=Se.instancing,$e.instancingColor=Se.instancingColor,$e.instancingMorph=Se.instancingMorph,$e.skinning=Se.skinning,$e.morphTargets=Se.morphTargets,$e.morphNormals=Se.morphNormals,$e.morphColors=Se.morphColors,$e.morphTargetsCount=Se.morphTargetsCount,$e.numClippingPlanes=Se.numClippingPlanes,$e.numIntersection=Se.numClipIntersection,$e.vertexAlphas=Se.vertexAlphas,$e.vertexTangents=Se.vertexTangents,$e.toneMapping=Se.toneMapping}function fc(ee,Se,$e,Ge,Ee){Se.isScene!==!0&&(Se=xt),ie.resetTextureUnits();const ot=Se.fog,bt=Ge.isMeshStandardMaterial?Se.environment:null,Tt=P===null?C.outputColorSpace:P.isXRRenderTarget===!0?P.texture.colorSpace:np,Lt=(Ge.isMeshStandardMaterial?Ae:j).get(Ge.envMap||bt),an=Ge.vertexColors===!0&&!!$e.attributes.color&&$e.attributes.color.itemSize===4,Zt=!!$e.attributes.tangent&&(!!Ge.normalMap||Ge.anisotropy>0),Xt=!!$e.morphAttributes.position,Dn=!!$e.morphAttributes.normal,Yn=!!$e.morphAttributes.color;let zs=th;Ge.toneMapped&&(P===null||P.isXRRenderTarget===!0)&&(zs=C.toneMapping);const Fn=$e.morphAttributes.position||$e.morphAttributes.normal||$e.morphAttributes.color,$n=Fn!==void 0?Fn.length:0,Qt=ke.get(Ge),Vs=_.state.lights;if(ce===!0&&(Te===!0||ee!==O)){const Gi=ee===O&&Ge.id===D;lt.setState(Ge,ee,Gi)}let Xn=!1;Ge.version===Qt.__version?(Qt.needsLights&&Qt.lightsStateVersion!==Vs.state.version||Qt.outputColorSpace!==Tt||Ee.isBatchedMesh&&Qt.batching===!1||!Ee.isBatchedMesh&&Qt.batching===!0||Ee.isBatchedMesh&&Qt.batchingColor===!0&&Ee.colorTexture===null||Ee.isBatchedMesh&&Qt.batchingColor===!1&&Ee.colorTexture!==null||Ee.isInstancedMesh&&Qt.instancing===!1||!Ee.isInstancedMesh&&Qt.instancing===!0||Ee.isSkinnedMesh&&Qt.skinning===!1||!Ee.isSkinnedMesh&&Qt.skinning===!0||Ee.isInstancedMesh&&Qt.instancingColor===!0&&Ee.instanceColor===null||Ee.isInstancedMesh&&Qt.instancingColor===!1&&Ee.instanceColor!==null||Ee.isInstancedMesh&&Qt.instancingMorph===!0&&Ee.morphTexture===null||Ee.isInstancedMesh&&Qt.instancingMorph===!1&&Ee.morphTexture!==null||Qt.envMap!==Lt||Ge.fog===!0&&Qt.fog!==ot||Qt.numClippingPlanes!==void 0&&(Qt.numClippingPlanes!==lt.numPlanes||Qt.numIntersection!==lt.numIntersection)||Qt.vertexAlphas!==an||Qt.vertexTangents!==Zt||Qt.morphTargets!==Xt||Qt.morphNormals!==Dn||Qt.morphColors!==Yn||Qt.toneMapping!==zs||Qt.morphTargetsCount!==$n)&&(Xn=!0):(Xn=!0,Qt.__version=Ge.version);let or=Qt.currentProgram;Xn===!0&&(or=gs(Ge,Se,Ee));let Cl=!1,_s=!1,El=!1;const ys=or.getUniforms(),lr=Qt.uniforms;if(Pe.useProgram(or.program)&&(Cl=!0,_s=!0,El=!0),Ge.id!==D&&(D=Ge.id,_s=!0),Cl||O!==ee){Pe.buffers.depth.getReversed()?(Be.copy(ee.projectionMatrix),kY(Be),LY(Be),ys.setValue(le,"projectionMatrix",Be)):ys.setValue(le,"projectionMatrix",ee.projectionMatrix),ys.setValue(le,"viewMatrix",ee.matrixWorldInverse);const Hi=ys.map.cameraPosition;Hi!==void 0&&Hi.setValue(le,ut.setFromMatrixPosition(ee.matrixWorld)),Fe.logarithmicDepthBuffer&&ys.setValue(le,"logDepthBufFC",2/(Math.log(ee.far+1)/Math.LN2)),(Ge.isMeshPhongMaterial||Ge.isMeshToonMaterial||Ge.isMeshLambertMaterial||Ge.isMeshBasicMaterial||Ge.isMeshStandardMaterial||Ge.isShaderMaterial)&&ys.setValue(le,"isOrthographic",ee.isOrthographicCamera===!0),O!==ee&&(O=ee,_s=!0,El=!0)}if(Ee.isSkinnedMesh){ys.setOptional(le,Ee,"bindMatrix"),ys.setOptional(le,Ee,"bindMatrixInverse");const Gi=Ee.skeleton;Gi&&(Gi.boneTexture===null&&Gi.computeBoneTexture(),ys.setValue(le,"boneTexture",Gi.boneTexture,ie))}Ee.isBatchedMesh&&(ys.setOptional(le,Ee,"batchingTexture"),ys.setValue(le,"batchingTexture",Ee._matricesTexture,ie),ys.setOptional(le,Ee,"batchingIdTexture"),ys.setValue(le,"batchingIdTexture",Ee._indirectTexture,ie),ys.setOptional(le,Ee,"batchingColorTexture"),Ee._colorsTexture!==null&&ys.setValue(le,"batchingColorTexture",Ee._colorsTexture,ie));const _i=$e.morphAttributes;if((_i.position!==void 0||_i.normal!==void 0||_i.color!==void 0)&&Pt.update(Ee,$e,or),(_s||Qt.receiveShadow!==Ee.receiveShadow)&&(Qt.receiveShadow=Ee.receiveShadow,ys.setValue(le,"receiveShadow",Ee.receiveShadow)),Ge.isMeshGouraudMaterial&&Ge.envMap!==null&&(lr.envMap.value=Lt,lr.flipEnvMap.value=Lt.isCubeTexture&&Lt.isRenderTargetTexture===!1?-1:1),Ge.isMeshStandardMaterial&&Ge.envMap===null&&Se.environment!==null&&(lr.envMapIntensity.value=Se.environmentIntensity),_s&&(ys.setValue(le,"toneMappingExposure",C.toneMappingExposure),Qt.needsLights&&yu(lr,El),ot&&Ge.fog===!0&&at.refreshFogUniforms(lr,ot),at.refreshMaterialUniforms(lr,Ge,V,W,_.state.transmissionRenderTarget[ee.id]),ww.upload(le,Wo(Qt),lr,ie)),Ge.isShaderMaterial&&Ge.uniformsNeedUpdate===!0&&(ww.upload(le,Wo(Qt),lr,ie),Ge.uniformsNeedUpdate=!1),Ge.isSpriteMaterial&&ys.setValue(le,"center",Ee.center),ys.setValue(le,"modelViewMatrix",Ee.modelViewMatrix),ys.setValue(le,"normalMatrix",Ee.normalMatrix),ys.setValue(le,"modelMatrix",Ee.matrixWorld),Ge.isShaderMaterial||Ge.isRawShaderMaterial){const Gi=Ge.uniformsGroups;for(let Hi=0,Vr=Gi.length;Hi<Vr;Hi++){const Ml=Gi[Hi];ge.update(Ml,or),ge.bind(Ml,or)}}return or}function yu(ee,Se){ee.ambientLightColor.needsUpdate=Se,ee.lightProbe.needsUpdate=Se,ee.directionalLights.needsUpdate=Se,ee.directionalLightShadows.needsUpdate=Se,ee.pointLights.needsUpdate=Se,ee.pointLightShadows.needsUpdate=Se,ee.spotLights.needsUpdate=Se,ee.spotLightShadows.needsUpdate=Se,ee.rectAreaLights.needsUpdate=Se,ee.hemisphereLights.needsUpdate=Se}function bi(ee){return ee.isMeshLambertMaterial||ee.isMeshToonMaterial||ee.isMeshPhongMaterial||ee.isMeshStandardMaterial||ee.isShadowMaterial||ee.isShaderMaterial&&ee.lights===!0}this.getActiveCubeFace=function(){return I},this.getActiveMipmapLevel=function(){return L},this.getRenderTarget=function(){return P},this.setRenderTargetTextures=function(ee,Se,$e){const Ge=ke.get(ee);Ge.__autoAllocateDepthBuffer=ee.resolveDepthBuffer===!1,Ge.__autoAllocateDepthBuffer===!1&&(Ge.__useRenderToTexture=!1),ke.get(ee.texture).__webglTexture=Se,ke.get(ee.depthTexture).__webglTexture=Ge.__autoAllocateDepthBuffer?void 0:$e,Ge.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(ee,Se){const $e=ke.get(ee);$e.__webglFramebuffer=Se,$e.__useDefaultFramebuffer=Se===void 0};const Of=le.createFramebuffer();this.setRenderTarget=function(ee,Se=0,$e=0){P=ee,I=Se,L=$e;let Ge=!0,Ee=null,ot=!1,bt=!1;if(ee){const Lt=ke.get(ee);if(Lt.__useDefaultFramebuffer!==void 0)Pe.bindFramebuffer(le.FRAMEBUFFER,null),Ge=!1;else if(Lt.__webglFramebuffer===void 0)ie.setupRenderTarget(ee);else if(Lt.__hasExternalTextures)ie.rebindTextures(ee,ke.get(ee.texture).__webglTexture,ke.get(ee.depthTexture).__webglTexture);else if(ee.depthBuffer){const Xt=ee.depthTexture;if(Lt.__boundDepthTexture!==Xt){if(Xt!==null&&ke.has(Xt)&&(ee.width!==Xt.image.width||ee.height!==Xt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");ie.setupDepthRenderbuffer(ee)}}const an=ee.texture;(an.isData3DTexture||an.isDataArrayTexture||an.isCompressedArrayTexture)&&(bt=!0);const Zt=ke.get(ee).__webglFramebuffer;ee.isWebGLCubeRenderTarget?(Array.isArray(Zt[Se])?Ee=Zt[Se][$e]:Ee=Zt[Se],ot=!0):ee.samples>0&&ie.useMultisampledRTT(ee)===!1?Ee=ke.get(ee).__webglMultisampledFramebuffer:Array.isArray(Zt)?Ee=Zt[$e]:Ee=Zt,F.copy(ee.viewport),X.copy(ee.scissor),q=ee.scissorTest}else F.copy(ne).multiplyScalar(V).floor(),X.copy(oe).multiplyScalar(V).floor(),q=ue;if($e!==0&&(Ee=Of),Pe.bindFramebuffer(le.FRAMEBUFFER,Ee)&&Ge&&Pe.drawBuffers(ee,Ee),Pe.viewport(F),Pe.scissor(X),Pe.setScissorTest(q),ot){const Lt=ke.get(ee.texture);le.framebufferTexture2D(le.FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_CUBE_MAP_POSITIVE_X+Se,Lt.__webglTexture,$e)}else if(bt){const Lt=ke.get(ee.texture),an=Se;le.framebufferTextureLayer(le.FRAMEBUFFER,le.COLOR_ATTACHMENT0,Lt.__webglTexture,$e,an)}else if(ee!==null&&$e!==0){const Lt=ke.get(ee.texture);le.framebufferTexture2D(le.FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_2D,Lt.__webglTexture,$e)}D=-1},this.readRenderTargetPixels=function(ee,Se,$e,Ge,Ee,ot,bt){if(!(ee&&ee.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Tt=ke.get(ee).__webglFramebuffer;if(ee.isWebGLCubeRenderTarget&&bt!==void 0&&(Tt=Tt[bt]),Tt){Pe.bindFramebuffer(le.FRAMEBUFFER,Tt);try{const Lt=ee.texture,an=Lt.format,Zt=Lt.type;if(!Fe.textureFormatReadable(an)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Fe.textureTypeReadable(Zt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Se>=0&&Se<=ee.width-Ge&&$e>=0&&$e<=ee.height-Ee&&le.readPixels(Se,$e,Ge,Ee,Je.convert(an),Je.convert(Zt),ot)}finally{const Lt=P!==null?ke.get(P).__webglFramebuffer:null;Pe.bindFramebuffer(le.FRAMEBUFFER,Lt)}}},this.readRenderTargetPixelsAsync=async function(ee,Se,$e,Ge,Ee,ot,bt){if(!(ee&&ee.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let Tt=ke.get(ee).__webglFramebuffer;if(ee.isWebGLCubeRenderTarget&&bt!==void 0&&(Tt=Tt[bt]),Tt)if(Se>=0&&Se<=ee.width-Ge&&$e>=0&&$e<=ee.height-Ee){Pe.bindFramebuffer(le.FRAMEBUFFER,Tt);const Lt=ee.texture,an=Lt.format,Zt=Lt.type;if(!Fe.textureFormatReadable(an))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Fe.textureTypeReadable(Zt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const Xt=le.createBuffer();le.bindBuffer(le.PIXEL_PACK_BUFFER,Xt),le.bufferData(le.PIXEL_PACK_BUFFER,ot.byteLength,le.STREAM_READ),le.readPixels(Se,$e,Ge,Ee,Je.convert(an),Je.convert(Zt),0);const Dn=P!==null?ke.get(P).__webglFramebuffer:null;Pe.bindFramebuffer(le.FRAMEBUFFER,Dn);const Yn=le.fenceSync(le.SYNC_GPU_COMMANDS_COMPLETE,0);return le.flush(),await BY(le,Yn,4),le.bindBuffer(le.PIXEL_PACK_BUFFER,Xt),le.getBufferSubData(le.PIXEL_PACK_BUFFER,0,ot),le.deleteBuffer(Xt),le.deleteSync(Yn),ot}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(ee,Se=null,$e=0){const Ge=Math.pow(2,-$e),Ee=Math.floor(ee.image.width*Ge),ot=Math.floor(ee.image.height*Ge),bt=Se!==null?Se.x:0,Tt=Se!==null?Se.y:0;ie.setTexture2D(ee,0),le.copyTexSubImage2D(le.TEXTURE_2D,$e,0,0,bt,Tt,Ee,ot),Pe.unbindTexture()};const Bf=le.createFramebuffer(),qo=le.createFramebuffer();this.copyTextureToTexture=function(ee,Se,$e=null,Ge=null,Ee=0,ot=null){ot===null&&(Ee!==0?(Aw("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),ot=Ee,Ee=0):ot=0);let bt,Tt,Lt,an,Zt,Xt,Dn,Yn,zs;const Fn=ee.isCompressedTexture?ee.mipmaps[ot]:ee.image;if($e!==null)bt=$e.max.x-$e.min.x,Tt=$e.max.y-$e.min.y,Lt=$e.isBox3?$e.max.z-$e.min.z:1,an=$e.min.x,Zt=$e.min.y,Xt=$e.isBox3?$e.min.z:0;else{const _i=Math.pow(2,-Ee);bt=Math.floor(Fn.width*_i),Tt=Math.floor(Fn.height*_i),ee.isDataArrayTexture?Lt=Fn.depth:ee.isData3DTexture?Lt=Math.floor(Fn.depth*_i):Lt=1,an=0,Zt=0,Xt=0}Ge!==null?(Dn=Ge.x,Yn=Ge.y,zs=Ge.z):(Dn=0,Yn=0,zs=0);const $n=Je.convert(Se.format),Qt=Je.convert(Se.type);let Vs;Se.isData3DTexture?(ie.setTexture3D(Se,0),Vs=le.TEXTURE_3D):Se.isDataArrayTexture||Se.isCompressedArrayTexture?(ie.setTexture2DArray(Se,0),Vs=le.TEXTURE_2D_ARRAY):(ie.setTexture2D(Se,0),Vs=le.TEXTURE_2D),le.pixelStorei(le.UNPACK_FLIP_Y_WEBGL,Se.flipY),le.pixelStorei(le.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Se.premultiplyAlpha),le.pixelStorei(le.UNPACK_ALIGNMENT,Se.unpackAlignment);const Xn=le.getParameter(le.UNPACK_ROW_LENGTH),or=le.getParameter(le.UNPACK_IMAGE_HEIGHT),Cl=le.getParameter(le.UNPACK_SKIP_PIXELS),_s=le.getParameter(le.UNPACK_SKIP_ROWS),El=le.getParameter(le.UNPACK_SKIP_IMAGES);le.pixelStorei(le.UNPACK_ROW_LENGTH,Fn.width),le.pixelStorei(le.UNPACK_IMAGE_HEIGHT,Fn.height),le.pixelStorei(le.UNPACK_SKIP_PIXELS,an),le.pixelStorei(le.UNPACK_SKIP_ROWS,Zt),le.pixelStorei(le.UNPACK_SKIP_IMAGES,Xt);const ys=ee.isDataArrayTexture||ee.isData3DTexture,lr=Se.isDataArrayTexture||Se.isData3DTexture;if(ee.isDepthTexture){const _i=ke.get(ee),Gi=ke.get(Se),Hi=ke.get(_i.__renderTarget),Vr=ke.get(Gi.__renderTarget);Pe.bindFramebuffer(le.READ_FRAMEBUFFER,Hi.__webglFramebuffer),Pe.bindFramebuffer(le.DRAW_FRAMEBUFFER,Vr.__webglFramebuffer);for(let Ml=0;Ml<Lt;Ml++)ys&&(le.framebufferTextureLayer(le.READ_FRAMEBUFFER,le.COLOR_ATTACHMENT0,ke.get(ee).__webglTexture,Ee,Xt+Ml),le.framebufferTextureLayer(le.DRAW_FRAMEBUFFER,le.COLOR_ATTACHMENT0,ke.get(Se).__webglTexture,ot,zs+Ml)),le.blitFramebuffer(an,Zt,bt,Tt,Dn,Yn,bt,Tt,le.DEPTH_BUFFER_BIT,le.NEAREST);Pe.bindFramebuffer(le.READ_FRAMEBUFFER,null),Pe.bindFramebuffer(le.DRAW_FRAMEBUFFER,null)}else if(Ee!==0||ee.isRenderTargetTexture||ke.has(ee)){const _i=ke.get(ee),Gi=ke.get(Se);Pe.bindFramebuffer(le.READ_FRAMEBUFFER,Bf),Pe.bindFramebuffer(le.DRAW_FRAMEBUFFER,qo);for(let Hi=0;Hi<Lt;Hi++)ys?le.framebufferTextureLayer(le.READ_FRAMEBUFFER,le.COLOR_ATTACHMENT0,_i.__webglTexture,Ee,Xt+Hi):le.framebufferTexture2D(le.READ_FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_2D,_i.__webglTexture,Ee),lr?le.framebufferTextureLayer(le.DRAW_FRAMEBUFFER,le.COLOR_ATTACHMENT0,Gi.__webglTexture,ot,zs+Hi):le.framebufferTexture2D(le.DRAW_FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_2D,Gi.__webglTexture,ot),Ee!==0?le.blitFramebuffer(an,Zt,bt,Tt,Dn,Yn,bt,Tt,le.COLOR_BUFFER_BIT,le.NEAREST):lr?le.copyTexSubImage3D(Vs,ot,Dn,Yn,zs+Hi,an,Zt,bt,Tt):le.copyTexSubImage2D(Vs,ot,Dn,Yn,an,Zt,bt,Tt);Pe.bindFramebuffer(le.READ_FRAMEBUFFER,null),Pe.bindFramebuffer(le.DRAW_FRAMEBUFFER,null)}else lr?ee.isDataTexture||ee.isData3DTexture?le.texSubImage3D(Vs,ot,Dn,Yn,zs,bt,Tt,Lt,$n,Qt,Fn.data):Se.isCompressedArrayTexture?le.compressedTexSubImage3D(Vs,ot,Dn,Yn,zs,bt,Tt,Lt,$n,Fn.data):le.texSubImage3D(Vs,ot,Dn,Yn,zs,bt,Tt,Lt,$n,Qt,Fn):ee.isDataTexture?le.texSubImage2D(le.TEXTURE_2D,ot,Dn,Yn,bt,Tt,$n,Qt,Fn.data):ee.isCompressedTexture?le.compressedTexSubImage2D(le.TEXTURE_2D,ot,Dn,Yn,Fn.width,Fn.height,$n,Fn.data):le.texSubImage2D(le.TEXTURE_2D,ot,Dn,Yn,bt,Tt,$n,Qt,Fn);le.pixelStorei(le.UNPACK_ROW_LENGTH,Xn),le.pixelStorei(le.UNPACK_IMAGE_HEIGHT,or),le.pixelStorei(le.UNPACK_SKIP_PIXELS,Cl),le.pixelStorei(le.UNPACK_SKIP_ROWS,_s),le.pixelStorei(le.UNPACK_SKIP_IMAGES,El),ot===0&&Se.generateMipmaps&&le.generateMipmap(Vs),Pe.unbindTexture()},this.copyTextureToTexture3D=function(ee,Se,$e=null,Ge=null,Ee=0){return Aw('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(ee,Se,$e,Ge,Ee)},this.initRenderTarget=function(ee){ke.get(ee).__webglFramebuffer===void 0&&ie.setupRenderTarget(ee)},this.initTexture=function(ee){ee.isCubeTexture?ie.setTextureCube(ee,0):ee.isData3DTexture?ie.setTexture3D(ee,0):ee.isDataArrayTexture||ee.isCompressedArrayTexture?ie.setTexture2DArray(ee,0):ie.setTexture2D(ee,0),Pe.unbindTexture()},this.resetState=function(){I=0,L=0,P=null,Pe.reset(),_t.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Zu}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=Qn._getDrawingBufferColorSpace(e),t.unpackColorSpace=Qn._getUnpackColorSpace()}}const Wse=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:A3,AddEquation:Ld,AddOperation:r9,AdditiveAnimationBlendMode:O3,AdditiveBlending:DI,AgXToneMapping:c9,AlphaFormat:E3,AlwaysCompare:C9,AlwaysDepth:Xw,AlwaysStencilFunc:LI,AmbientLight:p6,AnimationAction:T6,AnimationClip:fx,AnimationLoader:oZ,AnimationMixer:BZ,AnimationObjectGroup:DZ,AnimationUtils:sZ,ArcCurve:z9,ArrayCamera:_6,ArrowHelper:nQ,AttachedBindMode:kI,Audio:S6,AudioAnalyser:SZ,AudioContext:lO,AudioListener:vZ,AudioLoader:gZ,AxesHelper:sQ,BackSide:so,BasicDepthPacking:y9,BasicShadowMap:Uz,BatchedMesh:U9,Bone:kC,BooleanKeyframeTrack:jg,Box2:GZ,Box3:Ea,Box3Helper:eQ,BoxGeometry:qg,BoxHelper:QZ,BufferAttribute:us,BufferGeometry:Tn,BufferGeometryLoader:v6,ByteType:T3,Cache:lf,Camera:DC,CameraHelper:ZZ,CanvasTexture:CJ,CapsuleGeometry:UC,CatmullRomCurve3:G9,CineonToneMapping:l9,CircleGeometry:$C,ClampToEdgeWrapping:hl,Clock:uO,Color:Nt,ColorKeyframeTrack:nO,ColorManagement:Qn,CompressedArrayTexture:TJ,CompressedCubeTexture:wJ,CompressedTexture:FC,CompressedTextureLoader:lZ,ConeGeometry:zC,ConstantAlphaFactor:n9,ConstantColorFactor:e9,Controls:rQ,CubeCamera:B9,CubeReflectionMapping:yf,CubeRefractionMapping:ep,CubeTexture:t_,CubeTextureLoader:uZ,CubeUVReflectionMapping:Bx,CubicBezierCurve:q3,CubicBezierCurve3:H9,CubicInterpolant:l6,CullFaceBack:II,CullFaceFront:Pz,CullFaceFrontBack:UK,CullFaceNone:Fz,Curve:uc,CurvePath:W9,CustomBlending:$z,CustomToneMapping:u9,CylinderGeometry:Lx,Cylindrical:zZ,Data3DTexture:IC,DataArrayTexture:e_,DataTexture:nh,DataTextureLoader:cZ,DataUtils:JY,DecrementStencilOp:YK,DecrementWrapStencilOp:ZK,DefaultLoadingManager:h6,DepthFormat:ix,DepthStencilFormat:rx,DepthTexture:W3,DetachedBindMode:f9,DirectionalLight:oO,DirectionalLightHelper:JZ,DiscreteInterpolant:u6,DodecahedronGeometry:GC,DoubleSide:Ju,DstAlphaFactor:Kz,DstColorFactor:Jz,DynamicCopyUsage:dY,DynamicDrawUsage:oY,DynamicReadUsage:cY,EdgesGeometry:X9,EllipseCurve:PC,EqualCompare:S9,EqualDepth:jw,EqualStencilFunc:nY,EquirectangularReflectionMapping:fb,EquirectangularRefractionMapping:db,Euler:xl,EventDispatcher:yh,ExtrudeGeometry:HC,FileLoader:vl,Float16BufferAttribute:iJ,Float32BufferAttribute:Vt,FloatType:Eo,Fog:BC,FogExp2:OC,FramebufferTexture:AJ,FrontSide:ch,Frustum:i_,GLBufferAttribute:$Z,GLSL1:mY,GLSL3:FI,GreaterCompare:A9,GreaterDepth:Yw,GreaterEqualCompare:w9,GreaterEqualDepth:Kw,GreaterEqualStencilFunc:aY,GreaterStencilFunc:iY,GridHelper:KZ,Group:of,HalfFloatType:kx,HemisphereLight:d6,HemisphereLightHelper:jZ,IcosahedronGeometry:VC,ImageBitmapLoader:b6,ImageLoader:Ab,ImageUtils:R9,IncrementStencilOp:KK,IncrementWrapStencilOp:JK,InstancedBufferAttribute:Ag,InstancedBufferGeometry:x6,InstancedInterleavedBuffer:UZ,InstancedMesh:G3,Int16BufferAttribute:nJ,Int32BufferAttribute:sJ,Int8BufferAttribute:QY,IntType:AC,InterleavedBuffer:n_,InterleavedBufferAttribute:sp,Interpolant:Px,InterpolateDiscrete:ax,InterpolateLinear:ox,InterpolateSmooth:Sw,InvertStencilOp:QK,KeepStencilOp:Xm,KeyframeTrack:du,LOD:P9,LatheGeometry:r_,Layers:ux,LessCompare:_9,LessDepth:qw,LessEqualCompare:k3,LessEqualDepth:Sg,LessEqualStencilFunc:sY,LessStencilFunc:tY,Light:xp,LightProbe:y6,Line:vf,Line3:HZ,LineBasicMaterial:Ra,LineCurve:j3,LineCurve3:V9,LineDashedMaterial:r6,LineLoop:H3,LineSegments:lc,LinearFilter:$i,LinearInterpolant:tO,LinearMipMapLinearFilter:HK,LinearMipMapNearestFilter:GK,LinearMipmapLinearFilter:tu,LinearMipmapNearestFilter:Gy,LinearSRGBColorSpace:np,LinearToneMapping:a9,LinearTransfer:mb,Loader:Ia,LoaderUtils:Xd,LoadingManager:sO,LoopOnce:d9,LoopPingPong:m9,LoopRepeat:p9,LuminanceAlphaFormat:R3,LuminanceFormat:N3,MOUSE:Vm,Material:br,MaterialLoader:JC,MathUtils:E9,Matrix2:dO,Matrix3:An,Matrix4:rn,MaxEquation:Vz,Mesh:zi,MeshBasicMaterial:fl,MeshDepthMaterial:Z3,MeshDistanceMaterial:Q3,MeshLambertMaterial:s6,MeshMatcapMaterial:i6,MeshNormalMaterial:n6,MeshPhongMaterial:e6,MeshPhysicalMaterial:fu,MeshStandardMaterial:l_,MeshToonMaterial:t6,MinEquation:Hz,MirroredRepeatWrapping:tx,MixOperation:i9,MultiplyBlending:BI,MultiplyOperation:Zb,NearestFilter:Br,NearestMipMapLinearFilter:zK,NearestMipMapNearestFilter:$K,NearestMipmapLinearFilter:ng,NearestMipmapNearestFilter:SC,NeutralToneMapping:h9,NeverCompare:b9,NeverDepth:Ww,NeverStencilFunc:eY,NoBlending:cf,NoColorSpace:sf,NoToneMapping:th,NormalAnimationBlendMode:NC,NormalBlending:hg,NotEqualCompare:T9,NotEqualDepth:Jw,NotEqualStencilFunc:rY,NumberKeyframeTrack:wg,Object3D:ts,ObjectLoader:pZ,ObjectSpaceNormalMap:v9,OctahedronGeometry:a_,OneFactor:Xz,OneMinusConstantAlphaFactor:s9,OneMinusConstantColorFactor:t9,OneMinusDstAlphaFactor:Yz,OneMinusDstColorFactor:Zz,OneMinusSrcAlphaFactor:Vw,OneMinusSrcColorFactor:jz,OrthographicCamera:ff,PCFShadowMap:bC,PCFSoftShadowMap:J1,PMREMGenerator:WI,Path:vb,PerspectiveCamera:Ci,Plane:Zh,PlaneGeometry:Fx,PlaneHelper:tQ,PointLight:aO,PointLightHelper:XZ,Points:V3,PointsMaterial:LC,PolarGridHelper:YZ,PolyhedronGeometry:yp,PositionalAudio:_Z,PropertyBinding:rs,PropertyMixer:A6,QuadraticBezierCurve:K3,QuadraticBezierCurve3:Y3,Quaternion:kr,QuaternionKeyframeTrack:Cg,QuaternionLinearInterpolant:c6,RED_GREEN_RGTC2_Format:S2,RED_RGTC1_Format:D3,REVISION:Jb,RGBADepthPacking:x9,RGBAFormat:wa,RGBAIntegerFormat:MC,RGBA_ASTC_10x10_Format:g2,RGBA_ASTC_10x5_Format:d2,RGBA_ASTC_10x6_Format:p2,RGBA_ASTC_10x8_Format:m2,RGBA_ASTC_12x10_Format:y2,RGBA_ASTC_12x12_Format:x2,RGBA_ASTC_4x4_Format:r2,RGBA_ASTC_5x4_Format:a2,RGBA_ASTC_5x5_Format:o2,RGBA_ASTC_6x5_Format:l2,RGBA_ASTC_6x6_Format:u2,RGBA_ASTC_8x5_Format:c2,RGBA_ASTC_8x6_Format:h2,RGBA_ASTC_8x8_Format:f2,RGBA_BPTC_Format:nb,RGBA_ETC2_EAC_Format:i2,RGBA_PVRTC_2BPPV1_Format:t2,RGBA_PVRTC_4BPPV1_Format:e2,RGBA_S3TC_DXT1_Format:Q1,RGBA_S3TC_DXT3_Format:eb,RGBA_S3TC_DXT5_Format:tb,RGBDepthPacking:WK,RGBFormat:M3,RGBIntegerFormat:VK,RGB_BPTC_SIGNED_Format:v2,RGB_BPTC_UNSIGNED_Format:b2,RGB_ETC1_Format:n2,RGB_ETC2_Format:s2,RGB_PVRTC_2BPPV1_Format:Qw,RGB_PVRTC_4BPPV1_Format:Zw,RGB_S3TC_DXT1_Format:Z1,RGDepthPacking:XK,RGFormat:I3,RGIntegerFormat:EC,RawShaderMaterial:Q9,Ray:Xg,Raycaster:w6,RectAreaLight:m6,RedFormat:CC,RedIntegerFormat:Qb,ReinhardToneMapping:o9,RenderTarget:RC,RenderTarget3D:kZ,RenderTargetArray:LZ,RepeatWrapping:tp,ReplaceStencilOp:jK,ReverseSubtractEquation:Gz,RingGeometry:WC,SIGNED_RED_GREEN_RGTC2_Format:A2,SIGNED_RED_RGTC1_Format:_2,SRGBColorSpace:va,SRGBTransfer:Cs,Scene:U3,ShaderChunk:In,ShaderLib:ju,ShaderMaterial:sc,ShadowMaterial:Z9,Shape:dg,ShapeGeometry:XC,ShapePath:iQ,ShapeUtils:sh,ShortType:w3,Skeleton:s_,SkeletonHelper:WZ,SkinnedMesh:z3,Source:Pd,Sphere:ea,SphereGeometry:o_,Spherical:HI,SphericalHarmonics3:g6,SplineCurve:J3,SpotLight:rO,SpotLightHelper:VZ,Sprite:F9,SpriteMaterial:$3,SrcAlphaFactor:Hw,SrcAlphaSaturateFactor:Qz,SrcColorFactor:qz,StaticCopyUsage:fY,StaticDrawUsage:gb,StaticReadUsage:uY,StereoCamera:yZ,StreamCopyUsage:pY,StreamDrawUsage:lY,StreamReadUsage:hY,StringKeyframeTrack:Kg,SubtractEquation:zz,SubtractiveBlending:OI,TOUCH:Wm,TangentSpaceNormalMap:gp,TetrahedronGeometry:qC,Texture:ii,TextureLoader:f6,TextureUtils:cQ,TimestampQuery:gY,TorusGeometry:jC,TorusKnotGeometry:KC,Triangle:wo,TriangleFanDrawMode:T2,TriangleStripDrawMode:B3,TrianglesDrawMode:g9,TubeGeometry:YC,UVMapping:_C,Uint16BufferAttribute:F3,Uint32BufferAttribute:P3,Uint8BufferAttribute:eJ,Uint8ClampedBufferAttribute:tJ,Uniform:fO,UniformsGroup:PZ,UniformsLib:It,UniformsUtils:O9,UnsignedByteType:nc,UnsignedInt248Type:sx,UnsignedInt5999Type:C3,UnsignedIntType:xf,UnsignedShort4444Type:TC,UnsignedShort5551Type:wC,UnsignedShortType:nx,VSMShadowMap:qu,Vector2:tt,Vector3:ae,Vector4:os,VectorKeyframeTrack:Eg,VideoFrameTexture:SJ,VideoTexture:$9,WebGL3DRenderTarget:zY,WebGLArrayRenderTarget:$Y,WebGLCoordinateSystem:Zu,WebGLCubeRenderTarget:k9,WebGLRenderTarget:hh,WebGLRenderer:O6,WebGLUtils:D6,WebGPUCoordinateSystem:yb,WebXRController:Tw,WireframeGeometry:J9,WrapAroundEnding:pb,ZeroCurvatureEnding:sg,ZeroFactor:Wz,ZeroSlopeEnding:ig,ZeroStencilOp:qK,createCanvasElement:N9},Symbol.toStringTag,{value:"Module"}));var MR={exports:{}},Kh={};/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _P;function Xse(){return _P||(_P=1,Kh.ConcurrentRoot=1,Kh.ContinuousEventPriority=8,Kh.DefaultEventPriority=32,Kh.DiscreteEventPriority=2,Kh.IdleEventPriority=268435456,Kh.LegacyRoot=0,Kh.NoEventPriority=0),Kh}var SP;function qse(){return SP||(SP=1,MR.exports=Xse()),MR.exports}var Cw=qse(),NR={exports:{}},RR={},IR={exports:{}},DR={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var AP;function jse(){if(AP)return DR;AP=1;var s=Dx();function e(f,d){return f===d&&(f!==0||1/f===1/d)||f!==f&&d!==d}var t=typeof Object.is=="function"?Object.is:e,n=s.useState,i=s.useEffect,r=s.useLayoutEffect,a=s.useDebugValue;function o(f,d){var g=d(),x=n({inst:{value:g,getSnapshot:d}}),S=x[0].inst,b=x[1];return r(function(){S.value=g,S.getSnapshot=d,l(S)&&b({inst:S})},[f,g,d]),i(function(){return l(S)&&b({inst:S}),f(function(){l(S)&&b({inst:S})})},[f]),a(g),g}function l(f){var d=f.getSnapshot;f=f.value;try{var g=d();return!t(f,g)}catch{return!0}}function u(f,d){return d()}var c=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?u:o;return DR.useSyncExternalStore=s.useSyncExternalStore!==void 0?s.useSyncExternalStore:c,DR}var TP;function Kse(){return TP||(TP=1,IR.exports=jse()),IR.exports}/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var wP;function Yse(){if(wP)return RR;wP=1;var s=Dx(),e=Kse();function t(u,c){return u===c&&(u!==0||1/u===1/c)||u!==u&&c!==c}var n=typeof Object.is=="function"?Object.is:t,i=e.useSyncExternalStore,r=s.useRef,a=s.useEffect,o=s.useMemo,l=s.useDebugValue;return RR.useSyncExternalStoreWithSelector=function(u,c,f,d,g){var x=r(null);if(x.current===null){var S={hasValue:!1,value:null};x.current=S}else S=x.current;x=o(function(){function _(I){if(!T){if(T=!0,E=I,I=d(I),g!==void 0&&S.hasValue){var L=S.value;if(g(L,I))return C=L}return C=I}if(L=C,n(E,I))return L;var P=d(I);return g!==void 0&&g(L,P)?(E=I,L):(E=I,C=P)}var T=!1,E,C,R=f===void 0?null:f;return[function(){return _(c())},R===null?void 0:function(){return _(R())}]},[c,f,d,g]);var b=i(u,x[0],x[1]);return a(function(){S.hasValue=!0,S.value=b},[b]),l(b),b},RR}var CP;function Jse(){return CP||(CP=1,NR.exports=Yse()),NR.exports}var Zse=Jse();const Qse=yC(Zse),EP=s=>{let e;const t=new Set,n=(u,c)=>{const f=typeof u=="function"?u(e):u;if(!Object.is(f,e)){const d=e;e=c??(typeof f!="object"||f===null)?f:Object.assign({},e,f),t.forEach(g=>g(e,d))}},i=()=>e,o={setState:n,getState:i,getInitialState:()=>l,subscribe:u=>(t.add(u),()=>t.delete(u))},l=e=s(n,i,o);return o},eie=s=>s?EP(s):EP,{useSyncExternalStoreWithSelector:tie}=Qse,nie=s=>s;function sie(s,e=nie,t){const n=tie(s.subscribe,s.getState,s.getInitialState,e,t);return Wd.useDebugValue(n),n}const MP=(s,e)=>{const t=eie(s),n=(i,r=e)=>sie(t,i,r);return Object.assign(n,t),n},iie=(s,e)=>s?MP(s,e):MP;var OR={exports:{}},BR={exports:{}},kR={exports:{}},LR={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var NP;function rie(){return NP||(NP=1,function(s){function e($,W){var V=$.length;$.push(W);e:for(;0<V;){var se=V-1>>>1,G=$[se];if(0<i(G,W))$[se]=W,$[V]=G,V=se;else break e}}function t($){return $.length===0?null:$[0]}function n($){if($.length===0)return null;var W=$[0],V=$.pop();if(V!==W){$[0]=V;e:for(var se=0,G=$.length,ne=G>>>1;se<ne;){var oe=2*(se+1)-1,ue=$[oe],re=oe+1,ce=$[re];if(0>i(ue,V))re<G&&0>i(ce,ue)?($[se]=ce,$[re]=V,se=re):($[se]=ue,$[oe]=V,se=oe);else if(re<G&&0>i(ce,V))$[se]=ce,$[re]=V,se=re;else break e}}return W}function i($,W){var V=$.sortIndex-W.sortIndex;return V!==0?V:$.id-W.id}if(s.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;s.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();s.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,f=null,d=3,g=!1,x=!1,S=!1,b=typeof setTimeout=="function"?setTimeout:null,_=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function E($){for(var W=t(u);W!==null;){if(W.callback===null)n(u);else if(W.startTime<=$)n(u),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(u)}}function C($){if(S=!1,E($),!x)if(t(l)!==null)x=!0,J();else{var W=t(u);W!==null&&Y(C,W.startTime-$)}}var R=!1,I=-1,L=5,P=-1;function D(){return!(s.unstable_now()-P<L)}function O(){if(R){var $=s.unstable_now();P=$;var W=!0;try{e:{x=!1,S&&(S=!1,_(I),I=-1),g=!0;var V=d;try{t:{for(E($),f=t(l);f!==null&&!(f.expirationTime>$&&D());){var se=f.callback;if(typeof se=="function"){f.callback=null,d=f.priorityLevel;var G=se(f.expirationTime<=$);if($=s.unstable_now(),typeof G=="function"){f.callback=G,E($),W=!0;break t}f===t(l)&&n(l),E($)}else n(l);f=t(l)}if(f!==null)W=!0;else{var ne=t(u);ne!==null&&Y(C,ne.startTime-$),W=!1}}break e}finally{f=null,d=V,g=!1}W=void 0}}finally{W?F():R=!1}}}var F;if(typeof T=="function")F=function(){T(O)};else if(typeof MessageChannel<"u"){var X=new MessageChannel,q=X.port2;X.port1.onmessage=O,F=function(){q.postMessage(null)}}else F=function(){b(O,0)};function J(){R||(R=!0,F())}function Y($,W){I=b(function(){$(s.unstable_now())},W)}s.unstable_IdlePriority=5,s.unstable_ImmediatePriority=1,s.unstable_LowPriority=4,s.unstable_NormalPriority=3,s.unstable_Profiling=null,s.unstable_UserBlockingPriority=2,s.unstable_cancelCallback=function($){$.callback=null},s.unstable_continueExecution=function(){x||g||(x=!0,J())},s.unstable_forceFrameRate=function($){0>$||125<$?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<$?Math.floor(1e3/$):5},s.unstable_getCurrentPriorityLevel=function(){return d},s.unstable_getFirstCallbackNode=function(){return t(l)},s.unstable_next=function($){switch(d){case 1:case 2:case 3:var W=3;break;default:W=d}var V=d;d=W;try{return $()}finally{d=V}},s.unstable_pauseExecution=function(){},s.unstable_requestPaint=function(){},s.unstable_runWithPriority=function($,W){switch($){case 1:case 2:case 3:case 4:case 5:break;default:$=3}var V=d;d=$;try{return W()}finally{d=V}},s.unstable_scheduleCallback=function($,W,V){var se=s.unstable_now();switch(typeof V=="object"&&V!==null?(V=V.delay,V=typeof V=="number"&&0<V?se+V:se):V=se,$){case 1:var G=-1;break;case 2:G=250;break;case 5:G=1073741823;break;case 4:G=1e4;break;default:G=5e3}return G=V+G,$={id:c++,callback:W,priorityLevel:$,startTime:V,expirationTime:G,sortIndex:-1},V>se?($.sortIndex=V,e(u,$),t(l)===null&&$===t(u)&&(S?(_(I),I=-1):S=!0,Y(C,V-se))):($.sortIndex=G,e(l,$),x||g||(x=!0,J())),$},s.unstable_shouldYield=D,s.unstable_wrapCallback=function($){var W=d;return function(){var V=d;d=W;try{return $.apply(this,arguments)}finally{d=V}}}}(LR)),LR}var RP;function aie(){return RP||(RP=1,kR.exports=rie()),kR.exports}/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var IP;function oie(){return IP||(IP=1,function(s){s.exports=function(e){function t(m,y,w,N){return new Ov(m,y,w,N)}function n(){}function i(m){var y="https://react.dev/errors/"+m;if(1<arguments.length){y+="?args[]="+encodeURIComponent(arguments[1]);for(var w=2;w<arguments.length;w++)y+="&args[]="+encodeURIComponent(arguments[w])}return"Minified React error #"+m+"; visit "+y+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(m){return m===null||typeof m!="object"?null:(m=Ru&&m[Ru]||m["@@iterator"],typeof m=="function"?m:null)}function a(m){if(m==null)return null;if(typeof m=="function")return m.$$typeof===Fv?null:m.displayName||m.name||null;if(typeof m=="string")return m;switch(m){case Mc:return"Fragment";case uo:return"Portal";case I0:return"Profiler";case am:return"StrictMode";case D0:return"Suspense";case ed:return"SuspenseList"}if(typeof m=="object")switch(m.$$typeof){case Yo:return(m.displayName||"Context")+".Provider";case kv:return(m._context.displayName||"Context")+".Consumer";case lm:var y=m.render;return m=m.displayName,m||(m=y.displayName||y.name||"",m=m!==""?"ForwardRef("+m+")":"ForwardRef"),m;case O0:return y=m.displayName||null,y!==null?y:a(m.type)||"Memo";case co:y=m._payload,m=m._init;try{return a(m(y))}catch{}}return null}function o(m){if(Ol===void 0)try{throw Error()}catch(w){var y=w.stack.trim().match(/\n( *(at )?)/);Ol=y&&y[1]||"",Iu=-1<w.stack.indexOf(`
    at`)?" (<anonymous>)":-1<w.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Ol+m+Iu}function l(m,y){if(!m||Th)return"";Th=!0;var w=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var N={DetermineComponentFrameRoot:function(){try{if(y){var Rt=function(){throw Error()};if(Object.defineProperty(Rt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Rt,[])}catch(mn){var Bt=mn}Reflect.construct(m,[],Rt)}else{try{Rt.call()}catch(mn){Bt=mn}m.call(Rt.prototype)}}else{try{throw Error()}catch(mn){Bt=mn}(Rt=m())&&typeof Rt.catch=="function"&&Rt.catch(function(){})}}catch(mn){if(mn&&Bt&&typeof mn.stack=="string")return[mn.stack,Bt.stack]}return[null,null]}};N.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var k=Object.getOwnPropertyDescriptor(N.DetermineComponentFrameRoot,"name");k&&k.configurable&&Object.defineProperty(N.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var U=N.DetermineComponentFrameRoot(),te=U[0],de=U[1];if(te&&de){var Ne=te.split(`
`),Qe=de.split(`
`);for(k=N=0;N<Ne.length&&!Ne[N].includes("DetermineComponentFrameRoot");)N++;for(;k<Qe.length&&!Qe[k].includes("DetermineComponentFrameRoot");)k++;if(N===Ne.length||k===Qe.length)for(N=Ne.length-1,k=Qe.length-1;1<=N&&0<=k&&Ne[N]!==Qe[k];)k--;for(;1<=N&&0<=k;N--,k--)if(Ne[N]!==Qe[k]){if(N!==1||k!==1)do if(N--,k--,0>k||Ne[N]!==Qe[k]){var yt=`
`+Ne[N].replace(" at new "," at ");return m.displayName&&yt.includes("<anonymous>")&&(yt=yt.replace("<anonymous>",m.displayName)),yt}while(1<=N&&0<=k);break}}}finally{Th=!1,Error.prepareStackTrace=w}return(w=m?m.displayName||m.name:"")?o(w):""}function u(m){switch(m.tag){case 26:case 27:case 5:return o(m.type);case 16:return o("Lazy");case 13:return o("Suspense");case 19:return o("SuspenseList");case 0:case 15:return m=l(m.type,!1),m;case 11:return m=l(m.type.render,!1),m;case 1:return m=l(m.type,!0),m;default:return""}}function c(m){try{var y="";do y+=u(m),m=m.return;while(m);return y}catch(w){return`
Error generating stack: `+w.message+`
`+w.stack}}function f(m){var y=m,w=m;if(m.alternate)for(;y.return;)y=y.return;else{m=y;do y=m,(y.flags&4098)!==0&&(w=y.return),m=y.return;while(m)}return y.tag===3?w:null}function d(m){if(f(m)!==m)throw Error(i(188))}function g(m){var y=m.alternate;if(!y){if(y=f(m),y===null)throw Error(i(188));return y!==m?null:m}for(var w=m,N=y;;){var k=w.return;if(k===null)break;var U=k.alternate;if(U===null){if(N=k.return,N!==null){w=N;continue}break}if(k.child===U.child){for(U=k.child;U;){if(U===w)return d(k),m;if(U===N)return d(k),y;U=U.sibling}throw Error(i(188))}if(w.return!==N.return)w=k,N=U;else{for(var te=!1,de=k.child;de;){if(de===w){te=!0,w=k,N=U;break}if(de===N){te=!0,N=k,w=U;break}de=de.sibling}if(!te){for(de=U.child;de;){if(de===w){te=!0,w=U,N=k;break}if(de===N){te=!0,N=U,w=k;break}de=de.sibling}if(!te)throw Error(i(189))}}if(w.alternate!==N)throw Error(i(190))}if(w.tag!==3)throw Error(i(188));return w.stateNode.current===w?m:y}function x(m){var y=m.tag;if(y===5||y===26||y===27||y===6)return m;for(m=m.child;m!==null;){if(y=x(m),y!==null)return y;m=m.sibling}return null}function S(m){var y=m.tag;if(y===5||y===26||y===27||y===6)return m;for(m=m.child;m!==null;){if(m.tag!==4&&(y=S(m),y!==null))return y;m=m.sibling}return null}function b(m){return{current:m}}function _(m){0>ku||(m.current=li[ku],li[ku]=null,ku--)}function T(m,y){ku++,li[ku]=m.current,m.current=y}function E(m){return m>>>=0,m===0?32:31-(PA(m)/UA|0)|0}function C(m){var y=m&42;if(y!==0)return y;switch(m&-m){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return m&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return m}}function R(m,y){var w=m.pendingLanes;if(w===0)return 0;var N=0,k=m.suspendedLanes,U=m.pingedLanes,te=m.warmLanes;m=m.finishedLanes!==0;var de=w&134217727;return de!==0?(w=de&~k,w!==0?N=C(w):(U&=de,U!==0?N=C(U):m||(te=de&~te,te!==0&&(N=C(te))))):(de=w&~k,de!==0?N=C(de):U!==0?N=C(U):m||(te=w&~te,te!==0&&(N=C(te)))),N===0?0:y!==0&&y!==N&&(y&k)===0&&(k=N&-N,te=y&-y,k>=te||k===32&&(te&4194176)!==0)?y:N}function I(m,y){return(m.pendingLanes&~(m.suspendedLanes&~m.pingedLanes)&y)===0}function L(m,y){switch(m){case 1:case 2:case 4:case 8:return y+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return y+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function P(){var m=kl;return kl<<=1,(kl&4194176)===0&&(kl=128),m}function D(){var m=Eh;return Eh<<=1,(Eh&62914560)===0&&(Eh=4194304),m}function O(m){for(var y=[],w=0;31>w;w++)y.push(m);return y}function F(m,y){m.pendingLanes|=y,y!==268435456&&(m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0)}function X(m,y,w,N,k,U){var te=m.pendingLanes;m.pendingLanes=w,m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0,m.expiredLanes&=w,m.entangledLanes&=w,m.errorRecoveryDisabledLanes&=w,m.shellSuspendCounter=0;var de=m.entanglements,Ne=m.expirationTimes,Qe=m.hiddenUpdates;for(w=te&~w;0<w;){var yt=31-Yr(w),Rt=1<<yt;de[yt]=0,Ne[yt]=-1;var Bt=Qe[yt];if(Bt!==null)for(Qe[yt]=null,yt=0;yt<Bt.length;yt++){var mn=Bt[yt];mn!==null&&(mn.lane&=-536870913)}w&=~Rt}N!==0&&q(m,N,0),U!==0&&k===0&&m.tag!==0&&(m.suspendedLanes|=U&~(te&~y))}function q(m,y,w){m.pendingLanes|=y,m.suspendedLanes&=~y;var N=31-Yr(y);m.entangledLanes|=y,m.entanglements[N]=m.entanglements[N]|1073741824|w&4194218}function J(m,y){var w=m.entangledLanes|=y;for(m=m.entanglements;w;){var N=31-Yr(w),k=1<<N;k&y|m[N]&y&&(m[N]|=y),w&=~k}}function Y(m){return m&=-m,2<m?8<m?(m&134217727)!==0?32:268435456:8:2}function $(m){if(da&&typeof da.onCommitFiberRoot=="function")try{da.onCommitFiberRoot(ui,m,void 0,(m.current.flags&128)===128)}catch{}}function W(m){if(typeof GA=="function"&&Xi(m),da&&typeof da.setStrictMode=="function")try{da.setStrictMode(ui,m)}catch{}}function V(m,y){return m===y&&(m!==0||1/m===1/y)||m!==m&&y!==y}function se(m,y){if(typeof m=="object"&&m!==null){var w=n1.get(m);return w!==void 0?w:(y={value:m,source:y,stack:c(y)},n1.set(m,y),y)}return{value:m,source:y,stack:c(y)}}function G(m,y){Mh[Nh++]=ud,Mh[Nh++]=Rh,Rh=m,ud=y}function ne(m,y,w){Pa[Ua++]=Qo,Pa[Ua++]=el,Pa[Ua++]=kc,kc=m;var N=Qo;m=el;var k=32-Yr(N)-1;N&=~(1<<k),w+=1;var U=32-Yr(y)+k;if(30<U){var te=k-k%5;U=(N&(1<<te)-1).toString(32),N>>=te,k-=te,Qo=1<<32-Yr(y)+k|w<<k|N,el=U+m}else Qo=1<<U|w<<k|N,el=m}function oe(m){m.return!==null&&(G(m,1),ne(m,1,0))}function ue(m){for(;m===Rh;)Rh=Mh[--Nh],Mh[Nh]=null,ud=Mh[--Nh],Mh[Nh]=null;for(;m===kc;)kc=Pa[--Ua],Pa[Ua]=null,el=Pa[--Ua],Pa[Ua]=null,Qo=Pa[--Ua],Pa[Ua]=null}function re(m,y){T(Ll,y),T(cd,m),T(ki,null),m=sA(y),_(ki),T(ki,m)}function ce(){_(ki),_(cd),_(Ll)}function Te(m){m.memoizedState!==null&&T(Ih,m);var y=ki.current,w=id(y,m.type);y!==w&&(T(cd,m),T(ki,w))}function Be(m){cd.current===m&&(_(ki),_(cd)),Ih.current===m&&(_(Ih),jr?Jo._currentValue=Rc:Jo._currentValue2=Rc)}function Ke(m){var y=Error(i(418,""));throw Et(se(y,m)),ym}function ut(m,y){if(!pr)throw Error(i(175));MA(m.stateNode,m.type,m.memoizedProps,y,m)||Ke(m)}function ct(m){for(mr=m.return;mr;)switch(mr.tag){case 3:case 27:qi=!0;return;case 5:case 13:qi=!1;return;default:mr=mr.return}}function xt(m){if(!pr||m!==mr)return!1;if(!qn)return ct(m),qn=!0,!1;var y=!1;if(Ss?m.tag!==3&&m.tag!==27&&(m.tag!==5||G0(m.type)&&!xn(m.type,m.memoizedProps))&&(y=!0):m.tag!==3&&(m.tag!==5||G0(m.type)&&!xn(m.type,m.memoizedProps))&&(y=!0),y&&gr&&Ke(m),ct(m),m.tag===13){if(!pr)throw Error(i(316));if(m=m.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(i(317));gr=RA(m)}else gr=mr?Zv(m.stateNode):null;return!0}function kt(){pr&&(gr=mr=null,qn=!1)}function Et(m){po===null?po=[m]:po.push(m)}function le(){for(var m=Dh,y=tl=Dh=0;y<m;){var w=mo[y];mo[y++]=null;var N=mo[y];mo[y++]=null;var k=mo[y];mo[y++]=null;var U=mo[y];if(mo[y++]=null,N!==null&&k!==null){var te=N.pending;te===null?k.next=k:(k.next=te.next,te.next=k),N.pending=k}U!==0&&Pe(w,k,U)}}function Wt(m,y,w,N){mo[Dh++]=m,mo[Dh++]=y,mo[Dh++]=w,mo[Dh++]=N,tl|=N,m.lanes|=N,m=m.alternate,m!==null&&(m.lanes|=N)}function ze(m,y,w,N){return Wt(m,y,w,N),ht(m)}function Fe(m,y){return Wt(m,null,null,y),ht(m)}function Pe(m,y,w){m.lanes|=w;var N=m.alternate;N!==null&&(N.lanes|=w);for(var k=!1,U=m.return;U!==null;)U.childLanes|=w,N=U.alternate,N!==null&&(N.childLanes|=w),U.tag===22&&(m=U.stateNode,m===null||m._visibility&1||(k=!0)),m=U,U=U.return;k&&y!==null&&m.tag===3&&(U=m.stateNode,k=31-Yr(w),U=U.hiddenUpdates,m=U[k],m===null?U[k]=[y]:m.push(y),y.lane=w|536870912)}function ht(m){if(50<vd)throw vd=0,sy=null,Error(i(185));for(var y=m.return;y!==null;)m=y,y=m.return;return m.tag===3?m.stateNode:null}function ke(m){m!==Lu&&m.next===null&&(Lu===null?xm=Lu=m:Lu=Lu.next=m),Ms=!0,Oh||(Oh=!0,qe(j))}function ie(m,y){if(!s1&&Ms){s1=!0;do for(var w=!1,N=xm;N!==null;){if(m!==0){var k=N.pendingLanes;if(k===0)var U=0;else{var te=N.suspendedLanes,de=N.pingedLanes;U=(1<<31-Yr(42|m)+1)-1,U&=k&~(te&~de),U=U&201326677?U&201326677|1:U?U|2:0}U!==0&&(w=!0,Ye(N,U))}else U=zn,U=R(N,N===ds?U:0),(U&3)===0||I(N,U)||(w=!0,Ye(N,U));N=N.next}while(w);s1=!1}}function j(){Ms=Oh=!1;var m=0;hd!==0&&(oA()&&(m=hd),hd=0);for(var y=fo(),w=null,N=xm;N!==null;){var k=N.next,U=Ae(N,y);U===0?(N.next=null,w===null?xm=k:w.next=k,k===null&&(Lu=w)):(w=N,(m!==0||(U&3)!==0)&&(Ms=!0)),N=k}ie(m)}function Ae(m,y){for(var w=m.suspendedLanes,N=m.pingedLanes,k=m.expirationTimes,U=m.pendingLanes&-62914561;0<U;){var te=31-Yr(U),de=1<<te,Ne=k[te];Ne===-1?((de&w)===0||(de&N)!==0)&&(k[te]=L(de,y)):Ne<=y&&(m.expiredLanes|=de),U&=~de}if(y=ds,w=zn,w=R(m,m===y?w:0),N=m.callbackNode,w===0||m===y&&xs===2||m.cancelPendingCommit!==null)return N!==null&&N!==null&&X0(N),m.callbackNode=null,m.callbackPriority=0;if((w&3)===0||I(m,w)){if(y=w&-w,y===m.callbackPriority)return y;switch(N!==null&&X0(N),Y(w)){case 2:case 8:w=zA;break;case 32:w=K0;break;case 268435456:w=lN;break;default:w=K0}return N=Ue.bind(null,m),w=gm(w,N),m.callbackPriority=y,m.callbackNode=w,y}return N!==null&&N!==null&&X0(N),m.callbackPriority=2,m.callbackNode=null,2}function Ue(m,y){var w=m.callbackNode;if(Ko()&&m.callbackNode!==w)return null;var N=zn;return N=R(m,m===ds?N:0),N===0?null:(Ac(m,N,y),Ae(m,fo()),m.callbackNode!=null&&m.callbackNode===w?Ue.bind(null,m):null)}function Ye(m,y){if(Ko())return null;Ac(m,y,!0)}function qe(m){Gv?Bu(function(){(Zn&6)!==0?gm(j0,m):m()}):gm(j0,m)}function mt(){return hd===0&&(hd=P()),hd}function at(m,y){if(fd===null){var w=fd=[];Bh=0,$a=mt(),kh={status:"pending",value:void 0,then:function(N){w.push(N)}}}return Bh++,y.then(gt,gt),y}function gt(){if(--Bh===0&&fd!==null){kh!==null&&(kh.status="fulfilled");var m=fd;fd=null,$a=0,kh=null;for(var y=0;y<m.length;y++)(0,m[y])()}}function dn(m,y){var w=[],N={status:"pending",value:null,reason:null,then:function(k){w.push(k)}};return m.then(function(){N.status="fulfilled",N.value=y;for(var k=0;k<w.length;k++)(0,w[k])(y)},function(k){for(N.status="rejected",N.reason=k,k=0;k<w.length;k++)(0,w[k])(void 0)}),N}function lt(m){m.updateQueue={baseState:m.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Dt(m,y){m=m.updateQueue,y.updateQueue===m&&(y.updateQueue={baseState:m.baseState,firstBaseUpdate:m.firstBaseUpdate,lastBaseUpdate:m.lastBaseUpdate,shared:m.shared,callbacks:null})}function Ft(m){return{lane:m,tag:0,payload:null,callback:null,next:null}}function Pt(m,y,w){var N=m.updateQueue;if(N===null)return null;if(N=N.shared,(Zn&2)!==0){var k=N.pending;return k===null?y.next=y:(y.next=k.next,k.next=y),N.pending=y,y=ht(m),Pe(m,null,w),y}return Wt(m,N,y,w),ht(m)}function vt(m,y,w){if(y=y.updateQueue,y!==null&&(y=y.shared,(w&4194176)!==0)){var N=y.lanes;N&=m.pendingLanes,w|=N,y.lanes=w,J(m,w)}}function ye(m,y){var w=m.updateQueue,N=m.alternate;if(N!==null&&(N=N.updateQueue,w===N)){var k=null,U=null;if(w=w.firstBaseUpdate,w!==null){do{var te={lane:w.lane,tag:w.tag,payload:w.payload,callback:null,next:null};U===null?k=U=te:U=U.next=te,w=w.next}while(w!==null);U===null?k=U=y:U=U.next=y}else k=U=y;w={baseState:N.baseState,firstBaseUpdate:k,lastBaseUpdate:U,shared:N.shared,callbacks:N.callbacks},m.updateQueue=w;return}m=w.lastBaseUpdate,m===null?w.firstBaseUpdate=y:m.next=y,w.lastBaseUpdate=y}function Je(){if(Lh){var m=kh;if(m!==null)throw m}}function _t(m,y,w,N){Lh=!1;var k=m.updateQueue;Fu=!1;var U=k.firstBaseUpdate,te=k.lastBaseUpdate,de=k.shared.pending;if(de!==null){k.shared.pending=null;var Ne=de,Qe=Ne.next;Ne.next=null,te===null?U=Qe:te.next=Qe,te=Ne;var yt=m.alternate;yt!==null&&(yt=yt.updateQueue,de=yt.lastBaseUpdate,de!==te&&(de===null?yt.firstBaseUpdate=Qe:de.next=Qe,yt.lastBaseUpdate=Ne))}if(U!==null){var Rt=k.baseState;te=0,yt=Qe=Ne=null,de=U;do{var Bt=de.lane&-536870913,mn=Bt!==de.lane;if(mn?(zn&Bt)===Bt:(N&Bt)===Bt){Bt!==0&&Bt===$a&&(Lh=!0),yt!==null&&(yt=yt.next={lane:0,tag:de.tag,payload:de.payload,callback:null,next:null});e:{var ja=m,Vc=de;Bt=y;var Wc=w;switch(Vc.tag){case 1:if(ja=Vc.payload,typeof ja=="function"){Rt=ja.call(Wc,Rt,Bt);break e}Rt=ja;break e;case 3:ja.flags=ja.flags&-65537|128;case 0:if(ja=Vc.payload,Bt=typeof ja=="function"?ja.call(Wc,Rt,Bt):ja,Bt==null)break e;Rt=R0({},Rt,Bt);break e;case 2:Fu=!0}}Bt=de.callback,Bt!==null&&(m.flags|=64,mn&&(m.flags|=8192),mn=k.callbacks,mn===null?k.callbacks=[Bt]:mn.push(Bt))}else mn={lane:Bt,tag:de.tag,payload:de.payload,callback:de.callback,next:null},yt===null?(Qe=yt=mn,Ne=Rt):yt=yt.next=mn,te|=Bt;if(de=de.next,de===null){if(de=k.shared.pending,de===null)break;mn=de,de=mn.next,mn.next=null,k.lastBaseUpdate=mn,k.shared.pending=null}}while(!0);yt===null&&(Ne=Rt),k.baseState=Ne,k.firstBaseUpdate=Qe,k.lastBaseUpdate=yt,U===null&&(k.shared.lanes=0),Xa|=te,m.lanes=te,m.memoizedState=Rt}}function ge(m,y){if(typeof m!="function")throw Error(i(191,m));m.call(y)}function dt(m,y){var w=m.callbacks;if(w!==null)for(m.callbacks=null,m=0;m<w.length;m++)ge(w[m],y)}function We(m,y){if(pa(m,y))return!0;if(typeof m!="object"||m===null||typeof y!="object"||y===null)return!1;var w=Object.keys(m),N=Object.keys(y);if(w.length!==N.length)return!1;for(N=0;N<w.length;N++){var k=w[N];if(!Fl.call(y,k)||!pa(m[k],y[k]))return!1}return!0}function Ze(m){return m=m.status,m==="fulfilled"||m==="rejected"}function Mt(){}function At(m,y,w){switch(w=m[w],w===void 0?m.push(y):w!==y&&(y.then(Mt,Mt),y=w),y.status){case"fulfilled":return y.value;case"rejected":throw m=y.reason,m===dd?Error(i(483)):m;default:if(typeof y.status=="string")y.then(Mt,Mt);else{if(m=ds,m!==null&&100<m.shellSuspendCounter)throw Error(i(482));m=y,m.status="pending",m.then(function(N){if(y.status==="pending"){var k=y;k.status="fulfilled",k.value=N}},function(N){if(y.status==="pending"){var k=y;k.status="rejected",k.reason=N}})}switch(y.status){case"fulfilled":return y.value;case"rejected":throw m=y.reason,m===dd?Error(i(483)):m}throw Lc=y,dd}}function Kt(){if(Lc===null)throw Error(i(459));var m=Lc;return Lc=null,m}function Nn(m){var y=Pc;return Pc+=1,Fc===null&&(Fc=[]),At(Fc,m,y)}function cs(m,y){y=y.props.ref,m.ref=y!==void 0?y:null}function _n(m,y){throw y.$$typeof===tN?Error(i(525)):(m=Object.prototype.toString.call(y),Error(i(31,m==="[object Object]"?"object with keys {"+Object.keys(y).join(", ")+"}":m)))}function xi(m){var y=m._init;return y(m._payload)}function $s(m){function y(Oe,be){if(m){var Ve=Oe.deletions;Ve===null?(Oe.deletions=[be],Oe.flags|=16):Ve.push(be)}}function w(Oe,be){if(!m)return null;for(;be!==null;)y(Oe,be),be=be.sibling;return null}function N(Oe){for(var be=new Map;Oe!==null;)Oe.key!==null?be.set(Oe.key,Oe):be.set(Oe.index,Oe),Oe=Oe.sibling;return be}function k(Oe,be){return Oe=lo(Oe,be),Oe.index=0,Oe.sibling=null,Oe}function U(Oe,be,Ve){return Oe.index=Ve,m?(Ve=Oe.alternate,Ve!==null?(Ve=Ve.index,Ve<be?(Oe.flags|=33554434,be):Ve):(Oe.flags|=33554434,be)):(Oe.flags|=1048576,be)}function te(Oe){return m&&Oe.alternate===null&&(Oe.flags|=33554434),Oe}function de(Oe,be,Ve,pt){return be===null||be.tag!==6?(be=M0(Ve,Oe.mode,pt),be.return=Oe,be):(be=k(be,Ve),be.return=Oe,be)}function Ne(Oe,be,Ve,pt){var qt=Ve.type;return qt===Mc?yt(Oe,be,Ve.props.children,pt,Ve.key):be!==null&&(be.elementType===qt||typeof qt=="object"&&qt!==null&&qt.$$typeof===co&&xi(qt)===be.type)?(be=k(be,Ve.props),cs(be,Ve),be.return=Oe,be):(be=Dl(Ve.type,Ve.key,Ve.props,null,Oe.mode,pt),cs(be,Ve),be.return=Oe,be)}function Qe(Oe,be,Ve,pt){return be===null||be.tag!==4||be.stateNode.containerInfo!==Ve.containerInfo||be.stateNode.implementation!==Ve.implementation?(be=Bv(Ve,Oe.mode,pt),be.return=Oe,be):(be=k(be,Ve.children||[]),be.return=Oe,be)}function yt(Oe,be,Ve,pt,qt){return be===null||be.tag!==7?(be=Ys(Ve,Oe.mode,pt,qt),be.return=Oe,be):(be=k(be,Ve),be.return=Oe,be)}function Rt(Oe,be,Ve){if(typeof be=="string"&&be!==""||typeof be=="number"||typeof be=="bigint")return be=M0(""+be,Oe.mode,Ve),be.return=Oe,be;if(typeof be=="object"&&be!==null){switch(be.$$typeof){case rm:return Ve=Dl(be.type,be.key,be.props,null,Oe.mode,Ve),cs(Ve,be),Ve.return=Oe,Ve;case uo:return be=Bv(be,Oe.mode,Ve),be.return=Oe,be;case co:var pt=be._init;return be=pt(be._payload),Rt(Oe,be,Ve)}if(td(be)||r(be))return be=Ys(be,Oe.mode,Ve,null),be.return=Oe,be;if(typeof be.then=="function")return Rt(Oe,Nn(be),Ve);if(be.$$typeof===Yo)return Rt(Oe,Vp(Oe,be),Ve);_n(Oe,be)}return null}function Bt(Oe,be,Ve,pt){var qt=be!==null?be.key:null;if(typeof Ve=="string"&&Ve!==""||typeof Ve=="number"||typeof Ve=="bigint")return qt!==null?null:de(Oe,be,""+Ve,pt);if(typeof Ve=="object"&&Ve!==null){switch(Ve.$$typeof){case rm:return Ve.key===qt?Ne(Oe,be,Ve,pt):null;case uo:return Ve.key===qt?Qe(Oe,be,Ve,pt):null;case co:return qt=Ve._init,Ve=qt(Ve._payload),Bt(Oe,be,Ve,pt)}if(td(Ve)||r(Ve))return qt!==null?null:yt(Oe,be,Ve,pt,null);if(typeof Ve.then=="function")return Bt(Oe,be,Nn(Ve),pt);if(Ve.$$typeof===Yo)return Bt(Oe,be,Vp(Oe,Ve),pt);_n(Oe,Ve)}return null}function mn(Oe,be,Ve,pt,qt){if(typeof pt=="string"&&pt!==""||typeof pt=="number"||typeof pt=="bigint")return Oe=Oe.get(Ve)||null,de(be,Oe,""+pt,qt);if(typeof pt=="object"&&pt!==null){switch(pt.$$typeof){case rm:return Oe=Oe.get(pt.key===null?Ve:pt.key)||null,Ne(be,Oe,pt,qt);case uo:return Oe=Oe.get(pt.key===null?Ve:pt.key)||null,Qe(be,Oe,pt,qt);case co:var Ls=pt._init;return pt=Ls(pt._payload),mn(Oe,be,Ve,pt,qt)}if(td(pt)||r(pt))return Oe=Oe.get(Ve)||null,yt(be,Oe,pt,qt,null);if(typeof pt.then=="function")return mn(Oe,be,Ve,Nn(pt),qt);if(pt.$$typeof===Yo)return mn(Oe,be,Ve,Vp(be,pt),qt);_n(be,pt)}return null}function ja(Oe,be,Ve,pt){for(var qt=null,Ls=null,hn=be,is=be=0,ci=null;hn!==null&&is<Ve.length;is++){hn.index>is?(ci=hn,hn=null):ci=hn.sibling;var Pn=Bt(Oe,hn,Ve[is],pt);if(Pn===null){hn===null&&(hn=ci);break}m&&hn&&Pn.alternate===null&&y(Oe,hn),be=U(Pn,be,is),Ls===null?qt=Pn:Ls.sibling=Pn,Ls=Pn,hn=ci}if(is===Ve.length)return w(Oe,hn),qn&&G(Oe,is),qt;if(hn===null){for(;is<Ve.length;is++)hn=Rt(Oe,Ve[is],pt),hn!==null&&(be=U(hn,be,is),Ls===null?qt=hn:Ls.sibling=hn,Ls=hn);return qn&&G(Oe,is),qt}for(hn=N(hn);is<Ve.length;is++)ci=mn(hn,Oe,is,Ve[is],pt),ci!==null&&(m&&ci.alternate!==null&&hn.delete(ci.key===null?is:ci.key),be=U(ci,be,is),Ls===null?qt=ci:Ls.sibling=ci,Ls=ci);return m&&hn.forEach(function(Wl){return y(Oe,Wl)}),qn&&G(Oe,is),qt}function Vc(Oe,be,Ve,pt){if(Ve==null)throw Error(i(151));for(var qt=null,Ls=null,hn=be,is=be=0,ci=null,Pn=Ve.next();hn!==null&&!Pn.done;is++,Pn=Ve.next()){hn.index>is?(ci=hn,hn=null):ci=hn.sibling;var Wl=Bt(Oe,hn,Pn.value,pt);if(Wl===null){hn===null&&(hn=ci);break}m&&hn&&Wl.alternate===null&&y(Oe,hn),be=U(Wl,be,is),Ls===null?qt=Wl:Ls.sibling=Wl,Ls=Wl,hn=ci}if(Pn.done)return w(Oe,hn),qn&&G(Oe,is),qt;if(hn===null){for(;!Pn.done;is++,Pn=Ve.next())Pn=Rt(Oe,Pn.value,pt),Pn!==null&&(be=U(Pn,be,is),Ls===null?qt=Pn:Ls.sibling=Pn,Ls=Pn);return qn&&G(Oe,is),qt}for(hn=N(hn);!Pn.done;is++,Pn=Ve.next())Pn=mn(hn,Oe,is,Pn.value,pt),Pn!==null&&(m&&Pn.alternate!==null&&hn.delete(Pn.key===null?is:Pn.key),be=U(Pn,be,is),Ls===null?qt=Pn:Ls.sibling=Pn,Ls=Pn);return m&&hn.forEach(function(iy){return y(Oe,iy)}),qn&&G(Oe,is),qt}function Wc(Oe,be,Ve,pt){if(typeof Ve=="object"&&Ve!==null&&Ve.type===Mc&&Ve.key===null&&(Ve=Ve.props.children),typeof Ve=="object"&&Ve!==null){switch(Ve.$$typeof){case rm:e:{for(var qt=Ve.key;be!==null;){if(be.key===qt){if(qt=Ve.type,qt===Mc){if(be.tag===7){w(Oe,be.sibling),pt=k(be,Ve.props.children),pt.return=Oe,Oe=pt;break e}}else if(be.elementType===qt||typeof qt=="object"&&qt!==null&&qt.$$typeof===co&&xi(qt)===be.type){w(Oe,be.sibling),pt=k(be,Ve.props),cs(pt,Ve),pt.return=Oe,Oe=pt;break e}w(Oe,be);break}else y(Oe,be);be=be.sibling}Ve.type===Mc?(pt=Ys(Ve.props.children,Oe.mode,pt,Ve.key),pt.return=Oe,Oe=pt):(pt=Dl(Ve.type,Ve.key,Ve.props,null,Oe.mode,pt),cs(pt,Ve),pt.return=Oe,Oe=pt)}return te(Oe);case uo:e:{for(qt=Ve.key;be!==null;){if(be.key===qt)if(be.tag===4&&be.stateNode.containerInfo===Ve.containerInfo&&be.stateNode.implementation===Ve.implementation){w(Oe,be.sibling),pt=k(be,Ve.children||[]),pt.return=Oe,Oe=pt;break e}else{w(Oe,be);break}else y(Oe,be);be=be.sibling}pt=Bv(Ve,Oe.mode,pt),pt.return=Oe,Oe=pt}return te(Oe);case co:return qt=Ve._init,Ve=qt(Ve._payload),Wc(Oe,be,Ve,pt)}if(td(Ve))return ja(Oe,be,Ve,pt);if(r(Ve)){if(qt=r(Ve),typeof qt!="function")throw Error(i(150));return Ve=qt.call(Ve),Vc(Oe,be,Ve,pt)}if(typeof Ve.then=="function")return Wc(Oe,be,Nn(Ve),pt);if(Ve.$$typeof===Yo)return Wc(Oe,be,Vp(Oe,Ve),pt);_n(Oe,Ve)}return typeof Ve=="string"&&Ve!==""||typeof Ve=="number"||typeof Ve=="bigint"?(Ve=""+Ve,be!==null&&be.tag===6?(w(Oe,be.sibling),pt=k(be,Ve),pt.return=Oe,Oe=pt):(w(Oe,be),pt=M0(Ve,Oe.mode,pt),pt.return=Oe,Oe=pt),te(Oe)):w(Oe,be)}return function(Oe,be,Ve,pt){try{Pc=0;var qt=Wc(Oe,be,Ve,pt);return Fc=null,qt}catch(hn){if(hn===dd)throw hn;var Ls=t(29,hn,null,Oe.mode);return Ls.lanes=pt,Ls.return=Oe,Ls}finally{}}}function vi(m,y){m=Nr,T(pd,m),T(Ns,y),Nr=m|y.baseLanes}function Oi(){T(pd,Nr),T(Ns,Ns.current)}function wr(){Nr=pd.current,_(Ns),_(pd)}function aa(m){var y=m.alternate;T(Li,Li.current&1),T(za,m),As===null&&(y===null||Ns.current!==null||y.memoizedState!==null)&&(As=m)}function Dp(m){if(m.tag===22){if(T(Li,Li.current),T(za,m),As===null){var y=m.alternate;y!==null&&y.memoizedState!==null&&(As=m)}}else Ho()}function Ho(){T(Li,Li.current),T(za,za.current)}function Hr(m){_(za),As===m&&(As=null),_(Li)}function Vo(m){for(var y=m;y!==null;){if(y.tag===13){var w=y.memoizedState;if(w!==null&&(w=w.dehydrated,w===null||U0(w)||$0(w)))return y}else if(y.tag===19&&y.memoizedProps.revealOrder!==void 0){if((y.flags&128)!==0)return y}else if(y.child!==null){y.child.return=y,y=y.child;continue}if(y===m)break;for(;y.sibling===null;){if(y.return===null||y.return===m)return null;y=y.return}y.sibling.return=y.return,y=y.sibling}return null}function gs(){throw Error(i(321))}function Wo(m,y){if(y===null)return!1;for(var w=0;w<y.length&&w<m.length;w++)if(!pa(m[w],y[w]))return!1;return!0}function Xo(m,y,w,N,k,U){return Pu=U,wn=y,y.memoizedState=null,y.updateQueue=null,y.lanes=0,cn.H=m===null||m.memoizedState===null?zc:Jr,$c=!1,U=w(N,k),$c=!1,Fh&&(U=yu(y,w,N,k)),fc(m),U}function fc(m){cn.H=Js;var y=tn!==null&&tn.next!==null;if(Pu=0,Jn=tn=wn=null,go=!1,Ph=0,ji=null,y)throw Error(i(300));m===null||Ts||(m=m.dependencies,m!==null&&Hp(m)&&(Ts=!0))}function yu(m,y,w,N){wn=m;var k=0;do{if(Fh&&(ji=null),Ph=0,Fh=!1,25<=k)throw Error(i(301));if(k+=1,Jn=tn=null,m.updateQueue!=null){var U=m.updateQueue;U.lastEffect=null,U.events=null,U.stores=null,U.memoCache!=null&&(U.memoCache.index=0)}cn.H=Ga,U=y(w,N)}while(Fh);return U}function bi(){var m=cn.H,y=m.useState()[0];return y=typeof y.then=="function"?$e(y):y,m=m.useState()[0],(tn!==null?tn.memoizedState:null)!==m&&(wn.flags|=1024),y}function Of(){var m=Y0!==0;return Y0=0,m}function Bf(m,y,w){y.updateQueue=m.updateQueue,y.flags&=-2053,m.lanes&=~w}function qo(m){if(go){for(m=m.memoizedState;m!==null;){var y=m.queue;y!==null&&(y.pending=null),m=m.next}go=!1}Pu=0,Jn=tn=wn=null,Fh=!1,Ph=Y0=0,ji=null}function ee(){var m={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Jn===null?wn.memoizedState=Jn=m:Jn=Jn.next=m,Jn}function Se(){if(tn===null){var m=wn.alternate;m=m!==null?m.memoizedState:null}else m=tn.next;var y=Jn===null?wn.memoizedState:Jn.next;if(y!==null)Jn=y,tn=m;else{if(m===null)throw wn.alternate===null?Error(i(467)):Error(i(310));tn=m,m={memoizedState:tn.memoizedState,baseState:tn.baseState,baseQueue:tn.baseQueue,queue:tn.queue,next:null},Jn===null?wn.memoizedState=Jn=m:Jn=Jn.next=m}return Jn}function $e(m){var y=Ph;return Ph+=1,ji===null&&(ji=[]),m=At(ji,m,y),y=wn,(Jn===null?y.memoizedState:Jn.next)===null&&(y=y.alternate,cn.H=y===null||y.memoizedState===null?zc:Jr),m}function Ge(m){if(m!==null&&typeof m=="object"){if(typeof m.then=="function")return $e(m);if(m.$$typeof===Yo)return cr(m)}throw Error(i(438,String(m)))}function Ee(m){var y=null,w=wn.updateQueue;if(w!==null&&(y=w.memoCache),y==null){var N=wn.alternate;N!==null&&(N=N.updateQueue,N!==null&&(N=N.memoCache,N!=null&&(y={data:N.data.map(function(k){return k.slice()}),index:0})))}if(y==null&&(y={data:[],index:0}),w===null&&(w=J0(),wn.updateQueue=w),w.memoCache=y,w=y.data[y.index],w===void 0)for(w=y.data[y.index]=Array(m),N=0;N<m;N++)w[N]=nA;return y.index++,w}function ot(m,y){return typeof y=="function"?y(m):y}function bt(m){var y=Se();return Tt(y,tn,m)}function Tt(m,y,w){var N=m.queue;if(N===null)throw Error(i(311));N.lastRenderedReducer=w;var k=m.baseQueue,U=N.pending;if(U!==null){if(k!==null){var te=k.next;k.next=U.next,U.next=te}y.baseQueue=k=U,N.pending=null}if(U=m.baseState,k===null)m.memoizedState=U;else{y=k.next;var de=te=null,Ne=null,Qe=y,yt=!1;do{var Rt=Qe.lane&-536870913;if(Rt!==Qe.lane?(zn&Rt)===Rt:(Pu&Rt)===Rt){var Bt=Qe.revertLane;if(Bt===0)Ne!==null&&(Ne=Ne.next={lane:0,revertLane:0,action:Qe.action,hasEagerState:Qe.hasEagerState,eagerState:Qe.eagerState,next:null}),Rt===$a&&(yt=!0);else if((Pu&Bt)===Bt){Qe=Qe.next,Bt===$a&&(yt=!0);continue}else Rt={lane:0,revertLane:Qe.revertLane,action:Qe.action,hasEagerState:Qe.hasEagerState,eagerState:Qe.eagerState,next:null},Ne===null?(de=Ne=Rt,te=U):Ne=Ne.next=Rt,wn.lanes|=Bt,Xa|=Bt;Rt=Qe.action,$c&&w(U,Rt),U=Qe.hasEagerState?Qe.eagerState:w(U,Rt)}else Bt={lane:Rt,revertLane:Qe.revertLane,action:Qe.action,hasEagerState:Qe.hasEagerState,eagerState:Qe.eagerState,next:null},Ne===null?(de=Ne=Bt,te=U):Ne=Ne.next=Bt,wn.lanes|=Rt,Xa|=Rt;Qe=Qe.next}while(Qe!==null&&Qe!==y);if(Ne===null?te=U:Ne.next=de,!pa(U,m.memoizedState)&&(Ts=!0,yt&&(w=kh,w!==null)))throw w;m.memoizedState=U,m.baseState=te,m.baseQueue=Ne,N.lastRenderedState=U}return k===null&&(N.lanes=0),[m.memoizedState,N.dispatch]}function Lt(m){var y=Se(),w=y.queue;if(w===null)throw Error(i(311));w.lastRenderedReducer=m;var N=w.dispatch,k=w.pending,U=y.memoizedState;if(k!==null){w.pending=null;var te=k=k.next;do U=m(U,te.action),te=te.next;while(te!==k);pa(U,y.memoizedState)||(Ts=!0),y.memoizedState=U,y.baseQueue===null&&(y.baseState=U),w.lastRenderedState=U}return[U,N]}function an(m,y,w){var N=wn,k=Se(),U=qn;if(U){if(w===void 0)throw Error(i(407));w=w()}else w=y();var te=!pa((tn||k).memoizedState,w);if(te&&(k.memoizedState=w,Ts=!0),k=k.queue,rv(Dn.bind(null,N,k,m),[m]),k.getSnapshot!==y||te||Jn!==null&&Jn.memoizedState.tag&1){if(N.flags|=2048,Vr(9,Xt.bind(null,N,k,w,y),{destroy:void 0},null),ds===null)throw Error(i(349));U||(Pu&60)!==0||Zt(N,y,w)}return w}function Zt(m,y,w){m.flags|=16384,m={getSnapshot:y,value:w},y=wn.updateQueue,y===null?(y=J0(),wn.updateQueue=y,y.stores=[m]):(w=y.stores,w===null?y.stores=[m]:w.push(m))}function Xt(m,y,w,N){y.value=w,y.getSnapshot=N,Yn(y)&&zs(m)}function Dn(m,y,w){return w(function(){Yn(y)&&zs(m)})}function Yn(m){var y=m.getSnapshot;m=m.value;try{var w=y();return!pa(m,w)}catch{return!0}}function zs(m){var y=Fe(m,2);y!==null&&Wi(y,m,2)}function Fn(m){var y=ee();if(typeof m=="function"){var w=m;if(m=w(),$c){W(!0);try{w()}finally{W(!1)}}}return y.memoizedState=y.baseState=m,y.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ot,lastRenderedState:m},y}function $n(m,y,w,N){return m.baseState=w,Tt(m,tn,typeof N=="function"?N:ot)}function Qt(m,y,w,N,k){if(Pp(m))throw Error(i(485));if(m=y.action,m!==null){var U={payload:k,action:m,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(te){U.listeners.push(te)}};cn.T!==null?w(!0):U.isTransition=!1,N(U),w=y.pending,w===null?(U.next=y.pending=U,Vs(y,U)):(U.next=w.next,y.pending=w.next=U)}}function Vs(m,y){var w=y.action,N=y.payload,k=m.state;if(y.isTransition){var U=cn.T,te={};cn.T=te;try{var de=w(k,N),Ne=cn.S;Ne!==null&&Ne(te,de),Xn(m,y,de)}catch(Qe){Cl(m,y,Qe)}finally{cn.T=U}}else try{U=w(k,N),Xn(m,y,U)}catch(Qe){Cl(m,y,Qe)}}function Xn(m,y,w){w!==null&&typeof w=="object"&&typeof w.then=="function"?w.then(function(N){or(m,y,N)},function(N){return Cl(m,y,N)}):or(m,y,w)}function or(m,y,w){y.status="fulfilled",y.value=w,_s(y),m.state=w,y=m.pending,y!==null&&(w=y.next,w===y?m.pending=null:(w=w.next,y.next=w,Vs(m,w)))}function Cl(m,y,w){var N=m.pending;if(m.pending=null,N!==null){N=N.next;do y.status="rejected",y.reason=w,_s(y),y=y.next;while(y!==N)}m.action=null}function _s(m){m=m.listeners;for(var y=0;y<m.length;y++)(0,m[y])()}function El(m,y){return y}function ys(m,y){if(qn){var w=ds.formState;if(w!==null){e:{var N=wn;if(qn){if(gr){var k=Jv(gr,qi);if(k){gr=Zv(k),N=TA(k);break e}}Ke(N)}N=!1}N&&(y=w[0])}}w=ee(),w.memoizedState=w.baseState=y,N={pending:null,lanes:0,dispatch:null,lastRenderedReducer:El,lastRenderedState:y},w.queue=N,w=uv.bind(null,wn,N),N.dispatch=w,N=Fn(!1);var U=Ff.bind(null,wn,!1,N.queue);return N=ee(),k={state:y,dispatch:null,action:m,pending:null},N.queue=k,w=Qt.bind(null,wn,k,U,w),k.dispatch=w,N.memoizedState=m,[y,w,!1]}function lr(m){var y=Se();return _i(y,tn,m)}function _i(m,y,w){y=Tt(m,y,El)[0],m=bt(ot)[0],y=typeof y=="object"&&y!==null&&typeof y.then=="function"?$e(y):y;var N=Se(),k=N.queue,U=k.dispatch;return w!==N.memoizedState&&(wn.flags|=2048,Vr(9,Gi.bind(null,k,w),{destroy:void 0},null)),[y,U,m]}function Gi(m,y){m.action=y}function Hi(m){var y=Se(),w=tn;if(w!==null)return _i(y,w,m);Se(),y=y.memoizedState,w=Se();var N=w.queue.dispatch;return w.memoizedState=m,[y,N,!1]}function Vr(m,y,w,N){return m={tag:m,create:y,inst:w,deps:N,next:null},y=wn.updateQueue,y===null&&(y=J0(),wn.updateQueue=y),w=y.lastEffect,w===null?y.lastEffect=m.next=m:(N=w.next,w.next=m,m.next=N,y.lastEffect=m),m}function Ml(){return Se().memoizedState}function Op(m,y,w,N){var k=ee();wn.flags|=m,k.memoizedState=Vr(1|y,w,{destroy:void 0},N===void 0?null:N)}function Bp(m,y,w,N){var k=Se();N=N===void 0?null:N;var U=k.memoizedState.inst;tn!==null&&N!==null&&Wo(N,tn.memoizedState.deps)?k.memoizedState=Vr(y,w,U,N):(wn.flags|=m,k.memoizedState=Vr(1|y,w,U,N))}function l0(m,y){Op(8390656,8,m,y)}function rv(m,y){Bp(2048,8,m,y)}function BS(m,y){return Bp(4,2,m,y)}function kp(m,y){return Bp(4,4,m,y)}function u0(m,y){if(typeof y=="function"){m=m();var w=y(m);return function(){typeof w=="function"?w():y(null)}}if(y!=null)return m=m(),y.current=m,function(){y.current=null}}function c0(m,y,w){w=w!=null?w.concat([m]):null,Bp(4,4,u0.bind(null,y,m),w)}function dc(){}function bh(m,y){var w=Se();y=y===void 0?null:y;var N=w.memoizedState;return y!==null&&Wo(y,N[1])?N[0]:(w.memoizedState=[m,y],m)}function av(m,y){var w=Se();y=y===void 0?null:y;var N=w.memoizedState;if(y!==null&&Wo(y,N[1]))return N[0];if(N=m(),$c){W(!0);try{m()}finally{W(!1)}}return w.memoizedState=[N,y],N}function Lp(m,y,w){return w===void 0||(Pu&1073741824)!==0?m.memoizedState=y:(m.memoizedState=w,m=Mv(),wn.lanes|=m,Xa|=m,w)}function ov(m,y,w,N){return pa(w,y)?w:Ns.current!==null?(m=Lp(m,w,N),pa(m,y)||(Ts=!0),m):(Pu&42)===0?(Ts=!0,m.memoizedState=w):(m=Mv(),wn.lanes|=m,Xa|=m,y)}function kf(m,y,w,N,k){var U=Ou();Er(U!==0&&8>U?U:8);var te=cn.T,de={};cn.T=de,Ff(m,!1,y,w);try{var Ne=k(),Qe=cn.S;if(Qe!==null&&Qe(de,Ne),Ne!==null&&typeof Ne=="object"&&typeof Ne.then=="function"){var yt=dn(Ne,N);pc(m,y,yt,ai(m))}else pc(m,y,N,ai(m))}catch(Rt){pc(m,y,{then:function(){},status:"rejected",reason:Rt},ai())}finally{Er(U),cn.T=te}}function Nl(m){var y=m.memoizedState;if(y!==null)return y;y={memoizedState:Rc,baseState:Rc,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ot,lastRenderedState:Rc},next:null};var w={};return y.next={memoizedState:w,baseState:w,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ot,lastRenderedState:w},next:null},m.memoizedState=y,m=m.alternate,m!==null&&(m.memoizedState=y),y}function Fp(){return cr(Jo)}function Lf(){return Se().memoizedState}function xu(){return Se().memoizedState}function lv(m){for(var y=m.return;y!==null;){switch(y.tag){case 24:case 3:var w=ai();m=Ft(w);var N=Pt(y,m,w);N!==null&&(Wi(N,y,w),vt(N,y,w)),y={cache:xc()},m.payload=y;return}y=y.return}}function h0(m,y,w){var N=ai();w={lane:N,revertLane:0,action:w,hasEagerState:!1,eagerState:null,next:null},Pp(m)?Wr(y,w):(w=ze(m,y,w,N),w!==null&&(Wi(w,m,N),mc(w,y,N)))}function uv(m,y,w){var N=ai();pc(m,y,w,N)}function pc(m,y,w,N){var k={lane:N,revertLane:0,action:w,hasEagerState:!1,eagerState:null,next:null};if(Pp(m))Wr(y,k);else{var U=m.alternate;if(m.lanes===0&&(U===null||U.lanes===0)&&(U=y.lastRenderedReducer,U!==null))try{var te=y.lastRenderedState,de=U(te,w);if(k.hasEagerState=!0,k.eagerState=de,pa(de,te))return Wt(m,y,k,0),ds===null&&le(),!1}catch{}finally{}if(w=ze(m,y,k,N),w!==null)return Wi(w,m,N),mc(w,y,N),!0}return!1}function Ff(m,y,w,N){if(N={lane:2,revertLane:mt(),action:N,hasEagerState:!1,eagerState:null,next:null},Pp(m)){if(y)throw Error(i(479))}else y=ze(m,w,N,2),y!==null&&Wi(y,m,2)}function Pp(m){var y=m.alternate;return m===wn||y!==null&&y===wn}function Wr(m,y){Fh=go=!0;var w=m.pending;w===null?y.next=y:(y.next=w.next,w.next=y),m.pending=y}function mc(m,y,w){if((w&4194176)!==0){var N=y.lanes;N&=m.pendingLanes,w|=N,y.lanes=w,J(m,w)}}function Pf(m,y,w,N){y=m.memoizedState,w=w(N,y),w=w==null?y:R0({},y,w),m.memoizedState=w,m.lanes===0&&(m.updateQueue.baseState=w)}function Uf(m,y,w,N,k,U,te){return m=m.stateNode,typeof m.shouldComponentUpdate=="function"?m.shouldComponentUpdate(N,U,te):y.prototype&&y.prototype.isPureReactComponent?!We(w,N)||!We(k,U):!0}function kS(m,y,w,N){m=y.state,typeof y.componentWillReceiveProps=="function"&&y.componentWillReceiveProps(w,N),typeof y.UNSAFE_componentWillReceiveProps=="function"&&y.UNSAFE_componentWillReceiveProps(w,N),y.state!==m&&Ul.enqueueReplaceState(y,y.state,null)}function vu(m,y){var w=y;if("ref"in y){w={};for(var N in y)N!=="ref"&&(w[N]=y[N])}if(m=m.defaultProps){w===y&&(w=R0({},w));for(var k in m)w[k]===void 0&&(w[k]=m[k])}return w}function $f(m,y){try{var w=m.onUncaughtError;w(y.value,{componentStack:y.stack})}catch(N){setTimeout(function(){throw N})}}function zf(m,y,w){try{var N=m.onCaughtError;N(w.value,{componentStack:w.stack,errorBoundary:y.tag===1?y.stateNode:null})}catch(k){setTimeout(function(){throw k})}}function Gf(m,y,w){return w=Ft(w),w.tag=3,w.payload={element:null},w.callback=function(){$f(m,y)},w}function cv(m){return m=Ft(m),m.tag=3,m}function LS(m,y,w,N){var k=w.type.getDerivedStateFromError;if(typeof k=="function"){var U=N.value;m.payload=function(){return k(U)},m.callback=function(){zf(y,w,N)}}var te=w.stateNode;te!==null&&typeof te.componentDidCatch=="function"&&(m.callback=function(){zf(y,w,N),typeof k!="function"&&(Gc===null?Gc=new Set([this]):Gc.add(this));var de=N.stack;this.componentDidCatch(N.value,{componentStack:de!==null?de:""})})}function JM(m,y,w,N,k){if(w.flags|=32768,N!==null&&typeof N=="object"&&typeof N.then=="function"){if(y=w.alternate,y!==null&&Gp(y,w,k,!0),w=za.current,w!==null){switch(w.tag){case 13:return As===null?Eu():w.alternate===null&&ws===0&&(ws=3),w.flags&=-257,w.flags|=65536,w.lanes=k,N===bm?w.flags|=16384:(y=w.updateQueue,y===null?w.updateQueue=new Set([N]):y.add(N),Ah(m,N,k)),!1;case 22:return w.flags|=65536,N===bm?w.flags|=16384:(y=w.updateQueue,y===null?(y={transitions:null,markerInstances:null,retryQueue:new Set([N])},w.updateQueue=y):(w=y.retryQueue,w===null?y.retryQueue=new Set([N]):w.add(N)),Ah(m,N,k)),!1}throw Error(i(435,w.tag))}return Ah(m,N,k),Eu(),!1}if(qn)return y=za.current,y!==null?((y.flags&65536)===0&&(y.flags|=256),y.flags|=65536,y.lanes=k,N!==ym&&(m=Error(i(422),{cause:N}),Et(se(m,w)))):(N!==ym&&(y=Error(i(423),{cause:N}),Et(se(y,w))),m=m.current.alternate,m.flags|=65536,k&=-k,m.lanes|=k,N=se(N,w),k=Gf(m.stateNode,N,k),ye(m,k),ws!==4&&(ws=2)),!1;var U=Error(i(520),{cause:N});if(U=se(U,w),$h===null?$h=[U]:$h.push(U),ws!==4&&(ws=2),y===null)return!0;N=se(N,w),w=y;do{switch(w.tag){case 3:return w.flags|=65536,m=k&-k,w.lanes|=m,m=Gf(w.stateNode,N,m),ye(w,m),!1;case 1:if(y=w.type,U=w.stateNode,(w.flags&128)===0&&(typeof y.getDerivedStateFromError=="function"||U!==null&&typeof U.componentDidCatch=="function"&&(Gc===null||!Gc.has(U))))return w.flags|=65536,k&=-k,w.lanes|=k,k=cv(k),LS(k,m,w,N),ye(w,k),!1}w=w.return}while(w!==null);return!1}function ur(m,y,w,N){y.child=m===null?Pl(y,null,w,N):Uc(y,m.child,w,N)}function f0(m,y,w,N,k){w=w.render;var U=y.ref;if("ref"in N){var te={};for(var de in N)de!=="ref"&&(te[de]=N[de])}else te=N;return yc(y),N=Xo(m,y,w,te,U,k),de=Of(),m!==null&&!Ts?(Bf(m,y,k),bu(m,y,k)):(qn&&de&&oe(y),y.flags|=1,ur(m,y,N,k),y.child)}function FS(m,y,w,N,k){if(m===null){var U=w.type;return typeof U=="function"&&!tm(U)&&U.defaultProps===void 0&&w.compare===null?(y.tag=15,y.type=U,PS(m,y,U,N,k)):(m=Dl(w.type,null,N,y,y.mode,k),m.ref=y.ref,m.return=y,y.child=m)}if(U=m.child,!mv(m,k)){var te=U.memoizedProps;if(w=w.compare,w=w!==null?w:We,w(te,N)&&m.ref===y.ref)return bu(m,y,k)}return y.flags|=1,m=lo(U,N),m.ref=y.ref,m.return=y,y.child=m}function PS(m,y,w,N,k){if(m!==null){var U=m.memoizedProps;if(We(U,N)&&m.ref===y.ref)if(Ts=!1,y.pendingProps=N=U,mv(m,k))(m.flags&131072)!==0&&(Ts=!0);else return y.lanes=m.lanes,bu(m,y,k)}return d0(m,y,w,N,k)}function US(m,y,w){var N=y.pendingProps,k=N.children,U=(y.stateNode._pendingVisibility&2)!==0,te=m!==null?m.memoizedState:null;if(Up(m,y),N.mode==="hidden"||U){if((y.flags&128)!==0){if(N=te!==null?te.baseLanes|w:w,m!==null){for(k=y.child=m.child,U=0;k!==null;)U=U|k.lanes|k.childLanes,k=k.sibling;y.childLanes=U&~N}else y.childLanes=0,y.child=null;return $S(m,y,N,w)}if((w&536870912)!==0)y.memoizedState={baseLanes:0,cachePool:null},m!==null&&m0(y,te!==null?te.cachePool:null),te!==null?vi(y,te):Oi(),Dp(y);else return y.lanes=y.childLanes=536870912,$S(m,y,te!==null?te.baseLanes|w:w,w)}else te!==null?(m0(y,te.cachePool),vi(y,te),Ho(),y.memoizedState=null):(m!==null&&m0(y,null),Oi(),Ho());return ur(m,y,k,w),y.child}function $S(m,y,w,N){var k=yv();return k=k===null?null:{parent:jr?Rs._currentValue:Rs._currentValue2,pool:k},y.memoizedState={baseLanes:w,cachePool:k},m!==null&&m0(y,null),Oi(),Dp(y),m!==null&&Gp(m,y,N,!0),null}function Up(m,y){var w=y.ref;if(w===null)m!==null&&m.ref!==null&&(y.flags|=2097664);else{if(typeof w!="function"&&typeof w!="object")throw Error(i(284));(m===null||m.ref!==w)&&(y.flags|=2097664)}}function d0(m,y,w,N,k){return yc(y),w=Xo(m,y,w,N,void 0,k),N=Of(),m!==null&&!Ts?(Bf(m,y,k),bu(m,y,k)):(qn&&N&&oe(y),y.flags|=1,ur(m,y,w,k),y.child)}function zS(m,y,w,N,k,U){return yc(y),y.updateQueue=null,w=yu(y,N,w,k),fc(m),N=Of(),m!==null&&!Ts?(Bf(m,y,U),bu(m,y,U)):(qn&&N&&oe(y),y.flags|=1,ur(m,y,w,U),y.child)}function GS(m,y,w,N,k){if(yc(y),y.stateNode===null){var U=Bc,te=w.contextType;typeof te=="object"&&te!==null&&(U=cr(te)),U=new w(N,U),y.memoizedState=U.state!==null&&U.state!==void 0?U.state:null,U.updater=Ul,y.stateNode=U,U._reactInternals=y,U=y.stateNode,U.props=N,U.state=y.memoizedState,U.refs={},lt(y),te=w.contextType,U.context=typeof te=="object"&&te!==null?cr(te):Bc,U.state=y.memoizedState,te=w.getDerivedStateFromProps,typeof te=="function"&&(Pf(y,w,te,N),U.state=y.memoizedState),typeof w.getDerivedStateFromProps=="function"||typeof U.getSnapshotBeforeUpdate=="function"||typeof U.UNSAFE_componentWillMount!="function"&&typeof U.componentWillMount!="function"||(te=U.state,typeof U.componentWillMount=="function"&&U.componentWillMount(),typeof U.UNSAFE_componentWillMount=="function"&&U.UNSAFE_componentWillMount(),te!==U.state&&Ul.enqueueReplaceState(U,U.state,null),_t(y,N,U,k),Je(),U.state=y.memoizedState),typeof U.componentDidMount=="function"&&(y.flags|=4194308),N=!0}else if(m===null){U=y.stateNode;var de=y.memoizedProps,Ne=vu(w,de);U.props=Ne;var Qe=U.context,yt=w.contextType;te=Bc,typeof yt=="object"&&yt!==null&&(te=cr(yt));var Rt=w.getDerivedStateFromProps;yt=typeof Rt=="function"||typeof U.getSnapshotBeforeUpdate=="function",de=y.pendingProps!==de,yt||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(de||Qe!==te)&&kS(y,U,N,te),Fu=!1;var Bt=y.memoizedState;U.state=Bt,_t(y,N,U,k),Je(),Qe=y.memoizedState,de||Bt!==Qe||Fu?(typeof Rt=="function"&&(Pf(y,w,Rt,N),Qe=y.memoizedState),(Ne=Fu||Uf(y,w,Ne,N,Bt,Qe,te))?(yt||typeof U.UNSAFE_componentWillMount!="function"&&typeof U.componentWillMount!="function"||(typeof U.componentWillMount=="function"&&U.componentWillMount(),typeof U.UNSAFE_componentWillMount=="function"&&U.UNSAFE_componentWillMount()),typeof U.componentDidMount=="function"&&(y.flags|=4194308)):(typeof U.componentDidMount=="function"&&(y.flags|=4194308),y.memoizedProps=N,y.memoizedState=Qe),U.props=N,U.state=Qe,U.context=te,N=Ne):(typeof U.componentDidMount=="function"&&(y.flags|=4194308),N=!1)}else{U=y.stateNode,Dt(m,y),te=y.memoizedProps,yt=vu(w,te),U.props=yt,Rt=y.pendingProps,Bt=U.context,Qe=w.contextType,Ne=Bc,typeof Qe=="object"&&Qe!==null&&(Ne=cr(Qe)),de=w.getDerivedStateFromProps,(Qe=typeof de=="function"||typeof U.getSnapshotBeforeUpdate=="function")||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(te!==Rt||Bt!==Ne)&&kS(y,U,N,Ne),Fu=!1,Bt=y.memoizedState,U.state=Bt,_t(y,N,U,k),Je();var mn=y.memoizedState;te!==Rt||Bt!==mn||Fu||m!==null&&m.dependencies!==null&&Hp(m.dependencies)?(typeof de=="function"&&(Pf(y,w,de,N),mn=y.memoizedState),(yt=Fu||Uf(y,w,yt,N,Bt,mn,Ne)||m!==null&&m.dependencies!==null&&Hp(m.dependencies))?(Qe||typeof U.UNSAFE_componentWillUpdate!="function"&&typeof U.componentWillUpdate!="function"||(typeof U.componentWillUpdate=="function"&&U.componentWillUpdate(N,mn,Ne),typeof U.UNSAFE_componentWillUpdate=="function"&&U.UNSAFE_componentWillUpdate(N,mn,Ne)),typeof U.componentDidUpdate=="function"&&(y.flags|=4),typeof U.getSnapshotBeforeUpdate=="function"&&(y.flags|=1024)):(typeof U.componentDidUpdate!="function"||te===m.memoizedProps&&Bt===m.memoizedState||(y.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||te===m.memoizedProps&&Bt===m.memoizedState||(y.flags|=1024),y.memoizedProps=N,y.memoizedState=mn),U.props=N,U.state=mn,U.context=Ne,N=yt):(typeof U.componentDidUpdate!="function"||te===m.memoizedProps&&Bt===m.memoizedState||(y.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||te===m.memoizedProps&&Bt===m.memoizedState||(y.flags|=1024),N=!1)}return U=N,Up(m,y),N=(y.flags&128)!==0,U||N?(U=y.stateNode,w=N&&typeof w.getDerivedStateFromError!="function"?null:U.render(),y.flags|=1,m!==null&&N?(y.child=Uc(y,m.child,null,k),y.child=Uc(y,null,w,k)):ur(m,y,w,k),y.memoizedState=U.state,m=y.child):m=bu(m,y,k),m}function HS(m,y,w,N){return kt(),y.flags|=256,ur(m,y,w,N),y.child}function hv(m){return{baseLanes:m,cachePool:xv()}}function $p(m,y,w){return m=m!==null?m.childLanes&~w:0,y&&(m|=qa),m}function VS(m,y,w){var N=y.pendingProps,k=!1,U=(y.flags&128)!==0,te;if((te=U)||(te=m!==null&&m.memoizedState===null?!1:(Li.current&2)!==0),te&&(k=!0,y.flags&=-129),te=(y.flags&32)!==0,y.flags&=-33,m===null){if(qn){if(k?aa(y):Ho(),qn){var de=gr,Ne;(Ne=de)&&(de=EA(de,qi),de!==null?(y.memoizedState={dehydrated:de,treeContext:kc!==null?{id:Qo,overflow:el}:null,retryLane:536870912},Ne=t(18,null,null,0),Ne.stateNode=de,Ne.return=y,y.child=Ne,mr=y,gr=null,Ne=!0):Ne=!1),Ne||Ke(y)}if(de=y.memoizedState,de!==null&&(de=de.dehydrated,de!==null))return $0(de)?y.lanes=16:y.lanes=536870912,null;Hr(y)}return de=N.children,N=N.fallback,k?(Ho(),k=y.mode,de=dv({mode:"hidden",children:de},k),N=Ys(N,k,w,null),de.return=y,N.return=y,de.sibling=N,y.child=de,k=y.child,k.memoizedState=hv(w),k.childLanes=$p(m,te,w),y.memoizedState=ey,N):(aa(y),fv(y,de))}if(Ne=m.memoizedState,Ne!==null&&(de=Ne.dehydrated,de!==null)){if(U)y.flags&256?(aa(y),y.flags&=-257,y=p0(m,y,w)):y.memoizedState!==null?(Ho(),y.child=m.child,y.flags|=128,y=null):(Ho(),k=N.fallback,de=y.mode,N=dv({mode:"visible",children:N.children},de),k=Ys(k,de,w,null),k.flags|=2,N.return=y,k.return=y,N.sibling=k,y.child=N,Uc(y,m.child,null,w),N=y.child,N.memoizedState=hv(w),N.childLanes=$p(m,te,w),y.memoizedState=ey,y=k);else if(aa(y),$0(de))te=SA(de).digest,N=Error(i(419)),N.stack="",N.digest=te,Et({value:N,source:null,stack:null}),y=p0(m,y,w);else if(Ts||Gp(m,y,w,!1),te=(w&m.childLanes)!==0,Ts||te){if(te=ds,te!==null){if(N=w&-w,(N&42)!==0)N=1;else switch(N){case 2:N=1;break;case 8:N=4;break;case 32:N=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:N=64;break;case 268435456:N=134217728;break;default:N=0}if(N=(N&(te.suspendedLanes|w))!==0?0:N,N!==0&&N!==Ne.retryLane)throw Ne.retryLane=N,Fe(m,N),Wi(te,m,N),Q0}U0(de)||Eu(),y=p0(m,y,w)}else U0(de)?(y.flags|=128,y.child=m.child,y=Mu.bind(null,m),AA(de,y),y=null):(m=Ne.treeContext,pr&&(gr=CA(de),mr=y,qn=!0,po=null,qi=!1,m!==null&&(Pa[Ua++]=Qo,Pa[Ua++]=el,Pa[Ua++]=kc,Qo=m.id,el=m.overflow,kc=y)),y=fv(y,N.children),y.flags|=4096);return y}return k?(Ho(),k=N.fallback,de=y.mode,Ne=m.child,U=Ne.sibling,N=lo(Ne,{mode:"hidden",children:N.children}),N.subtreeFlags=Ne.subtreeFlags&31457280,U!==null?k=lo(U,k):(k=Ys(k,de,w,null),k.flags|=2),k.return=y,N.return=y,N.sibling=k,y.child=N,N=k,k=y.child,de=m.child.memoizedState,de===null?de=hv(w):(Ne=de.cachePool,Ne!==null?(U=jr?Rs._currentValue:Rs._currentValue2,Ne=Ne.parent!==U?{parent:U,pool:U}:Ne):Ne=xv(),de={baseLanes:de.baseLanes|w,cachePool:Ne}),k.memoizedState=de,k.childLanes=$p(m,te,w),y.memoizedState=ey,N):(aa(y),w=m.child,m=w.sibling,w=lo(w,{mode:"visible",children:N.children}),w.return=y,w.sibling=null,m!==null&&(te=y.deletions,te===null?(y.deletions=[m],y.flags|=16):te.push(m)),y.child=w,y.memoizedState=null,w)}function fv(m,y){return y=dv({mode:"visible",children:y},m.mode),y.return=m,m.child=y}function dv(m,y){return sm(m,y,0,null)}function p0(m,y,w){return Uc(y,m.child,null,w),m=fv(y,y.pendingProps.children),m.flags|=2,y.memoizedState=null,m}function WS(m,y,w){m.lanes|=y;var N=m.alternate;N!==null&&(N.lanes|=y),zp(m.return,y,w)}function pv(m,y,w,N,k){var U=m.memoizedState;U===null?m.memoizedState={isBackwards:y,rendering:null,renderingStartTime:0,last:N,tail:w,tailMode:k}:(U.isBackwards=y,U.rendering=null,U.renderingStartTime=0,U.last=N,U.tail=w,U.tailMode=k)}function XS(m,y,w){var N=y.pendingProps,k=N.revealOrder,U=N.tail;if(ur(m,y,N.children,w),N=Li.current,(N&2)!==0)N=N&1|2,y.flags|=128;else{if(m!==null&&(m.flags&128)!==0)e:for(m=y.child;m!==null;){if(m.tag===13)m.memoizedState!==null&&WS(m,w,y);else if(m.tag===19)WS(m,w,y);else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===y)break e;for(;m.sibling===null;){if(m.return===null||m.return===y)break e;m=m.return}m.sibling.return=m.return,m=m.sibling}N&=1}switch(T(Li,N),k){case"forwards":for(w=y.child,k=null;w!==null;)m=w.alternate,m!==null&&Vo(m)===null&&(k=w),w=w.sibling;w=k,w===null?(k=y.child,y.child=null):(k=w.sibling,w.sibling=null),pv(y,!1,k,w,U);break;case"backwards":for(w=null,k=y.child,y.child=null;k!==null;){if(m=k.alternate,m!==null&&Vo(m)===null){y.child=k;break}m=k.sibling,k.sibling=w,w=k,k=m}pv(y,!0,w,null,U);break;case"together":pv(y,!1,null,null,void 0);break;default:y.memoizedState=null}return y.child}function bu(m,y,w){if(m!==null&&(y.dependencies=m.dependencies),Xa|=y.lanes,(w&y.childLanes)===0)if(m!==null){if(Gp(m,y,w,!1),(w&y.childLanes)===0)return null}else return null;if(m!==null&&y.child!==m.child)throw Error(i(153));if(y.child!==null){for(m=y.child,w=lo(m,m.pendingProps),y.child=w,w.return=y;m.sibling!==null;)m=m.sibling,w=w.sibling=lo(m,m.pendingProps),w.return=y;w.sibling=null}return y.child}function mv(m,y){return(m.lanes&y)!==0?!0:(m=m.dependencies,!!(m!==null&&Hp(m)))}function ZM(m,y,w){switch(y.tag){case 3:re(y,y.stateNode.containerInfo),gc(y,Rs,m.memoizedState.cache),kt();break;case 27:case 5:Te(y);break;case 4:re(y,y.stateNode.containerInfo);break;case 10:gc(y,y.type,y.memoizedProps.value);break;case 13:var N=y.memoizedState;if(N!==null)return N.dehydrated!==null?(aa(y),y.flags|=128,null):(w&y.child.childLanes)!==0?VS(m,y,w):(aa(y),m=bu(m,y,w),m!==null?m.sibling:null);aa(y);break;case 19:var k=(m.flags&128)!==0;if(N=(w&y.childLanes)!==0,N||(Gp(m,y,w,!1),N=(w&y.childLanes)!==0),k){if(N)return XS(m,y,w);y.flags|=128}if(k=y.memoizedState,k!==null&&(k.rendering=null,k.tail=null,k.lastEffect=null),T(Li,Li.current),N)break;return null;case 22:case 23:return y.lanes=0,US(m,y,w);case 24:gc(y,Rs,m.memoizedState.cache)}return bu(m,y,w)}function qS(m,y,w){if(m!==null)if(m.memoizedProps!==y.pendingProps)Ts=!0;else{if(!mv(m,w)&&(y.flags&128)===0)return Ts=!1,ZM(m,y,w);Ts=(m.flags&131072)!==0}else Ts=!1,qn&&(y.flags&1048576)!==0&&ne(y,ud,y.index);switch(y.lanes=0,y.tag){case 16:e:{m=y.pendingProps;var N=y.elementType,k=N._init;if(N=k(N._payload),y.type=N,typeof N=="function")tm(N)?(m=vu(N,m),y.tag=1,y=GS(null,y,N,m,w)):(y.tag=0,y=d0(null,y,N,m,w));else{if(N!=null){if(k=N.$$typeof,k===lm){y.tag=11,y=f0(null,y,N,m,w);break e}else if(k===O0){y.tag=14,y=FS(null,y,N,m,w);break e}}throw y=a(N)||N,Error(i(306,y,""))}}return y;case 0:return d0(m,y,y.type,y.pendingProps,w);case 1:return N=y.type,k=vu(N,y.pendingProps),GS(m,y,N,k,w);case 3:e:{if(re(y,y.stateNode.containerInfo),m===null)throw Error(i(387));var U=y.pendingProps;k=y.memoizedState,N=k.element,Dt(m,y),_t(y,U,null,w);var te=y.memoizedState;if(U=te.cache,gc(y,Rs,U),U!==k.cache&&_h(y,[Rs],w,!0),Je(),U=te.element,pr&&k.isDehydrated)if(k={element:U,isDehydrated:!1,cache:te.cache},y.updateQueue.baseState=k,y.memoizedState=k,y.flags&256){y=HS(m,y,U,w);break e}else if(U!==N){N=se(Error(i(424)),y),Et(N),y=HS(m,y,U,w);break e}else for(pr&&(gr=wA(y.stateNode.containerInfo),mr=y,qn=!0,po=null,qi=!0),w=Pl(y,null,U,w),y.child=w;w;)w.flags=w.flags&-3|4096,w=w.sibling;else{if(kt(),U===N){y=bu(m,y,w);break e}ur(m,y,U,w)}y=y.child}return y;case 26:if(Fa)return Up(m,y),m===null?(w=t1(y.type,null,y.pendingProps,null))?y.memoizedState=w:qn||(y.stateNode=W0(y.type,y.pendingProps,Ll.current,y)):y.memoizedState=t1(y.type,m.memoizedProps,y.pendingProps,m.memoizedState),null;case 27:if(Ss)return Te(y),m===null&&Ss&&qn&&(N=y.stateNode=Zo(y.type,y.pendingProps,Ll.current,ki.current,!1),mr=y,qi=!0,gr=z0(N)),N=y.pendingProps.children,m!==null||qn?ur(m,y,N,w):y.child=Uc(y,null,N,w),Up(m,y),y.child;case 5:return m===null&&qn&&(H0(y.type,y.pendingProps,ki.current),(k=N=gr)&&(N=rN(N,y.type,y.pendingProps,qi),N!==null?(y.stateNode=N,mr=y,gr=z0(N),qi=!1,k=!0):k=!1),k||Ke(y)),Te(y),k=y.type,U=y.pendingProps,te=m!==null?m.memoizedProps:null,N=U.children,xn(k,U)?N=null:te!==null&&xn(k,te)&&(y.flags|=32),y.memoizedState!==null&&(k=Xo(m,y,bi,null,null,w),jr?Jo._currentValue=k:Jo._currentValue2=k),Up(m,y),ur(m,y,N,w),y.child;case 6:return m===null&&qn&&(DA(y.pendingProps,ki.current),(m=w=gr)&&(w=Qv(w,y.pendingProps,qi),w!==null?(y.stateNode=w,mr=y,gr=null,m=!0):m=!1),m||Ke(y)),null;case 13:return VS(m,y,w);case 4:return re(y,y.stateNode.containerInfo),N=y.pendingProps,m===null?y.child=Uc(y,null,N,w):ur(m,y,N,w),y.child;case 11:return f0(m,y,y.type,y.pendingProps,w);case 7:return ur(m,y,y.pendingProps,w),y.child;case 8:return ur(m,y,y.pendingProps.children,w),y.child;case 12:return ur(m,y,y.pendingProps.children,w),y.child;case 10:return N=y.pendingProps,gc(y,y.type,N.value),ur(m,y,N.children,w),y.child;case 9:return k=y.type._context,N=y.pendingProps.children,yc(y),k=cr(k),N=N(k),y.flags|=1,ur(m,y,N,w),y.child;case 14:return FS(m,y,y.type,y.pendingProps,w);case 15:return PS(m,y,y.type,y.pendingProps,w);case 19:return XS(m,y,w);case 22:return US(m,y,w);case 24:return yc(y),N=cr(Rs),m===null?(k=yv(),k===null&&(k=ds,U=xc(),k.pooledCache=U,U.refCount++,U!==null&&(k.pooledCacheLanes|=w),k=U),y.memoizedState={parent:N,cache:k},lt(y),gc(y,Rs,k)):((m.lanes&w)!==0&&(Dt(m,y),_t(y,null,null,w),Je()),k=m.memoizedState,U=y.memoizedState,k.parent!==N?(k={parent:N,cache:N},y.memoizedState=k,y.lanes===0&&(y.memoizedState=y.updateQueue.baseState=k),gc(y,Rs,N)):(N=U.cache,gc(y,Rs,N),N!==k.cache&&_h(y,[Rs],w,!0))),ur(m,y,y.pendingProps.children,w),y.child;case 29:throw y.pendingProps}throw Error(i(156,y.tag))}function gc(m,y,w){jr?(T(Uu,y._currentValue),y._currentValue=w):(T(Uu,y._currentValue2),y._currentValue2=w)}function _u(m){var y=Uu.current;jr?m._currentValue=y:m._currentValue2=y,_(Uu)}function zp(m,y,w){for(;m!==null;){var N=m.alternate;if((m.childLanes&y)!==y?(m.childLanes|=y,N!==null&&(N.childLanes|=y)):N!==null&&(N.childLanes&y)!==y&&(N.childLanes|=y),m===w)break;m=m.return}}function _h(m,y,w,N){var k=m.child;for(k!==null&&(k.return=m);k!==null;){var U=k.dependencies;if(U!==null){var te=k.child;U=U.firstContext;e:for(;U!==null;){var de=U;U=k;for(var Ne=0;Ne<y.length;Ne++)if(de.context===y[Ne]){U.lanes|=w,de=U.alternate,de!==null&&(de.lanes|=w),zp(U.return,w,m),N||(te=null);break e}U=de.next}}else if(k.tag===18){if(te=k.return,te===null)throw Error(i(341));te.lanes|=w,U=te.alternate,U!==null&&(U.lanes|=w),zp(te,w,m),te=null}else te=k.child;if(te!==null)te.return=k;else for(te=k;te!==null;){if(te===m){te=null;break}if(k=te.sibling,k!==null){k.return=te.return,te=k;break}te=te.return}k=te}}function Gp(m,y,w,N){m=null;for(var k=y,U=!1;k!==null;){if(!U){if((k.flags&524288)!==0)U=!0;else if((k.flags&262144)!==0)break}if(k.tag===10){var te=k.alternate;if(te===null)throw Error(i(387));if(te=te.memoizedProps,te!==null){var de=k.type;pa(k.pendingProps.value,te.value)||(m!==null?m.push(de):m=[de])}}else if(k===Ih.current){if(te=k.alternate,te===null)throw Error(i(387));te.memoizedState.memoizedState!==k.memoizedState.memoizedState&&(m!==null?m.push(Jo):m=[Jo])}k=k.return}m!==null&&_h(y,m,w,N),y.flags|=262144}function Hp(m){for(m=m.firstContext;m!==null;){var y=m.context;if(!pa(jr?y._currentValue:y._currentValue2,m.memoizedValue))return!0;m=m.next}return!1}function yc(m){sl=m,Ha=null,m=m.dependencies,m!==null&&(m.firstContext=null)}function cr(m){return gv(sl,m)}function Vp(m,y){return sl===null&&yc(m),gv(m,y)}function gv(m,y){var w=jr?y._currentValue:y._currentValue2;if(y={context:y,memoizedValue:w,next:null},Ha===null){if(m===null)throw Error(i(308));Ha=y,m.dependencies={lanes:0,firstContext:y},m.flags|=524288}else Ha=Ha.next=y;return w}function xc(){return{controller:new md,data:new Map,refCount:0}}function Wp(m){m.refCount--,m.refCount===0&&HA(VA,function(){m.controller.abort()})}function yv(){var m=$l.current;return m!==null?m:ds.pooledCache}function m0(m,y){y===null?T($l,$l.current):T($l,y.pool)}function xv(){var m=yv();return m===null?null:{parent:jr?Rs._currentValue:Rs._currentValue2,pool:m}}function oa(m){m.flags|=4}function Hf(m,y){if(m!==null&&m.child===y.child)return!1;if((y.flags&16)!==0)return!0;for(m=y.child;m!==null;){if((m.flags&13878)!==0||(m.subtreeFlags&13878)!==0)return!0;m=m.sibling}return!1}function Sh(m,y,w,N){if(Bi)for(w=y.child;w!==null;){if(w.tag===5||w.tag===6)cm(m,w.stateNode);else if(!(w.tag===4||Ss&&w.tag===27)&&w.child!==null){w.child.return=w,w=w.child;continue}if(w===y)break;for(;w.sibling===null;){if(w.return===null||w.return===y)return;w=w.return}w.sibling.return=w.return,w=w.sibling}else if(ho)for(var k=y.child;k!==null;){if(k.tag===5){var U=k.stateNode;w&&N&&(U=Kv(U,k.type,k.memoizedProps)),cm(m,U)}else if(k.tag===6)U=k.stateNode,w&&N&&(U=Yv(U,k.memoizedProps)),cm(m,U);else if(k.tag!==4){if(k.tag===22&&k.memoizedState!==null)U=k.child,U!==null&&(U.return=k),Sh(m,k,!0,!0);else if(k.child!==null){k.child.return=k,k=k.child;continue}}if(k===y)break;for(;k.sibling===null;){if(k.return===null||k.return===y)return;k=k.return}k.sibling.return=k.return,k=k.sibling}}function jS(m,y,w,N){if(ho)for(var k=y.child;k!==null;){if(k.tag===5){var U=k.stateNode;w&&N&&(U=Kv(U,k.type,k.memoizedProps)),jv(m,U)}else if(k.tag===6)U=k.stateNode,w&&N&&(U=Yv(U,k.memoizedProps)),jv(m,U);else if(k.tag!==4){if(k.tag===22&&k.memoizedState!==null)U=k.child,U!==null&&(U.return=k),jS(m,k,!(k.memoizedProps!==null&&k.memoizedProps.mode==="manual"),!0);else if(k.child!==null){k.child.return=k,k=k.child;continue}}if(k===y)break;for(;k.sibling===null;){if(k.return===null||k.return===y)return;k=k.return}k.sibling.return=k.return,k=k.sibling}}function Xp(m,y){if(ho&&Hf(m,y)){m=y.stateNode;var w=m.containerInfo,N=hm();jS(N,y,!1,!1),m.pendingChildren=N,oa(y),P0(w,N)}}function g0(m,y,w,N){if(Bi)m.memoizedProps!==N&&oa(y);else if(ho){var k=m.stateNode,U=m.memoizedProps;if((m=Hf(m,y))||U!==N){var te=ki.current;U=ad(k,w,U,N,!m,null),U===k?y.stateNode=k:(Du(U,w,N,te)&&oa(y),y.stateNode=U,m?Sh(U,y,!1,!1):oa(y))}else y.stateNode=k}}function y0(m,y,w){if($v(y,w)){if(m.flags|=16777216,!L0(y,w))if(Tc())m.flags|=8192;else throw Lc=bm,vm}else m.flags&=-16777217}function x0(m,y){if(kA(y)){if(m.flags|=16777216,!Ch(y))if(Tc())m.flags|=8192;else throw Lc=bm,vm}else m.flags&=-16777217}function Vf(m,y){y!==null&&(m.flags|=4),m.flags&16384&&(y=m.tag!==22?D():536870912,m.lanes|=y,Hl|=y)}function Wf(m,y){if(!qn)switch(m.tailMode){case"hidden":y=m.tail;for(var w=null;y!==null;)y.alternate!==null&&(w=y),y=y.sibling;w===null?m.tail=null:w.sibling=null;break;case"collapsed":w=m.tail;for(var N=null;w!==null;)w.alternate!==null&&(N=w),w=w.sibling;N===null?y||m.tail===null?m.tail=null:m.tail.sibling=null:N.sibling=null}}function Gs(m){var y=m.alternate!==null&&m.alternate.child===m.child,w=0,N=0;if(y)for(var k=m.child;k!==null;)w|=k.lanes|k.childLanes,N|=k.subtreeFlags&31457280,N|=k.flags&31457280,k.return=m,k=k.sibling;else for(k=m.child;k!==null;)w|=k.lanes|k.childLanes,N|=k.subtreeFlags,N|=k.flags,k.return=m,k=k.sibling;return m.subtreeFlags|=N,m.childLanes=w,y}function KS(m,y,w){var N=y.pendingProps;switch(ue(y),y.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Gs(y),null;case 1:return Gs(y),null;case 3:return w=y.stateNode,N=null,m!==null&&(N=m.memoizedState.cache),y.memoizedState.cache!==N&&(y.flags|=2048),_u(Rs),ce(),w.pendingContext&&(w.context=w.pendingContext,w.pendingContext=null),(m===null||m.child===null)&&(xt(y)?oa(y):m===null||m.memoizedState.isDehydrated&&(y.flags&256)===0||(y.flags|=1024,po!==null&&(Qp(po),po=null))),Xp(m,y),Gs(y),null;case 26:if(Fa){w=y.type;var k=y.memoizedState;return m===null?(oa(y),k!==null?(Gs(y),x0(y,k)):(Gs(y),y0(y,w,N))):k?k!==m.memoizedState?(oa(y),Gs(y),x0(y,k)):(Gs(y),y.flags&=-16777217):(Bi?m.memoizedProps!==N&&oa(y):g0(m,y,w,N),Gs(y),y0(y,w,N)),null}case 27:if(Ss){if(Be(y),w=Ll.current,k=y.type,m!==null&&y.stateNode!=null)Bi?m.memoizedProps!==N&&oa(y):g0(m,y,k,N);else{if(!N){if(y.stateNode===null)throw Error(i(166));return Gs(y),null}m=ki.current,xt(y)?ut(y,m):(m=Zo(k,N,w,m,!0),y.stateNode=m,oa(y))}return Gs(y),null}case 5:if(Be(y),w=y.type,m!==null&&y.stateNode!=null)g0(m,y,w,N);else{if(!N){if(y.stateNode===null)throw Error(i(166));return Gs(y),null}m=ki.current,xt(y)?ut(y,m):(k=Uv(w,N,Ll.current,m,y),Sh(k,y,!1,!1),y.stateNode=k,Du(k,w,N,m)&&oa(y))}return Gs(y),y0(y,y.type,y.pendingProps),null;case 6:if(m&&y.stateNode!=null)w=m.memoizedProps,Bi?w!==N&&oa(y):ho&&(w!==N?(y.stateNode=ms(N,Ll.current,ki.current,y),oa(y)):y.stateNode=m.stateNode);else{if(typeof N!="string"&&y.stateNode===null)throw Error(i(166));if(m=Ll.current,w=ki.current,xt(y)){if(!pr)throw Error(i(176));if(m=y.stateNode,w=y.memoizedProps,N=null,k=mr,k!==null)switch(k.tag){case 27:case 5:N=k.memoizedProps}e1(m,w,y,N)||Ke(y)}else y.stateNode=ms(N,m,w,y)}return Gs(y),null;case 13:if(N=y.memoizedState,m===null||m.memoizedState!==null&&m.memoizedState.dehydrated!==null){if(k=xt(y),N!==null&&N.dehydrated!==null){if(m===null){if(!k)throw Error(i(318));if(!pr)throw Error(i(344));if(k=y.memoizedState,k=k!==null?k.dehydrated:null,!k)throw Error(i(317));NA(k,y)}else kt(),(y.flags&128)===0&&(y.memoizedState=null),y.flags|=4;Gs(y),k=!1}else po!==null&&(Qp(po),po=null),k=!0;if(!k)return y.flags&256?(Hr(y),y):(Hr(y),null)}if(Hr(y),(y.flags&128)!==0)return y.lanes=w,y;if(w=N!==null,m=m!==null&&m.memoizedState!==null,w){N=y.child,k=null,N.alternate!==null&&N.alternate.memoizedState!==null&&N.alternate.memoizedState.cachePool!==null&&(k=N.alternate.memoizedState.cachePool.pool);var U=null;N.memoizedState!==null&&N.memoizedState.cachePool!==null&&(U=N.memoizedState.cachePool.pool),U!==k&&(N.flags|=2048)}return w!==m&&w&&(y.child.flags|=8192),Vf(y,y.updateQueue),Gs(y),null;case 4:return ce(),Xp(m,y),m===null&&oi(y.stateNode.containerInfo),Gs(y),null;case 10:return _u(y.type),Gs(y),null;case 19:if(_(Li),k=y.memoizedState,k===null)return Gs(y),null;if(N=(y.flags&128)!==0,U=k.rendering,U===null)if(N)Wf(k,!1);else{if(ws!==0||m!==null&&(m.flags&128)!==0)for(m=y.child;m!==null;){if(U=Vo(m),U!==null){for(y.flags|=128,Wf(k,!1),m=U.updateQueue,y.updateQueue=m,Vf(y,m),y.subtreeFlags=0,m=w,w=y.child;w!==null;)nm(w,m),w=w.sibling;return T(Li,Li.current&1|2),y.child}m=m.sibling}k.tail!==null&&fo()>xd&&(y.flags|=128,N=!0,Wf(k,!1),y.lanes=4194304)}else{if(!N)if(m=Vo(U),m!==null){if(y.flags|=128,N=!0,m=m.updateQueue,y.updateQueue=m,Vf(y,m),Wf(k,!0),k.tail===null&&k.tailMode==="hidden"&&!U.alternate&&!qn)return Gs(y),null}else 2*fo()-k.renderingStartTime>xd&&w!==536870912&&(y.flags|=128,N=!0,Wf(k,!1),y.lanes=4194304);k.isBackwards?(U.sibling=y.child,y.child=U):(m=k.last,m!==null?m.sibling=U:y.child=U,k.last=U)}return k.tail!==null?(y=k.tail,k.rendering=y,k.tail=y.sibling,k.renderingStartTime=fo(),y.sibling=null,m=Li.current,T(Li,N?m&1|2:m&1),y):(Gs(y),null);case 22:case 23:return Hr(y),wr(),N=y.memoizedState!==null,m!==null?m.memoizedState!==null!==N&&(y.flags|=8192):N&&(y.flags|=8192),N?(w&536870912)!==0&&(y.flags&128)===0&&(Gs(y),y.subtreeFlags&6&&(y.flags|=8192)):Gs(y),w=y.updateQueue,w!==null&&Vf(y,w.retryQueue),w=null,m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(w=m.memoizedState.cachePool.pool),N=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(N=y.memoizedState.cachePool.pool),N!==w&&(y.flags|=2048),m!==null&&_($l),null;case 24:return w=null,m!==null&&(w=m.memoizedState.cache),y.memoizedState.cache!==w&&(y.flags|=2048),_u(Rs),Gs(y),null;case 25:return null}throw Error(i(156,y.tag))}function QM(m,y){switch(ue(y),y.tag){case 1:return m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 3:return _u(Rs),ce(),m=y.flags,(m&65536)!==0&&(m&128)===0?(y.flags=m&-65537|128,y):null;case 26:case 27:case 5:return Be(y),null;case 13:if(Hr(y),m=y.memoizedState,m!==null&&m.dehydrated!==null){if(y.alternate===null)throw Error(i(340));kt()}return m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 19:return _(Li),null;case 4:return ce(),null;case 10:return _u(y.type),null;case 22:case 23:return Hr(y),wr(),m!==null&&_($l),m=y.flags,m&65536?(y.flags=m&-65537|128,y):null;case 24:return _u(Rs),null;case 25:return null;default:return null}}function YS(m,y){switch(ue(y),y.tag){case 3:_u(Rs),ce();break;case 26:case 27:case 5:Be(y);break;case 4:ce();break;case 13:Hr(y);break;case 19:_(Li);break;case 10:_u(y.type);break;case 22:case 23:Hr(y),wr(),m!==null&&_($l);break;case 24:_u(Rs)}}function qp(m,y){try{var w=y.updateQueue,N=w!==null?w.lastEffect:null;if(N!==null){var k=N.next;w=k;do{if((w.tag&m)===m){N=void 0;var U=w.create,te=w.inst;N=U(),te.destroy=N}w=w.next}while(w!==k)}}catch(de){hs(y,y.return,de)}}function vc(m,y,w){try{var N=y.updateQueue,k=N!==null?N.lastEffect:null;if(k!==null){var U=k.next;N=U;do{if((N.tag&m)===m){var te=N.inst,de=te.destroy;if(de!==void 0){te.destroy=void 0,k=y;var Ne=w;try{de()}catch(Qe){hs(k,Ne,Qe)}}}N=N.next}while(N!==U)}}catch(Qe){hs(y,y.return,Qe)}}function JS(m){var y=m.updateQueue;if(y!==null){var w=m.stateNode;try{dt(y,w)}catch(N){hs(m,m.return,N)}}}function la(m,y,w){w.props=vu(m.type,m.memoizedProps),w.state=m.memoizedState;try{w.componentWillUnmount()}catch(N){hs(m,y,N)}}function jo(m,y){try{var w=m.ref;if(w!==null){var N=m.stateNode;switch(m.tag){case 26:case 27:case 5:var k=sd(N);break;default:k=N}typeof w=="function"?m.refCleanup=w(k):w.current=k}}catch(U){hs(m,y,U)}}function ua(m,y){var w=m.ref,N=m.refCleanup;if(w!==null)if(typeof N=="function")try{N()}catch(k){hs(m,y,k)}finally{m.refCleanup=null,m=m.alternate,m!=null&&(m.refCleanup=null)}else if(typeof w=="function")try{w(null)}catch(k){hs(m,y,k)}else w.current=null}function vv(m){var y=m.type,w=m.memoizedProps,N=m.stateNode;try{sN(N,y,w,m)}catch(k){hs(m,m.return,k)}}function bv(m,y,w){try{pA(m.stateNode,m.type,w,y,m)}catch(N){hs(m,m.return,N)}}function _v(m){return m.tag===5||m.tag===3||(Fa?m.tag===26:!1)||(Ss?m.tag===27:!1)||m.tag===4}function jp(m){e:for(;;){for(;m.sibling===null;){if(m.return===null||_v(m.return))return null;m=m.return}for(m.sibling.return=m.return,m=m.sibling;m.tag!==5&&m.tag!==6&&(!Ss||m.tag!==27)&&m.tag!==18;){if(m.flags&2||m.child===null||m.tag===4)continue e;m.child.return=m,m=m.child}if(!(m.flags&2))return m.stateNode}}function Sv(m,y,w){var N=m.tag;if(N===5||N===6)m=m.stateNode,y?gA(w,m,y):Wv(w,m);else if(!(N===4||Ss&&N===27)&&(m=m.child,m!==null))for(Sv(m,y,w),m=m.sibling;m!==null;)Sv(m,y,w),m=m.sibling}function Su(m,y,w){var N=m.tag;if(N===5||N===6)m=m.stateNode,y?mA(w,m,y):fA(w,m);else if(!(N===4||Ss&&N===27)&&(m=m.child,m!==null))for(Su(m,y,w),m=m.sibling;m!==null;)Su(m,y,w),m=m.sibling}function v0(m,y,w){m=m.containerInfo;try{od(m,w)}catch(N){hs(y,y.return,N)}}function Kp(m,y){for(B0(m.containerInfo),pn=y;pn!==null;)if(m=pn,y=m.child,(m.subtreeFlags&1028)!==0&&y!==null)y.return=m,pn=y;else for(;pn!==null;){m=pn;var w=m.alternate;switch(y=m.flags,m.tag){case 0:break;case 11:case 15:break;case 1:if((y&1024)!==0&&w!==null){y=void 0;var N=m,k=w.memoizedProps;w=w.memoizedState;var U=N.stateNode;try{var te=vu(N.type,k,N.elementType===N.type);y=U.getSnapshotBeforeUpdate(te,w),U.__reactInternalSnapshotBeforeUpdate=y}catch(de){hs(N,N.return,de)}}break;case 3:(y&1024)!==0&&Bi&&_A(m.stateNode.containerInfo);break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((y&1024)!==0)throw Error(i(163))}if(y=m.sibling,y!==null){y.return=m.return,pn=y;break}pn=m.return}return te=On,On=!1,te}function b0(m,y,w){var N=w.flags;switch(w.tag){case 0:case 11:case 15:Tu(m,w),N&4&&qp(5,w);break;case 1:if(Tu(m,w),N&4)if(m=w.stateNode,y===null)try{m.componentDidMount()}catch(de){hs(w,w.return,de)}else{var k=vu(w.type,y.memoizedProps);y=y.memoizedState;try{m.componentDidUpdate(k,y,m.__reactInternalSnapshotBeforeUpdate)}catch(de){hs(w,w.return,de)}}N&64&&JS(w),N&512&&jo(w,w.return);break;case 3:if(Tu(m,w),N&64&&(N=w.updateQueue,N!==null)){if(m=null,w.child!==null)switch(w.child.tag){case 27:case 5:m=sd(w.child.stateNode);break;case 1:m=w.child.stateNode}try{dt(N,m)}catch(de){hs(w,w.return,de)}}break;case 26:if(Fa){Tu(m,w),N&512&&jo(w,w.return);break}case 27:case 5:Tu(m,w),y===null&&N&4&&vv(w),N&512&&jo(w,w.return);break;case 12:Tu(m,w);break;case 13:Tu(m,w),N&4&&_0(m,w);break;case 22:if(k=w.memoizedState!==null||zl,!k){y=y!==null&&y.memoizedState!==null||Zs;var U=zl,te=Zs;zl=k,(Zs=y)&&!te?wu(m,w,(w.subtreeFlags&8772)!==0):Tu(m,w),zl=U,Zs=te}N&512&&(w.memoizedProps.mode==="manual"?jo(w,w.return):ua(w,w.return));break;default:Tu(m,w)}}function Av(m){var y=m.alternate;y!==null&&(m.alternate=null,Av(y)),m.child=null,m.deletions=null,m.sibling=null,m.tag===5&&(y=m.stateNode,y!==null&&nN(y)),m.stateNode=null,m.return=null,m.dependencies=null,m.memoizedProps=null,m.memoizedState=null,m.pendingProps=null,m.stateNode=null,m.updateQueue=null}function hr(m,y,w){for(w=w.child;w!==null;)bc(m,y,w),w=w.sibling}function bc(m,y,w){if(da&&typeof da.onCommitFiberUnmount=="function")try{da.onCommitFiberUnmount(ui,w)}catch{}switch(w.tag){case 26:if(Fa){Zs||ua(w,y),hr(m,y,w),w.memoizedState?wh(w.memoizedState):w.stateNode&&ld(w.stateNode);break}case 27:if(Ss){Zs||ua(w,y);var N=en,k=Sn;en=w.stateNode,hr(m,y,w),Oc(w.stateNode),en=N,Sn=k;break}case 5:Zs||ua(w,y);case 6:if(Bi){if(N=en,k=Sn,en=null,hr(m,y,w),en=N,Sn=k,en!==null)if(Sn)try{yA(en,w.stateNode)}catch(U){hs(w,y,U)}else try{Xv(en,w.stateNode)}catch(U){hs(w,y,U)}}else hr(m,y,w);break;case 18:Bi&&en!==null&&(Sn?fm(en,w.stateNode):IA(en,w.stateNode));break;case 4:Bi?(N=en,k=Sn,en=w.stateNode.containerInfo,Sn=!0,hr(m,y,w),en=N,Sn=k):(ho&&v0(w.stateNode,w,hm()),hr(m,y,w));break;case 0:case 11:case 14:case 15:Zs||vc(2,w,y),Zs||vc(4,w,y),hr(m,y,w);break;case 1:Zs||(ua(w,y),N=w.stateNode,typeof N.componentWillUnmount=="function"&&la(w,y,N)),hr(m,y,w);break;case 21:hr(m,y,w);break;case 22:Zs||ua(w,y),Zs=(N=Zs)||w.memoizedState!==null,hr(m,y,w),Zs=N;break;default:hr(m,y,w)}}function _0(m,y){if(pr&&y.memoizedState===null&&(m=y.alternate,m!==null&&(m=m.memoizedState,m!==null&&(m=m.dehydrated,m!==null))))try{oN(m)}catch(w){hs(y,y.return,w)}}function ZS(m){switch(m.tag){case 13:case 19:var y=m.stateNode;return y===null&&(y=m.stateNode=new fs),y;case 22:return m=m.stateNode,y=m._retryCache,y===null&&(y=m._retryCache=new fs),y;default:throw Error(i(435,m.tag))}}function Au(m,y){var w=ZS(m);y.forEach(function(N){var k=Ec.bind(null,m,N);w.has(N)||(w.add(N),N.then(k,k))})}function Xr(m,y){var w=y.deletions;if(w!==null)for(var N=0;N<w.length;N++){var k=w[N],U=m,te=y;if(Bi){var de=te;e:for(;de!==null;){switch(de.tag){case 27:case 5:en=de.stateNode,Sn=!1;break e;case 3:en=de.stateNode.containerInfo,Sn=!0;break e;case 4:en=de.stateNode.containerInfo,Sn=!0;break e}de=de.return}if(en===null)throw Error(i(160));bc(U,te,k),en=null,Sn=!1}else bc(U,te,k);U=k.alternate,U!==null&&(U.return=null),k.return=null}if(y.subtreeFlags&13878)for(y=y.child;y!==null;)Tv(y,m),y=y.sibling}function Tv(m,y){var w=m.alternate,N=m.flags;switch(m.tag){case 0:case 11:case 14:case 15:Xr(y,m),ca(m),N&4&&(vc(3,m,m.return),qp(3,m),vc(5,m,m.return));break;case 1:Xr(y,m),ca(m),N&512&&(Zs||w===null||ua(w,w.return)),N&64&&zl&&(m=m.updateQueue,m!==null&&(N=m.callbacks,N!==null&&(w=m.shared.hiddenCallbacks,m.shared.hiddenCallbacks=w===null?N:w.concat(N))));break;case 26:if(Fa){var k=Xs;Xr(y,m),ca(m),N&512&&(Zs||w===null||ua(w,w.return)),N&4&&(N=w!==null?w.memoizedState:null,y=m.memoizedState,w===null?y===null?m.stateNode===null?m.stateNode=pm(k,m.type,m.memoizedProps,m):mm(k,m.type,m.stateNode):m.stateNode=OA(k,y,m.memoizedProps):N!==y?(N===null?w.stateNode!==null&&ld(w.stateNode):wh(N),y===null?mm(k,m.type,m.stateNode):OA(k,y,m.memoizedProps)):y===null&&m.stateNode!==null&&bv(m,m.memoizedProps,w.memoizedProps));break}case 27:if(Ss&&N&4&&m.alternate===null){k=m.stateNode;var U=m.memoizedProps;try{Dc(k),FA(m.type,U,k,m)}catch(yt){hs(m,m.return,yt)}}case 5:if(Xr(y,m),ca(m),N&512&&(Zs||w===null||ua(w,w.return)),Bi){if(m.flags&32){y=m.stateNode;try{qv(y)}catch(yt){hs(m,m.return,yt)}}N&4&&m.stateNode!=null&&(y=m.memoizedProps,bv(m,y,w!==null?w.memoizedProps:y)),N&1024&&(r1=!0)}break;case 6:if(Xr(y,m),ca(m),N&4&&Bi){if(m.stateNode===null)throw Error(i(162));N=m.memoizedProps,w=w!==null?w.memoizedProps:N,y=m.stateNode;try{dA(y,w,N)}catch(yt){hs(m,m.return,yt)}}break;case 3:if(Fa?(BA(),k=Xs,Xs=V0(y.containerInfo),Xr(y,m),Xs=k):Xr(y,m),ca(m),N&4){if(Bi&&pr&&w!==null&&w.memoizedState.isDehydrated)try{aN(y.containerInfo)}catch(yt){hs(m,m.return,yt)}if(ho){N=y.containerInfo,w=y.pendingChildren;try{od(N,w)}catch(yt){hs(m,m.return,yt)}}}r1&&(r1=!1,QS(m));break;case 4:Fa?(w=Xs,Xs=V0(m.stateNode.containerInfo),Xr(y,m),ca(m),Xs=w):(Xr(y,m),ca(m)),N&4&&ho&&v0(m.stateNode,m,m.stateNode.pendingChildren);break;case 12:Xr(y,m),ca(m);break;case 13:Xr(y,m),ca(m),m.child.flags&8192&&m.memoizedState!==null!=(w!==null&&w.memoizedState!==null)&&(Zr=fo()),N&4&&(N=m.updateQueue,N!==null&&(m.updateQueue=null,Au(m,N)));break;case 22:N&512&&(Zs||w===null||ua(w,w.return)),k=m.memoizedState!==null;var te=w!==null&&w.memoizedState!==null,de=zl,Ne=Zs;if(zl=de||k,Zs=Ne||te,Xr(y,m),Zs=Ne,zl=de,ca(m),y=m.stateNode,y._current=m,y._visibility&=-3,y._visibility|=y._pendingVisibility&2,N&8192&&(y._visibility=k?y._visibility&-2:y._visibility|1,k&&(y=zl||Zs,w===null||te||y||Xf(m)),Bi&&(m.memoizedProps===null||m.memoizedProps.mode!=="manual"))){e:if(w=null,Bi)for(y=m;;){if(y.tag===5||Fa&&y.tag===26||Ss&&y.tag===27){if(w===null){te=w=y;try{U=te.stateNode,k?xA(U):bA(te.stateNode,te.memoizedProps)}catch(yt){hs(te,te.return,yt)}}}else if(y.tag===6){if(w===null){te=y;try{var Qe=te.stateNode;k?vA(Qe):iN(Qe,te.memoizedProps)}catch(yt){hs(te,te.return,yt)}}}else if((y.tag!==22&&y.tag!==23||y.memoizedState===null||y===m)&&y.child!==null){y.child.return=y,y=y.child;continue}if(y===m)break e;for(;y.sibling===null;){if(y.return===null||y.return===m)break e;w===y&&(w=null),y=y.return}w===y&&(w=null),y.sibling.return=y.return,y=y.sibling}}N&4&&(N=m.updateQueue,N!==null&&(w=N.retryQueue,w!==null&&(N.retryQueue=null,Au(m,w))));break;case 19:Xr(y,m),ca(m),N&4&&(N=m.updateQueue,N!==null&&(m.updateQueue=null,Au(m,N)));break;case 21:break;default:Xr(y,m),ca(m)}}function ca(m){var y=m.flags;if(y&2){try{if(Bi&&(!Ss||m.tag!==27)){e:{for(var w=m.return;w!==null;){if(_v(w)){var N=w;break e}w=w.return}throw Error(i(160))}switch(N.tag){case 27:if(Ss){var k=N.stateNode,U=jp(m);Su(m,U,k);break}case 5:var te=N.stateNode;N.flags&32&&(qv(te),N.flags&=-33);var de=jp(m);Su(m,de,te);break;case 3:case 4:var Ne=N.stateNode.containerInfo,Qe=jp(m);Sv(m,Qe,Ne);break;default:throw Error(i(161))}}}catch(yt){hs(m,m.return,yt)}m.flags&=-3}y&4096&&(m.flags&=-4097)}function QS(m){if(m.subtreeFlags&1024)for(m=m.child;m!==null;){var y=m;QS(y),y.tag===5&&y.flags&1024&&F0(y.stateNode),m=m.sibling}}function Tu(m,y){if(y.subtreeFlags&8772)for(y=y.child;y!==null;)b0(m,y.alternate,y),y=y.sibling}function Xf(m){for(m=m.child;m!==null;){var y=m;switch(y.tag){case 0:case 11:case 14:case 15:vc(4,y,y.return),Xf(y);break;case 1:ua(y,y.return);var w=y.stateNode;typeof w.componentWillUnmount=="function"&&la(y,y.return,w),Xf(y);break;case 26:case 27:case 5:ua(y,y.return),Xf(y);break;case 22:ua(y,y.return),y.memoizedState===null&&Xf(y);break;default:Xf(y)}m=m.sibling}}function wu(m,y,w){for(w=w&&(y.subtreeFlags&8772)!==0,y=y.child;y!==null;){var N=y.alternate,k=m,U=y,te=U.flags;switch(U.tag){case 0:case 11:case 15:wu(k,U,w),qp(4,U);break;case 1:if(wu(k,U,w),N=U,k=N.stateNode,typeof k.componentDidMount=="function")try{k.componentDidMount()}catch(Qe){hs(N,N.return,Qe)}if(N=U,k=N.updateQueue,k!==null){var de=N.stateNode;try{var Ne=k.shared.hiddenCallbacks;if(Ne!==null)for(k.shared.hiddenCallbacks=null,k=0;k<Ne.length;k++)ge(Ne[k],de)}catch(Qe){hs(N,N.return,Qe)}}w&&te&64&&JS(U),jo(U,U.return);break;case 26:case 27:case 5:wu(k,U,w),w&&N===null&&te&4&&vv(U),jo(U,U.return);break;case 12:wu(k,U,w);break;case 13:wu(k,U,w),w&&te&4&&_0(k,U);break;case 22:U.memoizedState===null&&wu(k,U,w),jo(U,U.return);break;default:wu(k,U,w)}y=y.sibling}}function S0(m,y){var w=null;m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(w=m.memoizedState.cachePool.pool),m=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(m=y.memoizedState.cachePool.pool),m!==w&&(m!=null&&m.refCount++,w!=null&&Wp(w))}function Yp(m,y){m=null,y.alternate!==null&&(m=y.alternate.memoizedState.cache),y=y.memoizedState.cache,y!==m&&(y.refCount++,m!=null&&Wp(m))}function Vi(m,y,w,N){if(y.subtreeFlags&10256)for(y=y.child;y!==null;)wv(m,y,w,N),y=y.sibling}function wv(m,y,w,N){var k=y.flags;switch(y.tag){case 0:case 11:case 15:Vi(m,y,w,N),k&2048&&qp(9,y);break;case 3:Vi(m,y,w,N),k&2048&&(m=null,y.alternate!==null&&(m=y.alternate.memoizedState.cache),y=y.memoizedState.cache,y!==m&&(y.refCount++,m!=null&&Wp(m)));break;case 12:if(k&2048){Vi(m,y,w,N),m=y.stateNode;try{var U=y.memoizedProps,te=U.id,de=U.onPostCommit;typeof de=="function"&&de(te,y.alternate===null?"mount":"update",m.passiveEffectDuration,-0)}catch(Ne){hs(y,y.return,Ne)}}else Vi(m,y,w,N);break;case 23:break;case 22:U=y.stateNode,y.memoizedState!==null?U._visibility&4?Vi(m,y,w,N):Cr(m,y):U._visibility&4?Vi(m,y,w,N):(U._visibility|=4,fr(m,y,w,N,(y.subtreeFlags&10256)!==0)),k&2048&&S0(y.alternate,y);break;case 24:Vi(m,y,w,N),k&2048&&Yp(y.alternate,y);break;default:Vi(m,y,w,N)}}function fr(m,y,w,N,k){for(k=k&&(y.subtreeFlags&10256)!==0,y=y.child;y!==null;){var U=m,te=y,de=w,Ne=N,Qe=te.flags;switch(te.tag){case 0:case 11:case 15:fr(U,te,de,Ne,k),qp(8,te);break;case 23:break;case 22:var yt=te.stateNode;te.memoizedState!==null?yt._visibility&4?fr(U,te,de,Ne,k):Cr(U,te):(yt._visibility|=4,fr(U,te,de,Ne,k)),k&&Qe&2048&&S0(te.alternate,te);break;case 24:fr(U,te,de,Ne,k),k&&Qe&2048&&Yp(te.alternate,te);break;default:fr(U,te,de,Ne,k)}y=y.sibling}}function Cr(m,y){if(y.subtreeFlags&10256)for(y=y.child;y!==null;){var w=m,N=y,k=N.flags;switch(N.tag){case 22:Cr(w,N),k&2048&&S0(N.alternate,N);break;case 24:Cr(w,N),k&2048&&Yp(N.alternate,N);break;default:Cr(w,N)}y=y.sibling}}function ao(m){if(m.subtreeFlags&Va)for(m=m.child;m!==null;)A0(m),m=m.sibling}function A0(m){switch(m.tag){case 26:ao(m),m.flags&Va&&(m.memoizedState!==null?LA(Xs,m.memoizedState,m.memoizedProps):Kr(m.type,m.memoizedProps));break;case 5:ao(m),m.flags&Va&&Kr(m.type,m.memoizedProps);break;case 3:case 4:if(Fa){var y=Xs;Xs=V0(m.stateNode.containerInfo),ao(m),Xs=y}else ao(m);break;case 22:m.memoizedState===null&&(y=m.alternate,y!==null&&y.memoizedState!==null?(y=Va,Va=16777216,ao(m),Va=y):ao(m));break;default:ao(m)}}function Jp(m){var y=m.alternate;if(y!==null&&(m=y.child,m!==null)){y.child=null;do y=m.sibling,m.sibling=null,m=y;while(m!==null)}}function _c(m){var y=m.deletions;if((m.flags&16)!==0){if(y!==null)for(var w=0;w<y.length;w++){var N=y[w];pn=N,Cv(N,m)}Jp(m)}if(m.subtreeFlags&10256)for(m=m.child;m!==null;)T0(m),m=m.sibling}function T0(m){switch(m.tag){case 0:case 11:case 15:_c(m),m.flags&2048&&vc(9,m,m.return);break;case 3:_c(m);break;case 12:_c(m);break;case 22:var y=m.stateNode;m.memoizedState!==null&&y._visibility&4&&(m.return===null||m.return.tag!==13)?(y._visibility&=-5,Cu(m)):_c(m);break;default:_c(m)}}function Cu(m){var y=m.deletions;if((m.flags&16)!==0){if(y!==null)for(var w=0;w<y.length;w++){var N=y[w];pn=N,Cv(N,m)}Jp(m)}for(m=m.child;m!==null;){switch(y=m,y.tag){case 0:case 11:case 15:vc(8,y,y.return),Cu(y);break;case 22:w=y.stateNode,w._visibility&4&&(w._visibility&=-5,Cu(y));break;default:Cu(y)}m=m.sibling}}function Cv(m,y){for(;pn!==null;){var w=pn;switch(w.tag){case 0:case 11:case 15:vc(8,w,y);break;case 23:case 22:if(w.memoizedState!==null&&w.memoizedState.cachePool!==null){var N=w.memoizedState.cachePool.pool;N!=null&&N.refCount++}break;case 24:Wp(w.memoizedState.cache)}if(N=w.child,N!==null)N.return=w,pn=N;else e:for(w=m;pn!==null;){N=pn;var k=N.sibling,U=N.return;if(Av(N),N===w){pn=null;break e}if(k!==null){k.return=U,pn=k;break e}pn=U}}}function qf(m){var y=rA(m);if(y!=null){if(typeof y.memoizedProps["data-testname"]!="string")throw Error(i(364));return y}if(m=Hv(m),m===null)throw Error(i(362));return m.stateNode.current}function Sc(m,y){var w=m.tag;switch(y.$$typeof){case yd:if(m.type===y.value)return!0;break;case yo:e:{for(y=y.value,m=[m,0],w=0;w<m.length;){var N=m[w++],k=N.tag,U=m[w++],te=y[U];if(k!==5&&k!==26&&k!==27||!rd(N)){for(;te!=null&&Sc(N,te);)U++,te=y[U];if(U===y.length){y=!0;break e}else for(N=N.child;N!==null;)m.push(N,U),N=N.sibling}}y=!1}return y;case ks:if((w===5||w===26||w===27)&&uA(m.stateNode,y.value))return!0;break;case Gl:if((w===5||w===6||w===26||w===27)&&(m=lA(m),m!==null&&0<=m.indexOf(y.value)))return!0;break;case il:if((w===5||w===26||w===27)&&(m=m.memoizedProps["data-testname"],typeof m=="string"&&m.toLowerCase()===y.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Ev(m){switch(m.$$typeof){case yd:return"<"+(a(m.value)||"Unknown")+">";case yo:return":has("+(Ev(m)||"")+")";case ks:return'[role="'+m.value+'"]';case Gl:return'"'+m.value+'"';case il:return'[data-testname="'+m.value+'"]';default:throw Error(i(365))}}function ha(m,y){var w=[];m=[m,0];for(var N=0;N<m.length;){var k=m[N++],U=k.tag,te=m[N++],de=y[te];if(U!==5&&U!==26&&U!==27||!rd(k)){for(;de!=null&&Sc(k,de);)te++,de=y[te];if(te===y.length)w.push(k);else for(k=k.child;k!==null;)m.push(k,te),k=k.sibling}}return w}function Zp(m,y){if(!Ic)throw Error(i(363));m=qf(m),m=ha(m,y),y=[],m=Array.from(m);for(var w=0;w<m.length;){var N=m[w++],k=N.tag;if(k===5||k===26||k===27)rd(N)||y.push(N.stateNode);else for(N=N.child;N!==null;)m.push(N),N=N.sibling}return y}function ai(){if((Zn&2)!==0&&zn!==0)return zn&-zn;if(cn.T!==null){var m=$a;return m!==0?m:mt()}return aA()}function Mv(){qa===0&&(qa=(zn&536870912)===0||qn?P():536870912);var m=za.current;return m!==null&&(m.flags|=32),qa}function Wi(m,y,w){(m===ds&&xs===2||m.cancelPendingCommit!==null)&&(dr(m,0),fa(m,zn,qa,!1)),F(m,w),((Zn&2)===0||m!==ds)&&(m===ds&&((Zn&2)===0&&($u|=w),ws===4&&fa(m,zn,qa,!1)),ke(m))}function Ac(m,y,w){if((Zn&6)!==0)throw Error(i(327));var N=!w&&(y&60)===0&&(y&m.expiredLanes)===0||I(m,y),k=N?Rv(m,y):C0(m,y,!0),U=N;do{if(k===0){Wa&&!N&&fa(m,y,0,!1);break}else if(k===6)fa(m,y,0,!vo);else{if(w=m.current.alternate,U&&!jf(w)){k=C0(m,y,!1),U=!1;continue}if(k===2){if(U=y,m.errorRecoveryDisabledLanes&U)var te=0;else te=m.pendingLanes&-536870913,te=te!==0?te:te&536870912?536870912:0;if(te!==0){y=te;e:{var de=m;k=$h;var Ne=pr&&de.current.memoizedState.isDehydrated;if(Ne&&(dr(de,te).flags|=256),te=C0(de,te,!1),te!==2){if(Fi&&!Ne){de.errorRecoveryDisabledLanes|=U,$u|=U,k=4;break e}U=Qs,Qs=k,U!==null&&Qp(U)}k=te}if(U=!1,k!==2)continue}}if(k===1){dr(m,0),fa(m,y,0,!0);break}e:{switch(N=m,k){case 0:case 1:throw Error(i(345));case 4:if((y&4194176)===y){fa(N,y,qa,!vo);break e}break;case 2:Qs=null;break;case 3:case 5:break;default:throw Error(i(329))}if(N.finishedWork=w,N.finishedLanes=y,(y&62914560)===y&&(U=Zr+300-fo(),10<U)){if(fa(N,y,qa,!vo),R(N,0)!==0)break e;N.timeoutHandle=Ai(w0.bind(null,N,w,Qs,Sm,ty,y,qa,$u,Hl,vo,2,-0,0),U);break e}w0(N,w,Qs,Sm,ty,y,qa,$u,Hl,vo,0,-0,0)}}break}while(!0);ke(m)}function Qp(m){Qs===null?Qs=m:Qs.push.apply(Qs,m)}function w0(m,y,w,N,k,U,te,de,Ne,Qe,yt,Rt,Bt){var mn=y.subtreeFlags;if((mn&8192||(mn&16785408)===16785408)&&(zv(),A0(y),y=Ti(),y!==null)){m.cancelPendingCommit=y(wc.bind(null,m,w,N,k,te,de,Ne,1,Rt,Bt)),fa(m,U,te,!Qe);return}wc(m,w,N,k,te,de,Ne,yt,Rt,Bt)}function jf(m){for(var y=m;;){var w=y.tag;if((w===0||w===11||w===15)&&y.flags&16384&&(w=y.updateQueue,w!==null&&(w=w.stores,w!==null)))for(var N=0;N<w.length;N++){var k=w[N],U=k.getSnapshot;k=k.value;try{if(!pa(U(),k))return!1}catch{return!1}}if(w=y.child,y.subtreeFlags&16384&&w!==null)w.return=y,y=w;else{if(y===m)break;for(;y.sibling===null;){if(y.return===null||y.return===m)return!0;y=y.return}y.sibling.return=y.return,y=y.sibling}}return!0}function fa(m,y,w,N){y&=~_m,y&=~$u,m.suspendedLanes|=y,m.pingedLanes&=~y,N&&(m.warmLanes|=y),N=m.expirationTimes;for(var k=y;0<k;){var U=31-Yr(k),te=1<<U;N[U]=-1,k&=~te}w!==0&&q(m,w,y)}function em(){return(Zn&6)===0?(ie(0),!1):!0}function Kf(){if(nn!==null){if(xs===0)var m=nn.return;else m=nn,Ha=sl=null,qo(m),Fc=null,Pc=0,m=nn;for(;m!==null;)YS(m.alternate,m),m=m.return;nn=null}}function dr(m,y){m.finishedWork=null,m.finishedLanes=0;var w=m.timeoutHandle;w!==Nc&&(m.timeoutHandle=Nc,k0(w)),w=m.cancelPendingCommit,w!==null&&(m.cancelPendingCommit=null,w()),Kf(),ds=m,nn=w=lo(m.current,null),zn=y,xs=0,Mr=null,vo=!1,Wa=I(m,y),Fi=!1,Hl=qa=_m=$u=Xa=ws=0,Qs=$h=null,ty=!1,(y&8)!==0&&(y|=y&32);var N=m.entangledLanes;if(N!==0)for(m=m.entanglements,N&=y;0<N;){var k=31-Yr(N),U=1<<k;y|=m[k],N&=~U}return Nr=y,le(),w}function Ba(m,y){wn=null,cn.H=Js,y===dd?(y=Kt(),xs=3):y===vm?(y=Kt(),xs=4):xs=y===Q0?8:y!==null&&typeof y=="object"&&typeof y.then=="function"?6:1,Mr=y,nn===null&&(ws=1,$f(m,se(y,m.current)))}function Tc(){var m=za.current;return m===null?!0:(zn&4194176)===zn?As===null:(zn&62914560)===zn||(zn&536870912)!==0?m===As:!1}function Rl(){var m=cn.H;return cn.H=Js,m===null?Js:m}function Il(){var m=cn.A;return cn.A=gd,m}function Eu(){ws=4,vo||(zn&4194176)!==zn&&za.current!==null||(Wa=!0),(Xa&134217727)===0&&($u&134217727)===0||ds===null||fa(ds,zn,qa,!1)}function C0(m,y,w){var N=Zn;Zn|=2;var k=Rl(),U=Il();(ds!==m||zn!==y)&&(Sm=null,dr(m,y)),y=!1;var te=ws;e:do try{if(xs!==0&&nn!==null){var de=nn,Ne=Mr;switch(xs){case 8:Kf(),te=6;break e;case 3:case 2:case 6:za.current===null&&(y=!0);var Qe=xs;if(xs=0,Mr=null,oo(m,de,Ne,Qe),w&&Wa){te=0;break e}break;default:Qe=xs,xs=0,Mr=null,oo(m,de,Ne,Qe)}}Nv(),te=ws;break}catch(yt){Ba(m,yt)}while(!0);return y&&m.shellSuspendCounter++,Ha=sl=null,Zn=N,cn.H=k,cn.A=U,nn===null&&(ds=null,zn=0,le()),te}function Nv(){for(;nn!==null;)Ws(nn)}function Rv(m,y){var w=Zn;Zn|=2;var N=Rl(),k=Il();ds!==m||zn!==y?(Sm=null,xd=fo()+500,dr(m,y)):Wa=I(m,y);e:do try{if(xs!==0&&nn!==null){y=nn;var U=Mr;t:switch(xs){case 1:xs=0,Mr=null,oo(m,y,U,1);break;case 2:if(Ze(U)){xs=0,Mr=null,ss(y);break}y=function(){xs===2&&ds===m&&(xs=7),ke(m)},U.then(y,y);break e;case 3:xs=7;break e;case 4:xs=5;break e;case 7:Ze(U)?(xs=0,Mr=null,ss(y)):(xs=0,Mr=null,oo(m,y,U,7));break;case 5:var te=null;switch(nn.tag){case 26:te=nn.memoizedState;case 5:case 27:var de=nn,Ne=de.type,Qe=de.pendingProps;if(te?Ch(te):L0(Ne,Qe)){xs=0,Mr=null;var yt=de.sibling;if(yt!==null)nn=yt;else{var Rt=de.return;Rt!==null?(nn=Rt,ka(Rt)):nn=null}break t}}xs=0,Mr=null,oo(m,y,U,5);break;case 6:xs=0,Mr=null,oo(m,y,U,6);break;case 8:Kf(),ws=6;break e;default:throw Error(i(462))}}qr();break}catch(Bt){Ba(m,Bt)}while(!0);return Ha=sl=null,cn.H=N,cn.A=k,Zn=w,nn!==null?0:(ds=null,zn=0,le(),ws)}function qr(){for(;nn!==null&&!$A();)Ws(nn)}function Ws(m){var y=qS(m.alternate,m,Nr);m.memoizedProps=m.pendingProps,y===null?ka(m):nn=y}function ss(m){var y=m,w=y.alternate;switch(y.tag){case 15:case 0:y=zS(w,y,y.pendingProps,y.type,void 0,zn);break;case 11:y=zS(w,y,y.pendingProps,y.type.render,y.ref,zn);break;case 5:qo(y);default:YS(w,y),y=nn=nm(y,Nr),y=qS(w,y,Nr)}m.memoizedProps=m.pendingProps,y===null?ka(m):nn=y}function oo(m,y,w,N){Ha=sl=null,qo(y),Fc=null,Pc=0;var k=y.return;try{if(JM(m,k,y,w,zn)){ws=1,$f(m,se(w,m.current)),nn=null;return}}catch(U){if(k!==null)throw nn=k,U;ws=1,$f(m,se(w,m.current)),nn=null;return}y.flags&32768?(qn||N===1?m=!0:Wa||(zn&536870912)!==0?m=!1:(vo=m=!0,(N===2||N===3||N===6)&&(N=za.current,N!==null&&N.tag===13&&(N.flags|=16384))),E0(y,m)):ka(y)}function ka(m){var y=m;do{if((y.flags&32768)!==0){E0(y,vo);return}m=y.return;var w=KS(y.alternate,y,Nr);if(w!==null){nn=w;return}if(y=y.sibling,y!==null){nn=y;return}nn=y=m}while(y!==null);ws===0&&(ws=5)}function E0(m,y){do{var w=QM(m.alternate,m);if(w!==null){w.flags&=32767,nn=w;return}if(w=m.return,w!==null&&(w.flags|=32768,w.subtreeFlags=0,w.deletions=null),!y&&(m=m.sibling,m!==null)){nn=m;return}nn=m=w}while(m!==null);ws=6,nn=null}function wc(m,y,w,N,k,U,te,de,Ne,Qe){var yt=cn.T,Rt=Ou();try{Er(2),cn.T=null,eA(m,y,w,N,Rt,k,U,te,de,Ne,Qe)}finally{cn.T=yt,Er(Rt)}}function eA(m,y,w,N,k,U,te,de){do Ko();while(Vl!==null);if((Zn&6)!==0)throw Error(i(327));var Ne=m.finishedWork;if(N=m.finishedLanes,Ne===null)return null;if(m.finishedWork=null,m.finishedLanes=0,Ne===m.current)throw Error(i(177));m.callbackNode=null,m.callbackPriority=0,m.cancelPendingCommit=null;var Qe=Ne.lanes|Ne.childLanes;if(Qe|=tl,X(m,N,Qe,U,te,de),m===ds&&(nn=ds=null,zn=0),(Ne.subtreeFlags&10256)===0&&(Ne.flags&10256)===0||rl||(rl=!0,Hc=Qe,ny=w,Nu(K0,function(){return Ko(),null})),w=(Ne.flags&15990)!==0,(Ne.subtreeFlags&15990)!==0||w?(w=cn.T,cn.T=null,U=Ou(),Er(2),te=Zn,Zn|=4,Kp(m,Ne),Tv(Ne,m),iA(m.containerInfo),m.current=Ne,b0(m,Ne.alternate,Ne),q0(),Zn=te,Er(U),cn.T=w):m.current=Ne,rl?(rl=!1,Vl=m,zh=N):Iv(m,Qe),Qe=m.pendingLanes,Qe===0&&(Gc=null),$(Ne.stateNode),ke(m),y!==null)for(k=m.onRecoverableError,Ne=0;Ne<y.length;Ne++)Qe=y[Ne],k(Qe.value,{componentStack:Qe.stack});return(zh&3)!==0&&Ko(),Qe=m.pendingLanes,(N&4194218)!==0&&(Qe&42)!==0?m===sy?vd++:(vd=0,sy=m):vd=0,ie(0),null}function Iv(m,y){(m.pooledCacheLanes&=y)===0&&(y=m.pooledCache,y!=null&&(m.pooledCache=null,Wp(y)))}function Ko(){if(Vl!==null){var m=Vl,y=Hc;Hc=0;var w=Y(zh),N=32>w?32:w;w=cn.T;var k=Ou();try{if(Er(N),cn.T=null,Vl===null)var U=!1;else{N=ny,ny=null;var te=Vl,de=zh;if(Vl=null,zh=0,(Zn&6)!==0)throw Error(i(331));var Ne=Zn;if(Zn|=4,T0(te.current),wv(te,te.current,de,N),Zn=Ne,ie(0,!1),da&&typeof da.onPostCommitFiberRoot=="function")try{da.onPostCommitFiberRoot(ui,te)}catch{}U=!0}return U}finally{Er(k),cn.T=w,Iv(m,y)}}return!1}function Yf(m,y,w){y=se(w,y),y=Gf(m.stateNode,y,2),m=Pt(m,y,2),m!==null&&(F(m,2),ke(m))}function hs(m,y,w){if(m.tag===3)Yf(m,m,w);else for(;y!==null;){if(y.tag===3){Yf(y,m,w);break}else if(y.tag===1){var N=y.stateNode;if(typeof y.type.getDerivedStateFromError=="function"||typeof N.componentDidCatch=="function"&&(Gc===null||!Gc.has(N))){m=se(w,m),w=cv(2),N=Pt(y,w,2),N!==null&&(LS(w,N,y,m),F(N,2),ke(N));break}}y=y.return}}function Ah(m,y,w){var N=m.pingCache;if(N===null){N=m.pingCache=new xo;var k=new Set;N.set(y,k)}else k=N.get(y),k===void 0&&(k=new Set,N.set(y,k));k.has(w)||(Fi=!0,k.add(w),m=Dv.bind(null,m,y,w),y.then(m,m))}function Dv(m,y,w){var N=m.pingCache;N!==null&&N.delete(y),m.pingedLanes|=m.suspendedLanes&w,m.warmLanes&=~w,ds===m&&(zn&w)===w&&(ws===4||ws===3&&(zn&62914560)===zn&&300>fo()-Zr?(Zn&2)===0&&dr(m,0):_m|=w,Hl===zn&&(Hl=0)),ke(m)}function Cc(m,y){y===0&&(y=D()),m=Fe(m,y),m!==null&&(F(m,y),ke(m))}function Mu(m){var y=m.memoizedState,w=0;y!==null&&(w=y.retryLane),Cc(m,w)}function Ec(m,y){var w=0;switch(m.tag){case 13:var N=m.stateNode,k=m.memoizedState;k!==null&&(w=k.retryLane);break;case 19:N=m.stateNode;break;case 22:N=m.stateNode._retryCache;break;default:throw Error(i(314))}N!==null&&N.delete(y),Cc(m,w)}function Nu(m,y){return gm(m,y)}function Ov(m,y,w,N){this.tag=m,this.key=w,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=y,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=N,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function tm(m){return m=m.prototype,!(!m||!m.isReactComponent)}function lo(m,y){var w=m.alternate;return w===null?(w=t(m.tag,y,m.key,m.mode),w.elementType=m.elementType,w.type=m.type,w.stateNode=m.stateNode,w.alternate=m,m.alternate=w):(w.pendingProps=y,w.type=m.type,w.flags=0,w.subtreeFlags=0,w.deletions=null),w.flags=m.flags&31457280,w.childLanes=m.childLanes,w.lanes=m.lanes,w.child=m.child,w.memoizedProps=m.memoizedProps,w.memoizedState=m.memoizedState,w.updateQueue=m.updateQueue,y=m.dependencies,w.dependencies=y===null?null:{lanes:y.lanes,firstContext:y.firstContext},w.sibling=m.sibling,w.index=m.index,w.ref=m.ref,w.refCleanup=m.refCleanup,w}function nm(m,y){m.flags&=31457282;var w=m.alternate;return w===null?(m.childLanes=0,m.lanes=y,m.child=null,m.subtreeFlags=0,m.memoizedProps=null,m.memoizedState=null,m.updateQueue=null,m.dependencies=null,m.stateNode=null):(m.childLanes=w.childLanes,m.lanes=w.lanes,m.child=w.child,m.subtreeFlags=0,m.deletions=null,m.memoizedProps=w.memoizedProps,m.memoizedState=w.memoizedState,m.updateQueue=w.updateQueue,m.type=w.type,y=w.dependencies,m.dependencies=y===null?null:{lanes:y.lanes,firstContext:y.firstContext}),m}function Dl(m,y,w,N,k,U){var te=0;if(N=m,typeof m=="function")tm(m)&&(te=1);else if(typeof m=="string")te=Fa&&Ss?dm(m,w,ki.current)?26:Bl(m)?27:5:Fa?dm(m,w,ki.current)?26:5:Ss&&Bl(m)?27:5;else e:switch(m){case Mc:return Ys(w.children,k,U,y);case am:te=8,k|=24;break;case I0:return m=t(12,w,y,k|2),m.elementType=I0,m.lanes=U,m;case D0:return m=t(13,w,y,k),m.elementType=D0,m.lanes=U,m;case ed:return m=t(19,w,y,k),m.elementType=ed,m.lanes=U,m;case Lv:return sm(w,k,U,y);default:if(typeof m=="object"&&m!==null)switch(m.$$typeof){case om:case Yo:te=10;break e;case kv:te=9;break e;case lm:te=11;break e;case O0:te=14;break e;case co:te=16,N=null;break e}te=29,w=Error(i(130,m===null?"null":typeof m,"")),N=null}return y=t(te,w,y,k),y.elementType=m,y.type=N,y.lanes=U,y}function Ys(m,y,w,N){return m=t(7,m,N,y),m.lanes=w,m}function sm(m,y,w,N){m=t(22,m,N,y),m.elementType=Lv,m.lanes=w;var k={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var U=k._current;if(U===null)throw Error(i(456));if((k._pendingVisibility&2)===0){var te=Fe(U,2);te!==null&&(k._pendingVisibility|=2,Wi(te,U,2))}},attach:function(){var U=k._current;if(U===null)throw Error(i(456));if((k._pendingVisibility&2)!==0){var te=Fe(U,2);te!==null&&(k._pendingVisibility&=-3,Wi(te,U,2))}}};return m.stateNode=k,m}function M0(m,y,w){return m=t(6,m,null,y),m.lanes=w,m}function Bv(m,y,w){return y=t(4,m.children!==null?m.children:[],m.key,y),y.lanes=w,y.stateNode={containerInfo:m.containerInfo,pendingChildren:null,implementation:m.implementation},y}function eN(m,y,w,N,k,U,te,de){this.tag=1,this.containerInfo=m,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Nc,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=O(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=O(0),this.hiddenUpdates=O(null),this.identifierPrefix=N,this.onUncaughtError=k,this.onCaughtError=U,this.onRecoverableError=te,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=de,this.incompleteTransitions=new Map}function tA(m,y,w,N,k,U,te,de,Ne,Qe,yt,Rt){return m=new eN(m,y,w,te,de,Ne,Qe,Rt),y=1,U===!0&&(y|=24),U=t(3,null,null,y),m.current=U,U.stateNode=m,y=xc(),y.refCount++,m.pooledCache=y,y.refCount++,U.memoizedState={element:N,isDehydrated:w,cache:y},lt(U),m}function Si(m){return m?(m=Bc,m):Bc}function N0(m){var y=m._reactInternals;if(y===void 0)throw typeof m.render=="function"?Error(i(188)):(m=Object.keys(m).join(","),Error(i(268,m)));return m=g(y),m=m!==null?x(m):null,m===null?null:sd(m.stateNode)}function Jf(m,y,w,N,k,U){k=Si(k),N.context===null?N.context=k:N.pendingContext=k,N=Ft(y),N.payload={element:w},U=U===void 0?null:U,U!==null&&(N.callback=U),w=Pt(m,N,y),w!==null&&(Wi(w,m,y),vt(w,m,y))}function Zf(m,y){if(m=m.memoizedState,m!==null&&m.dehydrated!==null){var w=m.retryLane;m.retryLane=w!==0&&w<y?w:y}}function im(m,y){Zf(m,y),(m=m.alternate)&&Zf(m,y)}var yn={},Qf=Dx(),La=aie(),R0=Object.assign,tN=Symbol.for("react.element"),rm=Symbol.for("react.transitional.element"),uo=Symbol.for("react.portal"),Mc=Symbol.for("react.fragment"),am=Symbol.for("react.strict_mode"),I0=Symbol.for("react.profiler"),om=Symbol.for("react.provider"),kv=Symbol.for("react.consumer"),Yo=Symbol.for("react.context"),lm=Symbol.for("react.forward_ref"),D0=Symbol.for("react.suspense"),ed=Symbol.for("react.suspense_list"),O0=Symbol.for("react.memo"),co=Symbol.for("react.lazy"),Lv=Symbol.for("react.offscreen"),nA=Symbol.for("react.memo_cache_sentinel"),Ru=Symbol.iterator,Fv=Symbol.for("react.client.reference"),cn=Qf.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Ol,Iu,Th=!1,td=Array.isArray,Pv=e.rendererVersion,um=e.rendererPackageName,nd=e.extraDevToolsConfig,sd=e.getPublicInstance,sA=e.getRootHostContext,id=e.getChildHostContext,B0=e.prepareForCommit,iA=e.resetAfterCommit,Uv=e.createInstance,cm=e.appendInitialChild,Du=e.finalizeInitialChildren,xn=e.shouldSetTextContent,ms=e.createTextInstance,Ai=e.scheduleTimeout,k0=e.cancelTimeout,Nc=e.noTimeout,jr=e.isPrimaryRenderer;e.warnsIfNotActing;var Bi=e.supportsMutation,ho=e.supportsPersistence,pr=e.supportsHydration,rA=e.getInstanceFromNode;e.beforeActiveInstanceBlur,e.afterActiveInstanceBlur;var oi=e.preparePortalMount;e.prepareScopeUpdate,e.getInstanceFromScope;var Er=e.setCurrentUpdatePriority,Ou=e.getCurrentUpdatePriority,aA=e.resolveUpdatePriority;e.resolveEventType,e.resolveEventTimeStamp;var oA=e.shouldAttemptEagerTransition,nN=e.detachDeletedInstance;e.requestPostPaintCallback;var $v=e.maySuspendCommit,L0=e.preloadInstance,zv=e.startSuspendingCommit,Kr=e.suspendInstance,Ti=e.waitForCommitToBeReady,Rc=e.NotPendingTransition,Jo=e.HostTransitionContext,F0=e.resetFormInstance;e.bindToConsole;var Gv=e.supportsMicrotasks,Bu=e.scheduleMicrotask,Ic=e.supportsTestSelectors,Hv=e.findFiberRoot,Vv=e.getBoundingRect,lA=e.getTextContent,rd=e.isHiddenSubtree,uA=e.matchAccessibilityRole,cA=e.setFocusIfFocusable,hA=e.setupIntersectionObserver,fA=e.appendChild,Wv=e.appendChildToContainer,dA=e.commitTextUpdate,sN=e.commitMount,pA=e.commitUpdate,mA=e.insertBefore,gA=e.insertInContainerBefore,Xv=e.removeChild,yA=e.removeChildFromContainer,qv=e.resetTextContent,xA=e.hideInstance,vA=e.hideTextInstance,bA=e.unhideInstance,iN=e.unhideTextInstance,_A=e.clearContainer,ad=e.cloneInstance,hm=e.createContainerChildSet,jv=e.appendChildToContainerChildSet,P0=e.finalizeContainerChildren,od=e.replaceContainerChildren,Kv=e.cloneHiddenInstance,Yv=e.cloneHiddenTextInstance,U0=e.isSuspenseInstancePending,$0=e.isSuspenseInstanceFallback,SA=e.getSuspenseInstanceFallbackErrorDetails,AA=e.registerSuspenseInstanceRetry,Jv=e.canHydrateFormStateMarker,TA=e.isFormStateMarkerMatching,Zv=e.getNextHydratableSibling,z0=e.getFirstHydratableChild,wA=e.getFirstHydratableChildWithinContainer,CA=e.getFirstHydratableChildWithinSuspenseInstance,rN=e.canHydrateInstance,Qv=e.canHydrateTextInstance,EA=e.canHydrateSuspenseInstance,MA=e.hydrateInstance,e1=e.hydrateTextInstance,NA=e.hydrateSuspenseInstance,RA=e.getNextHydratableInstanceAfterSuspenseInstance,aN=e.commitHydratedContainer,oN=e.commitHydratedSuspenseInstance,IA=e.clearSuspenseBoundary,fm=e.clearSuspenseBoundaryFromContainer,G0=e.shouldDeleteUnhydratedTailInstances;e.diffHydratedPropsForDevWarnings,e.diffHydratedTextForDevWarnings,e.describeHydratableInstanceForDevWarnings;var H0=e.validateHydratableInstance,DA=e.validateHydratableTextInstance,Fa=e.supportsResources,dm=e.isHostHoistableType,V0=e.getHoistableRoot,t1=e.getResource,OA=e.acquireResource,wh=e.releaseResource,pm=e.hydrateHoistable,mm=e.mountHoistable,ld=e.unmountHoistable,W0=e.createHoistableInstance,BA=e.prepareToCommitHoistables,kA=e.mayResourceSuspendCommit,Ch=e.preloadResource,LA=e.suspendResource,Ss=e.supportsSingletons,Zo=e.resolveSingletonInstance,Dc=e.clearSingleton,FA=e.acquireSingletonInstance,Oc=e.releaseSingletonInstance,Bl=e.isHostSingletonType,li=[],ku=-1,Bc={},Yr=Math.clz32?Math.clz32:E,PA=Math.log,UA=Math.LN2,kl=128,Eh=4194304,gm=La.unstable_scheduleCallback,X0=La.unstable_cancelCallback,$A=La.unstable_shouldYield,q0=La.unstable_requestPaint,fo=La.unstable_now,j0=La.unstable_ImmediatePriority,zA=La.unstable_UserBlockingPriority,K0=La.unstable_NormalPriority,lN=La.unstable_IdlePriority,GA=La.log,Xi=La.unstable_setDisableYieldValue,ui=null,da=null,pa=typeof Object.is=="function"?Object.is:V,n1=new WeakMap,Mh=[],Nh=0,Rh=null,ud=0,Pa=[],Ua=0,kc=null,Qo=1,el="",ki=b(null),cd=b(null),Ll=b(null),Ih=b(null),mr=null,gr=null,qn=!1,po=null,qi=!1,ym=Error(i(519)),mo=[],Dh=0,tl=0,xm=null,Lu=null,Oh=!1,Ms=!1,s1=!1,hd=0,fd=null,Bh=0,$a=0,kh=null,Fu=!1,Lh=!1,Fl=Object.prototype.hasOwnProperty,dd=Error(i(460)),vm=Error(i(474)),bm={then:function(){}},Lc=null,Fc=null,Pc=0,Uc=$s(!0),Pl=$s(!1),Ns=b(null),pd=b(0),za=b(null),As=null,Li=b(0),Pu=0,wn=null,tn=null,Jn=null,go=!1,Fh=!1,$c=!1,Y0=0,Ph=0,ji=null,nl=0,J0=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}},Js={readContext:cr,use:Ge,useCallback:gs,useContext:gs,useEffect:gs,useImperativeHandle:gs,useLayoutEffect:gs,useInsertionEffect:gs,useMemo:gs,useReducer:gs,useRef:gs,useState:gs,useDebugValue:gs,useDeferredValue:gs,useTransition:gs,useSyncExternalStore:gs,useId:gs};Js.useCacheRefresh=gs,Js.useMemoCache=gs,Js.useHostTransitionStatus=gs,Js.useFormState=gs,Js.useActionState=gs,Js.useOptimistic=gs;var zc={readContext:cr,use:Ge,useCallback:function(m,y){return ee().memoizedState=[m,y===void 0?null:y],m},useContext:cr,useEffect:l0,useImperativeHandle:function(m,y,w){w=w!=null?w.concat([m]):null,Op(4194308,4,u0.bind(null,y,m),w)},useLayoutEffect:function(m,y){return Op(4194308,4,m,y)},useInsertionEffect:function(m,y){Op(4,2,m,y)},useMemo:function(m,y){var w=ee();y=y===void 0?null:y;var N=m();if($c){W(!0);try{m()}finally{W(!1)}}return w.memoizedState=[N,y],N},useReducer:function(m,y,w){var N=ee();if(w!==void 0){var k=w(y);if($c){W(!0);try{w(y)}finally{W(!1)}}}else k=y;return N.memoizedState=N.baseState=k,m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:m,lastRenderedState:k},N.queue=m,m=m.dispatch=h0.bind(null,wn,m),[N.memoizedState,m]},useRef:function(m){var y=ee();return m={current:m},y.memoizedState=m},useState:function(m){m=Fn(m);var y=m.queue,w=uv.bind(null,wn,y);return y.dispatch=w,[m.memoizedState,w]},useDebugValue:dc,useDeferredValue:function(m,y){var w=ee();return Lp(w,m,y)},useTransition:function(){var m=Fn(!1);return m=kf.bind(null,wn,m.queue,!0,!1),ee().memoizedState=m,[!1,m]},useSyncExternalStore:function(m,y,w){var N=wn,k=ee();if(qn){if(w===void 0)throw Error(i(407));w=w()}else{if(w=y(),ds===null)throw Error(i(349));(zn&60)!==0||Zt(N,y,w)}k.memoizedState=w;var U={value:w,getSnapshot:y};return k.queue=U,l0(Dn.bind(null,N,U,m),[m]),N.flags|=2048,Vr(9,Xt.bind(null,N,U,w,y),{destroy:void 0},null),w},useId:function(){var m=ee(),y=ds.identifierPrefix;if(qn){var w=el,N=Qo;w=(N&~(1<<32-Yr(N)-1)).toString(32)+w,y=":"+y+"R"+w,w=Y0++,0<w&&(y+="H"+w.toString(32)),y+=":"}else w=nl++,y=":"+y+"r"+w.toString(32)+":";return m.memoizedState=y},useCacheRefresh:function(){return ee().memoizedState=lv.bind(null,wn)}};zc.useMemoCache=Ee,zc.useHostTransitionStatus=Fp,zc.useFormState=ys,zc.useActionState=ys,zc.useOptimistic=function(m){var y=ee();y.memoizedState=y.baseState=m;var w={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return y.queue=w,y=Ff.bind(null,wn,!0,w),w.dispatch=y,[m,y]};var Jr={readContext:cr,use:Ge,useCallback:bh,useContext:cr,useEffect:rv,useImperativeHandle:c0,useInsertionEffect:BS,useLayoutEffect:kp,useMemo:av,useReducer:bt,useRef:Ml,useState:function(){return bt(ot)},useDebugValue:dc,useDeferredValue:function(m,y){var w=Se();return ov(w,tn.memoizedState,m,y)},useTransition:function(){var m=bt(ot)[0],y=Se().memoizedState;return[typeof m=="boolean"?m:$e(m),y]},useSyncExternalStore:an,useId:Lf};Jr.useCacheRefresh=xu,Jr.useMemoCache=Ee,Jr.useHostTransitionStatus=Fp,Jr.useFormState=lr,Jr.useActionState=lr,Jr.useOptimistic=function(m,y){var w=Se();return $n(w,tn,m,y)};var Ga={readContext:cr,use:Ge,useCallback:bh,useContext:cr,useEffect:rv,useImperativeHandle:c0,useInsertionEffect:BS,useLayoutEffect:kp,useMemo:av,useReducer:Lt,useRef:Ml,useState:function(){return Lt(ot)},useDebugValue:dc,useDeferredValue:function(m,y){var w=Se();return tn===null?Lp(w,m,y):ov(w,tn.memoizedState,m,y)},useTransition:function(){var m=Lt(ot)[0],y=Se().memoizedState;return[typeof m=="boolean"?m:$e(m),y]},useSyncExternalStore:an,useId:Lf};Ga.useCacheRefresh=xu,Ga.useMemoCache=Ee,Ga.useHostTransitionStatus=Fp,Ga.useFormState=Hi,Ga.useActionState=Hi,Ga.useOptimistic=function(m,y){var w=Se();return tn!==null?$n(w,tn,m,y):(w.baseState=m,[m,w.queue.dispatch])};var Ul={isMounted:function(m){return(m=m._reactInternals)?f(m)===m:!1},enqueueSetState:function(m,y,w){m=m._reactInternals;var N=ai(),k=Ft(N);k.payload=y,w!=null&&(k.callback=w),y=Pt(m,k,N),y!==null&&(Wi(y,m,N),vt(y,m,N))},enqueueReplaceState:function(m,y,w){m=m._reactInternals;var N=ai(),k=Ft(N);k.tag=1,k.payload=y,w!=null&&(k.callback=w),y=Pt(m,k,N),y!==null&&(Wi(y,m,N),vt(y,m,N))},enqueueForceUpdate:function(m,y){m=m._reactInternals;var w=ai(),N=Ft(w);N.tag=2,y!=null&&(N.callback=y),y=Pt(m,N,w),y!==null&&(Wi(y,m,w),vt(y,m,w))}},Z0=typeof reportError=="function"?reportError:function(m){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var y=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof m=="object"&&m!==null&&typeof m.message=="string"?String(m.message):String(m),error:m});if(!window.dispatchEvent(y))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",m);return}console.error(m)},Q0=Error(i(461)),Ts=!1,ey={dehydrated:null,treeContext:null,retryLane:0},Uu=b(null),sl=null,Ha=null,md=typeof AbortController<"u"?AbortController:function(){var m=[],y=this.signal={aborted:!1,addEventListener:function(w,N){m.push(N)}};this.abort=function(){y.aborted=!0,m.forEach(function(w){return w()})}},HA=La.unstable_scheduleCallback,VA=La.unstable_NormalPriority,Rs={$$typeof:Yo,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0},i1=cn.S;cn.S=function(m,y){typeof y=="object"&&y!==null&&typeof y.then=="function"&&at(m,y),i1!==null&&i1(m,y)};var $l=b(null),zl=!1,Zs=!1,r1=!1,fs=typeof WeakSet=="function"?WeakSet:Set,pn=null,On=!1,en=null,Sn=!1,Xs=null,Va=8192,gd={getCacheForType:function(m){var y=cr(Rs),w=y.data.get(m);return w===void 0&&(w=m(),y.data.set(m,w)),w}},yd=0,yo=1,ks=2,il=3,Gl=4;if(typeof Symbol=="function"&&Symbol.for){var Uh=Symbol.for;yd=Uh("selector.component"),yo=Uh("selector.has_pseudo_class"),ks=Uh("selector.role"),il=Uh("selector.test_id"),Gl=Uh("selector.text")}var xo=typeof WeakMap=="function"?WeakMap:Map,Zn=0,ds=null,nn=null,zn=0,xs=0,Mr=null,vo=!1,Wa=!1,Fi=!1,Nr=0,ws=0,Xa=0,$u=0,_m=0,qa=0,Hl=0,$h=null,Qs=null,ty=!1,Zr=0,xd=1/0,Sm=null,Gc=null,rl=!1,Vl=null,zh=0,Hc=0,ny=null,vd=0,sy=null;return yn.attemptContinuousHydration=function(m){if(m.tag===13){var y=Fe(m,67108864);y!==null&&Wi(y,m,67108864),im(m,67108864)}},yn.attemptHydrationAtCurrentPriority=function(m){if(m.tag===13){var y=ai(),w=Fe(m,y);w!==null&&Wi(w,m,y),im(m,y)}},yn.attemptSynchronousHydration=function(m){switch(m.tag){case 3:if(m=m.stateNode,m.current.memoizedState.isDehydrated){var y=C(m.pendingLanes);if(y!==0){for(m.pendingLanes|=2,m.entangledLanes|=2;y;){var w=1<<31-Yr(y);m.entanglements[1]|=w,y&=~w}ke(m),(Zn&6)===0&&(xd=fo()+500,ie(0))}}break;case 13:y=Fe(m,2),y!==null&&Wi(y,m,2),em(),im(m,2)}},yn.batchedUpdates=function(m,y){return m(y)},yn.createComponentSelector=function(m){return{$$typeof:yd,value:m}},yn.createContainer=function(m,y,w,N,k,U,te,de,Ne,Qe){return tA(m,y,!1,null,w,N,U,te,de,Ne,Qe,null)},yn.createHasPseudoClassSelector=function(m){return{$$typeof:yo,value:m}},yn.createHydrationContainer=function(m,y,w,N,k,U,te,de,Ne,Qe,yt,Rt,Bt){return m=tA(w,N,!0,m,k,U,de,Ne,Qe,yt,Rt,Bt),m.context=Si(null),w=m.current,N=ai(),k=Ft(N),k.callback=y??null,Pt(w,k,N),m.current.lanes=N,F(m,N),ke(m),m},yn.createPortal=function(m,y,w){var N=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:uo,key:N==null?null:""+N,children:m,containerInfo:y,implementation:w}},yn.createRoleSelector=function(m){return{$$typeof:ks,value:m}},yn.createTestNameSelector=function(m){return{$$typeof:il,value:m}},yn.createTextSelector=function(m){return{$$typeof:Gl,value:m}},yn.defaultOnCaughtError=function(m){console.error(m)},yn.defaultOnRecoverableError=function(m){Z0(m)},yn.defaultOnUncaughtError=function(m){Z0(m)},yn.deferredUpdates=function(m){var y=cn.T,w=Ou();try{return Er(32),cn.T=null,m()}finally{Er(w),cn.T=y}},yn.discreteUpdates=function(m,y,w,N,k){var U=cn.T,te=Ou();try{return Er(2),cn.T=null,m(y,w,N,k)}finally{Er(te),cn.T=U,Zn===0&&(xd=fo()+500)}},yn.findAllNodes=Zp,yn.findBoundingRects=function(m,y){if(!Ic)throw Error(i(363));y=Zp(m,y),m=[];for(var w=0;w<y.length;w++)m.push(Vv(y[w]));for(y=m.length-1;0<y;y--){w=m[y];for(var N=w.x,k=N+w.width,U=w.y,te=U+w.height,de=y-1;0<=de;de--)if(y!==de){var Ne=m[de],Qe=Ne.x,yt=Qe+Ne.width,Rt=Ne.y,Bt=Rt+Ne.height;if(N>=Qe&&U>=Rt&&k<=yt&&te<=Bt){m.splice(y,1);break}else if(N!==Qe||w.width!==Ne.width||Bt<U||Rt>te){if(!(U!==Rt||w.height!==Ne.height||yt<N||Qe>k)){Qe>N&&(Ne.width+=Qe-N,Ne.x=N),yt<k&&(Ne.width=k-Qe),m.splice(y,1);break}}else{Rt>U&&(Ne.height+=Rt-U,Ne.y=U),Bt<te&&(Ne.height=te-Rt),m.splice(y,1);break}}}return m},yn.findHostInstance=N0,yn.findHostInstanceWithNoPortals=function(m){return m=g(m),m=m!==null?S(m):null,m===null?null:sd(m.stateNode)},yn.findHostInstanceWithWarning=function(m){return N0(m)},yn.flushPassiveEffects=Ko,yn.flushSyncFromReconciler=function(m){var y=Zn;Zn|=1;var w=cn.T,N=Ou();try{if(Er(2),cn.T=null,m)return m()}finally{Er(N),cn.T=w,Zn=y,(Zn&6)===0&&ie(0)}},yn.flushSyncWork=em,yn.focusWithin=function(m,y){if(!Ic)throw Error(i(363));for(m=qf(m),y=ha(m,y),y=Array.from(y),m=0;m<y.length;){var w=y[m++],N=w.tag;if(!rd(w)){if((N===5||N===26||N===27)&&cA(w.stateNode))return!0;for(w=w.child;w!==null;)y.push(w),w=w.sibling}}return!1},yn.getFindAllNodesFailureDescription=function(m,y){if(!Ic)throw Error(i(363));var w=0,N=[];m=[qf(m),0];for(var k=0;k<m.length;){var U=m[k++],te=U.tag,de=m[k++],Ne=y[de];if((te!==5&&te!==26&&te!==27||!rd(U))&&(Sc(U,Ne)&&(N.push(Ev(Ne)),de++,de>w&&(w=de)),de<y.length))for(U=U.child;U!==null;)m.push(U,de),U=U.sibling}if(w<y.length){for(m=[];w<y.length;w++)m.push(Ev(y[w]));return`findAllNodes was able to match part of the selector:
  `+(N.join(" > ")+`

No matching component was found for:
  `)+m.join(" > ")}return null},yn.getPublicRootInstance=function(m){if(m=m.current,!m.child)return null;switch(m.child.tag){case 27:case 5:return sd(m.child.stateNode);default:return m.child.stateNode}},yn.injectIntoDevTools=function(){var m={bundleType:0,version:Pv,rendererPackageName:um,currentDispatcherRef:cn,findFiberByHostInstance:rA,reconcilerVersion:"19.0.0"};if(nd!==null&&(m.rendererConfig=nd),typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")m=!1;else{var y=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(y.isDisabled||!y.supportsFiber)m=!0;else{try{ui=y.inject(m),da=y}catch{}m=!!y.checkDCE}}return m},yn.isAlreadyRendering=function(){return!1},yn.observeVisibleRects=function(m,y,w,N){if(!Ic)throw Error(i(363));m=Zp(m,y);var k=hA(m,w,N).disconnect;return{disconnect:function(){k()}}},yn.shouldError=function(){return null},yn.shouldSuspend=function(){return!1},yn.startHostTransition=function(m,y,w,N){if(m.tag!==5)throw Error(i(476));var k=Nl(m).queue;kf(m,k,y,Rc,w===null?n:function(){var U=Nl(m).next.queue;return pc(m,U,{},ai()),w(N)})},yn.updateContainer=function(m,y,w,N){var k=y.current,U=ai();return Jf(k,U,m,y,w,N),U},yn.updateContainerSync=function(m,y,w,N){return y.tag===0&&Ko(),Jf(y.current,2,m,y,w,N),2},yn},s.exports.default=s.exports,Object.defineProperty(s.exports,"__esModule",{value:!0})}(BR)),BR.exports}var DP;function lie(){return DP||(DP=1,OR.exports=oie()),OR.exports}var uie=lie();const cie=yC(uie);var FR={exports:{}},PR={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var OP;function hie(){return OP||(OP=1,function(s){function e($,W){var V=$.length;$.push(W);e:for(;0<V;){var se=V-1>>>1,G=$[se];if(0<i(G,W))$[se]=W,$[V]=G,V=se;else break e}}function t($){return $.length===0?null:$[0]}function n($){if($.length===0)return null;var W=$[0],V=$.pop();if(V!==W){$[0]=V;e:for(var se=0,G=$.length,ne=G>>>1;se<ne;){var oe=2*(se+1)-1,ue=$[oe],re=oe+1,ce=$[re];if(0>i(ue,V))re<G&&0>i(ce,ue)?($[se]=ce,$[re]=V,se=re):($[se]=ue,$[oe]=V,se=oe);else if(re<G&&0>i(ce,V))$[se]=ce,$[re]=V,se=re;else break e}}return W}function i($,W){var V=$.sortIndex-W.sortIndex;return V!==0?V:$.id-W.id}if(s.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;s.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();s.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,f=null,d=3,g=!1,x=!1,S=!1,b=typeof setTimeout=="function"?setTimeout:null,_=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function E($){for(var W=t(u);W!==null;){if(W.callback===null)n(u);else if(W.startTime<=$)n(u),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(u)}}function C($){if(S=!1,E($),!x)if(t(l)!==null)x=!0,J();else{var W=t(u);W!==null&&Y(C,W.startTime-$)}}var R=!1,I=-1,L=5,P=-1;function D(){return!(s.unstable_now()-P<L)}function O(){if(R){var $=s.unstable_now();P=$;var W=!0;try{e:{x=!1,S&&(S=!1,_(I),I=-1),g=!0;var V=d;try{t:{for(E($),f=t(l);f!==null&&!(f.expirationTime>$&&D());){var se=f.callback;if(typeof se=="function"){f.callback=null,d=f.priorityLevel;var G=se(f.expirationTime<=$);if($=s.unstable_now(),typeof G=="function"){f.callback=G,E($),W=!0;break t}f===t(l)&&n(l),E($)}else n(l);f=t(l)}if(f!==null)W=!0;else{var ne=t(u);ne!==null&&Y(C,ne.startTime-$),W=!1}}break e}finally{f=null,d=V,g=!1}W=void 0}}finally{W?F():R=!1}}}var F;if(typeof T=="function")F=function(){T(O)};else if(typeof MessageChannel<"u"){var X=new MessageChannel,q=X.port2;X.port1.onmessage=O,F=function(){q.postMessage(null)}}else F=function(){b(O,0)};function J(){R||(R=!0,F())}function Y($,W){I=b(function(){$(s.unstable_now())},W)}s.unstable_IdlePriority=5,s.unstable_ImmediatePriority=1,s.unstable_LowPriority=4,s.unstable_NormalPriority=3,s.unstable_Profiling=null,s.unstable_UserBlockingPriority=2,s.unstable_cancelCallback=function($){$.callback=null},s.unstable_continueExecution=function(){x||g||(x=!0,J())},s.unstable_forceFrameRate=function($){0>$||125<$?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):L=0<$?Math.floor(1e3/$):5},s.unstable_getCurrentPriorityLevel=function(){return d},s.unstable_getFirstCallbackNode=function(){return t(l)},s.unstable_next=function($){switch(d){case 1:case 2:case 3:var W=3;break;default:W=d}var V=d;d=W;try{return $()}finally{d=V}},s.unstable_pauseExecution=function(){},s.unstable_requestPaint=function(){},s.unstable_runWithPriority=function($,W){switch($){case 1:case 2:case 3:case 4:case 5:break;default:$=3}var V=d;d=$;try{return W()}finally{d=V}},s.unstable_scheduleCallback=function($,W,V){var se=s.unstable_now();switch(typeof V=="object"&&V!==null?(V=V.delay,V=typeof V=="number"&&0<V?se+V:se):V=se,$){case 1:var G=-1;break;case 2:G=250;break;case 5:G=1073741823;break;case 4:G=1e4;break;default:G=5e3}return G=V+G,$={id:c++,callback:W,priorityLevel:$,startTime:V,expirationTime:G,sortIndex:-1},V>se?($.sortIndex=V,e(u,$),t(l)===null&&$===t(u)&&(S?(_(I),I=-1):S=!0,Y(C,V-se))):($.sortIndex=G,e(l,$),x||g||(x=!0,J())),$},s.unstable_shouldYield=D,s.unstable_wrapCallback=function($){var W=d;return function(){var V=d;d=W;try{return $.apply(this,arguments)}finally{d=V}}}}(PR)),PR}var BP;function fie(){return BP||(BP=1,FR.exports=hie()),FR.exports}var kP=fie();const die=s=>typeof s=="object"&&typeof s.then=="function",ag=[];function B6(s,e,t=(n,i)=>n===i){if(s===e)return!0;if(!s||!e)return!1;const n=s.length;if(e.length!==n)return!1;for(let i=0;i<n;i++)if(!t(s[i],e[i]))return!1;return!0}function k6(s,e=null,t=!1,n={}){e===null&&(e=[s]);for(const r of ag)if(B6(e,r.keys,r.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(r,"error"))throw r.error;if(Object.prototype.hasOwnProperty.call(r,"response"))return n.lifespan&&n.lifespan>0&&(r.timeout&&clearTimeout(r.timeout),r.timeout=setTimeout(r.remove,n.lifespan)),r.response;if(!t)throw r.promise}const i={keys:e,equal:n.equal,remove:()=>{const r=ag.indexOf(i);r!==-1&&ag.splice(r,1)},promise:(die(s)?s:s(...e)).then(r=>{i.response=r,n.lifespan&&n.lifespan>0&&(i.timeout=setTimeout(i.remove,n.lifespan))}).catch(r=>i.error=r)};if(ag.push(i),!t)throw i.promise}const pie=(s,e,t)=>k6(s,e,!1,t),mie=(s,e,t)=>void k6(s,e,!0,t),gie=s=>{if(s===void 0||s.length===0)ag.splice(0,ag.length);else{const e=ag.find(t=>B6(s,t.keys,t.equal));e&&e.remove()}};function mO(s,e,t){if(!s)return;if(t(s)===!0)return s;let n=e?s.return:s.child;for(;n;){const i=mO(n,e,t);if(i)return i;n=e?null:n.sibling}}function L6(s){try{return Object.defineProperties(s,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return s}}const gO=L6(Me.createContext(null));class F6 extends Me.Component{render(){return Me.createElement(gO.Provider,{value:this._reactInternals},this.props.children)}}function P6(){const s=Me.useContext(gO);if(s===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=Me.useId();return Me.useMemo(()=>{for(const t of[s,s==null?void 0:s.alternate]){if(!t)continue;const n=mO(t,!1,i=>{let r=i.memoizedState;for(;r;){if(r.memoizedState===e)return!0;r=r.next}});if(n)return n}},[s,e])}const yie=Symbol.for("react.context"),xie=s=>s!==null&&typeof s=="object"&&"$$typeof"in s&&s.$$typeof===yie;function vie(){const s=P6(),[e]=Me.useState(()=>new Map);e.clear();let t=s;for(;t;){const n=t.type;xie(n)&&n!==gO&&!e.has(n)&&e.set(n,Me.use(L6(n))),t=t.return}return e}function bie(){const s=vie();return Me.useMemo(()=>Array.from(s.keys()).reduce((e,t)=>n=>Me.createElement(e,null,Me.createElement(t.Provider,{...n,value:s.get(t)})),e=>Me.createElement(F6,{...e})),[s])}function U6(s){let e=s.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const $6=s=>s&&s.isOrthographicCamera,_ie=s=>s&&s.hasOwnProperty("current"),Sie=s=>s!=null&&(typeof s=="string"||typeof s=="number"||s.isColor),u_=((s,e)=>typeof window<"u"&&(((s=window.document)==null?void 0:s.createElement)||((e=window.navigator)==null?void 0:e.product)==="ReactNative"))()?Me.useLayoutEffect:Me.useEffect;function z6(s){const e=Me.useRef(s);return u_(()=>void(e.current=s),[s]),e}function Aie(){const s=P6(),e=bie();return Me.useMemo(()=>({children:t})=>{const i=!!mO(s,!0,r=>r.type===Me.StrictMode)?Me.StrictMode:Me.Fragment;return ft.jsx(i,{children:ft.jsx(e,{children:t})})},[s,e])}function Tie({set:s}){return u_(()=>(s(new Promise(()=>null)),()=>s(!1)),[s]),null}const wie=(s=>(s=class extends Me.Component{constructor(...t){super(...t),this.state={error:!1}}componentDidCatch(t){this.props.set(t)}render(){return this.state.error?null:this.props.children}},s.getDerivedStateFromError=()=>({error:!0}),s))();function G6(s){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(s)?Math.min(Math.max(s[0],t),s[1]):s}function Ey(s){var e;return(e=s.__r3f)==null?void 0:e.root.getState()}const ei={obj:s=>s===Object(s)&&!ei.arr(s)&&typeof s!="function",fun:s=>typeof s=="function",str:s=>typeof s=="string",num:s=>typeof s=="number",boo:s=>typeof s=="boolean",und:s=>s===void 0,nul:s=>s===null,arr:s=>Array.isArray(s),equ(s,e,{arrays:t="shallow",objects:n="reference",strict:i=!0}={}){if(typeof s!=typeof e||!!s!=!!e)return!1;if(ei.str(s)||ei.num(s)||ei.boo(s))return s===e;const r=ei.obj(s);if(r&&n==="reference")return s===e;const a=ei.arr(s);if(a&&t==="reference")return s===e;if((a||r)&&s===e)return!0;let o;for(o in s)if(!(o in e))return!1;if(r&&t==="shallow"&&n==="shallow"){for(o in i?e:s)if(!ei.equ(s[o],e[o],{strict:i,objects:"reference"}))return!1}else for(o in i?e:s)if(s[o]!==e[o])return!1;if(ei.und(o)){if(a&&s.length===0&&e.length===0||r&&Object.keys(s).length===0&&Object.keys(e).length===0)return!0;if(s!==e)return!1}return!0}};function Cie(s){const e={nodes:{},materials:{},meshes:{}};return s&&s.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material),t.isMesh&&!e.meshes[t.name]&&(e.meshes[t.name]=t)}),e}function Eie(s){s.type!=="Scene"&&(s.dispose==null||s.dispose());for(const e in s){const t=s[e];(t==null?void 0:t.type)!=="Scene"&&(t==null||t.dispose==null||t.dispose())}}const H6=["children","key","ref"];function Mie(s){const e={};for(const t in s)H6.includes(t)||(e[t]=s[t]);return e}function M2(s,e,t,n){const i=s;let r=i==null?void 0:i.__r3f;return r||(r={root:e,type:t,parent:null,children:[],props:Mie(n),object:i,eventCount:0,handlers:{},isHidden:!1},i&&(i.__r3f=r)),r}function Tb(s,e){let t=s[e];if(!e.includes("-"))return{root:s,key:e,target:t};t=s;for(const i of e.split("-")){var n;e=i,s=t,t=(n=t)==null?void 0:n[e]}return{root:s,key:e,target:t}}const LP=/-\d+$/;function N2(s,e){if(ei.str(e.props.attach)){if(LP.test(e.props.attach)){const i=e.props.attach.replace(LP,""),{root:r,key:a}=Tb(s.object,i);Array.isArray(r[a])||(r[a]=[])}const{root:t,key:n}=Tb(s.object,e.props.attach);e.previousAttach=t[n],t[n]=e.object}else ei.fun(e.props.attach)&&(e.previousAttach=e.props.attach(s.object,e.object))}function R2(s,e){if(ei.str(e.props.attach)){const{root:t,key:n}=Tb(s.object,e.props.attach),i=e.previousAttach;i===void 0?delete t[n]:t[n]=i}else e.previousAttach==null||e.previousAttach(s.object,e.object);delete e.previousAttach}const qI=[...H6,"args","dispose","attach","object","onUpdate","dispose"],FP=new Map;function Nie(s){let e=FP.get(s.constructor);try{e||(e=new s.constructor,FP.set(s.constructor,e))}catch{}return e}function Rie(s,e){const t={};for(const n in e)if(!qI.includes(n)&&!ei.equ(e[n],s.props[n])){t[n]=e[n];for(const i in e)i.startsWith(`${n}-`)&&(t[i]=e[i])}for(const n in s.props){if(qI.includes(n)||e.hasOwnProperty(n))continue;const{root:i,key:r}=Tb(s.object,n);if(i.constructor&&i.constructor.length===0){const a=Nie(i);ei.und(a)||(t[r]=a[r])}else t[r]=0}return t}const Iie=["map","emissiveMap","sheenColorMap","specularColorMap","envMap"],Die=/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;function Fd(s,e){var t;const n=s.__r3f,i=n&&U6(n).getState(),r=n==null?void 0:n.eventCount;for(const o in e){let l=e[o];if(qI.includes(o))continue;if(n&&Die.test(o)){typeof l=="function"?n.handlers[o]=l:delete n.handlers[o],n.eventCount=Object.keys(n.handlers).length;continue}if(l===void 0)continue;let{root:u,key:c,target:f}=Tb(s,o);if(f instanceof ux&&l instanceof ux)f.mask=l.mask;else if(f instanceof Nt&&Sie(l))f.set(l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&typeof f.copy=="function"&&l!=null&&l.constructor&&f.constructor===l.constructor)f.copy(l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&Array.isArray(l))typeof f.fromArray=="function"?f.fromArray(l):f.set(...l);else if(f!==null&&typeof f=="object"&&typeof f.set=="function"&&typeof l=="number")typeof f.setScalar=="function"?f.setScalar(l):f.set(l);else{var a;u[c]=l,i&&!i.linear&&Iie.includes(c)&&(a=u[c])!=null&&a.isTexture&&u[c].format===wa&&u[c].type===nc&&(u[c].colorSpace=va)}}if(n!=null&&n.parent&&i!=null&&i.internal&&(t=n.object)!=null&&t.isObject3D&&r!==n.eventCount){const o=n.object,l=i.internal.interaction.indexOf(o);l>-1&&i.internal.interaction.splice(l,1),n.eventCount&&o.raycast!==null&&i.internal.interaction.push(o)}return n&&n.props.attach===void 0&&(n.object.isBufferGeometry?n.props.attach="geometry":n.object.isMaterial&&(n.props.attach="material")),n&&$x(n),s}function $x(s){var e;if(!s.parent)return;s.props.onUpdate==null||s.props.onUpdate(s.object);const t=(e=s.root)==null||e.getState==null?void 0:e.getState();t&&t.internal.frames===0&&t.invalidate()}function Oie(s,e){s.manual||($6(s)?(s.left=e.width/-2,s.right=e.width/2,s.top=e.height/2,s.bottom=e.height/-2):s.aspect=e.width/e.height,s.updateProjectionMatrix())}const Ja=s=>s==null?void 0:s.isObject3D;function QT(s){return(s.eventObject||s.object).uuid+"/"+s.index+s.instanceId}function V6(s,e,t,n){const i=t.get(e);i&&(t.delete(e),t.size===0&&(s.delete(n),i.target.releasePointerCapture(n)))}function Bie(s,e){const{internal:t}=s.getState();t.interaction=t.interaction.filter(n=>n!==e),t.initialHits=t.initialHits.filter(n=>n!==e),t.hovered.forEach((n,i)=>{(n.eventObject===e||n.object===e)&&t.hovered.delete(i)}),t.capturedMap.forEach((n,i)=>{V6(t.capturedMap,e,n,i)})}function kie(s){function e(l){const{internal:u}=s.getState(),c=l.offsetX-u.initialClick[0],f=l.offsetY-u.initialClick[1];return Math.round(Math.sqrt(c*c+f*f))}function t(l){return l.filter(u=>["Move","Over","Enter","Out","Leave"].some(c=>{var f;return(f=u.__r3f)==null?void 0:f.handlers["onPointer"+c]}))}function n(l,u){const c=s.getState(),f=new Set,d=[],g=u?u(c.internal.interaction):c.internal.interaction;for(let _=0;_<g.length;_++){const T=Ey(g[_]);T&&(T.raycaster.camera=void 0)}c.previousRoot||c.events.compute==null||c.events.compute(l,c);function x(_){const T=Ey(_);if(!T||!T.events.enabled||T.raycaster.camera===null)return[];if(T.raycaster.camera===void 0){var E;T.events.compute==null||T.events.compute(l,T,(E=T.previousRoot)==null?void 0:E.getState()),T.raycaster.camera===void 0&&(T.raycaster.camera=null)}return T.raycaster.camera?T.raycaster.intersectObject(_,!0):[]}let S=g.flatMap(x).sort((_,T)=>{const E=Ey(_.object),C=Ey(T.object);return!E||!C?_.distance-T.distance:C.events.priority-E.events.priority||_.distance-T.distance}).filter(_=>{const T=QT(_);return f.has(T)?!1:(f.add(T),!0)});c.events.filter&&(S=c.events.filter(S,c));for(const _ of S){let T=_.object;for(;T;){var b;(b=T.__r3f)!=null&&b.eventCount&&d.push({..._,eventObject:T}),T=T.parent}}if("pointerId"in l&&c.internal.capturedMap.has(l.pointerId))for(let _ of c.internal.capturedMap.get(l.pointerId).values())f.has(QT(_.intersection))||d.push(_.intersection);return d}function i(l,u,c,f){if(l.length){const d={stopped:!1};for(const g of l){let x=Ey(g.object);if(x||g.object.traverseAncestors(S=>{const b=Ey(S);if(b)return x=b,!1}),x){const{raycaster:S,pointer:b,camera:_,internal:T}=x,E=new ae(b.x,b.y,0).unproject(_),C=D=>{var O,F;return(O=(F=T.capturedMap.get(D))==null?void 0:F.has(g.eventObject))!=null?O:!1},R=D=>{const O={intersection:g,target:u.target};T.capturedMap.has(D)?T.capturedMap.get(D).set(g.eventObject,O):T.capturedMap.set(D,new Map([[g.eventObject,O]])),u.target.setPointerCapture(D)},I=D=>{const O=T.capturedMap.get(D);O&&V6(T.capturedMap,g.eventObject,O,D)};let L={};for(let D in u){let O=u[D];typeof O!="function"&&(L[D]=O)}let P={...g,...L,pointer:b,intersections:l,stopped:d.stopped,delta:c,unprojectedPoint:E,ray:S.ray,camera:_,stopPropagation(){const D="pointerId"in u&&T.capturedMap.get(u.pointerId);if((!D||D.has(g.eventObject))&&(P.stopped=d.stopped=!0,T.hovered.size&&Array.from(T.hovered.values()).find(O=>O.eventObject===g.eventObject))){const O=l.slice(0,l.indexOf(g));r([...O,g])}},target:{hasPointerCapture:C,setPointerCapture:R,releasePointerCapture:I},currentTarget:{hasPointerCapture:C,setPointerCapture:R,releasePointerCapture:I},nativeEvent:u};if(f(P),d.stopped===!0)break}}}return l}function r(l){const{internal:u}=s.getState();for(const c of u.hovered.values())if(!l.length||!l.find(f=>f.object===c.object&&f.index===c.index&&f.instanceId===c.instanceId)){const d=c.eventObject.__r3f;if(u.hovered.delete(QT(c)),d!=null&&d.eventCount){const g=d.handlers,x={...c,intersections:l};g.onPointerOut==null||g.onPointerOut(x),g.onPointerLeave==null||g.onPointerLeave(x)}}}function a(l,u){for(let c=0;c<u.length;c++){const f=u[c].__r3f;f==null||f.handlers.onPointerMissed==null||f.handlers.onPointerMissed(l)}}function o(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>r([]);case"onLostPointerCapture":return u=>{const{internal:c}=s.getState();"pointerId"in u&&c.capturedMap.has(u.pointerId)&&requestAnimationFrame(()=>{c.capturedMap.has(u.pointerId)&&(c.capturedMap.delete(u.pointerId),r([]))})}}return function(c){const{onPointerMissed:f,internal:d}=s.getState();d.lastEvent.current=c;const g=l==="onPointerMove",x=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",b=n(c,g?t:void 0),_=x?e(c):0;l==="onPointerDown"&&(d.initialClick=[c.offsetX,c.offsetY],d.initialHits=b.map(E=>E.eventObject)),x&&!b.length&&_<=2&&(a(c,d.interaction),f&&f(c)),g&&r(b);function T(E){const C=E.eventObject,R=C.__r3f;if(!(R!=null&&R.eventCount))return;const I=R.handlers;if(g){if(I.onPointerOver||I.onPointerEnter||I.onPointerOut||I.onPointerLeave){const L=QT(E),P=d.hovered.get(L);P?P.stopped&&E.stopPropagation():(d.hovered.set(L,E),I.onPointerOver==null||I.onPointerOver(E),I.onPointerEnter==null||I.onPointerEnter(E))}I.onPointerMove==null||I.onPointerMove(E)}else{const L=I[l];L?(!x||d.initialHits.includes(C))&&(a(c,d.interaction.filter(P=>!d.initialHits.includes(P))),L(E)):x&&d.initialHits.includes(C)&&a(c,d.interaction.filter(P=>!d.initialHits.includes(P)))}}i(b,c,_,T)}}return{handlePointer:o}}const PP=s=>!!(s!=null&&s.render),W6=Me.createContext(null),Lie=(s,e)=>{const t=iie((o,l)=>{const u=new ae,c=new ae,f=new ae;function d(_=l().camera,T=c,E=l().size){const{width:C,height:R,top:I,left:L}=E,P=C/R;T.isVector3?f.copy(T):f.set(...T);const D=_.getWorldPosition(u).distanceTo(f);if($6(_))return{width:C/_.zoom,height:R/_.zoom,top:I,left:L,factor:1,distance:D,aspect:P};{const O=_.fov*Math.PI/180,F=2*Math.tan(O/2)*D,X=F*(C/R);return{width:X,height:F,top:I,left:L,factor:C/X,distance:D,aspect:P}}}let g;const x=_=>o(T=>({performance:{...T.performance,current:_}})),S=new tt;return{set:o,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},scene:null,xr:null,invalidate:(_=1)=>s(l(),_),advance:(_,T)=>e(_,T,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new uO,pointer:S,mouse:S,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const _=l();g&&clearTimeout(g),_.performance.current!==_.performance.min&&x(_.performance.min),g=setTimeout(()=>x(l().performance.max),_.performance.debounce)}},size:{width:0,height:0,top:0,left:0},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:d},setEvents:_=>o(T=>({...T,events:{...T.events,..._}})),setSize:(_,T,E=0,C=0)=>{const R=l().camera,I={width:_,height:T,top:E,left:C};o(L=>({size:I,viewport:{...L.viewport,...d(R,c,I)}}))},setDpr:_=>o(T=>{const E=G6(_);return{viewport:{...T.viewport,dpr:E,initialDpr:T.viewport.initialDpr||E}}}),setFrameloop:(_="always")=>{const T=l().clock;T.stop(),T.elapsedTime=0,_!=="never"&&(T.start(),T.elapsedTime=0),o(()=>({frameloop:_}))},previousRoot:void 0,internal:{interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,lastEvent:Me.createRef(),active:!1,frames:0,priority:0,subscribe:(_,T,E)=>{const C=l().internal;return C.priority=C.priority+(T>0?1:0),C.subscribers.push({ref:_,priority:T,store:E}),C.subscribers=C.subscribers.sort((R,I)=>R.priority-I.priority),()=>{const R=l().internal;R!=null&&R.subscribers&&(R.priority=R.priority-(T>0?1:0),R.subscribers=R.subscribers.filter(I=>I.ref!==_))}}}}}),n=t.getState();let i=n.size,r=n.viewport.dpr,a=n.camera;return t.subscribe(()=>{const{camera:o,size:l,viewport:u,gl:c,set:f}=t.getState();if(l.width!==i.width||l.height!==i.height||u.dpr!==r){i=l,r=u.dpr,Oie(o,l),u.dpr>0&&c.setPixelRatio(u.dpr);const d=typeof HTMLCanvasElement<"u"&&c.domElement instanceof HTMLCanvasElement;c.setSize(l.width,l.height,d)}o!==a&&(a=o,f(d=>({viewport:{...d.viewport,...d.viewport.getCurrentViewport(o)}})))}),t.subscribe(o=>s(o)),t};function X6(){const s=Me.useContext(W6);if(!s)throw new Error("R3F: Hooks can only be used within the Canvas component!");return s}function Od(s=t=>t,e){return X6()(s,e)}function Fie(s,e=0){const t=X6(),n=t.getState().internal.subscribe,i=z6(s);return u_(()=>n(i,e,t),[e,n,t]),null}const UP=new WeakMap,Pie=s=>{var e;return typeof s=="function"&&(s==null||(e=s.prototype)==null?void 0:e.constructor)===s};function q6(s,e){return function(t,...n){let i;return Pie(t)?(i=UP.get(t),i||(i=new t,UP.set(t,i))):i=t,s&&s(i),Promise.all(n.map(r=>new Promise((a,o)=>i.load(r,l=>{Ja(l==null?void 0:l.scene)&&Object.assign(l,Cie(l.scene)),a(l)},e,l=>o(new Error(`Could not load ${r}: ${l==null?void 0:l.message}`))))))}}function c_(s,e,t,n){const i=Array.isArray(e)?e:[e],r=pie(q6(t,n),[s,...i],{equal:ei.equ});return Array.isArray(e)?r:r[0]}c_.preload=function(s,e,t){const n=Array.isArray(e)?e:[e];return mie(q6(t),[s,...n])};c_.clear=function(s,e){const t=Array.isArray(e)?e:[e];return gie([s,...t])};function Uie(s){const e=cie(s);return e.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Me.version}),e}const j6=0,dx={},$ie=/^three(?=[A-Z])/,QC=s=>`${s[0].toUpperCase()}${s.slice(1)}`;let zie=0;const Gie=s=>typeof s=="function";function Hie(s){if(Gie(s)){const e=`${zie++}`;return dx[e]=s,e}else Object.assign(dx,s)}function K6(s,e){const t=QC(s),n=dx[t];if(s!=="primitive"&&!n)throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(s==="primitive"&&!e.object)throw new Error("R3F: Primitives without 'object' are invalid!");if(e.args!==void 0&&!Array.isArray(e.args))throw new Error("R3F: The args prop must be an array!")}function Vie(s,e,t){var n;return s=QC(s)in dx?s:s.replace($ie,""),K6(s,e),s==="primitive"&&(n=e.object)!=null&&n.__r3f&&delete e.object.__r3f,M2(e.object,t,s,e)}function Wie(s){if(!s.isHidden){var e;s.props.attach&&(e=s.parent)!=null&&e.object?R2(s.parent,s):Ja(s.object)&&(s.object.visible=!1),s.isHidden=!0,$x(s)}}function Y6(s){if(s.isHidden){var e;s.props.attach&&(e=s.parent)!=null&&e.object?N2(s.parent,s):Ja(s.object)&&s.props.visible!==!1&&(s.object.visible=!0),s.isHidden=!1,$x(s)}}function yO(s,e,t){const n=e.root.getState();if(!(!s.parent&&s.object!==n.scene)){if(!e.object){var i,r;const a=dx[QC(e.type)];e.object=(i=e.props.object)!=null?i:new a(...(r=e.props.args)!=null?r:[]),e.object.__r3f=e}if(Fd(e.object,e.props),e.props.attach)N2(s,e);else if(Ja(e.object)&&Ja(s.object)){const a=s.object.children.indexOf(t==null?void 0:t.object);if(t&&a!==-1){const o=s.object.children.indexOf(e.object);if(o!==-1){s.object.children.splice(o,1);const l=o<a?a-1:a;s.object.children.splice(l,0,e.object)}else e.object.parent=s.object,s.object.children.splice(a,0,e.object),e.object.dispatchEvent({type:"added"}),s.object.dispatchEvent({type:"childadded",child:e.object})}else s.object.add(e.object)}for(const a of e.children)yO(e,a);$x(e)}}function UR(s,e){e&&(e.parent=s,s.children.push(e),yO(s,e))}function $P(s,e,t){if(!e||!t)return;e.parent=s;const n=s.children.indexOf(t);n!==-1?s.children.splice(n,0,e):s.children.push(e),yO(s,e,t)}function J6(s){if(typeof s.dispose=="function"){const e=()=>{try{s.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT<"u"?e():kP.unstable_scheduleCallback(kP.unstable_IdlePriority,e)}}function jI(s,e,t){if(!e)return;e.parent=null;const n=s.children.indexOf(e);n!==-1&&s.children.splice(n,1),e.props.attach?R2(s,e):Ja(e.object)&&Ja(s.object)&&(s.object.remove(e.object),Bie(U6(e),e.object));const i=e.props.dispose!==null&&t!==!1;for(let r=e.children.length-1;r>=0;r--){const a=e.children[r];jI(e,a,i)}e.children.length=0,delete e.object.__r3f,i&&e.type!=="primitive"&&e.object.type!=="Scene"&&J6(e.object),t===void 0&&$x(e)}function Xie(s,e){for(const t of[s,s.alternate])if(t!==null)if(typeof t.ref=="function"){t.refCleanup==null||t.refCleanup();const n=t.ref(e);typeof n=="function"&&(t.refCleanup=n)}else t.ref&&(t.ref.current=e)}const Ew=[];function qie(){for(const[t]of Ew){const n=t.parent;if(n){t.props.attach?R2(n,t):Ja(t.object)&&Ja(n.object)&&n.object.remove(t.object);for(const i of t.children)i.props.attach?R2(t,i):Ja(i.object)&&Ja(t.object)&&t.object.remove(i.object)}t.isHidden&&Y6(t),t.object.__r3f&&delete t.object.__r3f,t.type!=="primitive"&&J6(t.object)}for(const[t,n,i]of Ew){t.props=n;const r=t.parent;if(r){var s,e;const a=dx[QC(t.type)];t.object=(s=t.props.object)!=null?s:new a(...(e=t.props.args)!=null?e:[]),t.object.__r3f=t,Xie(i,t.object),Fd(t.object,t.props),t.props.attach?N2(r,t):Ja(t.object)&&Ja(r.object)&&r.object.add(t.object);for(const o of t.children)o.props.attach?N2(t,o):Ja(o.object)&&Ja(t.object)&&t.object.add(o.object);$x(t)}}Ew.length=0}const $R=()=>{},zP={};let ew=j6;const jie=0,Kie=4,KI=Uie({isPrimaryRenderer:!1,warnsIfNotActing:!1,supportsMutation:!0,supportsPersistence:!1,supportsHydration:!1,createInstance:Vie,removeChild:jI,appendChild:UR,appendInitialChild:UR,insertBefore:$P,appendChildToContainer(s,e){const t=s.getState().scene.__r3f;!e||!t||UR(t,e)},removeChildFromContainer(s,e){const t=s.getState().scene.__r3f;!e||!t||jI(t,e)},insertInContainerBefore(s,e,t){const n=s.getState().scene.__r3f;!e||!t||!n||$P(n,e,t)},getRootHostContext:()=>zP,getChildHostContext:()=>zP,commitUpdate(s,e,t,n,i){var r,a,o;K6(e,n);let l=!1;if((s.type==="primitive"&&t.object!==n.object||((r=n.args)==null?void 0:r.length)!==((a=t.args)==null?void 0:a.length)||(o=n.args)!=null&&o.some((c,f)=>{var d;return c!==((d=t.args)==null?void 0:d[f])}))&&(l=!0),l)Ew.push([s,{...n},i]);else{const c=Rie(s,n);Object.keys(c).length&&(Object.assign(s.props,c),Fd(s.object,c))}(i.sibling===null||(i.flags&Kie)===jie)&&qie()},finalizeInitialChildren:()=>!1,commitMount(){},getPublicInstance:s=>s==null?void 0:s.object,prepareForCommit:()=>null,preparePortalMount:s=>M2(s.getState().scene,s,"",{}),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance:Wie,unhideInstance:Y6,createTextInstance:$R,hideTextInstance:$R,unhideTextInstance:$R,scheduleTimeout:typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout:typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout:-1,getInstanceFromNode:()=>null,beforeActiveInstanceBlur(){},afterActiveInstanceBlur(){},detachDeletedInstance(){},prepareScopeUpdate(){},getInstanceFromScope:()=>null,shouldAttemptEagerTransition:()=>!1,trackSchedulerEvent:()=>{},resolveEventType:()=>null,resolveEventTimeStamp:()=>-1.1,requestPostPaintCallback(){},maySuspendCommit:()=>!1,preloadInstance:()=>!0,startSuspendingCommit(){},suspendInstance(){},waitForCommitToBeReady:()=>null,NotPendingTransition:null,HostTransitionContext:Me.createContext(null),setCurrentUpdatePriority(s){ew=s},getCurrentUpdatePriority(){return ew},resolveUpdatePriority(){var s;if(ew!==j6)return ew;switch(typeof window<"u"&&((s=window.event)==null?void 0:s.type)){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Cw.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Cw.ContinuousEventPriority;default:return Cw.DefaultEventPriority}},resetFormInstance(){}}),Mg=new Map,My={objects:"shallow",strict:!1};function Yie(s,e){if(!e&&typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement&&s.parentElement){const{width:t,height:n,top:i,left:r}=s.parentElement.getBoundingClientRect();return{width:t,height:n,top:i,left:r}}else if(!e&&typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas)return{width:s.width,height:s.height,top:0,left:0};return{width:0,height:0,top:0,left:0,...e}}function Jie(s){const e=Mg.get(s),t=e==null?void 0:e.fiber,n=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,r=n||Lie(ZI,HP),a=t||KI.createContainer(r,Cw.ConcurrentRoot,null,!1,null,"",i,i,i,null);e||Mg.set(s,{fiber:a,store:r});let o,l,u=!1,c=null;return{async configure(f={}){let d;c=new Promise(ne=>d=ne);let{gl:g,size:x,scene:S,events:b,onCreated:_,shadows:T=!1,linear:E=!1,flat:C=!1,legacy:R=!1,orthographic:I=!1,frameloop:L="always",dpr:P=[1,2],performance:D,raycaster:O,camera:F,onPointerMissed:X}=f,q=r.getState(),J=q.gl;if(!q.gl){const ne={canvas:s,powerPreference:"high-performance",antialias:!0,alpha:!0},oe=typeof g=="function"?await g(ne):g;PP(oe)?J=oe:J=new O6({...ne,...g}),q.set({gl:J})}let Y=q.raycaster;Y||q.set({raycaster:Y=new w6});const{params:$,...W}=O||{};if(ei.equ(W,Y,My)||Fd(Y,{...W}),ei.equ($,Y.params,My)||Fd(Y,{params:{...Y.params,...$}}),!q.camera||q.camera===l&&!ei.equ(l,F,My)){l=F;const ne=F==null?void 0:F.isCamera,oe=ne?F:I?new ff(0,0,0,0,.1,1e3):new Ci(75,0,.1,1e3);ne||(oe.position.z=5,F&&(Fd(oe,F),oe.manual||("aspect"in F||"left"in F||"right"in F||"bottom"in F||"top"in F)&&(oe.manual=!0,oe.updateProjectionMatrix())),!q.camera&&!(F!=null&&F.rotation)&&oe.lookAt(0,0,0)),q.set({camera:oe}),Y.camera=oe}if(!q.scene){let ne;S!=null&&S.isScene?(ne=S,M2(ne,r,"",{})):(ne=new U3,M2(ne,r,"",{}),S&&Fd(ne,S)),q.set({scene:ne})}b&&!q.events.handlers&&q.set({events:b(r)});const V=Yie(s,x);if(ei.equ(V,q.size,My)||q.setSize(V.width,V.height,V.top,V.left),P&&q.viewport.dpr!==G6(P)&&q.setDpr(P),q.frameloop!==L&&q.setFrameloop(L),q.onPointerMissed||q.set({onPointerMissed:X}),D&&!ei.equ(D,q.performance,My)&&q.set(ne=>({performance:{...ne.performance,...D}})),!q.xr){var se;const ne=(re,ce)=>{const Te=r.getState();Te.frameloop!=="never"&&HP(re,!0,Te,ce)},oe=()=>{const re=r.getState();re.gl.xr.enabled=re.gl.xr.isPresenting,re.gl.xr.setAnimationLoop(re.gl.xr.isPresenting?ne:null),re.gl.xr.isPresenting||ZI(re)},ue={connect(){const re=r.getState().gl;re.xr.addEventListener("sessionstart",oe),re.xr.addEventListener("sessionend",oe)},disconnect(){const re=r.getState().gl;re.xr.removeEventListener("sessionstart",oe),re.xr.removeEventListener("sessionend",oe)}};typeof((se=J.xr)==null?void 0:se.addEventListener)=="function"&&ue.connect(),q.set({xr:ue})}if(J.shadowMap){const ne=J.shadowMap.enabled,oe=J.shadowMap.type;if(J.shadowMap.enabled=!!T,ei.boo(T))J.shadowMap.type=J1;else if(ei.str(T)){var G;const ue={basic:Uz,percentage:bC,soft:J1,variance:qu};J.shadowMap.type=(G=ue[T])!=null?G:J1}else ei.obj(T)&&Object.assign(J.shadowMap,T);(ne!==J.shadowMap.enabled||oe!==J.shadowMap.type)&&(J.shadowMap.needsUpdate=!0)}return Qn.enabled=!R,u||(J.outputColorSpace=E?np:va,J.toneMapping=C?th:A3),q.legacy!==R&&q.set(()=>({legacy:R})),q.linear!==E&&q.set(()=>({linear:E})),q.flat!==C&&q.set(()=>({flat:C})),g&&!ei.fun(g)&&!PP(g)&&!ei.equ(g,J,My)&&Fd(J,g),o=_,u=!0,d(),this},render(f){return!u&&!c&&this.configure(),c.then(()=>{KI.updateContainer(ft.jsx(Zie,{store:r,children:f,onCreated:o,rootElement:s}),a,null,()=>{})}),r},unmount(){Z6(s)}}}function Zie({store:s,children:e,onCreated:t,rootElement:n}){return u_(()=>{const i=s.getState();i.set(r=>({internal:{...r.internal,active:!0}})),t&&t(i),s.getState().events.connected||i.events.connect==null||i.events.connect(n)},[]),ft.jsx(W6.Provider,{value:s,children:e})}function Z6(s,e){const t=Mg.get(s),n=t==null?void 0:t.fiber;if(n){const i=t==null?void 0:t.store.getState();i&&(i.internal.active=!1),KI.updateContainer(null,n,null,()=>{i&&setTimeout(()=>{try{var r,a,o,l;i.events.disconnect==null||i.events.disconnect(),(r=i.gl)==null||(a=r.renderLists)==null||a.dispose==null||a.dispose(),(o=i.gl)==null||o.forceContextLoss==null||o.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),Eie(i.scene),Mg.delete(s)}catch{}},500)})}}const Qie=new Set,ere=new Set,tre=new Set;function zR(s,e){if(s.size)for(const{callback:t}of s.values())t(e)}function ab(s,e){switch(s){case"before":return zR(Qie,e);case"after":return zR(ere,e);case"tail":return zR(tre,e)}}let GR,HR;function YI(s,e,t){let n=e.clock.getDelta();e.frameloop==="never"&&typeof s=="number"&&(n=s-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=s),GR=e.internal.subscribers;for(let i=0;i<GR.length;i++)HR=GR[i],HR.ref.current(HR.store.getState(),n,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}let I2=!1,JI=!1,VR,GP,Ny;function Q6(s){GP=requestAnimationFrame(Q6),I2=!0,VR=0,ab("before",s),JI=!0;for(const t of Mg.values()){var e;Ny=t.store.getState(),Ny.internal.active&&(Ny.frameloop==="always"||Ny.internal.frames>0)&&!((e=Ny.gl.xr)!=null&&e.isPresenting)&&(VR+=YI(s,Ny))}if(JI=!1,ab("after",s),VR===0)return ab("tail",s),I2=!1,cancelAnimationFrame(GP)}function ZI(s,e=1){var t;if(!s)return Mg.forEach(n=>ZI(n.store.getState(),e));(t=s.gl.xr)!=null&&t.isPresenting||!s.internal.active||s.frameloop==="never"||(e>1?s.internal.frames=Math.min(60,s.internal.frames+e):JI?s.internal.frames=2:s.internal.frames=1,I2||(I2=!0,requestAnimationFrame(Q6)))}function HP(s,e=!0,t,n){if(e&&ab("before",s),t)YI(s,t,n);else for(const i of Mg.values())YI(s,i.store.getState());e&&ab("after",s)}const WR={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function nre(s){const{handlePointer:e}=kie(s);return{priority:1,enabled:!0,compute(t,n,i){n.pointer.set(t.offsetX/n.size.width*2-1,-(t.offsetY/n.size.height)*2+1),n.raycaster.setFromCamera(n.pointer,n.camera)},connected:void 0,handlers:Object.keys(WR).reduce((t,n)=>({...t,[n]:e(n)}),{}),update:()=>{var t;const{events:n,internal:i}=s.getState();(t=i.lastEvent)!=null&&t.current&&n.handlers&&n.handlers.onPointerMove(i.lastEvent.current)},connect:t=>{const{set:n,events:i}=s.getState();if(i.disconnect==null||i.disconnect(),n(r=>({events:{...r.events,connected:t}})),i.handlers)for(const r in i.handlers){const a=i.handlers[r],[o,l]=WR[r];t.addEventListener(o,a,{passive:l})}},disconnect:()=>{const{set:t,events:n}=s.getState();if(n.connected){if(n.handlers)for(const i in n.handlers){const r=n.handlers[i],[a]=WR[i];n.connected.removeEventListener(a,r)}t(i=>({events:{...i.events,connected:void 0}}))}}}}function VP(s,e){let t;return(...n)=>{window.clearTimeout(t),t=window.setTimeout(()=>s(...n),e)}}function sre({debounce:s,scroll:e,polyfill:t,offsetSize:n}={debounce:0,scroll:!1,offsetSize:!1}){const i=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[r,a]=Me.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),o=Me.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:r,orientationHandler:null}),l=s?typeof s=="number"?s:s.scroll:null,u=s?typeof s=="number"?s:s.resize:null,c=Me.useRef(!1);Me.useEffect(()=>(c.current=!0,()=>void(c.current=!1)));const[f,d,g]=Me.useMemo(()=>{const _=()=>{if(!o.current.element)return;const{left:T,top:E,width:C,height:R,bottom:I,right:L,x:P,y:D}=o.current.element.getBoundingClientRect(),O={left:T,top:E,width:C,height:R,bottom:I,right:L,x:P,y:D};o.current.element instanceof HTMLElement&&n&&(O.height=o.current.element.offsetHeight,O.width=o.current.element.offsetWidth),Object.freeze(O),c.current&&!ore(o.current.lastBounds,O)&&a(o.current.lastBounds=O)};return[_,u?VP(_,u):_,l?VP(_,l):_]},[a,n,l,u]);function x(){o.current.scrollContainers&&(o.current.scrollContainers.forEach(_=>_.removeEventListener("scroll",g,!0)),o.current.scrollContainers=null),o.current.resizeObserver&&(o.current.resizeObserver.disconnect(),o.current.resizeObserver=null),o.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",o.current.orientationHandler))}function S(){o.current.element&&(o.current.resizeObserver=new i(g),o.current.resizeObserver.observe(o.current.element),e&&o.current.scrollContainers&&o.current.scrollContainers.forEach(_=>_.addEventListener("scroll",g,{capture:!0,passive:!0})),o.current.orientationHandler=()=>{g()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",o.current.orientationHandler))}const b=_=>{!_||_===o.current.element||(x(),o.current.element=_,o.current.scrollContainers=e5(_),S())};return rre(g,!!e),ire(d),Me.useEffect(()=>{x(),S()},[e,g,d]),Me.useEffect(()=>x,[]),[b,r,f]}function ire(s){Me.useEffect(()=>{const e=s;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[s])}function rre(s,e){Me.useEffect(()=>{if(e){const t=s;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[s,e])}function e5(s){const e=[];if(!s||s===document.body)return e;const{overflow:t,overflowX:n,overflowY:i}=window.getComputedStyle(s);return[t,n,i].some(r=>r==="auto"||r==="scroll")&&e.push(s),[...e,...e5(s.parentElement)]}const are=["x","y","top","bottom","left","right","width","height"],ore=(s,e)=>are.every(t=>s[t]===e[t]);function lre({ref:s,children:e,fallback:t,resize:n,style:i,gl:r,events:a=nre,eventSource:o,eventPrefix:l,shadows:u,linear:c,flat:f,legacy:d,orthographic:g,frameloop:x,dpr:S,performance:b,raycaster:_,camera:T,scene:E,onPointerMissed:C,onCreated:R,...I}){Me.useMemo(()=>Hie(Wse),[]);const L=Aie(),[P,D]=sre({scroll:!0,debounce:{scroll:50,resize:0},...n}),O=Me.useRef(null),F=Me.useRef(null);Me.useImperativeHandle(s,()=>O.current);const X=z6(C),[q,J]=Me.useState(!1),[Y,$]=Me.useState(!1);if(q)throw q;if(Y)throw Y;const W=Me.useRef(null);u_(()=>{const se=O.current;if(D.width>0&&D.height>0&&se){W.current||(W.current=Jie(se));async function G(){await W.current.configure({gl:r,scene:E,events:a,shadows:u,linear:c,flat:f,legacy:d,orthographic:g,frameloop:x,dpr:S,performance:b,raycaster:_,camera:T,size:D,onPointerMissed:(...ne)=>X.current==null?void 0:X.current(...ne),onCreated:ne=>{ne.events.connect==null||ne.events.connect(o?_ie(o)?o.current:o:F.current),l&&ne.setEvents({compute:(oe,ue)=>{const re=oe[l+"X"],ce=oe[l+"Y"];ue.pointer.set(re/ue.size.width*2-1,-(ce/ue.size.height)*2+1),ue.raycaster.setFromCamera(ue.pointer,ue.camera)}}),R==null||R(ne)}}),W.current.render(ft.jsx(L,{children:ft.jsx(wie,{set:$,children:ft.jsx(Me.Suspense,{fallback:ft.jsx(Tie,{set:J}),children:e??null})})}))}G()}}),Me.useEffect(()=>{const se=O.current;if(se)return()=>Z6(se)},[]);const V=o?"none":"auto";return ft.jsx("div",{ref:F,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:V,...i},...I,children:ft.jsx("div",{ref:P,style:{width:"100%",height:"100%"},children:ft.jsx("canvas",{ref:O,style:{display:"block"},children:t})})})}function ure(s){return ft.jsx(F6,{children:ft.jsx(lre,{...s})})}function QI(){return QI=Object.assign?Object.assign.bind():function(s){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)({}).hasOwnProperty.call(t,n)&&(s[n]=t[n])}return s},QI.apply(null,arguments)}const cre=parseInt(Jb.replace(/\D+/g,""));function WP(s,e){if(e===g9)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),s;if(e===T2||e===B3){let t=s.getIndex();if(t===null){const a=[],o=s.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)a.push(l);s.setIndex(a),t=s.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),s}const n=t.count-2,i=[];if(t)if(e===T2)for(let a=1;a<=n;a++)i.push(t.getX(0)),i.push(t.getX(a)),i.push(t.getX(a+1));else for(let a=0;a<n;a++)a%2===0?(i.push(t.getX(a)),i.push(t.getX(a+1)),i.push(t.getX(a+2))):(i.push(t.getX(a+2)),i.push(t.getX(a+1)),i.push(t.getX(a)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=s.clone();return r.setIndex(i),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),s}var hre=Object.defineProperty,fre=(s,e,t)=>e in s?hre(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,dre=(s,e,t)=>(fre(s,e+"",t),t);class pre{constructor(){dre(this,"_listeners")}addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}}var mre=Object.defineProperty,gre=(s,e,t)=>e in s?mre(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,sn=(s,e,t)=>(gre(s,typeof e!="symbol"?e+"":e,t),t);const tw=new Xg,XP=new Zh,yre=Math.cos(70*(Math.PI/180)),qP=(s,e)=>(s%e+e)%e;let xre=class extends pre{constructor(e,t){super(),sn(this,"object"),sn(this,"domElement"),sn(this,"enabled",!0),sn(this,"target",new ae),sn(this,"minDistance",0),sn(this,"maxDistance",1/0),sn(this,"minZoom",0),sn(this,"maxZoom",1/0),sn(this,"minPolarAngle",0),sn(this,"maxPolarAngle",Math.PI),sn(this,"minAzimuthAngle",-1/0),sn(this,"maxAzimuthAngle",1/0),sn(this,"enableDamping",!1),sn(this,"dampingFactor",.05),sn(this,"enableZoom",!0),sn(this,"zoomSpeed",1),sn(this,"enableRotate",!0),sn(this,"rotateSpeed",1),sn(this,"enablePan",!0),sn(this,"panSpeed",1),sn(this,"screenSpacePanning",!0),sn(this,"keyPanSpeed",7),sn(this,"zoomToCursor",!1),sn(this,"autoRotate",!1),sn(this,"autoRotateSpeed",2),sn(this,"reverseOrbit",!1),sn(this,"reverseHorizontalOrbit",!1),sn(this,"reverseVerticalOrbit",!1),sn(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),sn(this,"mouseButtons",{LEFT:Vm.ROTATE,MIDDLE:Vm.DOLLY,RIGHT:Vm.PAN}),sn(this,"touches",{ONE:Wm.ROTATE,TWO:Wm.DOLLY_PAN}),sn(this,"target0"),sn(this,"position0"),sn(this,"zoom0"),sn(this,"_domElementKeyEvents",null),sn(this,"getPolarAngle"),sn(this,"getAzimuthalAngle"),sn(this,"setPolarAngle"),sn(this,"setAzimuthalAngle"),sn(this,"getDistance"),sn(this,"getZoomScale"),sn(this,"listenToKeyEvents"),sn(this,"stopListenToKeyEvents"),sn(this,"saveState"),sn(this,"reset"),sn(this,"update"),sn(this,"connect"),sn(this,"dispose"),sn(this,"dollyIn"),sn(this,"dollyOut"),sn(this,"getScale"),sn(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>c.phi,this.getAzimuthalAngle=()=>c.theta,this.setPolarAngle=ye=>{let Je=qP(ye,2*Math.PI),_t=c.phi;_t<0&&(_t+=2*Math.PI),Je<0&&(Je+=2*Math.PI);let ge=Math.abs(Je-_t);2*Math.PI-ge<ge&&(Je<_t?Je+=2*Math.PI:_t+=2*Math.PI),f.phi=Je-_t,n.update()},this.setAzimuthalAngle=ye=>{let Je=qP(ye,2*Math.PI),_t=c.theta;_t<0&&(_t+=2*Math.PI),Je<0&&(Je+=2*Math.PI);let ge=Math.abs(Je-_t);2*Math.PI-ge<ge&&(Je<_t?Je+=2*Math.PI:_t+=2*Math.PI),f.theta=Je-_t,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=ye=>{ye.addEventListener("keydown",at),this._domElementKeyEvents=ye},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",at),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(i),n.update(),l=o.NONE},this.update=(()=>{const ye=new ae,Je=new ae(0,1,0),_t=new kr().setFromUnitVectors(e.up,Je),ge=_t.clone().invert(),dt=new ae,We=new kr,Ze=2*Math.PI;return function(){const At=n.object.position;_t.setFromUnitVectors(e.up,Je),ge.copy(_t).invert(),ye.copy(At).sub(n.target),ye.applyQuaternion(_t),c.setFromVector3(ye),n.autoRotate&&l===o.NONE&&J(X()),n.enableDamping?(c.theta+=f.theta*n.dampingFactor,c.phi+=f.phi*n.dampingFactor):(c.theta+=f.theta,c.phi+=f.phi);let Kt=n.minAzimuthAngle,Nn=n.maxAzimuthAngle;isFinite(Kt)&&isFinite(Nn)&&(Kt<-Math.PI?Kt+=Ze:Kt>Math.PI&&(Kt-=Ze),Nn<-Math.PI?Nn+=Ze:Nn>Math.PI&&(Nn-=Ze),Kt<=Nn?c.theta=Math.max(Kt,Math.min(Nn,c.theta)):c.theta=c.theta>(Kt+Nn)/2?Math.max(Kt,c.theta):Math.min(Nn,c.theta)),c.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,c.phi)),c.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(g,n.dampingFactor):n.target.add(g),n.zoomToCursor&&D||n.object.isOrthographicCamera?c.radius=ue(c.radius):c.radius=ue(c.radius*d),ye.setFromSpherical(c),ye.applyQuaternion(ge),At.copy(n.target).add(ye),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),n.enableDamping===!0?(f.theta*=1-n.dampingFactor,f.phi*=1-n.dampingFactor,g.multiplyScalar(1-n.dampingFactor)):(f.set(0,0,0),g.set(0,0,0));let cs=!1;if(n.zoomToCursor&&D){let _n=null;if(n.object instanceof Ci&&n.object.isPerspectiveCamera){const xi=ye.length();_n=ue(xi*d);const $s=xi-_n;n.object.position.addScaledVector(L,$s),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const xi=new ae(P.x,P.y,0);xi.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/d)),n.object.updateProjectionMatrix(),cs=!0;const $s=new ae(P.x,P.y,0);$s.unproject(n.object),n.object.position.sub($s).add(xi),n.object.updateMatrixWorld(),_n=ye.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;_n!==null&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(_n).add(n.object.position):(tw.origin.copy(n.object.position),tw.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(tw.direction))<yre?e.lookAt(n.target):(XP.setFromNormalAndCoplanarPoint(n.object.up,n.target),tw.intersectPlane(XP,n.target))))}else n.object instanceof ff&&n.object.isOrthographicCamera&&(cs=d!==1,cs&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/d)),n.object.updateProjectionMatrix()));return d=1,D=!1,cs||dt.distanceToSquared(n.object.position)>u||8*(1-We.dot(n.object.quaternion))>u?(n.dispatchEvent(i),dt.copy(n.object.position),We.copy(n.object.quaternion),cs=!1,!0):!1}})(),this.connect=ye=>{n.domElement=ye,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",lt),n.domElement.addEventListener("pointerdown",j),n.domElement.addEventListener("pointercancel",Ue),n.domElement.addEventListener("wheel",mt)},this.dispose=()=>{var ye,Je,_t,ge,dt,We;n.domElement&&(n.domElement.style.touchAction="auto"),(ye=n.domElement)==null||ye.removeEventListener("contextmenu",lt),(Je=n.domElement)==null||Je.removeEventListener("pointerdown",j),(_t=n.domElement)==null||_t.removeEventListener("pointercancel",Ue),(ge=n.domElement)==null||ge.removeEventListener("wheel",mt),(dt=n.domElement)==null||dt.ownerDocument.removeEventListener("pointermove",Ae),(We=n.domElement)==null||We.ownerDocument.removeEventListener("pointerup",Ue),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",at)};const n=this,i={type:"change"},r={type:"start"},a={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=o.NONE;const u=1e-6,c=new HI,f=new HI;let d=1;const g=new ae,x=new tt,S=new tt,b=new tt,_=new tt,T=new tt,E=new tt,C=new tt,R=new tt,I=new tt,L=new ae,P=new tt;let D=!1;const O=[],F={};function X(){return 2*Math.PI/60/60*n.autoRotateSpeed}function q(){return Math.pow(.95,n.zoomSpeed)}function J(ye){n.reverseOrbit||n.reverseHorizontalOrbit?f.theta+=ye:f.theta-=ye}function Y(ye){n.reverseOrbit||n.reverseVerticalOrbit?f.phi+=ye:f.phi-=ye}const $=(()=>{const ye=new ae;return function(_t,ge){ye.setFromMatrixColumn(ge,0),ye.multiplyScalar(-_t),g.add(ye)}})(),W=(()=>{const ye=new ae;return function(_t,ge){n.screenSpacePanning===!0?ye.setFromMatrixColumn(ge,1):(ye.setFromMatrixColumn(ge,0),ye.crossVectors(n.object.up,ye)),ye.multiplyScalar(_t),g.add(ye)}})(),V=(()=>{const ye=new ae;return function(_t,ge){const dt=n.domElement;if(dt&&n.object instanceof Ci&&n.object.isPerspectiveCamera){const We=n.object.position;ye.copy(We).sub(n.target);let Ze=ye.length();Ze*=Math.tan(n.object.fov/2*Math.PI/180),$(2*_t*Ze/dt.clientHeight,n.object.matrix),W(2*ge*Ze/dt.clientHeight,n.object.matrix)}else dt&&n.object instanceof ff&&n.object.isOrthographicCamera?($(_t*(n.object.right-n.object.left)/n.object.zoom/dt.clientWidth,n.object.matrix),W(ge*(n.object.top-n.object.bottom)/n.object.zoom/dt.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function se(ye){n.object instanceof Ci&&n.object.isPerspectiveCamera||n.object instanceof ff&&n.object.isOrthographicCamera?d=ye:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function G(ye){se(d/ye)}function ne(ye){se(d*ye)}function oe(ye){if(!n.zoomToCursor||!n.domElement)return;D=!0;const Je=n.domElement.getBoundingClientRect(),_t=ye.clientX-Je.left,ge=ye.clientY-Je.top,dt=Je.width,We=Je.height;P.x=_t/dt*2-1,P.y=-(ge/We)*2+1,L.set(P.x,P.y,1).unproject(n.object).sub(n.object.position).normalize()}function ue(ye){return Math.max(n.minDistance,Math.min(n.maxDistance,ye))}function re(ye){x.set(ye.clientX,ye.clientY)}function ce(ye){oe(ye),C.set(ye.clientX,ye.clientY)}function Te(ye){_.set(ye.clientX,ye.clientY)}function Be(ye){S.set(ye.clientX,ye.clientY),b.subVectors(S,x).multiplyScalar(n.rotateSpeed);const Je=n.domElement;Je&&(J(2*Math.PI*b.x/Je.clientHeight),Y(2*Math.PI*b.y/Je.clientHeight)),x.copy(S),n.update()}function Ke(ye){R.set(ye.clientX,ye.clientY),I.subVectors(R,C),I.y>0?G(q()):I.y<0&&ne(q()),C.copy(R),n.update()}function ut(ye){T.set(ye.clientX,ye.clientY),E.subVectors(T,_).multiplyScalar(n.panSpeed),V(E.x,E.y),_.copy(T),n.update()}function ct(ye){oe(ye),ye.deltaY<0?ne(q()):ye.deltaY>0&&G(q()),n.update()}function xt(ye){let Je=!1;switch(ye.code){case n.keys.UP:V(0,n.keyPanSpeed),Je=!0;break;case n.keys.BOTTOM:V(0,-n.keyPanSpeed),Je=!0;break;case n.keys.LEFT:V(n.keyPanSpeed,0),Je=!0;break;case n.keys.RIGHT:V(-n.keyPanSpeed,0),Je=!0;break}Je&&(ye.preventDefault(),n.update())}function kt(){if(O.length==1)x.set(O[0].pageX,O[0].pageY);else{const ye=.5*(O[0].pageX+O[1].pageX),Je=.5*(O[0].pageY+O[1].pageY);x.set(ye,Je)}}function Et(){if(O.length==1)_.set(O[0].pageX,O[0].pageY);else{const ye=.5*(O[0].pageX+O[1].pageX),Je=.5*(O[0].pageY+O[1].pageY);_.set(ye,Je)}}function le(){const ye=O[0].pageX-O[1].pageX,Je=O[0].pageY-O[1].pageY,_t=Math.sqrt(ye*ye+Je*Je);C.set(0,_t)}function Wt(){n.enableZoom&&le(),n.enablePan&&Et()}function ze(){n.enableZoom&&le(),n.enableRotate&&kt()}function Fe(ye){if(O.length==1)S.set(ye.pageX,ye.pageY);else{const _t=vt(ye),ge=.5*(ye.pageX+_t.x),dt=.5*(ye.pageY+_t.y);S.set(ge,dt)}b.subVectors(S,x).multiplyScalar(n.rotateSpeed);const Je=n.domElement;Je&&(J(2*Math.PI*b.x/Je.clientHeight),Y(2*Math.PI*b.y/Je.clientHeight)),x.copy(S)}function Pe(ye){if(O.length==1)T.set(ye.pageX,ye.pageY);else{const Je=vt(ye),_t=.5*(ye.pageX+Je.x),ge=.5*(ye.pageY+Je.y);T.set(_t,ge)}E.subVectors(T,_).multiplyScalar(n.panSpeed),V(E.x,E.y),_.copy(T)}function ht(ye){const Je=vt(ye),_t=ye.pageX-Je.x,ge=ye.pageY-Je.y,dt=Math.sqrt(_t*_t+ge*ge);R.set(0,dt),I.set(0,Math.pow(R.y/C.y,n.zoomSpeed)),G(I.y),C.copy(R)}function ke(ye){n.enableZoom&&ht(ye),n.enablePan&&Pe(ye)}function ie(ye){n.enableZoom&&ht(ye),n.enableRotate&&Fe(ye)}function j(ye){var Je,_t;n.enabled!==!1&&(O.length===0&&((Je=n.domElement)==null||Je.ownerDocument.addEventListener("pointermove",Ae),(_t=n.domElement)==null||_t.ownerDocument.addEventListener("pointerup",Ue)),Dt(ye),ye.pointerType==="touch"?gt(ye):Ye(ye))}function Ae(ye){n.enabled!==!1&&(ye.pointerType==="touch"?dn(ye):qe(ye))}function Ue(ye){var Je,_t,ge;Ft(ye),O.length===0&&((Je=n.domElement)==null||Je.releasePointerCapture(ye.pointerId),(_t=n.domElement)==null||_t.ownerDocument.removeEventListener("pointermove",Ae),(ge=n.domElement)==null||ge.ownerDocument.removeEventListener("pointerup",Ue)),n.dispatchEvent(a),l=o.NONE}function Ye(ye){let Je;switch(ye.button){case 0:Je=n.mouseButtons.LEFT;break;case 1:Je=n.mouseButtons.MIDDLE;break;case 2:Je=n.mouseButtons.RIGHT;break;default:Je=-1}switch(Je){case Vm.DOLLY:if(n.enableZoom===!1)return;ce(ye),l=o.DOLLY;break;case Vm.ROTATE:if(ye.ctrlKey||ye.metaKey||ye.shiftKey){if(n.enablePan===!1)return;Te(ye),l=o.PAN}else{if(n.enableRotate===!1)return;re(ye),l=o.ROTATE}break;case Vm.PAN:if(ye.ctrlKey||ye.metaKey||ye.shiftKey){if(n.enableRotate===!1)return;re(ye),l=o.ROTATE}else{if(n.enablePan===!1)return;Te(ye),l=o.PAN}break;default:l=o.NONE}l!==o.NONE&&n.dispatchEvent(r)}function qe(ye){if(n.enabled!==!1)switch(l){case o.ROTATE:if(n.enableRotate===!1)return;Be(ye);break;case o.DOLLY:if(n.enableZoom===!1)return;Ke(ye);break;case o.PAN:if(n.enablePan===!1)return;ut(ye);break}}function mt(ye){n.enabled===!1||n.enableZoom===!1||l!==o.NONE&&l!==o.ROTATE||(ye.preventDefault(),n.dispatchEvent(r),ct(ye),n.dispatchEvent(a))}function at(ye){n.enabled===!1||n.enablePan===!1||xt(ye)}function gt(ye){switch(Pt(ye),O.length){case 1:switch(n.touches.ONE){case Wm.ROTATE:if(n.enableRotate===!1)return;kt(),l=o.TOUCH_ROTATE;break;case Wm.PAN:if(n.enablePan===!1)return;Et(),l=o.TOUCH_PAN;break;default:l=o.NONE}break;case 2:switch(n.touches.TWO){case Wm.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Wt(),l=o.TOUCH_DOLLY_PAN;break;case Wm.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;ze(),l=o.TOUCH_DOLLY_ROTATE;break;default:l=o.NONE}break;default:l=o.NONE}l!==o.NONE&&n.dispatchEvent(r)}function dn(ye){switch(Pt(ye),l){case o.TOUCH_ROTATE:if(n.enableRotate===!1)return;Fe(ye),n.update();break;case o.TOUCH_PAN:if(n.enablePan===!1)return;Pe(ye),n.update();break;case o.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;ke(ye),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;ie(ye),n.update();break;default:l=o.NONE}}function lt(ye){n.enabled!==!1&&ye.preventDefault()}function Dt(ye){O.push(ye)}function Ft(ye){delete F[ye.pointerId];for(let Je=0;Je<O.length;Je++)if(O[Je].pointerId==ye.pointerId){O.splice(Je,1);return}}function Pt(ye){let Je=F[ye.pointerId];Je===void 0&&(Je=new tt,F[ye.pointerId]=Je),Je.set(ye.pageX,ye.pageY)}function vt(ye){const Je=ye.pointerId===O[0].pointerId?O[1]:O[0];return F[Je.pointerId]}this.dollyIn=(ye=q())=>{ne(ye),n.update()},this.dollyOut=(ye=q())=>{G(ye),n.update()},this.getScale=()=>d,this.setScale=ye=>{se(ye),n.update()},this.getZoomScale=()=>q(),t!==void 0&&this.connect(t),this.update()}};function D2(s){if(typeof TextDecoder<"u")return new TextDecoder().decode(s);let e="";for(let t=0,n=s.length;t<n;t++)e+=String.fromCharCode(s[t]);try{return decodeURIComponent(escape(e))}catch{return e}}const og="srgb",df="srgb-linear",jP=3001,vre=3e3;class xO extends Ia{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Tre(t)}),this.register(function(t){return new wre(t)}),this.register(function(t){return new Bre(t)}),this.register(function(t){return new kre(t)}),this.register(function(t){return new Lre(t)}),this.register(function(t){return new Ere(t)}),this.register(function(t){return new Mre(t)}),this.register(function(t){return new Nre(t)}),this.register(function(t){return new Rre(t)}),this.register(function(t){return new Are(t)}),this.register(function(t){return new Ire(t)}),this.register(function(t){return new Cre(t)}),this.register(function(t){return new Ore(t)}),this.register(function(t){return new Dre(t)}),this.register(function(t){return new _re(t)}),this.register(function(t){return new Fre(t)}),this.register(function(t){return new Pre(t)})}load(e,t,n,i){const r=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const u=Xd.extractUrlBase(e);a=Xd.resolveURL(u,this.path)}else a=Xd.extractUrlBase(e);this.manager.itemStart(e);const o=function(u){i?i(u):console.error(u),r.manager.itemError(e),r.manager.itemEnd(e)},l=new vl(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{r.parse(u,a,function(c){t(c),r.manager.itemEnd(e)},o)}catch(c){o(c)}},n,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){let r;const a={},o={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(D2(new Uint8Array(e.slice(0,4)))===t5){try{a[Vn.KHR_BINARY_GLTF]=new Ure(e)}catch(c){i&&i(c);return}r=JSON.parse(a[Vn.KHR_BINARY_GLTF].content)}else r=JSON.parse(D2(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Zre(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const c=this.pluginCallbacks[u](l);c.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[c.name]=c,a[c.name]=!0}if(r.extensionsUsed)for(let u=0;u<r.extensionsUsed.length;++u){const c=r.extensionsUsed[u],f=r.extensionsRequired||[];switch(c){case Vn.KHR_MATERIALS_UNLIT:a[c]=new Sre;break;case Vn.KHR_DRACO_MESH_COMPRESSION:a[c]=new $re(r,this.dracoLoader);break;case Vn.KHR_TEXTURE_TRANSFORM:a[c]=new zre;break;case Vn.KHR_MESH_QUANTIZATION:a[c]=new Gre;break;default:f.indexOf(c)>=0&&o[c]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+c+'".')}}l.setExtensions(a),l.setPlugins(o),l.parse(n,i)}parseAsync(e,t){const n=this;return new Promise(function(i,r){n.parse(e,t,i,r)})}}function bre(){let s={};return{get:function(e){return s[e]},add:function(e,t){s[e]=t},remove:function(e){delete s[e]},removeAll:function(){s={}}}}const Vn={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class _re{constructor(e){this.parser=e,this.name=Vn.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let u;const c=new Nt(16777215);l.color!==void 0&&c.setRGB(l.color[0],l.color[1],l.color[2],df);const f=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new oO(c),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new aO(c),u.distance=f;break;case"spot":u=new rO(c),u.distance=f,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,Yh(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(u),t.cache.add(n,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return n._getNodeRef(t.cache,o,l)})}}class Sre{constructor(){this.name=Vn.KHR_MATERIALS_UNLIT}getMaterialType(){return fl}extendParams(e,t,n){const i=[];e.color=new Nt(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const a=r.baseColorFactor;e.color.setRGB(a[0],a[1],a[2],df),e.opacity=a[3]}r.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",r.baseColorTexture,og))}return Promise.all(i)}}class Are{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class Tre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(r.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new tt(o,o)}return Promise.all(r)}}class wre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class Cre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(t.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(t.iridescenceIOR=a.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(r)}}class Ere{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new Nt(0,0,0),t.sheenRoughness=0,t.sheen=1;const a=i.extensions[this.name];if(a.sheenColorFactor!==void 0){const o=a.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],df)}return a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&r.push(n.assignTexture(t,"sheenColorMap",a.sheenColorTexture,og)),a.sheenRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(r)}}class Mre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&r.push(n.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(r)}}class Nre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&r.push(n.assignTexture(t,"thicknessMap",a.thicknessTexture)),t.attenuationDistance=a.attenuationDistance||1/0;const o=a.attenuationColor||[1,1,1];return t.attenuationColor=new Nt().setRGB(o[0],o[1],o[2],df),Promise.all(r)}}class Rre{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class Ire{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&r.push(n.assignTexture(t,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return t.specularColor=new Nt().setRGB(o[0],o[1],o[2],df),a.specularColorTexture!==void 0&&r.push(n.assignTexture(t,"specularColorMap",a.specularColorTexture,og)),Promise.all(r)}}class Dre{constructor(e){this.parser=e,this.name=Vn.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return t.bumpScale=a.bumpFactor!==void 0?a.bumpFactor:1,a.bumpTexture!==void 0&&r.push(n.assignTexture(t,"bumpMap",a.bumpTexture)),Promise.all(r)}}class Ore{constructor(e){this.parser=e,this.name=Vn.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:fu}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.anisotropyStrength!==void 0&&(t.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(t.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&r.push(n.assignTexture(t,"anisotropyMap",a.anisotropyTexture)),Promise.all(r)}}class Bre{constructor(e){this.parser=e,this.name=Vn.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const r=i.extensions[this.name],a=t.options.ktx2Loader;if(!a){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,a)}}class kre{constructor(e){this.parser=e,this.name=Vn.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],o=i.images[a.source];let l=n.textureLoader;if(o.uri){const u=n.options.manager.getHandler(o.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Lre{constructor(e){this.parser=e,this.name=Vn.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],o=i.images[a.source];let l=n.textureLoader;if(o.uri){const u=n.options.manager.getHandler(o.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return n.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Fre{constructor(e){this.name=Vn.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],r=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(o){const l=i.byteOffset||0,u=i.byteLength||0,c=i.count,f=i.byteStride,d=new Uint8Array(o,l,u);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(c,f,d,i.mode,i.filter).then(function(g){return g.buffer}):a.ready.then(function(){const g=new ArrayBuffer(c*f);return a.decodeGltfBuffer(new Uint8Array(g),c,f,d,i.mode,i.filter),g})})}else return null}}class Pre{constructor(e){this.name=Vn.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=t.meshes[n.mesh];for(const u of i.primitives)if(u.mode!==Jl.TRIANGLES&&u.mode!==Jl.TRIANGLE_STRIP&&u.mode!==Jl.TRIANGLE_FAN&&u.mode!==void 0)return null;const a=n.extensions[this.name].attributes,o=[],l={};for(const u in a)o.push(this.parser.getDependency("accessor",a[u]).then(c=>(l[u]=c,l[u])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(u=>{const c=u.pop(),f=c.isGroup?c.children:[c],d=u[0].count,g=[];for(const x of f){const S=new rn,b=new ae,_=new kr,T=new ae(1,1,1),E=new G3(x.geometry,x.material,d);for(let C=0;C<d;C++)l.TRANSLATION&&b.fromBufferAttribute(l.TRANSLATION,C),l.ROTATION&&_.fromBufferAttribute(l.ROTATION,C),l.SCALE&&T.fromBufferAttribute(l.SCALE,C),E.setMatrixAt(C,S.compose(b,_,T));for(const C in l)if(C==="_COLOR_0"){const R=l[C];E.instanceColor=new Ag(R.array,R.itemSize,R.normalized)}else C!=="TRANSLATION"&&C!=="ROTATION"&&C!=="SCALE"&&x.geometry.setAttribute(C,l[C]);ts.prototype.copy.call(E,x),this.parser.assignFinalMaterial(E),g.push(E)}return c.isGroup?(c.clear(),c.add(...g),c):g[0]}))}}const t5="glTF",B1=12,KP={JSON:1313821514,BIN:5130562};class Ure{constructor(e){this.name=Vn.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,B1);if(this.header={magic:D2(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==t5)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-B1,i=new DataView(e,B1);let r=0;for(;r<n;){const a=i.getUint32(r,!0);r+=4;const o=i.getUint32(r,!0);if(r+=4,o===KP.JSON){const l=new Uint8Array(e,B1+r,a);this.content=D2(l)}else if(o===KP.BIN){const l=B1+r;this.body=e.slice(l,l+a)}r+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class $re{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Vn.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,r=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},l={},u={};for(const c in a){const f=eD[c]||c.toLowerCase();o[f]=a[c]}for(const c in e.attributes){const f=eD[c]||c.toLowerCase();if(a[c]!==void 0){const d=n.accessors[e.attributes[c]],g=Vy[d.componentType];u[f]=g.name,l[f]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(c){return new Promise(function(f,d){i.decodeDracoFile(c,function(g){for(const x in g.attributes){const S=g.attributes[x],b=l[x];b!==void 0&&(S.normalized=b)}f(g)},o,u,df,d)})})}}class zre{constructor(){this.name=Vn.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Gre{constructor(){this.name=Vn.KHR_MESH_QUANTIZATION}}class n5 extends Px{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i*3+i;for(let a=0;a!==i;a++)t[a]=n[r+a];return t}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=o*2,u=o*3,c=i-t,f=(n-t)/c,d=f*f,g=d*f,x=e*u,S=x-u,b=-2*g+3*d,_=g-d,T=1-b,E=_-d+f;for(let C=0;C!==o;C++){const R=a[S+C+o],I=a[S+C+l]*c,L=a[x+C+o],P=a[x+C]*c;r[C]=T*R+E*I+b*L+_*P}return r}}const Hre=new kr;class Vre extends n5{interpolate_(e,t,n,i){const r=super.interpolate_(e,t,n,i);return Hre.fromArray(r).normalize().toArray(r),r}}const Jl={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Vy={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},YP={9728:Br,9729:$i,9984:SC,9985:Gy,9986:ng,9987:tu},JP={33071:hl,33648:tx,10497:tp},XR={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},eD={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...cre>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Bd={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Wre={CUBICSPLINE:void 0,LINEAR:ox,STEP:ax},qR={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Xre(s){return s.DefaultMaterial===void 0&&(s.DefaultMaterial=new l_({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ch})),s.DefaultMaterial}function Fm(s,e,t){for(const n in t.extensions)s[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function Yh(s,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(s.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function qre(s,e,t){let n=!1,i=!1,r=!1;for(let u=0,c=e.length;u<c;u++){const f=e[u];if(f.POSITION!==void 0&&(n=!0),f.NORMAL!==void 0&&(i=!0),f.COLOR_0!==void 0&&(r=!0),n&&i&&r)break}if(!n&&!i&&!r)return Promise.resolve(s);const a=[],o=[],l=[];for(let u=0,c=e.length;u<c;u++){const f=e[u];if(n){const d=f.POSITION!==void 0?t.getDependency("accessor",f.POSITION):s.attributes.position;a.push(d)}if(i){const d=f.NORMAL!==void 0?t.getDependency("accessor",f.NORMAL):s.attributes.normal;o.push(d)}if(r){const d=f.COLOR_0!==void 0?t.getDependency("accessor",f.COLOR_0):s.attributes.color;l.push(d)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(u){const c=u[0],f=u[1],d=u[2];return n&&(s.morphAttributes.position=c),i&&(s.morphAttributes.normal=f),r&&(s.morphAttributes.color=d),s.morphTargetsRelative=!0,s})}function jre(s,e){if(s.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)s.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(s.morphTargetInfluences.length===t.length){s.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)s.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Kre(s){let e;const t=s.extensions&&s.extensions[Vn.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+jR(t.attributes):e=s.indices+":"+jR(s.attributes)+":"+s.mode,s.targets!==void 0)for(let n=0,i=s.targets.length;n<i;n++)e+=":"+jR(s.targets[n]);return e}function jR(s){let e="";const t=Object.keys(s).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+s[t[n]]+";";return e}function tD(s){switch(s){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Yre(s){return s.search(/\.jpe?g($|\?)/i)>0||s.search(/^data\:image\/jpeg/)===0?"image/jpeg":s.search(/\.webp($|\?)/i)>0||s.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Jre=new rn;class Zre{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new bre,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=!1,r=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,r=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||i&&r<98?this.textureLoader=new f6(this.options.manager):this.textureLoader=new b6(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new vl(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:n,userData:{}};return Fm(r,o,i),Yh(o,i),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){for(const l of o.scenes)l.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,r=t.length;i<r;i++){const a=t[i].joints;for(let o=0,l=a.length;o<l;o++)e[a[o]].isBone=!0}for(let i=0,r=e.length;i<r;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(n[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone(),r=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[u,c]of a.children.entries())r(c,o.children[u])};return r(n,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&n.push(r)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":i=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(r,a){return n.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Vn.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(r,a){n.load(Xd.resolveURL(t.uri,i.path),r,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,r=t.byteOffset||0;return n.slice(r,r+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=XR[i.type],o=Vy[i.componentType],l=i.normalized===!0,u=new o(i.count*a);return Promise.resolve(new us(u,a,l))}const r=[];return i.bufferView!==void 0?r.push(this.getDependency("bufferView",i.bufferView)):r.push(null),i.sparse!==void 0&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(a){const o=a[0],l=XR[i.type],u=Vy[i.componentType],c=u.BYTES_PER_ELEMENT,f=c*l,d=i.byteOffset||0,g=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,x=i.normalized===!0;let S,b;if(g&&g!==f){const _=Math.floor(d/g),T="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+_+":"+i.count;let E=t.cache.get(T);E||(S=new u(o,_*g,i.count*g/c),E=new n_(S,g/c),t.cache.add(T,E)),b=new sp(E,l,d%g/c,x)}else o===null?S=new u(i.count*l):S=new u(o,d,i.count*l),b=new us(S,l,x);if(i.sparse!==void 0){const _=XR.SCALAR,T=Vy[i.sparse.indices.componentType],E=i.sparse.indices.byteOffset||0,C=i.sparse.values.byteOffset||0,R=new T(a[1],E,i.sparse.count*_),I=new u(a[2],C,i.sparse.count*l);o!==null&&(b=new us(b.array.slice(),b.itemSize,b.normalized));for(let L=0,P=R.length;L<P;L++){const D=R[L];if(b.setX(D,I[L*l]),l>=2&&b.setY(D,I[L*l+1]),l>=3&&b.setZ(D,I[L*l+2]),l>=4&&b.setW(D,I[L*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return b})}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e].source,a=t.images[r];let o=this.textureLoader;if(a.uri){const l=n.manager.getHandler(a.uri);l!==null&&(o=l)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,n){const i=this,r=this.json,a=r.textures[e],o=r.images[t],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(t,n).then(function(c){c.flipY=!1,c.name=a.name||o.name||"",c.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(c.name=o.uri);const d=(r.samplers||{})[a.sampler]||{};return c.magFilter=YP[d.magFilter]||$i,c.minFilter=YP[d.minFilter]||tu,c.wrapS=JP[d.wrapS]||tp,c.wrapT=JP[d.wrapT]||tp,i.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,t){const n=this,i=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(f=>f.clone());const a=i.images[e],o=self.URL||self.webkitURL;let l=a.uri||"",u=!1;if(a.bufferView!==void 0)l=n.getDependency("bufferView",a.bufferView).then(function(f){u=!0;const d=new Blob([f],{type:a.mimeType});return l=o.createObjectURL(d),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(f){return new Promise(function(d,g){let x=d;t.isImageBitmapLoader===!0&&(x=function(S){const b=new ii(S);b.needsUpdate=!0,d(b)}),t.load(Xd.resolveURL(f,r.path),x,void 0,g)})}).then(function(f){return u===!0&&o.revokeObjectURL(l),Yh(f,a),f.userData.mimeType=a.mimeType||Yre(a.uri),f}).catch(function(f){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),f});return this.sourceCache[e]=c,c}assignTexture(e,t,n,i){const r=this;return this.getDependency("texture",n.index).then(function(a){if(!a)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(a=a.clone(),a.channel=n.texCoord),r.extensions[Vn.KHR_TEXTURE_TRANSFORM]){const o=n.extensions!==void 0?n.extensions[Vn.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=r.associations.get(a);a=r.extensions[Vn.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),r.associations.set(a,l)}}return i!==void 0&&(typeof i=="number"&&(i=i===jP?og:df),"colorSpace"in a?a.colorSpace=i:a.encoding=i===og?jP:vre),e[t]=a,a})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const i=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,a=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+n.uuid;let l=this.cache.get(o);l||(l=new LC,br.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,l.sizeAttenuation=!1,this.cache.add(o,l)),n=l}else if(e.isLine){const o="LineBasicMaterial:"+n.uuid;let l=this.cache.get(o);l||(l=new Ra,br.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,this.cache.add(o,l)),n=l}if(i||r||a){let o="ClonedMaterial:"+n.uuid+":";i&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=n.clone(),r&&(l.vertexColors=!0),a&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(n))),n=l}e.material=n}getMaterialType(){return l_}loadMaterial(e){const t=this,n=this.json,i=this.extensions,r=n.materials[e];let a;const o={},l=r.extensions||{},u=[];if(l[Vn.KHR_MATERIALS_UNLIT]){const f=i[Vn.KHR_MATERIALS_UNLIT];a=f.getMaterialType(),u.push(f.extendParams(o,r,t))}else{const f=r.pbrMetallicRoughness||{};if(o.color=new Nt(1,1,1),o.opacity=1,Array.isArray(f.baseColorFactor)){const d=f.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],df),o.opacity=d[3]}f.baseColorTexture!==void 0&&u.push(t.assignTexture(o,"map",f.baseColorTexture,og)),o.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,o.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(o,"metalnessMap",f.metallicRoughnessTexture)),u.push(t.assignTexture(o,"roughnessMap",f.metallicRoughnessTexture))),a=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}r.doubleSided===!0&&(o.side=Ju);const c=r.alphaMode||qR.OPAQUE;if(c===qR.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,c===qR.MASK&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&a!==fl&&(u.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new tt(1,1),r.normalTexture.scale!==void 0)){const f=r.normalTexture.scale;o.normalScale.set(f,f)}if(r.occlusionTexture!==void 0&&a!==fl&&(u.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&a!==fl){const f=r.emissiveFactor;o.emissive=new Nt().setRGB(f[0],f[1],f[2],df)}return r.emissiveTexture!==void 0&&a!==fl&&u.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,og)),Promise.all(u).then(function(){const f=new a(o);return r.name&&(f.name=r.name),Yh(f,r),t.associations.set(f,{materials:e}),r.extensions&&Fm(i,f,r),f})}createUniqueName(e){const t=rs.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function r(o){return n[Vn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(l){return ZP(l,o,t)})}const a=[];for(let o=0,l=e.length;o<l;o++){const u=e[o],c=Kre(u),f=i[c];if(f)a.push(f.promise);else{let d;u.extensions&&u.extensions[Vn.KHR_DRACO_MESH_COMPRESSION]?d=r(u):d=ZP(new Tn,u,t),i[c]={primitive:u,promise:d},a.push(d)}}return Promise.all(a)}loadMesh(e){const t=this,n=this.json,i=this.extensions,r=n.meshes[e],a=r.primitives,o=[];for(let l=0,u=a.length;l<u;l++){const c=a[l].material===void 0?Xre(this.cache):this.getDependency("material",a[l].material);o.push(c)}return o.push(t.loadGeometries(a)),Promise.all(o).then(function(l){const u=l.slice(0,l.length-1),c=l[l.length-1],f=[];for(let g=0,x=c.length;g<x;g++){const S=c[g],b=a[g];let _;const T=u[g];if(b.mode===Jl.TRIANGLES||b.mode===Jl.TRIANGLE_STRIP||b.mode===Jl.TRIANGLE_FAN||b.mode===void 0)_=r.isSkinnedMesh===!0?new z3(S,T):new zi(S,T),_.isSkinnedMesh===!0&&_.normalizeSkinWeights(),b.mode===Jl.TRIANGLE_STRIP?_.geometry=WP(_.geometry,B3):b.mode===Jl.TRIANGLE_FAN&&(_.geometry=WP(_.geometry,T2));else if(b.mode===Jl.LINES)_=new lc(S,T);else if(b.mode===Jl.LINE_STRIP)_=new vf(S,T);else if(b.mode===Jl.LINE_LOOP)_=new H3(S,T);else if(b.mode===Jl.POINTS)_=new V3(S,T);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+b.mode);Object.keys(_.geometry.morphAttributes).length>0&&jre(_,r),_.name=t.createUniqueName(r.name||"mesh_"+e),Yh(_,r),b.extensions&&Fm(i,_,b),t.assignFinalMaterial(_),f.push(_)}for(let g=0,x=f.length;g<x;g++)t.associations.set(f[g],{meshes:e,primitives:g});if(f.length===1)return r.extensions&&Fm(i,f[0],r),f[0];const d=new of;r.extensions&&Fm(i,d,r),t.associations.set(d,{meshes:e});for(let g=0,x=f.length;g<x;g++)d.add(f[g]);return d})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new Ci(E9.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new ff(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Yh(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let i=0,r=t.joints.length;i<r;i++)n.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const r=i.pop(),a=i,o=[],l=[];for(let u=0,c=a.length;u<c;u++){const f=a[u];if(f){o.push(f);const d=new rn;r!==null&&d.fromArray(r.array,u*16),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[u])}return new s_(o,l)})}loadAnimation(e){const t=this.json,n=this,i=t.animations[e],r=i.name?i.name:"animation_"+e,a=[],o=[],l=[],u=[],c=[];for(let f=0,d=i.channels.length;f<d;f++){const g=i.channels[f],x=i.samplers[g.sampler],S=g.target,b=S.node,_=i.parameters!==void 0?i.parameters[x.input]:x.input,T=i.parameters!==void 0?i.parameters[x.output]:x.output;S.node!==void 0&&(a.push(this.getDependency("node",b)),o.push(this.getDependency("accessor",_)),l.push(this.getDependency("accessor",T)),u.push(x),c.push(S))}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(u),Promise.all(c)]).then(function(f){const d=f[0],g=f[1],x=f[2],S=f[3],b=f[4],_=[];for(let T=0,E=d.length;T<E;T++){const C=d[T],R=g[T],I=x[T],L=S[T],P=b[T];if(C===void 0)continue;C.updateMatrix&&C.updateMatrix();const D=n._createAnimationTracks(C,R,I,L,P);if(D)for(let O=0;O<D.length;O++)_.push(D[O])}return new fx(r,void 0,_)})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(r){const a=n._getNodeRef(n.meshCache,i.mesh,r);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,u=i.weights.length;l<u;l++)o.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const t=this.json,n=this,i=t.nodes[e],r=n._loadNodeShallow(e),a=[],o=i.children||[];for(let u=0,c=o.length;u<c;u++)a.push(n.getDependency("node",o[u]));const l=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([r,Promise.all(a),l]).then(function(u){const c=u[0],f=u[1],d=u[2];d!==null&&c.traverse(function(g){g.isSkinnedMesh&&g.bind(d,Jre)});for(let g=0,x=f.length;g<x;g++)c.add(f[g]);return c})}_loadNodeShallow(e){const t=this.json,n=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],a=r.name?i.createUniqueName(r.name):"",o=[],l=i._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&o.push(l),r.camera!==void 0&&o.push(i.getDependency("camera",r.camera).then(function(u){return i._getNodeRef(i.cameraCache,r.camera,u)})),i._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){o.push(u)}),this.nodeCache[e]=Promise.all(o).then(function(u){let c;if(r.isBone===!0?c=new kC:u.length>1?c=new of:u.length===1?c=u[0]:c=new ts,c!==u[0])for(let f=0,d=u.length;f<d;f++)c.add(u[f]);if(r.name&&(c.userData.name=r.name,c.name=a),Yh(c,r),r.extensions&&Fm(n,c,r),r.matrix!==void 0){const f=new rn;f.fromArray(r.matrix),c.applyMatrix4(f)}else r.translation!==void 0&&c.position.fromArray(r.translation),r.rotation!==void 0&&c.quaternion.fromArray(r.rotation),r.scale!==void 0&&c.scale.fromArray(r.scale);return i.associations.has(c)||i.associations.set(c,{}),i.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],i=this,r=new of;n.name&&(r.name=i.createUniqueName(n.name)),Yh(r,n),n.extensions&&Fm(t,r,n);const a=n.nodes||[],o=[];for(let l=0,u=a.length;l<u;l++)o.push(i.getDependency("node",a[l]));return Promise.all(o).then(function(l){for(let c=0,f=l.length;c<f;c++)r.add(l[c]);const u=c=>{const f=new Map;for(const[d,g]of i.associations)(d instanceof br||d instanceof ii)&&f.set(d,g);return c.traverse(d=>{const g=i.associations.get(d);g!=null&&f.set(d,g)}),f};return i.associations=u(r),r})}_createAnimationTracks(e,t,n,i,r){const a=[],o=e.name?e.name:e.uuid,l=[];Bd[r.path]===Bd.weights?e.traverse(function(d){d.morphTargetInfluences&&l.push(d.name?d.name:d.uuid)}):l.push(o);let u;switch(Bd[r.path]){case Bd.weights:u=wg;break;case Bd.rotation:u=Cg;break;case Bd.position:case Bd.scale:u=Eg;break;default:switch(n.itemSize){case 1:u=wg;break;case 2:case 3:default:u=Eg;break}break}const c=i.interpolation!==void 0?Wre[i.interpolation]:ox,f=this._getArrayFromAccessor(n);for(let d=0,g=l.length;d<g;d++){const x=new u(l[d]+"."+Bd[r.path],t.array,f,c);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(x),a.push(x)}return a}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=tD(t.constructor),i=new Float32Array(t.length);for(let r=0,a=t.length;r<a;r++)i[r]=t[r]*n;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const i=this instanceof Cg?Vre:n5;return new i(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Qre(s,e,t){const n=e.attributes,i=new Ea;if(n.POSITION!==void 0){const o=t.json.accessors[n.POSITION],l=o.min,u=o.max;if(l!==void 0&&u!==void 0){if(i.set(new ae(l[0],l[1],l[2]),new ae(u[0],u[1],u[2])),o.normalized){const c=tD(Vy[o.componentType]);i.min.multiplyScalar(c),i.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const o=new ae,l=new ae;for(let u=0,c=r.length;u<c;u++){const f=r[u];if(f.POSITION!==void 0){const d=t.json.accessors[f.POSITION],g=d.min,x=d.max;if(g!==void 0&&x!==void 0){if(l.setX(Math.max(Math.abs(g[0]),Math.abs(x[0]))),l.setY(Math.max(Math.abs(g[1]),Math.abs(x[1]))),l.setZ(Math.max(Math.abs(g[2]),Math.abs(x[2]))),d.normalized){const S=tD(Vy[d.componentType]);l.multiplyScalar(S)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}s.boundingBox=i;const a=new ea;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,s.boundingSphere=a}function ZP(s,e,t){const n=e.attributes,i=[];function r(a,o){return t.getDependency("accessor",a).then(function(l){s.setAttribute(o,l)})}for(const a in n){const o=eD[a]||a.toLowerCase();o in s.attributes||i.push(r(n[a],o))}if(e.indices!==void 0&&!s.index){const a=t.getDependency("accessor",e.indices).then(function(o){s.setIndex(o)});i.push(a)}return Yh(s,e),Qre(s,e,t),Promise.all(i).then(function(){return e.targets!==void 0?qre(s,e.targets,t):s})}const KR=new WeakMap;class eae extends Ia{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,i){const r=new vl(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,a=>{const o={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(a,o).then(t).catch(i)},n,i)}decodeDracoFile(e,t,n,i){const r={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(const l in t.attributeTypes){const u=t.attributeTypes[l];u.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[l]=u.name)}const n=JSON.stringify(t);if(KR.has(e)){const l=KR.get(e);if(l.key===n)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const r=this.workerNextTaskID++,a=e.byteLength,o=this._getWorker(r,a).then(l=>(i=l,new Promise((u,c)=>{i._callbacks[r]={resolve:u,reject:c},i.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return o.catch(()=>!0).then(()=>{i&&r&&this._releaseTask(i,r)}),KR.set(e,{key:n,promise:o}),o}_createGeometry(e){const t=new Tn;e.index&&t.setIndex(new us(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const i=e.attributes[n],r=i.name,a=i.array,o=i.itemSize;t.setAttribute(r,new us(a,o))}return t}_loadLibrary(e,t){const n=new vl(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((i,r)=>{n.load(e,i,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{const i=n[0];e||(this.decoderConfig.wasmBinary=n[1]);const r=tae.toString(),a=["/* draco decoder */",i,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([a]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(r){const a=r.data;switch(a.type){case"decode":i._callbacks[a.id].resolve(a);break;case"error":i._callbacks[a.id].reject(a);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+a.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,r){return i._taskLoad>r._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function tae(){let s,e;onmessage=function(a){const o=a.data;switch(o.type){case"init":s=o.decoderConfig,e=new Promise(function(c){s.onModuleLoaded=function(f){c({draco:f})},DracoDecoderModule(s)});break;case"decode":const l=o.buffer,u=o.taskConfig;e.then(c=>{const f=c.draco,d=new f.Decoder,g=new f.DecoderBuffer;g.Init(new Int8Array(l),l.byteLength);try{const x=t(f,d,g,u),S=x.attributes.map(b=>b.array.buffer);x.index&&S.push(x.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:x},S)}catch(x){console.error(x),self.postMessage({type:"error",id:o.id,error:x.message})}finally{f.destroy(g),f.destroy(d)}});break}};function t(a,o,l,u){const c=u.attributeIDs,f=u.attributeTypes;let d,g;const x=o.GetEncodedGeometryType(l);if(x===a.TRIANGULAR_MESH)d=new a.Mesh,g=o.DecodeBufferToMesh(l,d);else if(x===a.POINT_CLOUD)d=new a.PointCloud,g=o.DecodeBufferToPointCloud(l,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!g.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+g.error_msg());const S={index:null,attributes:[]};for(const b in c){const _=self[f[b]];let T,E;if(u.useUniqueIDs)E=c[b],T=o.GetAttributeByUniqueId(d,E);else{if(E=o.GetAttributeId(d,a[c[b]]),E===-1)continue;T=o.GetAttribute(d,E)}S.attributes.push(i(a,o,d,b,_,T))}return x===a.TRIANGULAR_MESH&&(S.index=n(a,o,d)),a.destroy(d),S}function n(a,o,l){const c=l.num_faces()*3,f=c*4,d=a._malloc(f);o.GetTrianglesUInt32Array(l,f,d);const g=new Uint32Array(a.HEAPF32.buffer,d,c).slice();return a._free(d),{array:g,itemSize:1}}function i(a,o,l,u,c,f){const d=f.num_components(),x=l.num_points()*d,S=x*c.BYTES_PER_ELEMENT,b=r(a,c),_=a._malloc(S);o.GetAttributeDataArrayForAllPoints(l,f,b,S,_);const T=new c(a.HEAPF32.buffer,_,x).slice();return a._free(_),{name:u,array:T,itemSize:d}}function r(a,o){switch(o){case Float32Array:return a.DT_FLOAT32;case Int8Array:return a.DT_INT8;case Int16Array:return a.DT_INT16;case Int32Array:return a.DT_INT32;case Uint8Array:return a.DT_UINT8;case Uint16Array:return a.DT_UINT16;case Uint32Array:return a.DT_UINT32}}}let nw;const YR=()=>{if(nw)return nw;const s="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),n=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let i=s;WebAssembly.validate(t)&&(i=e);let r;const a=WebAssembly.instantiate(o(i),{}).then(f=>{r=f.instance,r.exports.__wasm_call_ctors()});function o(f){const d=new Uint8Array(f.length);for(let x=0;x<f.length;++x){const S=f.charCodeAt(x);d[x]=S>96?S-71:S>64?S-65:S>47?S+4:S>46?63:62}let g=0;for(let x=0;x<f.length;++x)d[g++]=d[x]<60?n[d[x]]:(d[x]-60)*64+d[++x];return d.buffer.slice(0,g)}function l(f,d,g,x,S,b){const _=r.exports.sbrk,T=g+3&-4,E=_(T*x),C=_(S.length),R=new Uint8Array(r.exports.memory.buffer);R.set(S,C);const I=f(E,g,x,C,S.length);if(I===0&&b&&b(E,T,x),d.set(R.subarray(E,E+g*x)),_(E-_(0)),I!==0)throw new Error(`Malformed buffer data: ${I}`)}const u={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},c={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return nw={ready:a,supported:!0,decodeVertexBuffer(f,d,g,x,S){l(r.exports.meshopt_decodeVertexBuffer,f,d,g,x,r.exports[u[S]])},decodeIndexBuffer(f,d,g,x){l(r.exports.meshopt_decodeIndexBuffer,f,d,g,x)},decodeIndexSequence(f,d,g,x){l(r.exports.meshopt_decodeIndexSequence,f,d,g,x)},decodeGltfBuffer(f,d,g,x,S,b){l(r.exports[c[S]],f,d,g,x,r.exports[u[b]])}},nw};let sw=null,s5="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function i5(s=!0,e=!0,t){return n=>{t&&t(n),s&&(sw||(sw=new eae),sw.setDecoderPath(typeof s=="string"?s:s5),n.setDRACOLoader(sw)),e&&n.setMeshoptDecoder(typeof YR=="function"?YR():YR)}}const h_=(s,e,t,n)=>c_(xO,s,i5(e,t,n));h_.preload=(s,e,t,n)=>c_.preload(xO,s,i5(e,t,n));h_.clear=s=>c_.clear(xO,s);h_.setDecoderPath=s=>{s5=s};const nae=Me.forwardRef(({makeDefault:s,camera:e,regress:t,domElement:n,enableDamping:i=!0,keyEvents:r=!1,onChange:a,onStart:o,onEnd:l,...u},c)=>{const f=Od(I=>I.invalidate),d=Od(I=>I.camera),g=Od(I=>I.gl),x=Od(I=>I.events),S=Od(I=>I.setEvents),b=Od(I=>I.set),_=Od(I=>I.get),T=Od(I=>I.performance),E=e||d,C=n||x.connected||g.domElement,R=Me.useMemo(()=>new xre(E),[E]);return Fie(()=>{R.enabled&&R.update()},-1),Me.useEffect(()=>(r&&R.connect(r===!0?C:r),R.connect(C),()=>void R.dispose()),[r,C,t,R,f]),Me.useEffect(()=>{const I=D=>{f(),t&&T.regress(),a&&a(D)},L=D=>{o&&o(D)},P=D=>{l&&l(D)};return R.addEventListener("change",I),R.addEventListener("start",L),R.addEventListener("end",P),()=>{R.removeEventListener("start",L),R.removeEventListener("end",P),R.removeEventListener("change",I)}},[a,o,l,R,f,S]),Me.useEffect(()=>{if(s){const I=_().controls;return b({controls:R}),()=>b({controls:I})}},[s,R]),Me.createElement("primitive",QI({ref:c,object:R,enableDamping:i},u))});var r5={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},QP=Wd.createContext&&Wd.createContext(r5),sae=["attr","size","title"];function iae(s,e){if(s==null)return{};var t=rae(s,e),n,i;if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(s);for(i=0;i<r.length;i++)n=r[i],!(e.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(s,n)&&(t[n]=s[n])}return t}function rae(s,e){if(s==null)return{};var t={};for(var n in s)if(Object.prototype.hasOwnProperty.call(s,n)){if(e.indexOf(n)>=0)continue;t[n]=s[n]}return t}function O2(){return O2=Object.assign?Object.assign.bind():function(s){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(s[n]=t[n])}return s},O2.apply(this,arguments)}function eU(s,e){var t=Object.keys(s);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(s);e&&(n=n.filter(function(i){return Object.getOwnPropertyDescriptor(s,i).enumerable})),t.push.apply(t,n)}return t}function B2(s){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?eU(Object(t),!0).forEach(function(n){aae(s,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(t)):eU(Object(t)).forEach(function(n){Object.defineProperty(s,n,Object.getOwnPropertyDescriptor(t,n))})}return s}function aae(s,e,t){return e=oae(e),e in s?Object.defineProperty(s,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):s[e]=t,s}function oae(s){var e=lae(s,"string");return typeof e=="symbol"?e:e+""}function lae(s,e){if(typeof s!="object"||!s)return s;var t=s[Symbol.toPrimitive];if(t!==void 0){var n=t.call(s,e);if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(s)}function a5(s){return s&&s.map((e,t)=>Wd.createElement(e.tag,B2({key:t},e.attr),a5(e.child)))}function o5(s){return e=>Wd.createElement(uae,O2({attr:B2({},s.attr)},e),a5(s.child))}function uae(s){var e=t=>{var{attr:n,size:i,title:r}=s,a=iae(s,sae),o=i||t.size||"1em",l;return t.className&&(l=t.className),s.className&&(l=(l?l+" ":"")+s.className),Wd.createElement("svg",O2({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,n,a,{className:l,style:B2(B2({color:s.color||t.color},t.style),s.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),r&&Wd.createElement("title",null,r),s.children)};return QP!==void 0?Wd.createElement(QP.Consumer,null,t=>e(t)):e(r5)}function cae(s){return o5({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 64C110.06 64 0 125.91 0 208v98.13C0 384.48 114.62 448 256 448s256-63.52 256-141.87V208c0-82.09-110.06-144-256-144zm0 64c106.04 0 192 35.82 192 80 0 9.26-3.97 18.12-10.91 26.39C392.15 208.21 328.23 192 256 192s-136.15 16.21-181.09 42.39C67.97 226.12 64 217.26 64 208c0-44.18 85.96-80 192-80zM120.43 264.64C155.04 249.93 201.64 240 256 240s100.96 9.93 135.57 24.64C356.84 279.07 308.93 288 256 288s-100.84-8.93-135.57-23.36z"},child:[]}]})(s)}function hae(s){return o5({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M212.333 224.333H12c-6.627 0-12-5.373-12-12V12C0 5.373 5.373 0 12 0h48c6.627 0 12 5.373 12 12v78.112C117.773 39.279 184.26 7.47 258.175 8.007c136.906.994 246.448 111.623 246.157 248.532C504.041 393.258 393.12 504 256.333 504c-64.089 0-122.496-24.313-166.51-64.215-5.099-4.622-5.334-12.554-.467-17.42l33.967-33.967c4.474-4.474 11.662-4.717 16.401-.525C170.76 415.336 211.58 432 256.333 432c97.268 0 176-78.716 176-176 0-97.267-78.716-176-176-176-58.496 0-110.28 28.476-142.274 72.333h98.274c6.627 0 12 5.373 12 12v48c0 6.627-5.373 12-12 12z"},child:[]}]})(s)}function fae({skinColor:s,hairColor:e,eyeColor:t,...n}){const{scene:i}=h_("/project-3d-reconstructie-van-een-mesolithische-vrouw-mohamadmatar7/models/woman.glb");return Me.useEffect(()=>{i.traverse(r=>{console.log("child",r.name),r.isMesh&&(r.material=r.material.clone(),r.name==="Object_8"&&r.material.color.set(s),(r.name==="Object_4"||r.name==="Object_6"||r.name==="hair_line_1"||r.name==="hair_1_0")&&r.material.color.set(e),r.name==="Sketchfab_Scene"&&r.material.color.set(t))})},[i,s,e,t]),ft.jsx("primitive",{object:i,...n})}function JR({label:s,value:e,onChange:t,options:n,type:i="picker"}){if(i==="slider"){const r=`linear-gradient(to right, ${n.join(",")})`;return ft.jsxs("div",{className:"flex flex-col gap-2 w-full",children:[ft.jsx("label",{className:"text-sm font-semibold text-[#EEBD74]",style:{textShadow:"1px 1px 2px black"},children:s}),ft.jsx("input",{type:"range",min:"0",max:n.length-1,step:"0.01",value:e,onChange:a=>t(a.target.value),className:"w-full h-3 rounded-lg appearance-none cursor-pointer border-2 border-gray-300",style:{background:r}})]})}return ft.jsxs("div",{className:"flex flex-col gap-2 w-full",children:[ft.jsx("label",{className:"text-sm font-semibold text-[#EEBD74]",style:{textShadow:"1px 1px 2px black"},children:s}),"      ",ft.jsx("div",{className:"flex flex-wrap gap-3",children:n.map(r=>ft.jsx("button",{onClick:()=>t(r),className:`w-10 h-10 rounded-full border-2 shadow-sm transition-transform duration-200 ease-in-out hover:scale-110 ${e===r?"ring-2 ring-offset-2 ring-black":"border-gray-300"}`,style:{backgroundColor:r},"aria-label":`${s} ${r}`},r))})]})}function Jh(s){if(s===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return s}function l5(s,e){s.prototype=Object.create(e.prototype),s.prototype.constructor=s,s.__proto__=e}/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var yl={autoSleep:120,force3D:"auto",nullTargetWarn:1,units:{lineHeight:""}},px={duration:.5,overwrite:!1,delay:0},vO,ta,ni,ih=1e8,Ca=1/ih,nD=Math.PI*2,dae=nD/4,pae=0,u5=Math.sqrt,mae=Math.cos,gae=Math.sin,Lr=function(e){return typeof e=="string"},Ei=function(e){return typeof e=="function"},bf=function(e){return typeof e=="number"},bO=function(e){return typeof e>"u"},fh=function(e){return typeof e=="object"},No=function(e){return e!==!1},_O=function(){return typeof window<"u"},iw=function(e){return Ei(e)||Lr(e)},c5=typeof ArrayBuffer=="function"&&ArrayBuffer.isView||function(){},Ma=Array.isArray,sD=/(?:-?\.?\d|\.)+/gi,h5=/[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,$y=/[-+=.]*\d+[.e-]*\d*[a-z%]*/g,ZR=/[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,f5=/[+-]=-?[.\d]+/,d5=/[^,'"\[\]\s]+/gi,yae=/^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,hi,jc,iD,SO,bl={},k2={},p5,m5=function(e){return(k2=mx(e,bl))&&Bo},AO=function(e,t){return console.warn("Invalid property",e,"set to",t,"Missing plugin? gsap.registerPlugin()")},wb=function(e,t){return!t&&console.warn(e)},g5=function(e,t){return e&&(bl[e]=t)&&k2&&(k2[e]=t)||bl},Cb=function(){return 0},xae={suppressEvents:!0,isStart:!0,kill:!1},Mw={suppressEvents:!0,kill:!1},vae={suppressEvents:!0},TO={},qd=[],rD={},y5,ll={},QR={},tU=30,Nw=[],wO="",CO=function(e){var t=e[0],n,i;if(fh(t)||Ei(t)||(e=[e]),!(n=(t._gsap||{}).harness)){for(i=Nw.length;i--&&!Nw[i].targetTest(t););n=Nw[i]}for(i=e.length;i--;)e[i]&&(e[i]._gsap||(e[i]._gsap=new z5(e[i],n)))||e.splice(i,1);return e},pg=function(e){return e._gsap||CO(nu(e))[0]._gsap},x5=function(e,t,n){return(n=e[t])&&Ei(n)?e[t]():bO(n)&&e.getAttribute&&e.getAttribute(t)||n},Ro=function(e,t){return(e=e.split(",")).forEach(t)||e},Ui=function(e){return Math.round(e*1e5)/1e5||0},Zi=function(e){return Math.round(e*1e7)/1e7||0},Wy=function(e,t){var n=t.charAt(0),i=parseFloat(t.substr(2));return e=parseFloat(e),n==="+"?e+i:n==="-"?e-i:n==="*"?e*i:e/i},bae=function(e,t){for(var n=t.length,i=0;e.indexOf(t[i])<0&&++i<n;);return i<n},L2=function(){var e=qd.length,t=qd.slice(0),n,i;for(rD={},qd.length=0,n=0;n<e;n++)i=t[n],i&&i._lazy&&(i.render(i._lazy[0],i._lazy[1],!0)._lazy=0)},v5=function(e,t,n,i){qd.length&&!ta&&L2(),e.render(t,n,ta&&t<0&&(e._initted||e._startAt)),qd.length&&!ta&&L2()},b5=function(e){var t=parseFloat(e);return(t||t===0)&&(e+"").match(d5).length<2?t:Lr(e)?e.trim():e},_5=function(e){return e},_l=function(e,t){for(var n in t)n in e||(e[n]=t[n]);return e},_ae=function(e){return function(t,n){for(var i in n)i in t||i==="duration"&&e||i==="ease"||(t[i]=n[i])}},mx=function(e,t){for(var n in t)e[n]=t[n];return e},nU=function s(e,t){for(var n in t)n!=="__proto__"&&n!=="constructor"&&n!=="prototype"&&(e[n]=fh(t[n])?s(e[n]||(e[n]={}),t[n]):t[n]);return e},F2=function(e,t){var n={},i;for(i in e)i in t||(n[i]=e[i]);return n},ob=function(e){var t=e.parent||hi,n=e.keyframes?_ae(Ma(e.keyframes)):_l;if(No(e.inherit))for(;t;)n(e,t.vars.defaults),t=t.parent||t._dp;return e},Sae=function(e,t){for(var n=e.length,i=n===t.length;i&&n--&&e[n]===t[n];);return n<0},S5=function(e,t,n,i,r){var a=e[i],o;if(r)for(o=t[r];a&&a[r]>o;)a=a._prev;return a?(t._next=a._next,a._next=t):(t._next=e[n],e[n]=t),t._next?t._next._prev=t:e[i]=t,t._prev=a,t.parent=t._dp=e,t},eE=function(e,t,n,i){n===void 0&&(n="_first"),i===void 0&&(i="_last");var r=t._prev,a=t._next;r?r._next=a:e[n]===t&&(e[n]=a),a?a._prev=r:e[i]===t&&(e[i]=r),t._next=t._prev=t.parent=null},ip=function(e,t){e.parent&&(!t||e.parent.autoRemoveChildren)&&e.parent.remove&&e.parent.remove(e),e._act=0},mg=function(e,t){if(e&&(!t||t._end>e._dur||t._start<0))for(var n=e;n;)n._dirty=1,n=n.parent;return e},Aae=function(e){for(var t=e.parent;t&&t.parent;)t._dirty=1,t.totalDuration(),t=t.parent;return e},aD=function(e,t,n,i){return e._startAt&&(ta?e._startAt.revert(Mw):e.vars.immediateRender&&!e.vars.autoRevert||e._startAt.render(t,!0,i))},Tae=function s(e){return!e||e._ts&&s(e.parent)},sU=function(e){return e._repeat?gx(e._tTime,e=e.duration()+e._rDelay)*e:0},gx=function(e,t){var n=Math.floor(e=Zi(e/t));return e&&n===e?n-1:n},P2=function(e,t){return(e-t._start)*t._ts+(t._ts>=0?0:t._dirty?t.totalDuration():t._tDur)},tE=function(e){return e._end=Zi(e._start+(e._tDur/Math.abs(e._ts||e._rts||Ca)||0))},nE=function(e,t){var n=e._dp;return n&&n.smoothChildTiming&&e._ts&&(e._start=Zi(n._time-(e._ts>0?t/e._ts:((e._dirty?e.totalDuration():e._tDur)-t)/-e._ts)),tE(e),n._dirty||mg(n,e)),e},A5=function(e,t){var n;if((t._time||!t._dur&&t._initted||t._start<e._time&&(t._dur||!t.add))&&(n=P2(e.rawTime(),t),(!t._dur||f_(0,t.totalDuration(),n)-t._tTime>Ca)&&t.render(n,!0)),mg(e,t)._dp&&e._initted&&e._time>=e._dur&&e._ts){if(e._dur<e.duration())for(n=e;n._dp;)n.rawTime()>=0&&n.totalTime(n._tTime),n=n._dp;e._zTime=-1e-8}},Zc=function(e,t,n,i){return t.parent&&ip(t),t._start=Zi((bf(n)?n:n||e!==hi?Yl(e,n,t):e._time)+t._delay),t._end=Zi(t._start+(t.totalDuration()/Math.abs(t.timeScale())||0)),S5(e,t,"_first","_last",e._sort?"_start":0),oD(t)||(e._recent=t),i||A5(e,t),e._ts<0&&nE(e,e._tTime),e},T5=function(e,t){return(bl.ScrollTrigger||AO("scrollTrigger",t))&&bl.ScrollTrigger.create(t,e)},w5=function(e,t,n,i,r){if(MO(e,t,r),!e._initted)return 1;if(!n&&e._pt&&!ta&&(e._dur&&e.vars.lazy!==!1||!e._dur&&e.vars.lazy)&&y5!==ul.frame)return qd.push(e),e._lazy=[r,i],1},wae=function s(e){var t=e.parent;return t&&t._ts&&t._initted&&!t._lock&&(t.rawTime()<0||s(t))},oD=function(e){var t=e.data;return t==="isFromStart"||t==="isStart"},Cae=function(e,t,n,i){var r=e.ratio,a=t<0||!t&&(!e._start&&wae(e)&&!(!e._initted&&oD(e))||(e._ts<0||e._dp._ts<0)&&!oD(e))?0:1,o=e._rDelay,l=0,u,c,f;if(o&&e._repeat&&(l=f_(0,e._tDur,t),c=gx(l,o),e._yoyo&&c&1&&(a=1-a),c!==gx(e._tTime,o)&&(r=1-a,e.vars.repeatRefresh&&e._initted&&e.invalidate())),a!==r||ta||i||e._zTime===Ca||!t&&e._zTime){if(!e._initted&&w5(e,t,i,n,l))return;for(f=e._zTime,e._zTime=t||(n?Ca:0),n||(n=t&&!f),e.ratio=a,e._from&&(a=1-a),e._time=0,e._tTime=l,u=e._pt;u;)u.r(a,u.d),u=u._next;t<0&&aD(e,t,n,!0),e._onUpdate&&!n&&dl(e,"onUpdate"),l&&e._repeat&&!n&&e.parent&&dl(e,"onRepeat"),(t>=e._tDur||t<0)&&e.ratio===a&&(a&&ip(e,1),!n&&!ta&&(dl(e,a?"onComplete":"onReverseComplete",!0),e._prom&&e._prom()))}else e._zTime||(e._zTime=t)},Eae=function(e,t,n){var i;if(n>t)for(i=e._first;i&&i._start<=n;){if(i.data==="isPause"&&i._start>t)return i;i=i._next}else for(i=e._last;i&&i._start>=n;){if(i.data==="isPause"&&i._start<t)return i;i=i._prev}},yx=function(e,t,n,i){var r=e._repeat,a=Zi(t)||0,o=e._tTime/e._tDur;return o&&!i&&(e._time*=a/e._dur),e._dur=a,e._tDur=r?r<0?1e10:Zi(a*(r+1)+e._rDelay*r):a,o>0&&!i&&nE(e,e._tTime=e._tDur*o),e.parent&&tE(e),n||mg(e.parent,e),e},iU=function(e){return e instanceof to?mg(e):yx(e,e._dur)},Mae={_start:0,endTime:Cb,totalDuration:Cb},Yl=function s(e,t,n){var i=e.labels,r=e._recent||Mae,a=e.duration()>=ih?r.endTime(!1):e._dur,o,l,u;return Lr(t)&&(isNaN(t)||t in i)?(l=t.charAt(0),u=t.substr(-1)==="%",o=t.indexOf("="),l==="<"||l===">"?(o>=0&&(t=t.replace(/=/,"")),(l==="<"?r._start:r.endTime(r._repeat>=0))+(parseFloat(t.substr(1))||0)*(u?(o<0?r:n).totalDuration()/100:1)):o<0?(t in i||(i[t]=a),i[t]):(l=parseFloat(t.charAt(o-1)+t.substr(o+1)),u&&n&&(l=l/100*(Ma(n)?n[0]:n).totalDuration()),o>1?s(e,t.substr(0,o-1),n)+l:a+l)):t==null?a:+t},lb=function(e,t,n){var i=bf(t[1]),r=(i?2:1)+(e<2?0:1),a=t[r],o,l;if(i&&(a.duration=t[1]),a.parent=n,e){for(o=a,l=n;l&&!("immediateRender"in o);)o=l.vars.defaults||{},l=No(l.vars.inherit)&&l.parent;a.immediateRender=No(o.immediateRender),e<2?a.runBackwards=1:a.startAt=t[r-1]}return new Yi(t[0],a,t[r+1])},vp=function(e,t){return e||e===0?t(e):t},f_=function(e,t,n){return n<e?e:n>t?t:n},Aa=function(e,t){return!Lr(e)||!(t=yae.exec(e))?"":t[1]},Nae=function(e,t,n){return vp(n,function(i){return f_(e,t,i)})},lD=[].slice,C5=function(e,t){return e&&fh(e)&&"length"in e&&(!t&&!e.length||e.length-1 in e&&fh(e[0]))&&!e.nodeType&&e!==jc},Rae=function(e,t,n){return n===void 0&&(n=[]),e.forEach(function(i){var r;return Lr(i)&&!t||C5(i,1)?(r=n).push.apply(r,nu(i)):n.push(i)})||n},nu=function(e,t,n){return ni&&!t&&ni.selector?ni.selector(e):Lr(e)&&!n&&(iD||!xx())?lD.call((t||SO).querySelectorAll(e),0):Ma(e)?Rae(e,n):C5(e)?lD.call(e,0):e?[e]:[]},uD=function(e){return e=nu(e)[0]||wb("Invalid scope")||{},function(t){var n=e.current||e.nativeElement||e;return nu(t,n.querySelectorAll?n:n===e?wb("Invalid scope")||SO.createElement("div"):e)}},E5=function(e){return e.sort(function(){return .5-Math.random()})},M5=function(e){if(Ei(e))return e;var t=fh(e)?e:{each:e},n=gg(t.ease),i=t.from||0,r=parseFloat(t.base)||0,a={},o=i>0&&i<1,l=isNaN(i)||o,u=t.axis,c=i,f=i;return Lr(i)?c=f={center:.5,edges:.5,end:1}[i]||0:!o&&l&&(c=i[0],f=i[1]),function(d,g,x){var S=(x||t).length,b=a[S],_,T,E,C,R,I,L,P,D;if(!b){if(D=t.grid==="auto"?0:(t.grid||[1,ih])[1],!D){for(L=-1e8;L<(L=x[D++].getBoundingClientRect().left)&&D<S;);D<S&&D--}for(b=a[S]=[],_=l?Math.min(D,S)*c-.5:i%D,T=D===ih?0:l?S*f/D-.5:i/D|0,L=0,P=ih,I=0;I<S;I++)E=I%D-_,C=T-(I/D|0),b[I]=R=u?Math.abs(u==="y"?C:E):u5(E*E+C*C),R>L&&(L=R),R<P&&(P=R);i==="random"&&E5(b),b.max=L-P,b.min=P,b.v=S=(parseFloat(t.amount)||parseFloat(t.each)*(D>S?S-1:u?u==="y"?S/D:D:Math.max(D,S/D))||0)*(i==="edges"?-1:1),b.b=S<0?r-S:r,b.u=Aa(t.amount||t.each)||0,n=n&&S<0?P5(n):n}return S=(b[d]-b.min)/b.max||0,Zi(b.b+(n?n(S):S)*b.v)+b.u}},cD=function(e){var t=Math.pow(10,((e+"").split(".")[1]||"").length);return function(n){var i=Zi(Math.round(parseFloat(n)/e)*e*t);return(i-i%1)/t+(bf(n)?0:Aa(n))}},N5=function(e,t){var n=Ma(e),i,r;return!n&&fh(e)&&(i=n=e.radius||ih,e.values?(e=nu(e.values),(r=!bf(e[0]))&&(i*=i)):e=cD(e.increment)),vp(t,n?Ei(e)?function(a){return r=e(a),Math.abs(r-a)<=i?r:a}:function(a){for(var o=parseFloat(r?a.x:a),l=parseFloat(r?a.y:0),u=ih,c=0,f=e.length,d,g;f--;)r?(d=e[f].x-o,g=e[f].y-l,d=d*d+g*g):d=Math.abs(e[f]-o),d<u&&(u=d,c=f);return c=!i||u<=i?e[c]:a,r||c===a||bf(a)?c:c+Aa(a)}:cD(e))},R5=function(e,t,n,i){return vp(Ma(e)?!t:n===!0?!!(n=0):!i,function(){return Ma(e)?e[~~(Math.random()*e.length)]:(n=n||1e-5)&&(i=n<1?Math.pow(10,(n+"").length-2):1)&&Math.floor(Math.round((e-n/2+Math.random()*(t-e+n*.99))/n)*n*i)/i})},Iae=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(i){return t.reduce(function(r,a){return a(r)},i)}},Dae=function(e,t){return function(n){return e(parseFloat(n))+(t||Aa(n))}},Oae=function(e,t,n){return D5(e,t,0,1,n)},I5=function(e,t,n){return vp(n,function(i){return e[~~t(i)]})},Bae=function s(e,t,n){var i=t-e;return Ma(e)?I5(e,s(0,e.length),t):vp(n,function(r){return(i+(r-e)%i)%i+e})},kae=function s(e,t,n){var i=t-e,r=i*2;return Ma(e)?I5(e,s(0,e.length-1),t):vp(n,function(a){return a=(r+(a-e)%r)%r||0,e+(a>i?r-a:a)})},Eb=function(e){for(var t=0,n="",i,r,a,o;~(i=e.indexOf("random(",t));)a=e.indexOf(")",i),o=e.charAt(i+7)==="[",r=e.substr(i+7,a-i-7).match(o?d5:sD),n+=e.substr(t,i-t)+R5(o?r:+r[0],o?0:+r[1],+r[2]||1e-5),t=a+1;return n+e.substr(t,e.length-t)},D5=function(e,t,n,i,r){var a=t-e,o=i-n;return vp(r,function(l){return n+((l-e)/a*o||0)})},Lae=function s(e,t,n,i){var r=isNaN(e+t)?0:function(g){return(1-g)*e+g*t};if(!r){var a=Lr(e),o={},l,u,c,f,d;if(n===!0&&(i=1)&&(n=null),a)e={p:e},t={p:t};else if(Ma(e)&&!Ma(t)){for(c=[],f=e.length,d=f-2,u=1;u<f;u++)c.push(s(e[u-1],e[u]));f--,r=function(x){x*=f;var S=Math.min(d,~~x);return c[S](x-S)},n=t}else i||(e=mx(Ma(e)?[]:{},e));if(!c){for(l in t)EO.call(o,e,l,"get",t[l]);r=function(x){return IO(x,o)||(a?e.p:e)}}}return vp(n,r)},rU=function(e,t,n){var i=e.labels,r=ih,a,o,l;for(a in i)o=i[a]-t,o<0==!!n&&o&&r>(o=Math.abs(o))&&(l=a,r=o);return l},dl=function(e,t,n){var i=e.vars,r=i[t],a=ni,o=e._ctx,l,u,c;if(r)return l=i[t+"Params"],u=i.callbackScope||e,n&&qd.length&&L2(),o&&(ni=o),c=l?r.apply(u,l):r.call(u),ni=a,c},H1=function(e){return ip(e),e.scrollTrigger&&e.scrollTrigger.kill(!!ta),e.progress()<1&&dl(e,"onInterrupt"),e},zy,O5=[],B5=function(e){if(e)if(e=!e.name&&e.default||e,_O()||e.headless){var t=e.name,n=Ei(e),i=t&&!n&&e.init?function(){this._props=[]}:e,r={init:Cb,render:IO,add:EO,kill:Zae,modifier:Jae,rawVars:0},a={targetTest:0,get:0,getSetter:RO,aliases:{},register:0};if(xx(),e!==i){if(ll[t])return;_l(i,_l(F2(e,r),a)),mx(i.prototype,mx(r,F2(e,a))),ll[i.prop=t]=i,e.targetTest&&(Nw.push(i),TO[t]=1),t=(t==="css"?"CSS":t.charAt(0).toUpperCase()+t.substr(1))+"Plugin"}g5(t,i),e.register&&e.register(Bo,i,Io)}else O5.push(e)},Fs=255,V1={aqua:[0,Fs,Fs],lime:[0,Fs,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,Fs],navy:[0,0,128],white:[Fs,Fs,Fs],olive:[128,128,0],yellow:[Fs,Fs,0],orange:[Fs,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[Fs,0,0],pink:[Fs,192,203],cyan:[0,Fs,Fs],transparent:[Fs,Fs,Fs,0]},eI=function(e,t,n){return e+=e<0?1:e>1?-1:0,(e*6<1?t+(n-t)*e*6:e<.5?n:e*3<2?t+(n-t)*(2/3-e)*6:t)*Fs+.5|0},k5=function(e,t,n){var i=e?bf(e)?[e>>16,e>>8&Fs,e&Fs]:0:V1.black,r,a,o,l,u,c,f,d,g,x;if(!i){if(e.substr(-1)===","&&(e=e.substr(0,e.length-1)),V1[e])i=V1[e];else if(e.charAt(0)==="#"){if(e.length<6&&(r=e.charAt(1),a=e.charAt(2),o=e.charAt(3),e="#"+r+r+a+a+o+o+(e.length===5?e.charAt(4)+e.charAt(4):"")),e.length===9)return i=parseInt(e.substr(1,6),16),[i>>16,i>>8&Fs,i&Fs,parseInt(e.substr(7),16)/255];e=parseInt(e.substr(1),16),i=[e>>16,e>>8&Fs,e&Fs]}else if(e.substr(0,3)==="hsl"){if(i=x=e.match(sD),!t)l=+i[0]%360/360,u=+i[1]/100,c=+i[2]/100,a=c<=.5?c*(u+1):c+u-c*u,r=c*2-a,i.length>3&&(i[3]*=1),i[0]=eI(l+1/3,r,a),i[1]=eI(l,r,a),i[2]=eI(l-1/3,r,a);else if(~e.indexOf("="))return i=e.match(h5),n&&i.length<4&&(i[3]=1),i}else i=e.match(sD)||V1.transparent;i=i.map(Number)}return t&&!x&&(r=i[0]/Fs,a=i[1]/Fs,o=i[2]/Fs,f=Math.max(r,a,o),d=Math.min(r,a,o),c=(f+d)/2,f===d?l=u=0:(g=f-d,u=c>.5?g/(2-f-d):g/(f+d),l=f===r?(a-o)/g+(a<o?6:0):f===a?(o-r)/g+2:(r-a)/g+4,l*=60),i[0]=~~(l+.5),i[1]=~~(u*100+.5),i[2]=~~(c*100+.5)),n&&i.length<4&&(i[3]=1),i},L5=function(e){var t=[],n=[],i=-1;return e.split(jd).forEach(function(r){var a=r.match($y)||[];t.push.apply(t,a),n.push(i+=a.length+1)}),t.c=n,t},aU=function(e,t,n){var i="",r=(e+i).match(jd),a=t?"hsla(":"rgba(",o=0,l,u,c,f;if(!r)return e;if(r=r.map(function(d){return(d=k5(d,t,1))&&a+(t?d[0]+","+d[1]+"%,"+d[2]+"%,"+d[3]:d.join(","))+")"}),n&&(c=L5(e),l=n.c,l.join(i)!==c.c.join(i)))for(u=e.replace(jd,"1").split($y),f=u.length-1;o<f;o++)i+=u[o]+(~l.indexOf(o)?r.shift()||a+"0,0,0,0)":(c.length?c:r.length?r:n).shift());if(!u)for(u=e.split(jd),f=u.length-1;o<f;o++)i+=u[o]+r[o];return i+u[f]},jd=function(){var s="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",e;for(e in V1)s+="|"+e+"\\b";return new RegExp(s+")","gi")}(),Fae=/hsl[a]?\(/,F5=function(e){var t=e.join(" "),n;if(jd.lastIndex=0,jd.test(t))return n=Fae.test(t),e[1]=aU(e[1],n),e[0]=aU(e[0],n,L5(e[1])),!0},Mb,ul=function(){var s=Date.now,e=500,t=33,n=s(),i=n,r=1e3/240,a=r,o=[],l,u,c,f,d,g,x=function S(b){var _=s()-i,T=b===!0,E,C,R,I;if((_>e||_<0)&&(n+=_-t),i+=_,R=i-n,E=R-a,(E>0||T)&&(I=++f.frame,d=R-f.time*1e3,f.time=R=R/1e3,a+=E+(E>=r?4:r-E),C=1),T||(l=u(S)),C)for(g=0;g<o.length;g++)o[g](R,d,I,b)};return f={time:0,frame:0,tick:function(){x(!0)},deltaRatio:function(b){return d/(1e3/(b||60))},wake:function(){p5&&(!iD&&_O()&&(jc=iD=window,SO=jc.document||{},bl.gsap=Bo,(jc.gsapVersions||(jc.gsapVersions=[])).push(Bo.version),m5(k2||jc.GreenSockGlobals||!jc.gsap&&jc||{}),O5.forEach(B5)),c=typeof requestAnimationFrame<"u"&&requestAnimationFrame,l&&f.sleep(),u=c||function(b){return setTimeout(b,a-f.time*1e3+1|0)},Mb=1,x(2))},sleep:function(){(c?cancelAnimationFrame:clearTimeout)(l),Mb=0,u=Cb},lagSmoothing:function(b,_){e=b||1/0,t=Math.min(_||33,e)},fps:function(b){r=1e3/(b||240),a=f.time*1e3+r},add:function(b,_,T){var E=_?function(C,R,I,L){b(C,R,I,L),f.remove(E)}:b;return f.remove(b),o[T?"unshift":"push"](E),xx(),E},remove:function(b,_){~(_=o.indexOf(b))&&o.splice(_,1)&&g>=_&&g--},_listeners:o},f}(),xx=function(){return!Mb&&ul.wake()},es={},Pae=/^[\d.\-M][\d.\-,\s]/,Uae=/["']/g,$ae=function(e){for(var t={},n=e.substr(1,e.length-3).split(":"),i=n[0],r=1,a=n.length,o,l,u;r<a;r++)l=n[r],o=r!==a-1?l.lastIndexOf(","):l.length,u=l.substr(0,o),t[i]=isNaN(u)?u.replace(Uae,"").trim():+u,i=l.substr(o+1).trim();return t},zae=function(e){var t=e.indexOf("(")+1,n=e.indexOf(")"),i=e.indexOf("(",t);return e.substring(t,~i&&i<n?e.indexOf(")",n+1):n)},Gae=function(e){var t=(e+"").split("("),n=es[t[0]];return n&&t.length>1&&n.config?n.config.apply(null,~e.indexOf("{")?[$ae(t[1])]:zae(e).split(",").map(b5)):es._CE&&Pae.test(e)?es._CE("",e):n},P5=function(e){return function(t){return 1-e(1-t)}},U5=function s(e,t){for(var n=e._first,i;n;)n instanceof to?s(n,t):n.vars.yoyoEase&&(!n._yoyo||!n._repeat)&&n._yoyo!==t&&(n.timeline?s(n.timeline,t):(i=n._ease,n._ease=n._yEase,n._yEase=i,n._yoyo=t)),n=n._next},gg=function(e,t){return e&&(Ei(e)?e:es[e]||Gae(e))||t},Yg=function(e,t,n,i){n===void 0&&(n=function(l){return 1-t(1-l)}),i===void 0&&(i=function(l){return l<.5?t(l*2)/2:1-t((1-l)*2)/2});var r={easeIn:t,easeOut:n,easeInOut:i},a;return Ro(e,function(o){es[o]=bl[o]=r,es[a=o.toLowerCase()]=n;for(var l in r)es[a+(l==="easeIn"?".in":l==="easeOut"?".out":".inOut")]=es[o+"."+l]=r[l]}),r},$5=function(e){return function(t){return t<.5?(1-e(1-t*2))/2:.5+e((t-.5)*2)/2}},tI=function s(e,t,n){var i=t>=1?t:1,r=(n||(e?.3:.45))/(t<1?t:1),a=r/nD*(Math.asin(1/i)||0),o=function(c){return c===1?1:i*Math.pow(2,-10*c)*gae((c-a)*r)+1},l=e==="out"?o:e==="in"?function(u){return 1-o(1-u)}:$5(o);return r=nD/r,l.config=function(u,c){return s(e,u,c)},l},nI=function s(e,t){t===void 0&&(t=1.70158);var n=function(a){return a?--a*a*((t+1)*a+t)+1:0},i=e==="out"?n:e==="in"?function(r){return 1-n(1-r)}:$5(n);return i.config=function(r){return s(e,r)},i};Ro("Linear,Quad,Cubic,Quart,Quint,Strong",function(s,e){var t=e<5?e+1:e;Yg(s+",Power"+(t-1),e?function(n){return Math.pow(n,t)}:function(n){return n},function(n){return 1-Math.pow(1-n,t)},function(n){return n<.5?Math.pow(n*2,t)/2:1-Math.pow((1-n)*2,t)/2})});es.Linear.easeNone=es.none=es.Linear.easeIn;Yg("Elastic",tI("in"),tI("out"),tI());(function(s,e){var t=1/e,n=2*t,i=2.5*t,r=function(o){return o<t?s*o*o:o<n?s*Math.pow(o-1.5/e,2)+.75:o<i?s*(o-=2.25/e)*o+.9375:s*Math.pow(o-2.625/e,2)+.984375};Yg("Bounce",function(a){return 1-r(1-a)},r)})(7.5625,2.75);Yg("Expo",function(s){return Math.pow(2,10*(s-1))*s+s*s*s*s*s*s*(1-s)});Yg("Circ",function(s){return-(u5(1-s*s)-1)});Yg("Sine",function(s){return s===1?1:-mae(s*dae)+1});Yg("Back",nI("in"),nI("out"),nI());es.SteppedEase=es.steps=bl.SteppedEase={config:function(e,t){e===void 0&&(e=1);var n=1/e,i=e+(t?0:1),r=t?1:0,a=1-Ca;return function(o){return((i*f_(0,a,o)|0)+r)*n}}};px.ease=es["quad.out"];Ro("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",function(s){return wO+=s+","+s+"Params,"});var z5=function(e,t){this.id=pae++,e._gsap=this,this.target=e,this.harness=t,this.get=t?t.get:x5,this.set=t?t.getSetter:RO},Nb=function(){function s(t){this.vars=t,this._delay=+t.delay||0,(this._repeat=t.repeat===1/0?-2:t.repeat||0)&&(this._rDelay=t.repeatDelay||0,this._yoyo=!!t.yoyo||!!t.yoyoEase),this._ts=1,yx(this,+t.duration,1,1),this.data=t.data,ni&&(this._ctx=ni,ni.data.push(this)),Mb||ul.wake()}var e=s.prototype;return e.delay=function(n){return n||n===0?(this.parent&&this.parent.smoothChildTiming&&this.startTime(this._start+n-this._delay),this._delay=n,this):this._delay},e.duration=function(n){return arguments.length?this.totalDuration(this._repeat>0?n+(n+this._rDelay)*this._repeat:n):this.totalDuration()&&this._dur},e.totalDuration=function(n){return arguments.length?(this._dirty=0,yx(this,this._repeat<0?n:(n-this._repeat*this._rDelay)/(this._repeat+1))):this._tDur},e.totalTime=function(n,i){if(xx(),!arguments.length)return this._tTime;var r=this._dp;if(r&&r.smoothChildTiming&&this._ts){for(nE(this,n),!r._dp||r.parent||A5(r,this);r&&r.parent;)r.parent._time!==r._start+(r._ts>=0?r._tTime/r._ts:(r.totalDuration()-r._tTime)/-r._ts)&&r.totalTime(r._tTime,!0),r=r.parent;!this.parent&&this._dp.autoRemoveChildren&&(this._ts>0&&n<this._tDur||this._ts<0&&n>0||!this._tDur&&!n)&&Zc(this._dp,this,this._start-this._delay)}return(this._tTime!==n||!this._dur&&!i||this._initted&&Math.abs(this._zTime)===Ca||!n&&!this._initted&&(this.add||this._ptLookup))&&(this._ts||(this._pTime=n),v5(this,n,i)),this},e.time=function(n,i){return arguments.length?this.totalTime(Math.min(this.totalDuration(),n+sU(this))%(this._dur+this._rDelay)||(n?this._dur:0),i):this._time},e.totalProgress=function(n,i){return arguments.length?this.totalTime(this.totalDuration()*n,i):this.totalDuration()?Math.min(1,this._tTime/this._tDur):this.rawTime()>=0&&this._initted?1:0},e.progress=function(n,i){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&!(this.iteration()&1)?1-n:n)+sU(this),i):this.duration()?Math.min(1,this._time/this._dur):this.rawTime()>0?1:0},e.iteration=function(n,i){var r=this.duration()+this._rDelay;return arguments.length?this.totalTime(this._time+(n-1)*r,i):this._repeat?gx(this._tTime,r)+1:1},e.timeScale=function(n,i){if(!arguments.length)return this._rts===-1e-8?0:this._rts;if(this._rts===n)return this;var r=this.parent&&this._ts?P2(this.parent._time,this):this._tTime;return this._rts=+n||0,this._ts=this._ps||n===-1e-8?0:this._rts,this.totalTime(f_(-Math.abs(this._delay),this._tDur,r),i!==!1),tE(this),Aae(this)},e.paused=function(n){return arguments.length?(this._ps!==n&&(this._ps=n,n?(this._pTime=this._tTime||Math.max(-this._delay,this.rawTime()),this._ts=this._act=0):(xx(),this._ts=this._rts,this.totalTime(this.parent&&!this.parent.smoothChildTiming?this.rawTime():this._tTime||this._pTime,this.progress()===1&&Math.abs(this._zTime)!==Ca&&(this._tTime-=Ca)))),this):this._ps},e.startTime=function(n){if(arguments.length){this._start=n;var i=this.parent||this._dp;return i&&(i._sort||!this.parent)&&Zc(i,this,n-this._delay),this}return this._start},e.endTime=function(n){return this._start+(No(n)?this.totalDuration():this.duration())/Math.abs(this._ts||1)},e.rawTime=function(n){var i=this.parent||this._dp;return i?n&&(!this._ts||this._repeat&&this._time&&this.totalProgress()<1)?this._tTime%(this._dur+this._rDelay):this._ts?P2(i.rawTime(n),this):this._tTime:this._tTime},e.revert=function(n){n===void 0&&(n=vae);var i=ta;return ta=n,(this._initted||this._startAt)&&(this.timeline&&this.timeline.revert(n),this.totalTime(-.01,n.suppressEvents)),this.data!=="nested"&&n.kill!==!1&&this.kill(),ta=i,this},e.globalTime=function(n){for(var i=this,r=arguments.length?n:i.rawTime();i;)r=i._start+r/(Math.abs(i._ts)||1),i=i._dp;return!this.parent&&this._sat?this._sat.globalTime(n):r},e.repeat=function(n){return arguments.length?(this._repeat=n===1/0?-2:n,iU(this)):this._repeat===-2?1/0:this._repeat},e.repeatDelay=function(n){if(arguments.length){var i=this._time;return this._rDelay=n,iU(this),i?this.time(i):this}return this._rDelay},e.yoyo=function(n){return arguments.length?(this._yoyo=n,this):this._yoyo},e.seek=function(n,i){return this.totalTime(Yl(this,n),No(i))},e.restart=function(n,i){return this.play().totalTime(n?-this._delay:0,No(i)),this._dur||(this._zTime=-1e-8),this},e.play=function(n,i){return n!=null&&this.seek(n,i),this.reversed(!1).paused(!1)},e.reverse=function(n,i){return n!=null&&this.seek(n||this.totalDuration(),i),this.reversed(!0).paused(!1)},e.pause=function(n,i){return n!=null&&this.seek(n,i),this.paused(!0)},e.resume=function(){return this.paused(!1)},e.reversed=function(n){return arguments.length?(!!n!==this.reversed()&&this.timeScale(-this._rts||(n?-1e-8:0)),this):this._rts<0},e.invalidate=function(){return this._initted=this._act=0,this._zTime=-1e-8,this},e.isActive=function(){var n=this.parent||this._dp,i=this._start,r;return!!(!n||this._ts&&this._initted&&n.isActive()&&(r=n.rawTime(!0))>=i&&r<this.endTime(!0)-Ca)},e.eventCallback=function(n,i,r){var a=this.vars;return arguments.length>1?(i?(a[n]=i,r&&(a[n+"Params"]=r),n==="onUpdate"&&(this._onUpdate=i)):delete a[n],this):a[n]},e.then=function(n){var i=this;return new Promise(function(r){var a=Ei(n)?n:_5,o=function(){var u=i.then;i.then=null,Ei(a)&&(a=a(i))&&(a.then||a===i)&&(i.then=u),r(a),i.then=u};i._initted&&i.totalProgress()===1&&i._ts>=0||!i._tTime&&i._ts<0?o():i._prom=o})},e.kill=function(){H1(this)},s}();_l(Nb.prototype,{_time:0,_start:0,_end:0,_tTime:0,_tDur:0,_dirty:0,_repeat:0,_yoyo:!1,parent:null,_initted:!1,_rDelay:0,_ts:1,_dp:0,ratio:0,_zTime:-1e-8,_prom:0,_ps:!1,_rts:1});var to=function(s){l5(e,s);function e(n,i){var r;return n===void 0&&(n={}),r=s.call(this,n)||this,r.labels={},r.smoothChildTiming=!!n.smoothChildTiming,r.autoRemoveChildren=!!n.autoRemoveChildren,r._sort=No(n.sortChildren),hi&&Zc(n.parent||hi,Jh(r),i),n.reversed&&r.reverse(),n.paused&&r.paused(!0),n.scrollTrigger&&T5(Jh(r),n.scrollTrigger),r}var t=e.prototype;return t.to=function(i,r,a){return lb(0,arguments,this),this},t.from=function(i,r,a){return lb(1,arguments,this),this},t.fromTo=function(i,r,a,o){return lb(2,arguments,this),this},t.set=function(i,r,a){return r.duration=0,r.parent=this,ob(r).repeatDelay||(r.repeat=0),r.immediateRender=!!r.immediateRender,new Yi(i,r,Yl(this,a),1),this},t.call=function(i,r,a){return Zc(this,Yi.delayedCall(0,i,r),a)},t.staggerTo=function(i,r,a,o,l,u,c){return a.duration=r,a.stagger=a.stagger||o,a.onComplete=u,a.onCompleteParams=c,a.parent=this,new Yi(i,a,Yl(this,l)),this},t.staggerFrom=function(i,r,a,o,l,u,c){return a.runBackwards=1,ob(a).immediateRender=No(a.immediateRender),this.staggerTo(i,r,a,o,l,u,c)},t.staggerFromTo=function(i,r,a,o,l,u,c,f){return o.startAt=a,ob(o).immediateRender=No(o.immediateRender),this.staggerTo(i,r,o,l,u,c,f)},t.render=function(i,r,a){var o=this._time,l=this._dirty?this.totalDuration():this._tDur,u=this._dur,c=i<=0?0:Zi(i),f=this._zTime<0!=i<0&&(this._initted||!u),d,g,x,S,b,_,T,E,C,R,I,L;if(this!==hi&&c>l&&i>=0&&(c=l),c!==this._tTime||a||f){if(o!==this._time&&u&&(c+=this._time-o,i+=this._time-o),d=c,C=this._start,E=this._ts,_=!E,f&&(u||(o=this._zTime),(i||!r)&&(this._zTime=i)),this._repeat){if(I=this._yoyo,b=u+this._rDelay,this._repeat<-1&&i<0)return this.totalTime(b*100+i,r,a);if(d=Zi(c%b),c===l?(S=this._repeat,d=u):(R=Zi(c/b),S=~~R,S&&S===R&&(d=u,S--),d>u&&(d=u)),R=gx(this._tTime,b),!o&&this._tTime&&R!==S&&this._tTime-R*b-this._dur<=0&&(R=S),I&&S&1&&(d=u-d,L=1),S!==R&&!this._lock){var P=I&&R&1,D=P===(I&&S&1);if(S<R&&(P=!P),o=P?0:c%u?u:c,this._lock=1,this.render(o||(L?0:Zi(S*b)),r,!u)._lock=0,this._tTime=c,!r&&this.parent&&dl(this,"onRepeat"),this.vars.repeatRefresh&&!L&&(this.invalidate()._lock=1),o&&o!==this._time||_!==!this._ts||this.vars.onRepeat&&!this.parent&&!this._act)return this;if(u=this._dur,l=this._tDur,D&&(this._lock=2,o=P?u:-1e-4,this.render(o,!0),this.vars.repeatRefresh&&!L&&this.invalidate()),this._lock=0,!this._ts&&!_)return this;U5(this,L)}}if(this._hasPause&&!this._forcing&&this._lock<2&&(T=Eae(this,Zi(o),Zi(d)),T&&(c-=d-(d=T._start))),this._tTime=c,this._time=d,this._act=!E,this._initted||(this._onUpdate=this.vars.onUpdate,this._initted=1,this._zTime=i,o=0),!o&&d&&!r&&!S&&(dl(this,"onStart"),this._tTime!==c))return this;if(d>=o&&i>=0)for(g=this._first;g;){if(x=g._next,(g._act||d>=g._start)&&g._ts&&T!==g){if(g.parent!==this)return this.render(i,r,a);if(g.render(g._ts>0?(d-g._start)*g._ts:(g._dirty?g.totalDuration():g._tDur)+(d-g._start)*g._ts,r,a),d!==this._time||!this._ts&&!_){T=0,x&&(c+=this._zTime=-1e-8);break}}g=x}else{g=this._last;for(var O=i<0?i:d;g;){if(x=g._prev,(g._act||O<=g._end)&&g._ts&&T!==g){if(g.parent!==this)return this.render(i,r,a);if(g.render(g._ts>0?(O-g._start)*g._ts:(g._dirty?g.totalDuration():g._tDur)+(O-g._start)*g._ts,r,a||ta&&(g._initted||g._startAt)),d!==this._time||!this._ts&&!_){T=0,x&&(c+=this._zTime=O?-1e-8:Ca);break}}g=x}}if(T&&!r&&(this.pause(),T.render(d>=o?0:-1e-8)._zTime=d>=o?1:-1,this._ts))return this._start=C,tE(this),this.render(i,r,a);this._onUpdate&&!r&&dl(this,"onUpdate",!0),(c===l&&this._tTime>=this.totalDuration()||!c&&o)&&(C===this._start||Math.abs(E)!==Math.abs(this._ts))&&(this._lock||((i||!u)&&(c===l&&this._ts>0||!c&&this._ts<0)&&ip(this,1),!r&&!(i<0&&!o)&&(c||o||!l)&&(dl(this,c===l&&i>=0?"onComplete":"onReverseComplete",!0),this._prom&&!(c<l&&this.timeScale()>0)&&this._prom())))}return this},t.add=function(i,r){var a=this;if(bf(r)||(r=Yl(this,r,i)),!(i instanceof Nb)){if(Ma(i))return i.forEach(function(o){return a.add(o,r)}),this;if(Lr(i))return this.addLabel(i,r);if(Ei(i))i=Yi.delayedCall(0,i);else return this}return this!==i?Zc(this,i,r):this},t.getChildren=function(i,r,a,o){i===void 0&&(i=!0),r===void 0&&(r=!0),a===void 0&&(a=!0),o===void 0&&(o=-1e8);for(var l=[],u=this._first;u;)u._start>=o&&(u instanceof Yi?r&&l.push(u):(a&&l.push(u),i&&l.push.apply(l,u.getChildren(!0,r,a)))),u=u._next;return l},t.getById=function(i){for(var r=this.getChildren(1,1,1),a=r.length;a--;)if(r[a].vars.id===i)return r[a]},t.remove=function(i){return Lr(i)?this.removeLabel(i):Ei(i)?this.killTweensOf(i):(i.parent===this&&eE(this,i),i===this._recent&&(this._recent=this._last),mg(this))},t.totalTime=function(i,r){return arguments.length?(this._forcing=1,!this._dp&&this._ts&&(this._start=Zi(ul.time-(this._ts>0?i/this._ts:(this.totalDuration()-i)/-this._ts))),s.prototype.totalTime.call(this,i,r),this._forcing=0,this):this._tTime},t.addLabel=function(i,r){return this.labels[i]=Yl(this,r),this},t.removeLabel=function(i){return delete this.labels[i],this},t.addPause=function(i,r,a){var o=Yi.delayedCall(0,r||Cb,a);return o.data="isPause",this._hasPause=1,Zc(this,o,Yl(this,i))},t.removePause=function(i){var r=this._first;for(i=Yl(this,i);r;)r._start===i&&r.data==="isPause"&&ip(r),r=r._next},t.killTweensOf=function(i,r,a){for(var o=this.getTweensOf(i,a),l=o.length;l--;)Ud!==o[l]&&o[l].kill(i,r);return this},t.getTweensOf=function(i,r){for(var a=[],o=nu(i),l=this._first,u=bf(r),c;l;)l instanceof Yi?bae(l._targets,o)&&(u?(!Ud||l._initted&&l._ts)&&l.globalTime(0)<=r&&l.globalTime(l.totalDuration())>r:!r||l.isActive())&&a.push(l):(c=l.getTweensOf(o,r)).length&&a.push.apply(a,c),l=l._next;return a},t.tweenTo=function(i,r){r=r||{};var a=this,o=Yl(a,i),l=r,u=l.startAt,c=l.onStart,f=l.onStartParams,d=l.immediateRender,g,x=Yi.to(a,_l({ease:r.ease||"none",lazy:!1,immediateRender:!1,time:o,overwrite:"auto",duration:r.duration||Math.abs((o-(u&&"time"in u?u.time:a._time))/a.timeScale())||Ca,onStart:function(){if(a.pause(),!g){var b=r.duration||Math.abs((o-(u&&"time"in u?u.time:a._time))/a.timeScale());x._dur!==b&&yx(x,b,0,1).render(x._time,!0,!0),g=1}c&&c.apply(x,f||[])}},r));return d?x.render(0):x},t.tweenFromTo=function(i,r,a){return this.tweenTo(r,_l({startAt:{time:Yl(this,i)}},a))},t.recent=function(){return this._recent},t.nextLabel=function(i){return i===void 0&&(i=this._time),rU(this,Yl(this,i))},t.previousLabel=function(i){return i===void 0&&(i=this._time),rU(this,Yl(this,i),1)},t.currentLabel=function(i){return arguments.length?this.seek(i,!0):this.previousLabel(this._time+Ca)},t.shiftChildren=function(i,r,a){a===void 0&&(a=0);for(var o=this._first,l=this.labels,u;o;)o._start>=a&&(o._start+=i,o._end+=i),o=o._next;if(r)for(u in l)l[u]>=a&&(l[u]+=i);return mg(this)},t.invalidate=function(i){var r=this._first;for(this._lock=0;r;)r.invalidate(i),r=r._next;return s.prototype.invalidate.call(this,i)},t.clear=function(i){i===void 0&&(i=!0);for(var r=this._first,a;r;)a=r._next,this.remove(r),r=a;return this._dp&&(this._time=this._tTime=this._pTime=0),i&&(this.labels={}),mg(this)},t.totalDuration=function(i){var r=0,a=this,o=a._last,l=ih,u,c,f;if(arguments.length)return a.timeScale((a._repeat<0?a.duration():a.totalDuration())/(a.reversed()?-i:i));if(a._dirty){for(f=a.parent;o;)u=o._prev,o._dirty&&o.totalDuration(),c=o._start,c>l&&a._sort&&o._ts&&!a._lock?(a._lock=1,Zc(a,o,c-o._delay,1)._lock=0):l=c,c<0&&o._ts&&(r-=c,(!f&&!a._dp||f&&f.smoothChildTiming)&&(a._start+=c/a._ts,a._time-=c,a._tTime-=c),a.shiftChildren(-c,!1,-1/0),l=0),o._end>r&&o._ts&&(r=o._end),o=u;yx(a,a===hi&&a._time>r?a._time:r,1,1),a._dirty=0}return a._tDur},e.updateRoot=function(i){if(hi._ts&&(v5(hi,P2(i,hi)),y5=ul.frame),ul.frame>=tU){tU+=yl.autoSleep||120;var r=hi._first;if((!r||!r._ts)&&yl.autoSleep&&ul._listeners.length<2){for(;r&&!r._ts;)r=r._next;r||ul.sleep()}}},e}(Nb);_l(to.prototype,{_lock:0,_hasPause:0,_forcing:0});var Hae=function(e,t,n,i,r,a,o){var l=new Io(this._pt,e,t,0,1,q5,null,r),u=0,c=0,f,d,g,x,S,b,_,T;for(l.b=n,l.e=i,n+="",i+="",(_=~i.indexOf("random("))&&(i=Eb(i)),a&&(T=[n,i],a(T,e,t),n=T[0],i=T[1]),d=n.match(ZR)||[];f=ZR.exec(i);)x=f[0],S=i.substring(u,f.index),g?g=(g+1)%5:S.substr(-5)==="rgba("&&(g=1),x!==d[c++]&&(b=parseFloat(d[c-1])||0,l._pt={_next:l._pt,p:S||c===1?S:",",s:b,c:x.charAt(1)==="="?Wy(b,x)-b:parseFloat(x)-b,m:g&&g<4?Math.round:0},u=ZR.lastIndex);return l.c=u<i.length?i.substring(u,i.length):"",l.fp=o,(f5.test(i)||_)&&(l.e=0),this._pt=l,l},EO=function(e,t,n,i,r,a,o,l,u,c){Ei(i)&&(i=i(r||0,e,a));var f=e[t],d=n!=="get"?n:Ei(f)?u?e[t.indexOf("set")||!Ei(e["get"+t.substr(3)])?t:"get"+t.substr(3)](u):e[t]():f,g=Ei(f)?u?jae:W5:NO,x;if(Lr(i)&&(~i.indexOf("random(")&&(i=Eb(i)),i.charAt(1)==="="&&(x=Wy(d,i)+(Aa(d)||0),(x||x===0)&&(i=x))),!c||d!==i||hD)return!isNaN(d*i)&&i!==""?(x=new Io(this._pt,e,t,+d||0,i-(d||0),typeof f=="boolean"?Yae:X5,0,g),u&&(x.fp=u),o&&x.modifier(o,this,e),this._pt=x):(!f&&!(t in e)&&AO(t,i),Hae.call(this,e,t,d,i,g,l||yl.stringFilter,u))},Vae=function(e,t,n,i,r){if(Ei(e)&&(e=ub(e,r,t,n,i)),!fh(e)||e.style&&e.nodeType||Ma(e)||c5(e))return Lr(e)?ub(e,r,t,n,i):e;var a={},o;for(o in e)a[o]=ub(e[o],r,t,n,i);return a},G5=function(e,t,n,i,r,a){var o,l,u,c;if(ll[e]&&(o=new ll[e]).init(r,o.rawVars?t[e]:Vae(t[e],i,r,a,n),n,i,a)!==!1&&(n._pt=l=new Io(n._pt,r,e,0,1,o.render,o,0,o.priority),n!==zy))for(u=n._ptLookup[n._targets.indexOf(r)],c=o._props.length;c--;)u[o._props[c]]=l;return o},Ud,hD,MO=function s(e,t,n){var i=e.vars,r=i.ease,a=i.startAt,o=i.immediateRender,l=i.lazy,u=i.onUpdate,c=i.runBackwards,f=i.yoyoEase,d=i.keyframes,g=i.autoRevert,x=e._dur,S=e._startAt,b=e._targets,_=e.parent,T=_&&_.data==="nested"?_.vars.targets:b,E=e._overwrite==="auto"&&!vO,C=e.timeline,R,I,L,P,D,O,F,X,q,J,Y,$,W;if(C&&(!d||!r)&&(r="none"),e._ease=gg(r,px.ease),e._yEase=f?P5(gg(f===!0?r:f,px.ease)):0,f&&e._yoyo&&!e._repeat&&(f=e._yEase,e._yEase=e._ease,e._ease=f),e._from=!C&&!!i.runBackwards,!C||d&&!i.stagger){if(X=b[0]?pg(b[0]).harness:0,$=X&&i[X.prop],R=F2(i,TO),S&&(S._zTime<0&&S.progress(1),t<0&&c&&o&&!g?S.render(-1,!0):S.revert(c&&x?Mw:xae),S._lazy=0),a){if(ip(e._startAt=Yi.set(b,_l({data:"isStart",overwrite:!1,parent:_,immediateRender:!0,lazy:!S&&No(l),startAt:null,delay:0,onUpdate:u&&function(){return dl(e,"onUpdate")},stagger:0},a))),e._startAt._dp=0,e._startAt._sat=e,t<0&&(ta||!o&&!g)&&e._startAt.revert(Mw),o&&x&&t<=0&&n<=0){t&&(e._zTime=t);return}}else if(c&&x&&!S){if(t&&(o=!1),L=_l({overwrite:!1,data:"isFromStart",lazy:o&&!S&&No(l),immediateRender:o,stagger:0,parent:_},R),$&&(L[X.prop]=$),ip(e._startAt=Yi.set(b,L)),e._startAt._dp=0,e._startAt._sat=e,t<0&&(ta?e._startAt.revert(Mw):e._startAt.render(-1,!0)),e._zTime=t,!o)s(e._startAt,Ca,Ca);else if(!t)return}for(e._pt=e._ptCache=0,l=x&&No(l)||l&&!x,I=0;I<b.length;I++){if(D=b[I],F=D._gsap||CO(b)[I]._gsap,e._ptLookup[I]=J={},rD[F.id]&&qd.length&&L2(),Y=T===b?I:T.indexOf(D),X&&(q=new X).init(D,$||R,e,Y,T)!==!1&&(e._pt=P=new Io(e._pt,D,q.name,0,1,q.render,q,0,q.priority),q._props.forEach(function(V){J[V]=P}),q.priority&&(O=1)),!X||$)for(L in R)ll[L]&&(q=G5(L,R,e,Y,D,T))?q.priority&&(O=1):J[L]=P=EO.call(e,D,L,"get",R[L],Y,T,0,i.stringFilter);e._op&&e._op[I]&&e.kill(D,e._op[I]),E&&e._pt&&(Ud=e,hi.killTweensOf(D,J,e.globalTime(t)),W=!e.parent,Ud=0),e._pt&&l&&(rD[F.id]=1)}O&&j5(e),e._onInit&&e._onInit(e)}e._onUpdate=u,e._initted=(!e._op||e._pt)&&!W,d&&t<=0&&C.render(ih,!0,!0)},Wae=function(e,t,n,i,r,a,o,l){var u=(e._pt&&e._ptCache||(e._ptCache={}))[t],c,f,d,g;if(!u)for(u=e._ptCache[t]=[],d=e._ptLookup,g=e._targets.length;g--;){if(c=d[g][t],c&&c.d&&c.d._pt)for(c=c.d._pt;c&&c.p!==t&&c.fp!==t;)c=c._next;if(!c)return hD=1,e.vars[t]="+=0",MO(e,o),hD=0,l?wb(t+" not eligible for reset"):1;u.push(c)}for(g=u.length;g--;)f=u[g],c=f._pt||f,c.s=(i||i===0)&&!r?i:c.s+(i||0)+a*c.c,c.c=n-c.s,f.e&&(f.e=Ui(n)+Aa(f.e)),f.b&&(f.b=c.s+Aa(f.b))},Xae=function(e,t){var n=e[0]?pg(e[0]).harness:0,i=n&&n.aliases,r,a,o,l;if(!i)return t;r=mx({},t);for(a in i)if(a in r)for(l=i[a].split(","),o=l.length;o--;)r[l[o]]=r[a];return r},qae=function(e,t,n,i){var r=t.ease||i||"power1.inOut",a,o;if(Ma(t))o=n[e]||(n[e]=[]),t.forEach(function(l,u){return o.push({t:u/(t.length-1)*100,v:l,e:r})});else for(a in t)o=n[a]||(n[a]=[]),a==="ease"||o.push({t:parseFloat(e),v:t[a],e:r})},ub=function(e,t,n,i,r){return Ei(e)?e.call(t,n,i,r):Lr(e)&&~e.indexOf("random(")?Eb(e):e},H5=wO+"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",V5={};Ro(H5+",id,stagger,delay,duration,paused,scrollTrigger",function(s){return V5[s]=1});var Yi=function(s){l5(e,s);function e(n,i,r,a){var o;typeof i=="number"&&(r.duration=i,i=r,r=null),o=s.call(this,a?i:ob(i))||this;var l=o.vars,u=l.duration,c=l.delay,f=l.immediateRender,d=l.stagger,g=l.overwrite,x=l.keyframes,S=l.defaults,b=l.scrollTrigger,_=l.yoyoEase,T=i.parent||hi,E=(Ma(n)||c5(n)?bf(n[0]):"length"in i)?[n]:nu(n),C,R,I,L,P,D,O,F;if(o._targets=E.length?CO(E):wb("GSAP target "+n+" not found. https://gsap.com",!yl.nullTargetWarn)||[],o._ptLookup=[],o._overwrite=g,x||d||iw(u)||iw(c)){if(i=o.vars,C=o.timeline=new to({data:"nested",defaults:S||{},targets:T&&T.data==="nested"?T.vars.targets:E}),C.kill(),C.parent=C._dp=Jh(o),C._start=0,d||iw(u)||iw(c)){if(L=E.length,O=d&&M5(d),fh(d))for(P in d)~H5.indexOf(P)&&(F||(F={}),F[P]=d[P]);for(R=0;R<L;R++)I=F2(i,V5),I.stagger=0,_&&(I.yoyoEase=_),F&&mx(I,F),D=E[R],I.duration=+ub(u,Jh(o),R,D,E),I.delay=(+ub(c,Jh(o),R,D,E)||0)-o._delay,!d&&L===1&&I.delay&&(o._delay=c=I.delay,o._start+=c,I.delay=0),C.to(D,I,O?O(R,D,E):0),C._ease=es.none;C.duration()?u=c=0:o.timeline=0}else if(x){ob(_l(C.vars.defaults,{ease:"none"})),C._ease=gg(x.ease||i.ease||"none");var X=0,q,J,Y;if(Ma(x))x.forEach(function($){return C.to(E,$,">")}),C.duration();else{I={};for(P in x)P==="ease"||P==="easeEach"||qae(P,x[P],I,x.easeEach);for(P in I)for(q=I[P].sort(function($,W){return $.t-W.t}),X=0,R=0;R<q.length;R++)J=q[R],Y={ease:J.e,duration:(J.t-(R?q[R-1].t:0))/100*u},Y[P]=J.v,C.to(E,Y,X),X+=Y.duration;C.duration()<u&&C.to({},{duration:u-C.duration()})}}u||o.duration(u=C.duration())}else o.timeline=0;return g===!0&&!vO&&(Ud=Jh(o),hi.killTweensOf(E),Ud=0),Zc(T,Jh(o),r),i.reversed&&o.reverse(),i.paused&&o.paused(!0),(f||!u&&!x&&o._start===Zi(T._time)&&No(f)&&Tae(Jh(o))&&T.data!=="nested")&&(o._tTime=-1e-8,o.render(Math.max(0,-c)||0)),b&&T5(Jh(o),b),o}var t=e.prototype;return t.render=function(i,r,a){var o=this._time,l=this._tDur,u=this._dur,c=i<0,f=i>l-Ca&&!c?l:i<Ca?0:i,d,g,x,S,b,_,T,E,C;if(!u)Cae(this,i,r,a);else if(f!==this._tTime||!i||a||!this._initted&&this._tTime||this._startAt&&this._zTime<0!==c||this._lazy){if(d=f,E=this.timeline,this._repeat){if(S=u+this._rDelay,this._repeat<-1&&c)return this.totalTime(S*100+i,r,a);if(d=Zi(f%S),f===l?(x=this._repeat,d=u):(b=Zi(f/S),x=~~b,x&&x===b?(d=u,x--):d>u&&(d=u)),_=this._yoyo&&x&1,_&&(C=this._yEase,d=u-d),b=gx(this._tTime,S),d===o&&!a&&this._initted&&x===b)return this._tTime=f,this;x!==b&&(E&&this._yEase&&U5(E,_),this.vars.repeatRefresh&&!_&&!this._lock&&d!==S&&this._initted&&(this._lock=a=1,this.render(Zi(S*x),!0).invalidate()._lock=0))}if(!this._initted){if(w5(this,c?i:d,a,r,f))return this._tTime=0,this;if(o!==this._time&&!(a&&this.vars.repeatRefresh&&x!==b))return this;if(u!==this._dur)return this.render(i,r,a)}if(this._tTime=f,this._time=d,!this._act&&this._ts&&(this._act=1,this._lazy=0),this.ratio=T=(C||this._ease)(d/u),this._from&&(this.ratio=T=1-T),d&&!o&&!r&&!x&&(dl(this,"onStart"),this._tTime!==f))return this;for(g=this._pt;g;)g.r(T,g.d),g=g._next;E&&E.render(i<0?i:E._dur*E._ease(d/this._dur),r,a)||this._startAt&&(this._zTime=i),this._onUpdate&&!r&&(c&&aD(this,i,r,a),dl(this,"onUpdate")),this._repeat&&x!==b&&this.vars.onRepeat&&!r&&this.parent&&dl(this,"onRepeat"),(f===this._tDur||!f)&&this._tTime===f&&(c&&!this._onUpdate&&aD(this,i,!0,!0),(i||!u)&&(f===this._tDur&&this._ts>0||!f&&this._ts<0)&&ip(this,1),!r&&!(c&&!o)&&(f||o||_)&&(dl(this,f===l?"onComplete":"onReverseComplete",!0),this._prom&&!(f<l&&this.timeScale()>0)&&this._prom()))}return this},t.targets=function(){return this._targets},t.invalidate=function(i){return(!i||!this.vars.runBackwards)&&(this._startAt=0),this._pt=this._op=this._onUpdate=this._lazy=this.ratio=0,this._ptLookup=[],this.timeline&&this.timeline.invalidate(i),s.prototype.invalidate.call(this,i)},t.resetTo=function(i,r,a,o,l){Mb||ul.wake(),this._ts||this.play();var u=Math.min(this._dur,(this._dp._time-this._start)*this._ts),c;return this._initted||MO(this,u),c=this._ease(u/this._dur),Wae(this,i,r,a,o,c,u,l)?this.resetTo(i,r,a,o,1):(nE(this,0),this.parent||S5(this._dp,this,"_first","_last",this._dp._sort?"_start":0),this.render(0))},t.kill=function(i,r){if(r===void 0&&(r="all"),!i&&(!r||r==="all"))return this._lazy=this._pt=0,this.parent?H1(this):this.scrollTrigger&&this.scrollTrigger.kill(!!ta),this;if(this.timeline){var a=this.timeline.totalDuration();return this.timeline.killTweensOf(i,r,Ud&&Ud.vars.overwrite!==!0)._first||H1(this),this.parent&&a!==this.timeline.totalDuration()&&yx(this,this._dur*this.timeline._tDur/a,0,1),this}var o=this._targets,l=i?nu(i):o,u=this._ptLookup,c=this._pt,f,d,g,x,S,b,_;if((!r||r==="all")&&Sae(o,l))return r==="all"&&(this._pt=0),H1(this);for(f=this._op=this._op||[],r!=="all"&&(Lr(r)&&(S={},Ro(r,function(T){return S[T]=1}),r=S),r=Xae(o,r)),_=o.length;_--;)if(~l.indexOf(o[_])){d=u[_],r==="all"?(f[_]=r,x=d,g={}):(g=f[_]=f[_]||{},x=r);for(S in x)b=d&&d[S],b&&((!("kill"in b.d)||b.d.kill(S)===!0)&&eE(this,b,"_pt"),delete d[S]),g!=="all"&&(g[S]=1)}return this._initted&&!this._pt&&c&&H1(this),this},e.to=function(i,r){return new e(i,r,arguments[2])},e.from=function(i,r){return lb(1,arguments)},e.delayedCall=function(i,r,a,o){return new e(r,0,{immediateRender:!1,lazy:!1,overwrite:!1,delay:i,onComplete:r,onReverseComplete:r,onCompleteParams:a,onReverseCompleteParams:a,callbackScope:o})},e.fromTo=function(i,r,a){return lb(2,arguments)},e.set=function(i,r){return r.duration=0,r.repeatDelay||(r.repeat=0),new e(i,r)},e.killTweensOf=function(i,r,a){return hi.killTweensOf(i,r,a)},e}(Nb);_l(Yi.prototype,{_targets:[],_lazy:0,_startAt:0,_op:0,_onInit:0});Ro("staggerTo,staggerFrom,staggerFromTo",function(s){Yi[s]=function(){var e=new to,t=lD.call(arguments,0);return t.splice(s==="staggerFromTo"?5:4,0,0),e[s].apply(e,t)}});var NO=function(e,t,n){return e[t]=n},W5=function(e,t,n){return e[t](n)},jae=function(e,t,n,i){return e[t](i.fp,n)},Kae=function(e,t,n){return e.setAttribute(t,n)},RO=function(e,t){return Ei(e[t])?W5:bO(e[t])&&e.setAttribute?Kae:NO},X5=function(e,t){return t.set(t.t,t.p,Math.round((t.s+t.c*e)*1e6)/1e6,t)},Yae=function(e,t){return t.set(t.t,t.p,!!(t.s+t.c*e),t)},q5=function(e,t){var n=t._pt,i="";if(!e&&t.b)i=t.b;else if(e===1&&t.e)i=t.e;else{for(;n;)i=n.p+(n.m?n.m(n.s+n.c*e):Math.round((n.s+n.c*e)*1e4)/1e4)+i,n=n._next;i+=t.c}t.set(t.t,t.p,i,t)},IO=function(e,t){for(var n=t._pt;n;)n.r(e,n.d),n=n._next},Jae=function(e,t,n,i){for(var r=this._pt,a;r;)a=r._next,r.p===i&&r.modifier(e,t,n),r=a},Zae=function(e){for(var t=this._pt,n,i;t;)i=t._next,t.p===e&&!t.op||t.op===e?eE(this,t,"_pt"):t.dep||(n=1),t=i;return!n},Qae=function(e,t,n,i){i.mSet(e,t,i.m.call(i.tween,n,i.mt),i)},j5=function(e){for(var t=e._pt,n,i,r,a;t;){for(n=t._next,i=r;i&&i.pr>t.pr;)i=i._next;(t._prev=i?i._prev:a)?t._prev._next=t:r=t,(t._next=i)?i._prev=t:a=t,t=n}e._pt=r},Io=function(){function s(t,n,i,r,a,o,l,u,c){this.t=n,this.s=r,this.c=a,this.p=i,this.r=o||X5,this.d=l||this,this.set=u||NO,this.pr=c||0,this._next=t,t&&(t._prev=this)}var e=s.prototype;return e.modifier=function(n,i,r){this.mSet=this.mSet||this.set,this.set=Qae,this.m=n,this.mt=r,this.tween=i},s}();Ro(wO+"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",function(s){return TO[s]=1});bl.TweenMax=bl.TweenLite=Yi;bl.TimelineLite=bl.TimelineMax=to;hi=new to({sortChildren:!1,defaults:px,autoRemoveChildren:!0,id:"root",smoothChildTiming:!0});yl.stringFilter=F5;var yg=[],Rw={},eoe=[],oU=0,toe=0,sI=function(e){return(Rw[e]||eoe).map(function(t){return t()})},fD=function(){var e=Date.now(),t=[];e-oU>2&&(sI("matchMediaInit"),yg.forEach(function(n){var i=n.queries,r=n.conditions,a,o,l,u;for(o in i)a=jc.matchMedia(i[o]).matches,a&&(l=1),a!==r[o]&&(r[o]=a,u=1);u&&(n.revert(),l&&t.push(n))}),sI("matchMediaRevert"),t.forEach(function(n){return n.onMatch(n,function(i){return n.add(null,i)})}),oU=e,sI("matchMedia"))},K5=function(){function s(t,n){this.selector=n&&uD(n),this.data=[],this._r=[],this.isReverted=!1,this.id=toe++,t&&this.add(t)}var e=s.prototype;return e.add=function(n,i,r){Ei(n)&&(r=i,i=n,n=Ei);var a=this,o=function(){var u=ni,c=a.selector,f;return u&&u!==a&&u.data.push(a),r&&(a.selector=uD(r)),ni=a,f=i.apply(a,arguments),Ei(f)&&a._r.push(f),ni=u,a.selector=c,a.isReverted=!1,f};return a.last=o,n===Ei?o(a,function(l){return a.add(null,l)}):n?a[n]=o:o},e.ignore=function(n){var i=ni;ni=null,n(this),ni=i},e.getTweens=function(){var n=[];return this.data.forEach(function(i){return i instanceof s?n.push.apply(n,i.getTweens()):i instanceof Yi&&!(i.parent&&i.parent.data==="nested")&&n.push(i)}),n},e.clear=function(){this._r.length=this.data.length=0},e.kill=function(n,i){var r=this;if(n?function(){for(var o=r.getTweens(),l=r.data.length,u;l--;)u=r.data[l],u.data==="isFlip"&&(u.revert(),u.getChildren(!0,!0,!1).forEach(function(c){return o.splice(o.indexOf(c),1)}));for(o.map(function(c){return{g:c._dur||c._delay||c._sat&&!c._sat.vars.immediateRender?c.globalTime(0):-1/0,t:c}}).sort(function(c,f){return f.g-c.g||-1/0}).forEach(function(c){return c.t.revert(n)}),l=r.data.length;l--;)u=r.data[l],u instanceof to?u.data!=="nested"&&(u.scrollTrigger&&u.scrollTrigger.revert(),u.kill()):!(u instanceof Yi)&&u.revert&&u.revert(n);r._r.forEach(function(c){return c(n,r)}),r.isReverted=!0}():this.data.forEach(function(o){return o.kill&&o.kill()}),this.clear(),i)for(var a=yg.length;a--;)yg[a].id===this.id&&yg.splice(a,1)},e.revert=function(n){this.kill(n||{})},s}(),noe=function(){function s(t){this.contexts=[],this.scope=t,ni&&ni.data.push(this)}var e=s.prototype;return e.add=function(n,i,r){fh(n)||(n={matches:n});var a=new K5(0,r||this.scope),o=a.conditions={},l,u,c;ni&&!a.selector&&(a.selector=ni.selector),this.contexts.push(a),i=a.add("onMatch",i),a.queries=n;for(u in n)u==="all"?c=1:(l=jc.matchMedia(n[u]),l&&(yg.indexOf(a)<0&&yg.push(a),(o[u]=l.matches)&&(c=1),l.addListener?l.addListener(fD):l.addEventListener("change",fD)));return c&&i(a,function(f){return a.add(null,f)}),this},e.revert=function(n){this.kill(n||{})},e.kill=function(n){this.contexts.forEach(function(i){return i.kill(n,!0)})},s}(),U2={registerPlugin:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];t.forEach(function(i){return B5(i)})},timeline:function(e){return new to(e)},getTweensOf:function(e,t){return hi.getTweensOf(e,t)},getProperty:function(e,t,n,i){Lr(e)&&(e=nu(e)[0]);var r=pg(e||{}).get,a=n?_5:b5;return n==="native"&&(n=""),e&&(t?a((ll[t]&&ll[t].get||r)(e,t,n,i)):function(o,l,u){return a((ll[o]&&ll[o].get||r)(e,o,l,u))})},quickSetter:function(e,t,n){if(e=nu(e),e.length>1){var i=e.map(function(c){return Bo.quickSetter(c,t,n)}),r=i.length;return function(c){for(var f=r;f--;)i[f](c)}}e=e[0]||{};var a=ll[t],o=pg(e),l=o.harness&&(o.harness.aliases||{})[t]||t,u=a?function(c){var f=new a;zy._pt=0,f.init(e,n?c+n:c,zy,0,[e]),f.render(1,f),zy._pt&&IO(1,zy)}:o.set(e,l);return a?u:function(c){return u(e,l,n?c+n:c,o,1)}},quickTo:function(e,t,n){var i,r=Bo.to(e,_l((i={},i[t]="+=0.1",i.paused=!0,i.stagger=0,i),n||{})),a=function(l,u,c){return r.resetTo(t,l,u,c)};return a.tween=r,a},isTweening:function(e){return hi.getTweensOf(e,!0).length>0},defaults:function(e){return e&&e.ease&&(e.ease=gg(e.ease,px.ease)),nU(px,e||{})},config:function(e){return nU(yl,e||{})},registerEffect:function(e){var t=e.name,n=e.effect,i=e.plugins,r=e.defaults,a=e.extendTimeline;(i||"").split(",").forEach(function(o){return o&&!ll[o]&&!bl[o]&&wb(t+" effect requires "+o+" plugin.")}),QR[t]=function(o,l,u){return n(nu(o),_l(l||{},r),u)},a&&(to.prototype[t]=function(o,l,u){return this.add(QR[t](o,fh(l)?l:(u=l)&&{},this),u)})},registerEase:function(e,t){es[e]=gg(t)},parseEase:function(e,t){return arguments.length?gg(e,t):es},getById:function(e){return hi.getById(e)},exportRoot:function(e,t){e===void 0&&(e={});var n=new to(e),i,r;for(n.smoothChildTiming=No(e.smoothChildTiming),hi.remove(n),n._dp=0,n._time=n._tTime=hi._time,i=hi._first;i;)r=i._next,(t||!(!i._dur&&i instanceof Yi&&i.vars.onComplete===i._targets[0]))&&Zc(n,i,i._start-i._delay),i=r;return Zc(hi,n,0),n},context:function(e,t){return e?new K5(e,t):ni},matchMedia:function(e){return new noe(e)},matchMediaRefresh:function(){return yg.forEach(function(e){var t=e.conditions,n,i;for(i in t)t[i]&&(t[i]=!1,n=1);n&&e.revert()})||fD()},addEventListener:function(e,t){var n=Rw[e]||(Rw[e]=[]);~n.indexOf(t)||n.push(t)},removeEventListener:function(e,t){var n=Rw[e],i=n&&n.indexOf(t);i>=0&&n.splice(i,1)},utils:{wrap:Bae,wrapYoyo:kae,distribute:M5,random:R5,snap:N5,normalize:Oae,getUnit:Aa,clamp:Nae,splitColor:k5,toArray:nu,selector:uD,mapRange:D5,pipe:Iae,unitize:Dae,interpolate:Lae,shuffle:E5},install:m5,effects:QR,ticker:ul,updateRoot:to.updateRoot,plugins:ll,globalTimeline:hi,core:{PropTween:Io,globals:g5,Tween:Yi,Timeline:to,Animation:Nb,getCache:pg,_removeLinkedListItem:eE,reverting:function(){return ta},context:function(e){return e&&ni&&(ni.data.push(e),e._ctx=ni),ni},suppressOverwrites:function(e){return vO=e}}};Ro("to,from,fromTo,delayedCall,set,killTweensOf",function(s){return U2[s]=Yi[s]});ul.add(to.updateRoot);zy=U2.to({},{duration:0});var soe=function(e,t){for(var n=e._pt;n&&n.p!==t&&n.op!==t&&n.fp!==t;)n=n._next;return n},ioe=function(e,t){var n=e._targets,i,r,a;for(i in t)for(r=n.length;r--;)a=e._ptLookup[r][i],a&&(a=a.d)&&(a._pt&&(a=soe(a,i)),a&&a.modifier&&a.modifier(t[i],e,n[r],i))},iI=function(e,t){return{name:e,rawVars:1,init:function(i,r,a){a._onInit=function(o){var l,u;if(Lr(r)&&(l={},Ro(r,function(c){return l[c]=1}),r=l),t){l={};for(u in r)l[u]=t(r[u]);r=l}ioe(o,r)}}}},Bo=U2.registerPlugin({name:"attr",init:function(e,t,n,i,r){var a,o,l;this.tween=n;for(a in t)l=e.getAttribute(a)||"",o=this.add(e,"setAttribute",(l||0)+"",t[a],i,r,0,0,a),o.op=a,o.b=l,this._props.push(a)},render:function(e,t){for(var n=t._pt;n;)ta?n.set(n.t,n.p,n.b,n):n.r(e,n.d),n=n._next}},{name:"endArray",init:function(e,t){for(var n=t.length;n--;)this.add(e,n,e[n]||0,t[n],0,0,0,0,0,1)}},iI("roundProps",cD),iI("modifiers"),iI("snap",N5))||U2;Yi.version=to.version=Bo.version="3.12.7";p5=1;_O()&&xx();es.Power0;es.Power1;es.Power2;es.Power3;es.Power4;es.Linear;es.Quad;es.Cubic;es.Quart;es.Quint;es.Strong;es.Elastic;es.Back;es.SteppedEase;es.Bounce;es.Sine;es.Expo;es.Circ;/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var lU,$d,Xy,DO,lg,uU,OO,roe=function(){return typeof window<"u"},_f={},jm=180/Math.PI,qy=Math.PI/180,Ry=Math.atan2,cU=1e8,BO=/([A-Z])/g,aoe=/(left|right|width|margin|padding|x)/i,ooe=/[\s,\(]\S/,Qc={autoAlpha:"opacity,visibility",scale:"scaleX,scaleY",alpha:"opacity"},dD=function(e,t){return t.set(t.t,t.p,Math.round((t.s+t.c*e)*1e4)/1e4+t.u,t)},loe=function(e,t){return t.set(t.t,t.p,e===1?t.e:Math.round((t.s+t.c*e)*1e4)/1e4+t.u,t)},uoe=function(e,t){return t.set(t.t,t.p,e?Math.round((t.s+t.c*e)*1e4)/1e4+t.u:t.b,t)},coe=function(e,t){var n=t.s+t.c*e;t.set(t.t,t.p,~~(n+(n<0?-.5:.5))+t.u,t)},Y5=function(e,t){return t.set(t.t,t.p,e?t.e:t.b,t)},J5=function(e,t){return t.set(t.t,t.p,e!==1?t.b:t.e,t)},hoe=function(e,t,n){return e.style[t]=n},foe=function(e,t,n){return e.style.setProperty(t,n)},doe=function(e,t,n){return e._gsap[t]=n},poe=function(e,t,n){return e._gsap.scaleX=e._gsap.scaleY=n},moe=function(e,t,n,i,r){var a=e._gsap;a.scaleX=a.scaleY=n,a.renderTransform(r,a)},goe=function(e,t,n,i,r){var a=e._gsap;a[t]=n,a.renderTransform(r,a)},di="transform",Do=di+"Origin",yoe=function s(e,t){var n=this,i=this.target,r=i.style,a=i._gsap;if(e in _f&&r){if(this.tfm=this.tfm||{},e!=="transform")e=Qc[e]||e,~e.indexOf(",")?e.split(",").forEach(function(o){return n.tfm[o]=Qh(i,o)}):this.tfm[e]=a.x?a[e]:Qh(i,e),e===Do&&(this.tfm.zOrigin=a.zOrigin);else return Qc.transform.split(",").forEach(function(o){return s.call(n,o,t)});if(this.props.indexOf(di)>=0)return;a.svg&&(this.svgo=i.getAttribute("data-svg-origin"),this.props.push(Do,t,"")),e=di}(r||t)&&this.props.push(e,t,r[e])},Z5=function(e){e.translate&&(e.removeProperty("translate"),e.removeProperty("scale"),e.removeProperty("rotate"))},xoe=function(){var e=this.props,t=this.target,n=t.style,i=t._gsap,r,a;for(r=0;r<e.length;r+=3)e[r+1]?e[r+1]===2?t[e[r]](e[r+2]):t[e[r]]=e[r+2]:e[r+2]?n[e[r]]=e[r+2]:n.removeProperty(e[r].substr(0,2)==="--"?e[r]:e[r].replace(BO,"-$1").toLowerCase());if(this.tfm){for(a in this.tfm)i[a]=this.tfm[a];i.svg&&(i.renderTransform(),t.setAttribute("data-svg-origin",this.svgo||"")),r=OO(),(!r||!r.isStart)&&!n[di]&&(Z5(n),i.zOrigin&&n[Do]&&(n[Do]+=" "+i.zOrigin+"px",i.zOrigin=0,i.renderTransform()),i.uncache=1)}},Q5=function(e,t){var n={target:e,props:[],revert:xoe,save:yoe};return e._gsap||Bo.core.getCache(e),t&&e.style&&e.nodeType&&t.split(",").forEach(function(i){return n.save(i)}),n},e8,pD=function(e,t){var n=$d.createElementNS?$d.createElementNS((t||"http://www.w3.org/1999/xhtml").replace(/^https/,"http"),e):$d.createElement(e);return n&&n.style?n:$d.createElement(e)},rh=function s(e,t,n){var i=getComputedStyle(e);return i[t]||i.getPropertyValue(t.replace(BO,"-$1").toLowerCase())||i.getPropertyValue(t)||!n&&s(e,vx(t)||t,1)||""},hU="O,Moz,ms,Ms,Webkit".split(","),vx=function(e,t,n){var i=t||lg,r=i.style,a=5;if(e in r&&!n)return e;for(e=e.charAt(0).toUpperCase()+e.substr(1);a--&&!(hU[a]+e in r););return a<0?null:(a===3?"ms":a>=0?hU[a]:"")+e},mD=function(){roe()&&window.document&&(lU=window,$d=lU.document,Xy=$d.documentElement,lg=pD("div")||{style:{}},pD("div"),di=vx(di),Do=di+"Origin",lg.style.cssText="border-width:0;line-height:0;position:absolute;padding:0",e8=!!vx("perspective"),OO=Bo.core.reverting,DO=1)},fU=function(e){var t=e.ownerSVGElement,n=pD("svg",t&&t.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),i=e.cloneNode(!0),r;i.style.display="block",n.appendChild(i),Xy.appendChild(n);try{r=i.getBBox()}catch{}return n.removeChild(i),Xy.removeChild(n),r},dU=function(e,t){for(var n=t.length;n--;)if(e.hasAttribute(t[n]))return e.getAttribute(t[n])},t8=function(e){var t,n;try{t=e.getBBox()}catch{t=fU(e),n=1}return t&&(t.width||t.height)||n||(t=fU(e)),t&&!t.width&&!t.x&&!t.y?{x:+dU(e,["x","cx","x1"])||0,y:+dU(e,["y","cy","y1"])||0,width:0,height:0}:t},n8=function(e){return!!(e.getCTM&&(!e.parentNode||e.ownerSVGElement)&&t8(e))},Ng=function(e,t){if(t){var n=e.style,i;t in _f&&t!==Do&&(t=di),n.removeProperty?(i=t.substr(0,2),(i==="ms"||t.substr(0,6)==="webkit")&&(t="-"+t),n.removeProperty(i==="--"?t:t.replace(BO,"-$1").toLowerCase())):n.removeAttribute(t)}},zd=function(e,t,n,i,r,a){var o=new Io(e._pt,t,n,0,1,a?J5:Y5);return e._pt=o,o.b=i,o.e=r,e._props.push(n),o},pU={deg:1,rad:1,turn:1},voe={grid:1,flex:1},rp=function s(e,t,n,i){var r=parseFloat(n)||0,a=(n+"").trim().substr((r+"").length)||"px",o=lg.style,l=aoe.test(t),u=e.tagName.toLowerCase()==="svg",c=(u?"client":"offset")+(l?"Width":"Height"),f=100,d=i==="px",g=i==="%",x,S,b,_;if(i===a||!r||pU[i]||pU[a])return r;if(a!=="px"&&!d&&(r=s(e,t,n,"px")),_=e.getCTM&&n8(e),(g||a==="%")&&(_f[t]||~t.indexOf("adius")))return x=_?e.getBBox()[l?"width":"height"]:e[c],Ui(g?r/x*f:r/100*x);if(o[l?"width":"height"]=f+(d?a:i),S=i!=="rem"&&~t.indexOf("adius")||i==="em"&&e.appendChild&&!u?e:e.parentNode,_&&(S=(e.ownerSVGElement||{}).parentNode),(!S||S===$d||!S.appendChild)&&(S=$d.body),b=S._gsap,b&&g&&b.width&&l&&b.time===ul.time&&!b.uncache)return Ui(r/b.width*f);if(g&&(t==="height"||t==="width")){var T=e.style[t];e.style[t]=f+i,x=e[c],T?e.style[t]=T:Ng(e,t)}else(g||a==="%")&&!voe[rh(S,"display")]&&(o.position=rh(e,"position")),S===e&&(o.position="static"),S.appendChild(lg),x=lg[c],S.removeChild(lg),o.position="absolute";return l&&g&&(b=pg(S),b.time=ul.time,b.width=S[c]),Ui(d?x*r/f:x&&r?f/x*r:0)},Qh=function(e,t,n,i){var r;return DO||mD(),t in Qc&&t!=="transform"&&(t=Qc[t],~t.indexOf(",")&&(t=t.split(",")[0])),_f[t]&&t!=="transform"?(r=Ib(e,i),r=t!=="transformOrigin"?r[t]:r.svg?r.origin:z2(rh(e,Do))+" "+r.zOrigin+"px"):(r=e.style[t],(!r||r==="auto"||i||~(r+"").indexOf("calc("))&&(r=$2[t]&&$2[t](e,t,n)||rh(e,t)||x5(e,t)||(t==="opacity"?1:0))),n&&!~(r+"").trim().indexOf(" ")?rp(e,t,r,n)+n:r},boe=function(e,t,n,i){if(!n||n==="none"){var r=vx(t,e,1),a=r&&rh(e,r,1);a&&a!==n?(t=r,n=a):t==="borderColor"&&(n=rh(e,"borderTopColor"))}var o=new Io(this._pt,e.style,t,0,1,q5),l=0,u=0,c,f,d,g,x,S,b,_,T,E,C,R;if(o.b=n,o.e=i,n+="",i+="",i==="auto"&&(S=e.style[t],e.style[t]=i,i=rh(e,t)||i,S?e.style[t]=S:Ng(e,t)),c=[n,i],F5(c),n=c[0],i=c[1],d=n.match($y)||[],R=i.match($y)||[],R.length){for(;f=$y.exec(i);)b=f[0],T=i.substring(l,f.index),x?x=(x+1)%5:(T.substr(-5)==="rgba("||T.substr(-5)==="hsla(")&&(x=1),b!==(S=d[u++]||"")&&(g=parseFloat(S)||0,C=S.substr((g+"").length),b.charAt(1)==="="&&(b=Wy(g,b)+C),_=parseFloat(b),E=b.substr((_+"").length),l=$y.lastIndex-E.length,E||(E=E||yl.units[t]||C,l===i.length&&(i+=E,o.e+=E)),C!==E&&(g=rp(e,t,S,E)||0),o._pt={_next:o._pt,p:T||u===1?T:",",s:g,c:_-g,m:x&&x<4||t==="zIndex"?Math.round:0});o.c=l<i.length?i.substring(l,i.length):""}else o.r=t==="display"&&i==="none"?J5:Y5;return f5.test(i)&&(o.e=0),this._pt=o,o},mU={top:"0%",bottom:"100%",left:"0%",right:"100%",center:"50%"},_oe=function(e){var t=e.split(" "),n=t[0],i=t[1]||"50%";return(n==="top"||n==="bottom"||i==="left"||i==="right")&&(e=n,n=i,i=e),t[0]=mU[n]||n,t[1]=mU[i]||i,t.join(" ")},Soe=function(e,t){if(t.tween&&t.tween._time===t.tween._dur){var n=t.t,i=n.style,r=t.u,a=n._gsap,o,l,u;if(r==="all"||r===!0)i.cssText="",l=1;else for(r=r.split(","),u=r.length;--u>-1;)o=r[u],_f[o]&&(l=1,o=o==="transformOrigin"?Do:di),Ng(n,o);l&&(Ng(n,di),a&&(a.svg&&n.removeAttribute("transform"),i.scale=i.rotate=i.translate="none",Ib(n,1),a.uncache=1,Z5(i)))}},$2={clearProps:function(e,t,n,i,r){if(r.data!=="isFromStart"){var a=e._pt=new Io(e._pt,t,n,0,0,Soe);return a.u=i,a.pr=-10,a.tween=r,e._props.push(n),1}}},Rb=[1,0,0,1,0,0],s8={},i8=function(e){return e==="matrix(1, 0, 0, 1, 0, 0)"||e==="none"||!e},gU=function(e){var t=rh(e,di);return i8(t)?Rb:t.substr(7).match(h5).map(Ui)},kO=function(e,t){var n=e._gsap||pg(e),i=e.style,r=gU(e),a,o,l,u;return n.svg&&e.getAttribute("transform")?(l=e.transform.baseVal.consolidate().matrix,r=[l.a,l.b,l.c,l.d,l.e,l.f],r.join(",")==="1,0,0,1,0,0"?Rb:r):(r===Rb&&!e.offsetParent&&e!==Xy&&!n.svg&&(l=i.display,i.display="block",a=e.parentNode,(!a||!e.offsetParent&&!e.getBoundingClientRect().width)&&(u=1,o=e.nextElementSibling,Xy.appendChild(e)),r=gU(e),l?i.display=l:Ng(e,"display"),u&&(o?a.insertBefore(e,o):a?a.appendChild(e):Xy.removeChild(e))),t&&r.length>6?[r[0],r[1],r[4],r[5],r[12],r[13]]:r)},gD=function(e,t,n,i,r,a){var o=e._gsap,l=r||kO(e,!0),u=o.xOrigin||0,c=o.yOrigin||0,f=o.xOffset||0,d=o.yOffset||0,g=l[0],x=l[1],S=l[2],b=l[3],_=l[4],T=l[5],E=t.split(" "),C=parseFloat(E[0])||0,R=parseFloat(E[1])||0,I,L,P,D;n?l!==Rb&&(L=g*b-x*S)&&(P=C*(b/L)+R*(-S/L)+(S*T-b*_)/L,D=C*(-x/L)+R*(g/L)-(g*T-x*_)/L,C=P,R=D):(I=t8(e),C=I.x+(~E[0].indexOf("%")?C/100*I.width:C),R=I.y+(~(E[1]||E[0]).indexOf("%")?R/100*I.height:R)),i||i!==!1&&o.smooth?(_=C-u,T=R-c,o.xOffset=f+(_*g+T*S)-_,o.yOffset=d+(_*x+T*b)-T):o.xOffset=o.yOffset=0,o.xOrigin=C,o.yOrigin=R,o.smooth=!!i,o.origin=t,o.originIsAbsolute=!!n,e.style[Do]="0px 0px",a&&(zd(a,o,"xOrigin",u,C),zd(a,o,"yOrigin",c,R),zd(a,o,"xOffset",f,o.xOffset),zd(a,o,"yOffset",d,o.yOffset)),e.setAttribute("data-svg-origin",C+" "+R)},Ib=function(e,t){var n=e._gsap||new z5(e);if("x"in n&&!t&&!n.uncache)return n;var i=e.style,r=n.scaleX<0,a="px",o="deg",l=getComputedStyle(e),u=rh(e,Do)||"0",c,f,d,g,x,S,b,_,T,E,C,R,I,L,P,D,O,F,X,q,J,Y,$,W,V,se,G,ne,oe,ue,re,ce;return c=f=d=S=b=_=T=E=C=0,g=x=1,n.svg=!!(e.getCTM&&n8(e)),l.translate&&((l.translate!=="none"||l.scale!=="none"||l.rotate!=="none")&&(i[di]=(l.translate!=="none"?"translate3d("+(l.translate+" 0 0").split(" ").slice(0,3).join(", ")+") ":"")+(l.rotate!=="none"?"rotate("+l.rotate+") ":"")+(l.scale!=="none"?"scale("+l.scale.split(" ").join(",")+") ":"")+(l[di]!=="none"?l[di]:"")),i.scale=i.rotate=i.translate="none"),L=kO(e,n.svg),n.svg&&(n.uncache?(V=e.getBBox(),u=n.xOrigin-V.x+"px "+(n.yOrigin-V.y)+"px",W=""):W=!t&&e.getAttribute("data-svg-origin"),gD(e,W||u,!!W||n.originIsAbsolute,n.smooth!==!1,L)),R=n.xOrigin||0,I=n.yOrigin||0,L!==Rb&&(F=L[0],X=L[1],q=L[2],J=L[3],c=Y=L[4],f=$=L[5],L.length===6?(g=Math.sqrt(F*F+X*X),x=Math.sqrt(J*J+q*q),S=F||X?Ry(X,F)*jm:0,T=q||J?Ry(q,J)*jm+S:0,T&&(x*=Math.abs(Math.cos(T*qy))),n.svg&&(c-=R-(R*F+I*q),f-=I-(R*X+I*J))):(ce=L[6],ue=L[7],G=L[8],ne=L[9],oe=L[10],re=L[11],c=L[12],f=L[13],d=L[14],P=Ry(ce,oe),b=P*jm,P&&(D=Math.cos(-P),O=Math.sin(-P),W=Y*D+G*O,V=$*D+ne*O,se=ce*D+oe*O,G=Y*-O+G*D,ne=$*-O+ne*D,oe=ce*-O+oe*D,re=ue*-O+re*D,Y=W,$=V,ce=se),P=Ry(-q,oe),_=P*jm,P&&(D=Math.cos(-P),O=Math.sin(-P),W=F*D-G*O,V=X*D-ne*O,se=q*D-oe*O,re=J*O+re*D,F=W,X=V,q=se),P=Ry(X,F),S=P*jm,P&&(D=Math.cos(P),O=Math.sin(P),W=F*D+X*O,V=Y*D+$*O,X=X*D-F*O,$=$*D-Y*O,F=W,Y=V),b&&Math.abs(b)+Math.abs(S)>359.9&&(b=S=0,_=180-_),g=Ui(Math.sqrt(F*F+X*X+q*q)),x=Ui(Math.sqrt($*$+ce*ce)),P=Ry(Y,$),T=Math.abs(P)>2e-4?P*jm:0,C=re?1/(re<0?-re:re):0),n.svg&&(W=e.getAttribute("transform"),n.forceCSS=e.setAttribute("transform","")||!i8(rh(e,di)),W&&e.setAttribute("transform",W))),Math.abs(T)>90&&Math.abs(T)<270&&(r?(g*=-1,T+=S<=0?180:-180,S+=S<=0?180:-180):(x*=-1,T+=T<=0?180:-180)),t=t||n.uncache,n.x=c-((n.xPercent=c&&(!t&&n.xPercent||(Math.round(e.offsetWidth/2)===Math.round(-c)?-50:0)))?e.offsetWidth*n.xPercent/100:0)+a,n.y=f-((n.yPercent=f&&(!t&&n.yPercent||(Math.round(e.offsetHeight/2)===Math.round(-f)?-50:0)))?e.offsetHeight*n.yPercent/100:0)+a,n.z=d+a,n.scaleX=Ui(g),n.scaleY=Ui(x),n.rotation=Ui(S)+o,n.rotationX=Ui(b)+o,n.rotationY=Ui(_)+o,n.skewX=T+o,n.skewY=E+o,n.transformPerspective=C+a,(n.zOrigin=parseFloat(u.split(" ")[2])||!t&&n.zOrigin||0)&&(i[Do]=z2(u)),n.xOffset=n.yOffset=0,n.force3D=yl.force3D,n.renderTransform=n.svg?Toe:e8?r8:Aoe,n.uncache=0,n},z2=function(e){return(e=e.split(" "))[0]+" "+e[1]},rI=function(e,t,n){var i=Aa(t);return Ui(parseFloat(t)+parseFloat(rp(e,"x",n+"px",i)))+i},Aoe=function(e,t){t.z="0px",t.rotationY=t.rotationX="0deg",t.force3D=0,r8(e,t)},Pm="0deg",k1="0px",Um=") ",r8=function(e,t){var n=t||this,i=n.xPercent,r=n.yPercent,a=n.x,o=n.y,l=n.z,u=n.rotation,c=n.rotationY,f=n.rotationX,d=n.skewX,g=n.skewY,x=n.scaleX,S=n.scaleY,b=n.transformPerspective,_=n.force3D,T=n.target,E=n.zOrigin,C="",R=_==="auto"&&e&&e!==1||_===!0;if(E&&(f!==Pm||c!==Pm)){var I=parseFloat(c)*qy,L=Math.sin(I),P=Math.cos(I),D;I=parseFloat(f)*qy,D=Math.cos(I),a=rI(T,a,L*D*-E),o=rI(T,o,-Math.sin(I)*-E),l=rI(T,l,P*D*-E+E)}b!==k1&&(C+="perspective("+b+Um),(i||r)&&(C+="translate("+i+"%, "+r+"%) "),(R||a!==k1||o!==k1||l!==k1)&&(C+=l!==k1||R?"translate3d("+a+", "+o+", "+l+") ":"translate("+a+", "+o+Um),u!==Pm&&(C+="rotate("+u+Um),c!==Pm&&(C+="rotateY("+c+Um),f!==Pm&&(C+="rotateX("+f+Um),(d!==Pm||g!==Pm)&&(C+="skew("+d+", "+g+Um),(x!==1||S!==1)&&(C+="scale("+x+", "+S+Um),T.style[di]=C||"translate(0, 0)"},Toe=function(e,t){var n=t||this,i=n.xPercent,r=n.yPercent,a=n.x,o=n.y,l=n.rotation,u=n.skewX,c=n.skewY,f=n.scaleX,d=n.scaleY,g=n.target,x=n.xOrigin,S=n.yOrigin,b=n.xOffset,_=n.yOffset,T=n.forceCSS,E=parseFloat(a),C=parseFloat(o),R,I,L,P,D;l=parseFloat(l),u=parseFloat(u),c=parseFloat(c),c&&(c=parseFloat(c),u+=c,l+=c),l||u?(l*=qy,u*=qy,R=Math.cos(l)*f,I=Math.sin(l)*f,L=Math.sin(l-u)*-d,P=Math.cos(l-u)*d,u&&(c*=qy,D=Math.tan(u-c),D=Math.sqrt(1+D*D),L*=D,P*=D,c&&(D=Math.tan(c),D=Math.sqrt(1+D*D),R*=D,I*=D)),R=Ui(R),I=Ui(I),L=Ui(L),P=Ui(P)):(R=f,P=d,I=L=0),(E&&!~(a+"").indexOf("px")||C&&!~(o+"").indexOf("px"))&&(E=rp(g,"x",a,"px"),C=rp(g,"y",o,"px")),(x||S||b||_)&&(E=Ui(E+x-(x*R+S*L)+b),C=Ui(C+S-(x*I+S*P)+_)),(i||r)&&(D=g.getBBox(),E=Ui(E+i/100*D.width),C=Ui(C+r/100*D.height)),D="matrix("+R+","+I+","+L+","+P+","+E+","+C+")",g.setAttribute("transform",D),T&&(g.style[di]=D)},woe=function(e,t,n,i,r){var a=360,o=Lr(r),l=parseFloat(r)*(o&&~r.indexOf("rad")?jm:1),u=l-i,c=i+u+"deg",f,d;return o&&(f=r.split("_")[1],f==="short"&&(u%=a,u!==u%(a/2)&&(u+=u<0?a:-360)),f==="cw"&&u<0?u=(u+a*cU)%a-~~(u/a)*a:f==="ccw"&&u>0&&(u=(u-a*cU)%a-~~(u/a)*a)),e._pt=d=new Io(e._pt,t,n,i,u,loe),d.e=c,d.u="deg",e._props.push(n),d},yU=function(e,t){for(var n in t)e[n]=t[n];return e},Coe=function(e,t,n){var i=yU({},n._gsap),r="perspective,force3D,transformOrigin,svgOrigin",a=n.style,o,l,u,c,f,d,g,x;i.svg?(u=n.getAttribute("transform"),n.setAttribute("transform",""),a[di]=t,o=Ib(n,1),Ng(n,di),n.setAttribute("transform",u)):(u=getComputedStyle(n)[di],a[di]=t,o=Ib(n,1),a[di]=u);for(l in _f)u=i[l],c=o[l],u!==c&&r.indexOf(l)<0&&(g=Aa(u),x=Aa(c),f=g!==x?rp(n,l,u,x):parseFloat(u),d=parseFloat(c),e._pt=new Io(e._pt,o,l,f,d-f,dD),e._pt.u=x||0,e._props.push(l));yU(o,i)};Ro("padding,margin,Width,Radius",function(s,e){var t="Top",n="Right",i="Bottom",r="Left",a=(e<3?[t,n,i,r]:[t+r,t+n,i+n,i+r]).map(function(o){return e<2?s+o:"border"+o+s});$2[e>1?"border"+s:s]=function(o,l,u,c,f){var d,g;if(arguments.length<4)return d=a.map(function(x){return Qh(o,x,u)}),g=d.join(" "),g.split(d[0]).length===5?d[0]:g;d=(c+"").split(" "),g={},a.forEach(function(x,S){return g[x]=d[S]=d[S]||d[(S-1)/2|0]}),o.init(l,g,f)}});var a8={name:"css",register:mD,targetTest:function(e){return e.style&&e.nodeType},init:function(e,t,n,i,r){var a=this._props,o=e.style,l=n.vars.startAt,u,c,f,d,g,x,S,b,_,T,E,C,R,I,L,P;DO||mD(),this.styles=this.styles||Q5(e),P=this.styles.props,this.tween=n;for(S in t)if(S!=="autoRound"&&(c=t[S],!(ll[S]&&G5(S,t,n,i,e,r)))){if(g=typeof c,x=$2[S],g==="function"&&(c=c.call(n,i,e,r),g=typeof c),g==="string"&&~c.indexOf("random(")&&(c=Eb(c)),x)x(this,e,S,c,n)&&(L=1);else if(S.substr(0,2)==="--")u=(getComputedStyle(e).getPropertyValue(S)+"").trim(),c+="",jd.lastIndex=0,jd.test(u)||(b=Aa(u),_=Aa(c)),_?b!==_&&(u=rp(e,S,u,_)+_):b&&(c+=b),this.add(o,"setProperty",u,c,i,r,0,0,S),a.push(S),P.push(S,0,o[S]);else if(g!=="undefined"){if(l&&S in l?(u=typeof l[S]=="function"?l[S].call(n,i,e,r):l[S],Lr(u)&&~u.indexOf("random(")&&(u=Eb(u)),Aa(u+"")||u==="auto"||(u+=yl.units[S]||Aa(Qh(e,S))||""),(u+"").charAt(1)==="="&&(u=Qh(e,S))):u=Qh(e,S),d=parseFloat(u),T=g==="string"&&c.charAt(1)==="="&&c.substr(0,2),T&&(c=c.substr(2)),f=parseFloat(c),S in Qc&&(S==="autoAlpha"&&(d===1&&Qh(e,"visibility")==="hidden"&&f&&(d=0),P.push("visibility",0,o.visibility),zd(this,o,"visibility",d?"inherit":"hidden",f?"inherit":"hidden",!f)),S!=="scale"&&S!=="transform"&&(S=Qc[S],~S.indexOf(",")&&(S=S.split(",")[0]))),E=S in _f,E){if(this.styles.save(S),C||(R=e._gsap,R.renderTransform&&!t.parseTransform||Ib(e,t.parseTransform),I=t.smoothOrigin!==!1&&R.smooth,C=this._pt=new Io(this._pt,o,di,0,1,R.renderTransform,R,0,-1),C.dep=1),S==="scale")this._pt=new Io(this._pt,R,"scaleY",R.scaleY,(T?Wy(R.scaleY,T+f):f)-R.scaleY||0,dD),this._pt.u=0,a.push("scaleY",S),S+="X";else if(S==="transformOrigin"){P.push(Do,0,o[Do]),c=_oe(c),R.svg?gD(e,c,0,I,0,this):(_=parseFloat(c.split(" ")[2])||0,_!==R.zOrigin&&zd(this,R,"zOrigin",R.zOrigin,_),zd(this,o,S,z2(u),z2(c)));continue}else if(S==="svgOrigin"){gD(e,c,1,I,0,this);continue}else if(S in s8){woe(this,R,S,d,T?Wy(d,T+c):c);continue}else if(S==="smoothOrigin"){zd(this,R,"smooth",R.smooth,c);continue}else if(S==="force3D"){R[S]=c;continue}else if(S==="transform"){Coe(this,c,e);continue}}else S in o||(S=vx(S)||S);if(E||(f||f===0)&&(d||d===0)&&!ooe.test(c)&&S in o)b=(u+"").substr((d+"").length),f||(f=0),_=Aa(c)||(S in yl.units?yl.units[S]:b),b!==_&&(d=rp(e,S,u,_)),this._pt=new Io(this._pt,E?R:o,S,d,(T?Wy(d,T+f):f)-d,!E&&(_==="px"||S==="zIndex")&&t.autoRound!==!1?coe:dD),this._pt.u=_||0,b!==_&&_!=="%"&&(this._pt.b=u,this._pt.r=uoe);else if(S in o)boe.call(this,e,S,u,T?T+c:c);else if(S in e)this.add(e,S,u||e[S],T?T+c:c,i,r);else if(S!=="parseTransform"){AO(S,c);continue}E||(S in o?P.push(S,0,o[S]):typeof e[S]=="function"?P.push(S,2,e[S]()):P.push(S,1,u||e[S])),a.push(S)}}L&&j5(this)},render:function(e,t){if(t.tween._time||!OO())for(var n=t._pt;n;)n.r(e,n.d),n=n._next;else t.styles.revert()},get:Qh,aliases:Qc,getSetter:function(e,t,n){var i=Qc[t];return i&&i.indexOf(",")<0&&(t=i),t in _f&&t!==Do&&(e._gsap.x||Qh(e,"x"))?n&&uU===n?t==="scale"?poe:doe:(uU=n||{})&&(t==="scale"?moe:goe):e.style&&!bO(e.style[t])?hoe:~t.indexOf("-")?foe:RO(e,t)},core:{_removeProperty:Ng,_getMatrix:kO}};Bo.utils.checkPrefix=vx;Bo.core.getStyleSaver=Q5;(function(s,e,t,n){var i=Ro(s+","+e+","+t,function(r){_f[r]=1});Ro(e,function(r){yl.units[r]="deg",s8[r]=1}),Qc[i[13]]=s+","+e,Ro(n,function(r){var a=r.split(":");Qc[a[1]]=i[a[0]]})})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent","rotation,rotationX,rotationY,skewX,skewY","transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective","0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");Ro("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",function(s){yl.units[s]="px"});Bo.registerPlugin(a8);var o8=Bo.registerPlugin(a8)||Bo;o8.core.Tween;function Eoe({position:s,rotation:e,scale:t}){const{scene:n}=h_("/project-3d-reconstructie-van-een-mesolithische-vrouw-mohamadmatar7/models/earring.glb"),i=Me.useRef();return Me.useEffect(()=>{o8.fromTo(i.current,{opacity:0},{opacity:1,duration:1})},[]),ft.jsx("primitive",{ref:i,object:n,position:s,rotation:e,scale:t})}function Moe(){const[s,e]=Me.useState(.1),[t,n]=Me.useState("#3b2f2f"),[i,r]=Me.useState("#000000"),[a,o]=Me.useState(1),[l,u]=Me.useState(!1),[c,f]=DK(),d=["#ffffff","#f1c27d","#dab28f","#a8754f","#8d5524","#000000"],g=b=>{const _=Math.round(b);return d[_]||d[0]},x=()=>{f({skin:s,hair:t,eyes:i,intensity:a,earrings:l?"true":"false"})};Me.useEffect(()=>{const b=c.get("skin"),_=c.get("hair"),T=c.get("eyes"),E=c.get("intensity"),C=c.get("earrings");b&&e(parseFloat(b)),_&&n(_),T&&r(T),E&&o(parseFloat(E)),C&&u(C==="true")},[c]);const S=()=>{e(.1),n("#3b2f2f"),r("#000000"),o(1),u(!1),x()};return Me.useEffect(()=>{x()},[s,t,i,a,l]),ft.jsxs("div",{className:"flex flex-col md:flex-row w-full h-screen",children:[ft.jsxs("div",{className:"w-full md:w-[320px] h-[50vh] md:h-auto overflow-y-auto p-6 shadow-md z-10 flex flex-col gap-6",children:[ft.jsx("h2",{className:"text-xl md:text-2xl font-semibold text-[#EEBD74] text-center uppercase",style:{textShadow:"2px 2px 2px #5C3A1E"},children:"Pas het model aan"}),ft.jsx(JR,{label:"Huidkleur",value:s,onChange:e,options:d,type:"slider"}),ft.jsx(JR,{label:"Haarkleur",value:t,onChange:n,options:["#2e2e2e","#4a2f27","#b55239","#8b5e3c"]}),ft.jsx(JR,{label:"Oogkleur",value:i,onChange:r,options:["#5f9ea0","#1c1c1c","#654321","#a9c9ff"]}),ft.jsxs("div",{className:"flex items-center justify-between gap-3",children:[ft.jsxs("div",{className:"flex items-center gap-2",children:[ft.jsx(cae,{className:"text-[#EEBD74] text-xl transform -rotate-45"}),ft.jsx("span",{className:"text-sm font-medium text-[#EEBD74]",children:"Oorring"})]}),ft.jsxs("label",{className:"relative inline-flex items-center cursor-pointer",children:[ft.jsx("input",{type:"checkbox",className:"sr-only peer",checked:l,onChange:()=>u(!l)}),ft.jsx("div",{className:"w-11 h-6 bg-white rounded-full peer-checked:bg-[#86561C] transition-all"}),ft.jsx("div",{className:"absolute left-1 top-1 w-4 h-4 bg-[#86561C] rounded-full transition-transform peer-checked:translate-x-5 peer-checked:bg-white"})]})]}),ft.jsx(Noe,{label:"Lichtintensiteit",children:ft.jsx("input",{type:"range",min:"0",max:"8",step:"0.1",value:a,onChange:b=>o(parseFloat(b.target.value)),className:"w-full h-2 bg-transparent border-2 border-[#7A3D02] rounded-full cursor-pointer appearance-none outline-none",style:{background:`linear-gradient(to right, #7A3D02 ${a*12.5}%, #c6893b 0%)`}})}),ft.jsxs("button",{onClick:S,className:"mt-4 w-full flex items-center justify-center gap-2 px-4 py-2 bg-[#86561C] hover:bg-[#6c4710] text-white rounded-md shadow-lg transition duration-200 ease-in-out",children:[ft.jsx(hae,{})," Reset"]})]}),ft.jsx("div",{className:"flex-1 h-full",children:ft.jsxs(ure,{camera:{position:[0,2,6],fov:45},children:[ft.jsx("ambientLight",{intensity:1.5}),ft.jsx("directionalLight",{position:[3,3,3],intensity:a}),ft.jsxs(Me.Suspense,{fallback:null,children:[ft.jsx(fae,{skinColor:g(s),hairColor:t,eyeColor:i,scale:1.5,position:[0,0,0],rotation:[-.35,0,0]}),l&&ft.jsx(ft.Fragment,{children:ft.jsx(Eoe,{position:[1.15,-.3,.7],scale:[.02,.02,.02],rotation:[-.2,Math.PI,-.2]})})]}),ft.jsx(nae,{})]})})]})}function Noe({label:s,children:e}){return ft.jsxs("div",{className:"flex flex-col gap-1 w-full",children:[ft.jsx("label",{className:"text-sm font-medium text-[#EEBD74]",children:s}),e]})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Roe=1e-7,Ioe=1e-4;class l8{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class LO{refCount(e){return _o("refCount")}incRef(e){return _o("incRef")}timerAvailable(){return!0}time(e){return _o("time")}read(e){return _o("read")}readSync(e){return _o("readSync")}readToGPU(e,t){return _o("readToGPU")}numDataIds(){return _o("numDataIds")}disposeData(e,t){return _o("disposeData")}write(e,t,n){return _o("write")}move(e,t,n,i,r){return _o("move")}createTensorFromGPUData(e,t,n){return _o("createTensorFromGPUData")}memory(){return _o("memory")}floatPrecision(){return _o("floatPrecision")}epsilon(){return this.floatPrecision()===32?Roe:Ioe}dispose(){return _o("dispose")}}function _o(s){throw new Error(`'${s}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Doe(s){let e=s.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,By(s,e,t)}function Rg(s,e,t){return Math.max(s,Math.min(e,t))}function FO(s){return s%2===0?s:s+1}function By(s,e,t){const n=s[e];s[e]=s[t],s[t]=n}function Ooe(s){let e=0;for(let t=0;t<s.length;t++)e+=s[t];return e}function K(s,e){if(!s)throw new Error(typeof e=="string"?e:e())}function zo(s,e,t=""){K(Wn(s,e),()=>t+` Shapes ${s} and ${e} must match`)}function zx(s){K(s!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Xe(s){if(s.length===0)return 1;let e=s[0];for(let t=1;t<s.length;t++)e*=s[t];return e}function Boe(s,e){if(s===e)return!0;if(s==null||e==null||s.length!==e.length)return!1;for(let t=0;t<s.length;t++)if(s[t]!==null&&e[t]!==null&&s[t]!==e[t])return!1;return!0}function Wn(s,e){if(s===e)return!0;if(s==null||e==null||s.length!==e.length)return!1;for(let t=0;t<s.length;t++)if(s[t]!==e[t])return!1;return!0}function bx(s){return s%1===0}function yD(s){const e=Math.ceil(Math.sqrt(s));return[e,Math.ceil(s/e)]}function jy(s,e){return e<=s.length?s:s+" ".repeat(e-s.length)}function xU(s,e=i=>0,t,n){return new Promise((i,r)=>{let a=0;const o=()=>{if(s()){i();return}a++;const l=e(a);if(t!=null&&a>=t){r();return}n!=null?n(o,l):setTimeout(o,l)};o()})}function u8(s,e){let t=1,n=-1;for(let r=0;r<s.length;++r)if(s[r]>=0)t*=s[r];else if(s[r]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${r}`);n=r}else if(s[r]<0)throw Error(`Shapes can not be < 0. Found ${s[r]} at dim ${r}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${s}`);return s}if(t===0)throw Error(`Cannot infer the missing size in [${s}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=s.slice();return i[n]=e/t,i}function kn(s,e){const t=e.length;return s=s==null?e.map((n,i)=>i):[].concat(s),K(s.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${s}`),K(s.every(n=>bx(n)),()=>`All values in axis param must be integers but got axis ${s}`),s.map(n=>n<0?t+n:n)}function bp(s,e){const t=[],n=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:kn(e,s).sort();let a=0;for(let o=0;o<s.length;++o){if(r!=null){if(r[a]===o&&s[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${s[o]}' is not 1`);(r[a]==null||r[a]>o)&&s[o]===1&&(t.push(s[o]),n.push(o)),r[a]<=o&&a++}s[o]!==1&&(t.push(s[o]),n.push(o))}return{newShape:t,keptDims:n}}function Fr(s,e){return Mi(s,e)}function Mi(s,e){let t=null;if(s==null||s==="float32")t=new Float32Array(e);else if(s==="int32")t=new Int32Array(e);else if(s==="bool")t=new Uint8Array(e);else if(s==="string")t=new Array(e);else throw new Error(`Unknown data type ${s}`);return t}function koe(s,e){for(let t=0;t<s.length;t++){const n=s[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function Loe(s){return s==="bool"||s==="complex64"||s==="float32"||s==="int32"||s==="string"}function c8(s,e){return!(e==="complex64"||e==="float32"&&s!=="complex64"||e==="int32"&&s!=="float32"&&s!=="complex64"||e==="bool"&&s==="bool")}function G2(s){if(s==="float32"||s==="int32")return 4;if(s==="complex64")return 8;if(s==="bool")return 1;throw new Error(`Unknown dtype ${s}`)}function Foe(s){if(s==null)return 0;let e=0;return s.forEach(t=>e+=t.length),e}function d_(s){return typeof s=="string"||s instanceof String}function Poe(s){return typeof s=="boolean"}function xD(s){return typeof s=="number"}function Gx(s){return Array.isArray(s)?Gx(s[0]):s instanceof Float32Array?"float32":s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray?"int32":xD(s)?"float32":d_(s)?"string":Poe(s)?"bool":"float32"}function vD(s){return!!(s&&s.constructor&&s.call&&s.apply)}function bD(s,e){for(let t=e;t<s;++t)if(s%t===0)return t;return s}function jt(s){const e=s.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=s[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*s[n+1];return t}function h8(s,e,t,n=!1){const i=new Array;if(e.length===1){const r=e[0]*(n?2:1);for(let a=0;a<r;a++)i[a]=t[s+a]}else{const r=e[0],a=e.slice(1),o=a.reduce((l,u)=>l*u)*(n?2:1);for(let l=0;l<r;l++)i[l]=h8(s+l*o,a,t,n)}return i}function au(s,e,t=!1){if(s.length===0)return e[0];const n=s.reduce((i,r)=>i*r)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${s}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return h8(0,s,e,t)}function Uoe(s,e){if(Array.isArray(s))return s;if(e==="float32")return s instanceof Float32Array?s:new Float32Array(s);if(e==="int32")return s instanceof Int32Array?s:new Int32Array(s);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(s));throw new Error(`Unknown dtype ${e}`)}function PO(s,e){const t=sa(s,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function sa(s,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(s);if(e==="int32")return new Int32Array(s);if(e==="bool")return new Uint8Array(s);throw new Error(`Unknown data type ${e}`)}function f8(s,e){const t=s.reduce((n,i)=>n*i,1);if(e==null||e==="float32")return au(s,new Float32Array(t));if(e==="int32")return au(s,new Int32Array(t));if(e==="bool")return au(s,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Tl(s){s.forEach(e=>{K(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${s}].`)})}function ah(s,e,t){if(e===0)return 0;if(e===1)return s[0];let n=s[s.length-1];for(let i=0;i<s.length-1;++i)n+=t[i]*s[i];return n}function Hx(s,e,t){if(e===0)return[];if(e===1)return[s];const n=new Array(e);for(let i=0;i<n.length-1;++i)n[i]=Math.floor(s/t[i]),s-=n[i]*t[i];return n[n.length-1]=s,n}function Ig(s){return s&&s.then&&typeof s.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vU="tfjsflags";class $oe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=zoe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const i=this.urlFlags[e];Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ig(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);vU in e&&e[vU].split(",").forEach(n=>{const[i,r]=n.split(":");this.urlFlags[i]=Hoe(i,r)})}}function zoe(s){const e={};return s.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(Goe(e,n[0],n[1]),n.join("="))),e}function Goe(s,e,t){s[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Hoe(s,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ie(){return d8}let d8=null;function Voe(s){d8=s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aI;function p8(){if(aI==null){let s;if(typeof window<"u")s=window;else if(typeof global<"u")s=global;else if(typeof process<"u")s=process;else if(typeof self<"u")s=self;else throw new Error("Could not find a global object");aI=s}return aI}function Woe(){const s=p8();return s._tfGlobals==null&&(s._tfGlobals=new Map),s._tfGlobals}function UO(s,e){const t=Woe();if(t.has(s))return t.get(s);{const n=e();return t.set(s,n),t.get(s)}}const sE="Abs",p_="Acos",m_="Acosh",Vx="Add",iE="AddN",$O="All",zO="Any",rE="ArgMax",aE="ArgMin",g_="Asin",y_="Asinh",x_="Atan",v_="Atanh",b_="Atan2",oE="AvgPool",GO="AvgPoolGrad",lE="AvgPool3D",HO="AvgPool3DGrad",uE="BatchMatMul",cE="BatchToSpaceND",VO="Bincount",hE="BitwiseAnd",Xoe="BroadcastTo",WO="BroadcastArgs",__="Cast",S_="Ceil",A_="ClipByValue",XO="Complex",fE="ComplexAbs",dE="Concat",pE="Conv2D",qO="Conv2DBackpropFilter",mE="Conv2DBackpropInput",gE="Conv3D",jO="Conv3DBackpropFilterV2",KO="Conv3DBackpropInputV2",T_="Cos",w_="Cosh",YO="Cumprod",yE="Cumsum",JO="CropAndResize",ZO="DenseBincount",QO="DepthToSpace",xE="DepthwiseConv2dNative",eB="DepthwiseConv2dNativeBackpropFilter",tB="DepthwiseConv2dNativeBackpropInput",nB="Diag",vE="Dilation2D",_D="Dilation2DBackpropInput",SD="Dilation2DBackpropFilter",qoe="Draw",C_="RealDiv",sB="Einsum",E_="Elu",iB="EluGrad",M_="Erf",bE="Equal",N_="Exp",_E="ExpandDims",R_="Expm1",rB="FFT",aB="Fill",oB="FlipLeftRight",I_="Floor",D_="FloorDiv",SE="FusedBatchNorm",AE="GatherV2",lB="GatherNd",TE="Greater",O_="GreaterEqual",B_="Identity",uB="IFFT",cB="Imag",k_="IsFinite",L_="IsInf",F_="IsNan",wE="LeakyRelu",CE="Less",EE="LessEqual",hB="LinSpace",P_="Log",U_="Log1p",ME="LogicalAnd",NE="LogicalNot",RE="LogicalOr",joe="LogSoftmax",IE="LRN",fB="LRNGrad",DE="Max",$_="Maximum",OE="MaxPool",dB="MaxPoolGrad",BE="MaxPool3D",pB="MaxPool3DGrad",mB="MaxPoolWithArgmax",kE="Mean",LE="Min",z_="Minimum",FE="MirrorPad",G_="Mod",gB="Multinomial",H_="Multiply",PE="Neg",UE="NotEqual",yB="NonMaxSuppressionV3",xB="NonMaxSuppressionV4",vB="NonMaxSuppressionV5",$E="OnesLike",zE="OneHot",GE="Pack",HE="PadV2",V_="Pow",VE="Prelu",WE="Prod",bB="RaggedGather",_B="RaggedRange",SB="RaggedTensorToTensor",AB="Range",TB="Real",W_="Reciprocal",X_="Relu",XE="Reshape",qE="ResizeNearestNeighbor",wB="ResizeNearestNeighborGrad",jE="ResizeBilinear",CB="ResizeBilinearGrad",q_="Relu6",KE="Reverse",j_="Round",K_="Rsqrt",EB="ScatterNd",MB="TensorScatterUpdate",NB="SearchSorted",YE="Select",Y_="Selu",JE="Slice",J_="Sin",Z_="Sinh",Q_="Sign",eS="Sigmoid",tS="Softplus",nS="Sqrt",ZE="Sum",QE="SpaceToBatchND",eM="SplitV",tM="Softmax",RB="SparseFillEmptyRows",IB="SparseReshape",DB="SparseSegmentMean",OB="SparseSegmentSum",BB="SparseToDense",sS="SquaredDifference",kB="Square",nM="StaticRegexReplace",LB="StridedSlice",FB="StringNGrams",PB="StringSplit",UB="StringToHashBucketFast",iS="Sub",rS="Tan",aS="Tanh",oS="Tile",$B="TopK",zB="Transform",Ky="Transpose",GB="Unique",sM="Unpack",iM="UnsortedSegmentSum",rM="ZerosLike",lS="Step",AD="FromPixels",HB="RotateWithOffset",H2="_FusedMatMul",V2="FusedConv2D",W2="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(...s){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(...s)}function Koe(...s){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.log(...s)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X2=UO("kernelRegistry",()=>new Map),TD=UO("gradRegistry",()=>new Map);function wD(s,e){const t=g8(s,e);return X2.get(t)}function bU(s){return TD.get(s)}function _U(s){const e=X2.entries(),t=[];for(;;){const{done:n,value:i}=e.next();if(n)break;const[r,a]=i,[o]=r.split("_");o===s&&t.push(a)}return t}function m8(s){const{kernelName:e,backendName:t}=s,n=g8(e,t);X2.has(n)&&cl(`The kernel '${e}' for backend '${t}' is already registered`),X2.set(n,s)}function Yoe(s){const{kernelName:e}=s;TD.has(e)&&Ie().getBool("DEBUG")&&cl(`Overriding the gradient for '${e}'`),TD.set(e,s)}function g8(s,e){return`${e}_${s}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(s){return s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray}var oI,SU;function Joe(){if(SU)return oI;SU=1,oI=e;var s=null;try{s=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(O,F,X){this.low=O|0,this.high=F|0,this.unsigned=!!X}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(O){return(O&&O.__isLong__)===!0}e.isLong=t;var n={},i={};function r(O,F){var X,q,J;return F?(O>>>=0,(J=0<=O&&O<256)&&(q=i[O],q)?q:(X=o(O,(O|0)<0?-1:0,!0),J&&(i[O]=X),X)):(O|=0,(J=-128<=O&&O<128)&&(q=n[O],q)?q:(X=o(O,O<0?-1:0,!1),J&&(n[O]=X),X))}e.fromInt=r;function a(O,F){if(isNaN(O))return F?T:_;if(F){if(O<0)return T;if(O>=x)return L}else{if(O<=-9223372036854776e3)return P;if(O+1>=S)return I}return O<0?a(-O,F).neg():o(O%g|0,O/g|0,F)}e.fromNumber=a;function o(O,F,X){return new e(O,F,X)}e.fromBits=o;var l=Math.pow;function u(O,F,X){if(O.length===0)throw Error("empty string");if(O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return _;if(typeof F=="number"?(X=F,F=!1):F=!!F,X=X||10,X<2||36<X)throw RangeError("radix");var q;if((q=O.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return u(O.substring(1),F,X).neg();for(var J=a(l(X,8)),Y=_,$=0;$<O.length;$+=8){var W=Math.min(8,O.length-$),V=parseInt(O.substring($,$+W),X);if(W<8){var se=a(l(X,W));Y=Y.mul(se).add(a(V))}else Y=Y.mul(J),Y=Y.add(a(V))}return Y.unsigned=F,Y}e.fromString=u;function c(O,F){return typeof O=="number"?a(O,F):typeof O=="string"?u(O,F):o(O.low,O.high,typeof F=="boolean"?F:O.unsigned)}e.fromValue=c;var f=65536,d=1<<24,g=f*f,x=g*g,S=x/2,b=r(d),_=r(0);e.ZERO=_;var T=r(0,!0);e.UZERO=T;var E=r(1);e.ONE=E;var C=r(1,!0);e.UONE=C;var R=r(-1);e.NEG_ONE=R;var I=o(-1,2147483647,!1);e.MAX_VALUE=I;var L=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=L;var P=o(0,-2147483648,!1);e.MIN_VALUE=P;var D=e.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},D.toString=function(F){if(F=F||10,F<2||36<F)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(P)){var X=a(F),q=this.div(X),J=q.mul(X).sub(this);return q.toString(F)+J.toInt().toString(F)}else return"-"+this.neg().toString(F);for(var Y=a(l(F,6),this.unsigned),$=this,W="";;){var V=$.div(Y),se=$.sub(V.mul(Y)).toInt()>>>0,G=se.toString(F);if($=V,$.isZero())return G+W;for(;G.length<6;)G="0"+G;W=""+G+W}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(P)?64:this.neg().getNumBitsAbs();for(var F=this.high!=0?this.high:this.low,X=31;X>0&&(F&1<<X)==0;X--);return this.high!=0?X+33:X+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(F){return t(F)||(F=c(F)),this.unsigned!==F.unsigned&&this.high>>>31===1&&F.high>>>31===1?!1:this.high===F.high&&this.low===F.low},D.eq=D.equals,D.notEquals=function(F){return!this.eq(F)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(F){return this.comp(F)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(F){return this.comp(F)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(F){return this.comp(F)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(F){return this.comp(F)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(F){if(t(F)||(F=c(F)),this.eq(F))return 0;var X=this.isNegative(),q=F.isNegative();return X&&!q?-1:!X&&q?1:this.unsigned?F.high>>>0>this.high>>>0||F.high===this.high&&F.low>>>0>this.low>>>0?-1:1:this.sub(F).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(P)?P:this.not().add(E)},D.neg=D.negate,D.add=function(F){t(F)||(F=c(F));var X=this.high>>>16,q=this.high&65535,J=this.low>>>16,Y=this.low&65535,$=F.high>>>16,W=F.high&65535,V=F.low>>>16,se=F.low&65535,G=0,ne=0,oe=0,ue=0;return ue+=Y+se,oe+=ue>>>16,ue&=65535,oe+=J+V,ne+=oe>>>16,oe&=65535,ne+=q+W,G+=ne>>>16,ne&=65535,G+=X+$,G&=65535,o(oe<<16|ue,G<<16|ne,this.unsigned)},D.subtract=function(F){return t(F)||(F=c(F)),this.add(F.neg())},D.sub=D.subtract,D.multiply=function(F){if(this.isZero())return _;if(t(F)||(F=c(F)),s){var X=s.mul(this.low,this.high,F.low,F.high);return o(X,s.get_high(),this.unsigned)}if(F.isZero())return _;if(this.eq(P))return F.isOdd()?P:_;if(F.eq(P))return this.isOdd()?P:_;if(this.isNegative())return F.isNegative()?this.neg().mul(F.neg()):this.neg().mul(F).neg();if(F.isNegative())return this.mul(F.neg()).neg();if(this.lt(b)&&F.lt(b))return a(this.toNumber()*F.toNumber(),this.unsigned);var q=this.high>>>16,J=this.high&65535,Y=this.low>>>16,$=this.low&65535,W=F.high>>>16,V=F.high&65535,se=F.low>>>16,G=F.low&65535,ne=0,oe=0,ue=0,re=0;return re+=$*G,ue+=re>>>16,re&=65535,ue+=Y*G,oe+=ue>>>16,ue&=65535,ue+=$*se,oe+=ue>>>16,ue&=65535,oe+=J*G,ne+=oe>>>16,oe&=65535,oe+=Y*se,ne+=oe>>>16,oe&=65535,oe+=$*V,ne+=oe>>>16,oe&=65535,ne+=q*G+J*se+Y*V+$*W,ne&=65535,o(ue<<16|re,ne<<16|oe,this.unsigned)},D.mul=D.multiply,D.divide=function(F){if(t(F)||(F=c(F)),F.isZero())throw Error("division by zero");if(s){if(!this.unsigned&&this.high===-2147483648&&F.low===-1&&F.high===-1)return this;var X=(this.unsigned?s.div_u:s.div_s)(this.low,this.high,F.low,F.high);return o(X,s.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:_;var q,J,Y;if(this.unsigned){if(F.unsigned||(F=F.toUnsigned()),F.gt(this))return T;if(F.gt(this.shru(1)))return C;Y=T}else{if(this.eq(P)){if(F.eq(E)||F.eq(R))return P;if(F.eq(P))return E;var $=this.shr(1);return q=$.div(F).shl(1),q.eq(_)?F.isNegative()?E:R:(J=this.sub(F.mul(q)),Y=q.add(J.div(F)),Y)}else if(F.eq(P))return this.unsigned?T:_;if(this.isNegative())return F.isNegative()?this.neg().div(F.neg()):this.neg().div(F).neg();if(F.isNegative())return this.div(F.neg()).neg();Y=_}for(J=this;J.gte(F);){q=Math.max(1,Math.floor(J.toNumber()/F.toNumber()));for(var W=Math.ceil(Math.log(q)/Math.LN2),V=W<=48?1:l(2,W-48),se=a(q),G=se.mul(F);G.isNegative()||G.gt(J);)q-=V,se=a(q,this.unsigned),G=se.mul(F);se.isZero()&&(se=E),Y=Y.add(se),J=J.sub(G)}return Y},D.div=D.divide,D.modulo=function(F){if(t(F)||(F=c(F)),s){var X=(this.unsigned?s.rem_u:s.rem_s)(this.low,this.high,F.low,F.high);return o(X,s.get_high(),this.unsigned)}return this.sub(this.div(F).mul(F))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return o(~this.low,~this.high,this.unsigned)},D.and=function(F){return t(F)||(F=c(F)),o(this.low&F.low,this.high&F.high,this.unsigned)},D.or=function(F){return t(F)||(F=c(F)),o(this.low|F.low,this.high|F.high,this.unsigned)},D.xor=function(F){return t(F)||(F=c(F)),o(this.low^F.low,this.high^F.high,this.unsigned)},D.shiftLeft=function(F){return t(F)&&(F=F.toInt()),(F&=63)===0?this:F<32?o(this.low<<F,this.high<<F|this.low>>>32-F,this.unsigned):o(0,this.low<<F-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(F){return t(F)&&(F=F.toInt()),(F&=63)===0?this:F<32?o(this.low>>>F|this.high<<32-F,this.high>>F,this.unsigned):o(this.high>>F-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(F){if(t(F)&&(F=F.toInt()),F&=63,F===0)return this;var X=this.high;if(F<32){var q=this.low;return o(q>>>F|X<<32-F,X>>>F,this.unsigned)}else return F===32?o(X,0,this.unsigned):o(X>>>F-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},D.toBytes=function(F){return F?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var F=this.high,X=this.low;return[X&255,X>>>8&255,X>>>16&255,X>>>24,F&255,F>>>8&255,F>>>16&255,F>>>24]},D.toBytesBE=function(){var F=this.high,X=this.low;return[F>>>24,F>>>16&255,F>>>8&255,F&255,X>>>24,X>>>16&255,X>>>8&255,X&255]},e.fromBytes=function(F,X,q){return q?e.fromBytesLE(F,X):e.fromBytesBE(F,X)},e.fromBytesLE=function(F,X){return new e(F[0]|F[1]<<8|F[2]<<16|F[3]<<24,F[4]|F[5]<<8|F[6]<<16|F[7]<<24,X)},e.fromBytesBE=function(F,X){return new e(F[4]<<24|F[5]<<16|F[6]<<8|F[7],F[0]<<24|F[1]<<16|F[2]<<8|F[3],X)},oI}var x8=Joe();const v8=yC(x8),Zoe=nj({__proto__:null,default:v8},[x8]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm=v8||Zoe;function aM(s){return Zm.fromString(s,!0,16)}const b8=aM("c3a5c85c97cb3127"),Km=aM("b492b66fbe98f273"),_a=aM("9ae16a3b2f90404f");function CD(s){return s.xor(s.shru(47))}function _8(s,e,t){const n=s.slice(e,e+t);return Zm.fromBytes(Array.from(n),!0,!0)}function Ps(s,e){return _8(s,e,8)}function AU(s,e){return _8(s,e,4)}function yr(s,e){return e===0?s:s.shru(e).or(s.shl(64-e))}function Kd(s,e,t=aM("9ddfea08eb382d69")){let n=s.xor(e).mul(t);n=n.xor(n.shru(47));let i=e.xor(n).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function Qoe(s,e,t,n,i,r){i=i.add(s),r=yr(r.add(i).add(n),21);const a=i;return i=i.add(e),i=i.add(t),r=r.add(yr(i,44)),[i.add(n),r.add(a)]}function rw(s,e,t,n){return Qoe(Ps(s,e),Ps(s,e+8),Ps(s,e+16),Ps(s,e+24),t,n)}function ele(s,e=s.length){if(e>=8){const t=_a.add(e*2),n=Ps(s,0).add(_a),i=Ps(s,e-8),r=yr(i,37).mul(t).add(n),a=yr(n,25).add(i).mul(t);return Kd(r,a,t)}if(e>=4){const t=_a.add(e*2),n=AU(s,0);return Kd(n.shl(3).add(e),AU(s,e-4),t)}if(e>0){const t=s[0],n=s[e>>1],i=s[e-1],r=t+(n<<8),a=e+(i<<2);return CD(_a.mul(r).xor(b8.mul(a))).mul(_a)}return _a}function tle(s,e=s.length){const t=_a.add(e*2),n=Ps(s,0).mul(Km),i=Ps(s,8),r=Ps(s,e-8).mul(t),a=Ps(s,e-16).mul(_a);return Kd(yr(n.add(i),43).add(yr(r,30)).add(a),n.add(yr(i.add(_a),18)).add(r),t)}function nle(s,e=s.length){const t=_a.add(e*2),n=Ps(s,0).mul(_a),i=Ps(s,8),r=Ps(s,e-8).mul(t),a=Ps(s,e-16).mul(_a),o=yr(n.add(i),43).add(yr(r,30)).add(a),l=Kd(o,n.add(yr(i.add(_a),18)).add(r),t),u=Ps(s,16).mul(t),c=Ps(s,24),f=o.add(Ps(s,e-32)).mul(t),d=l.add(Ps(s,e-24)).mul(t);return Kd(yr(u.add(c),43).add(yr(f,30)).add(d),u.add(yr(c.add(n),18)).add(f),t)}function sle(s,e=s.length){const t=Zm.fromNumber(81,!0);if(e<=32)return e<=16?ele(s,e):tle(s,e);if(e<=64)return nle(s,e);let n=t,i=t.mul(Km).add(113),r=CD(i.mul(_a).add(113)).mul(_a),a=[Zm.UZERO,Zm.UZERO],o=[Zm.UZERO,Zm.UZERO];n=n.mul(_a).add(Ps(s,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do n=yr(n.add(i).add(a[0]).add(Ps(s,l+8)),37).mul(Km),i=yr(i.add(a[1]).add(Ps(s,l+48)),42).mul(Km),n=n.xor(o[1]),i=i.add(a[0]).add(Ps(s,l+40)),r=yr(r.add(o[0]),33).mul(Km),a=rw(s,l,a[1].mul(Km),n.add(o[0])),o=rw(s,l+32,r.add(o[1]),i.add(Ps(s,l+16))),[r,n]=[n,r],l+=64;while(l!==u);const f=Km.add(r.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),n=yr(n.add(i).add(a[0]).add(Ps(s,l+8)),37).mul(f),i=yr(i.add(a[1]).add(Ps(s,l+48)),42).mul(f),n=n.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(Ps(s,l+40))),r=yr(r.add(o[0]),33).mul(f),a=rw(s,l,a[1].mul(f),n.add(o[0])),o=rw(s,l+32,r.add(o[1]),i.add(Ps(s,l+16))),[r,n]=[n,r],Kd(Kd(a[0],o[0],f).add(CD(i).mul(b8)).add(r),Kd(a[1],o[1],f).add(n),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(s,e){return e==="string"?Yd(s):Jg([s],e)}function ile(s,e){return s instanceof Float32Array&&e==="float32"||s instanceof Int32Array&&e==="int32"||s instanceof Uint8Array&&e==="bool"}function Jg(s,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(s)&&(s=Dg(s)),Ie().getBool("DEBUG")&&koe(s,e),ile(s,e))return s;if(e==null||e==="float32"||e==="complex64")return new Float32Array(s);if(e==="int32")return new Int32Array(s);if(e==="bool"){const t=new Uint8Array(s.length);for(let n=0;n<t.length;++n)Math.round(s[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Za(){return Ie().platform.now()}function Yd(s,e="utf-8"){return e=e||"utf-8",Ie().platform.encode(s,e)}function ap(s,e="utf-8"){return e=e||"utf-8",Ie().platform.decode(s,e)}function uu(s){return Ie().platform.isTypedArray!=null?Ie().platform.isTypedArray(s):y8(s)}function Dg(s,e=[],t=!1){if(e==null&&(e=[]),typeof s=="boolean"||typeof s=="number"||typeof s=="string"||Ig(s)||s==null||uu(s)&&t)e.push(s);else if(Array.isArray(s)||uu(s))for(let n=0;n<s.length;++n)Dg(s[n],e,t);else{let n=-1;for(const i of Object.keys(s))/^([1-9]+[0-9]*|0)$/.test(i)&&(n=Math.max(n,Number(i)));for(let i=0;i<=n;i++)Dg(s[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rle{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new ole)}profileKernel(e,t,n){let i;const r=()=>{i=n()};let a;const o=Za();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const u of i)u.dataSync();a=Promise.resolve({kernelMs:Za()-o})}if(Ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<i.length;u++){const c=i[u];c.data().then(f=>{ale(f,c.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:i,inputs:r,extraInfo:a}=e;n.forEach(o=>{Promise.all([o.data(),i,a]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],r,l[2])})})}}function ale(s,e,t){if(e!=="float32")return!1;for(let n=0;n<s.length;n++){const i=s[n];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class ole{logKernelProfile(e,t,n,i,r,a){const o=typeof i=="number"?jy(`${i}ms`,9):i.error,l=jy(e,25),u=t.rank,c=t.size,f=jy(t.shape.toString(),14);let d="";for(const g in r){const x=r[g];if(x!=null){const S=x.shape||t.shape,b=S.length;d+=`${g}: ${b}D ${b>0?S:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${f}	%c${c}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lle(s,e,t){const n={},i={};for(let l=0;l<e.length;l++)n[e[l].id]=!0;for(let l=0;l<s.length;l++){const u=s[l],c=u.inputs;for(const f in c){const d=c[f];let g=!1;for(let x=0;x<e.length;x++)if(n[d.id]){u.outputs.forEach(S=>n[S.id]=!0),g=!0,i[u.id]=!0;break}if(g)break}}const r={};r[t.id]=!0;const a={};for(let l=s.length-1;l>=0;l--){const u=s[l],c=u.inputs;for(let f=0;f<u.outputs.length;f++)if(r[u.outputs[f].id]){for(const d in c)r[c[d].id]=!0,a[u.id]=!0;break}}const o=[];for(let l=0;l<s.length;l++){const u=s[l];if(i[u.id]&&a[u.id]){const c={};for(const d in u.inputs){const g=u.inputs[d];n[g.id]&&(c[d]=g)}const f=Object.assign({},u);f.inputs=c,f.outputs=u.outputs,o.push(f)}}return o}function ule(s,e,t,n){for(let i=e.length-1;i>=0;i--){const r=e[i],a=[];if(r.outputs.forEach(l=>{const u=s[l.id];u!=null?a.push(u):a.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const o=r.gradient(a);for(const l in r.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=t(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=r.inputs[l];if(!Wn(u.shape,c.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(s[c.id]==null)s[c.id]=u;else{const f=s[c.id];s[c.id]=n(f,u),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TU=20,L1=3,lI=7;function cle(s,e,t,n){const i=jt(e),r=hle(s,e,t,i),a=e.length,o=Iw(s,e,t,i,r),l=["Tensor"];return n&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function hle(s,e,t,n){const i=Xe(e),r=n[n.length-1],a=new Array(r).fill(0),o=e.length,l=t==="complex64"?X1(s):s;if(o>1)for(let u=0;u<i/r;u++){const c=u*r;for(let f=0;f<r;f++)a[f]=Math.max(a[f],W1(l[c+f],0,t).length)}return a}function W1(s,e,t){let n;return Array.isArray(s)?n=`${parseFloat(s[0].toFixed(lI))} + ${parseFloat(s[1].toFixed(lI))}j`:d_(s)?n=`'${s}'`:t==="bool"?n=S8(s):n=parseFloat(s.toFixed(lI)).toString(),jy(n,e)}function S8(s){return s===0?"false":"true"}function Iw(s,e,t,n,i,r=!0){const a=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const S=X1(s);return[W1(S[0],0,t)]}return t==="bool"?[S8(s[0])]:[s[0].toString()]}if(l===1){if(o>TU){const b=L1*a;let _=Array.from(s.slice(0,b)),T=Array.from(s.slice((o-L1)*a,o*a));return t==="complex64"&&(_=X1(_),T=X1(T)),["["+_.map((E,C)=>W1(E,i[C],t)).join(", ")+", ..., "+T.map((E,C)=>W1(E,i[o-L1+C],t)).join(", ")+"]"]}return["["+(t==="complex64"?X1(s):Array.from(s)).map((b,_)=>W1(b,i[_],t)).join(", ")+"]"]}const u=e.slice(1),c=n.slice(1),f=n[0]*a,d=[];if(o>TU){for(let S=0;S<L1;S++){const b=S*f,_=b+f;d.push(...Iw(s.slice(b,_),u,t,c,i,!1))}d.push("...");for(let S=o-L1;S<o;S++){const b=S*f,_=b+f;d.push(...Iw(s.slice(b,_),u,t,c,i,S===o-1))}}else for(let S=0;S<o;S++){const b=S*f,_=b+f;d.push(...Iw(s.slice(b,_),u,t,c,i,S===o-1))}const g=l===2?",":"";d[0]="["+(o>0?d[0]+g:"");for(let S=1;S<d.length-1;S++)d[S]=" "+d[S]+g;let x=`,
`;for(let S=2;S<l;S++)x+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":x),d}function X1(s){const e=[];for(let t=0;t<s.length;t+=2)e.push([s[t],s[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nr{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Xe(e),n!=null){const i=n.length;K(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Mi(t,this.size),this.strides=jt(e)}set(e,...t){t.length===0&&(t=[0]),K(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let i=0;i<e.length-1;++i)n+=this.strides[i]*e[i];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ku().makeTensor(this.values,this.shape,this.dtype)}}let Ku=null,ky=null;function fle(s){Ku=s}function dle(s){ky=s}class ls{constructor(e,t,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Xe(e),this.strides=jt(e),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ky.buffer(this.shape,this.dtype,e)}bufferSync(){return ky.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return au(this.shape,e,this.dtype==="complex64")}arraySync(){return au(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ku().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>ap(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ku().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ku().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ap(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ku().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ku().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ky.print(this,e)}clone(){return this.throwIfDisposed(),ky.clone(this)}toString(e=!1){const t=this.dataSync();return cle(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ky.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ku().makeVariable(this,e,t,n)}}Object.defineProperty(ls,Symbol.hasInstance,{value:s=>!!s&&s.data!=null&&s.dataSync!=null&&s.throwIfDisposed!=null});function je(){return UO("Tensor",()=>ls)}je();class q2 extends ls{constructor(e,t,n,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Wn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ku().disposeTensor(this),this.dataId=e.dataId,Ku().incRef(this,null)}dispose(){Ku().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(q2,Symbol.hasInstance,{value:s=>s instanceof ls&&s.assign!=null&&s.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var wU;(function(s){s.R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6"})(wU||(wU={}));var ED;(function(s){s.float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64"})(ED||(ED={}));var MD;(function(s){s.float32="float32",s.int32="int32",s.bool="bool",s.complex64="complex64"})(MD||(MD={}));var ND;(function(s){s.float32="float32",s.int32="float32",s.bool="float32",s.complex64="complex64"})(ND||(ND={}));var RD;(function(s){s.float32="complex64",s.int32="complex64",s.bool="complex64",s.complex64="complex64"})(RD||(RD={}));const ple={float32:ND,int32:ED,bool:MD,complex64:RD};function ko(s,e){if(s==="string"||e==="string"){if(s==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${s} with ${e}`)}return ple[s][e]}function VB(s){return ko(s,"int32")}function A8(s){return s!=null&&typeof s=="object"&&"texture"in s&&s.texture instanceof WebGLTexture}function T8(s){return typeof GPUBuffer<"u"&&s!=null&&typeof s=="object"&&"buffer"in s&&s.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(s,e){if(s.dtype===e.dtype)return[s,e];const t=ko(s.dtype,e.dtype);return[s.cast(t),e.cast(t)]}function mle(s,e){K(s.dtype===e.dtype,()=>`The dtypes of the first(${s.dtype}) and second(${e.dtype}) input must match`)}function w8(s){const e=[];return C8(s,e,new Set),e}function C8(s,e,t){if(s==null)return;if(s instanceof ls){e.push(s);return}if(!gle(s))return;const n=s;for(const i in n){const r=n[i];t.has(r)||(t.add(r),C8(r,e,t))}}function gle(s){return Array.isArray(s)||typeof s=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(s){return s.kernelName!=null}class CU{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class _x{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new CU}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(cl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new rle(this.backendInstance),!0}setupRegisteredKernels(){_U(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){_U(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(n&&!(n instanceof LO)&&typeof n.then=="function"){const i=++this.pendingBackendInitId,r=n.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,cl(`Initialization of backend ${e} failed`),cl(a.stack||a.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return cl(`Initialization of backend ${e} failed`),cl(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:i,asyncInit:r}=this.initializeBackend(n);if(r||i)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),i=n.backend,r=this.readSync(t),a=i.refCount(t);i.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let i;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,n){e();try{const i=n();return t(),i}catch(i){throw t(),i}}nextTensorId(){return _x.nextTensorId++}nextVariableId(){return _x.nextVariableId++}clone(e){const t=me.runKernel(B_,{x:e}),n={x:e},i=a=>({x:()=>{const o="float32",l={x:a},u={dtype:o};return me.runKernel(__,l,u)}}),r=[];return this.addTapeNode(this.state.activeScope.name,n,[t],i,r,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(wD(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const i=this.backend.numDataIds();let r=0;n.forEach(l=>{r+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-t-r-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const i=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=uI(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(uI(e)){const{kernelName:x,inputs:S,attrs:b}=e;this.backendName==null&&this.backend;const _=wD(x,this.backendName);K(_!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),o=()=>{const T=this.backend.numDataIds();l=_.kernelFunc({inputs:S,attrs:b,backend:this.backend});const E=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,T,E);const C=E.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(i){const R=this.getTensorsForGradient(x,S,C);n=this.saveTensorsForBackwardMode(R)}return C}}else{const{forwardFunc:x}=e,S=b=>{i&&(n=b.map(_=>this.keep(this.clone(_))))};o=()=>{const b=this.backend.numDataIds();l=this.tidy(()=>x(this.backend,S));const _=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,b,_),_}}const{inputs:c,attrs:f}=e,d=uI(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(g=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),t=g.outputs)}),i&&this.addTapeNode(u,c,t,d,n,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(x=>c[x]!=null?c[x].shape:null),outputShapes:t.map(x=>x.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){const i=bU(e);if(i!=null){const r=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(K(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(u=>t[u])):o=r.map(u=>t[u]);const l=n.filter((u,c)=>a[c]);return o.concat(l)}return[]}makeTensor(e,t,n,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",i=i||this.backend;let r=e;n==="string"&&d_(e[0])&&(r=e.map(l=>Yd(l)));const a=i.write(r,t,n),o=new ls(t,n,a,this.nextTensorId());if(this.trackTensor(o,i),n==="string"){const l=this.state.tensorInfo.get(a),u=Foe(r);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(e,t,n,i){n=n||"float32";const r={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:i,dtype:r}=e,a=new ls(i,r,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,i){n=n||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new q2(e,t,n,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*G2(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof q2||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*G2(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,i,r,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},l=bU(e);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=u=>(u=u.map((c,f)=>{if(c==null){const d=n[f],g=sa(d.size,d.dtype);return this.makeTensor(g,d.shape,d.dtype)}return c}),i(u.length>1?u:u[0],r,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=w8(e),n=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const a=this.state.activeScope.track[r];!a.kept&&!n.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,n,i=!1){if(K(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));K(r instanceof ls,()=>"The result y returned by f() must be a tensor.");const a=lle(this.state.activeTape,t,r);if(!i&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[r.id]=n??yle(r.shape),ule(o,a,u=>this.tidy(u),xle);const l=t.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return K(vD(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{K(t.every(o=>o instanceof ls),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const i={};t.forEach((o,l)=>{i[l]=o});const r=(o,l)=>(n=e(...t,l),K(n.value instanceof ls,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),K(vD(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(o,l)=>{const u=n.gradFunc(o,l),c=Array.isArray(u)?u:[u];K(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),K(c.every(d=>d instanceof ls),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return c.forEach((d,g)=>{f[g]=()=>d}),f};return this.runKernelFunc({forwardFunc:r,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Za(),n=await this.backend.time(e);return n.wallMs=Za()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new CU;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}_x.nextTensorId=0;_x.nextVariableId=0;function yle(s){const e=PO(Xe(s),"float32");return me.makeTensor(e,s,"float32")}function E8(){const s=p8();if(s._tfengine==null){const e=new $oe(s);s._tfengine=new _x(e)}return Voe(s._tfengine.ENV),fle(()=>s._tfengine),s._tfengine}const me=E8();function xle(s,e){const t={a:s,b:e};return me.runKernel(Vx,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vle(){return typeof navigator<"u"&&navigator!=null}function M8(s){if(s||vle()){if(s||(s=navigator),s.product==="ReactNative")return!0;const e=s.userAgent||s.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=s;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function N8(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const io=Ie();io.registerFlag("DEBUG",()=>!1,s=>{s&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});io.registerFlag("IS_BROWSER",()=>N8());io.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");io.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));io.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));io.registerFlag("PROD",()=>!1);io.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>io.getBool("DEBUG"));io.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);io.registerFlag("IS_TEST",()=>!1);io.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>io.getBool("DEBUG"));io.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);io.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);io.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sp(s,e){let t=s;if(uu(s))return e==="string"?[]:[s.length];if(A8(s)){const i=s.channels||"RGBA";return[s.height,s.width*i.length]}else if(T8(s))return[s.buffer.size/(e==null?4:G2(e))];if(!Array.isArray(s))return[];const n=[];for(;Array.isArray(t)||uu(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(s)&&Ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&R8(s,n,[]),n}function R8(s,e,t){if(t=t||[],!Array.isArray(s)&&!uu(s)){K(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}K(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${s.length} elements`),K(s.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${s.length} elements`);const n=e.slice(1);for(let i=0;i<s.length;++i)R8(s[i],n,t.concat(i))}function EU(s,e,t,n){if(s!=="string_or_numeric"){if(s==null)throw new Error("Expected dtype cannot be null.");if(s!=="numeric"&&s!==e||s==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${s} tensor, but got ${e} tensor`)}}function Q(s,e,t,n="numeric"){if(s instanceof je())return EU(n,s.dtype,e,t),s;let i=Gx(s);if(i!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(i=n),EU(n,i,e,t),s==null||!uu(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string"){const l=s==null?"null":s.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const r=Sp(s,i);!uu(s)&&!Array.isArray(s)&&(s=[s]);const o=i!=="string"?Jg(s,i):Dg(s,[],!0);return me.makeTensor(o,r,i)}function j2(s,e,t,n="numeric"){if(!Array.isArray(s))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return s.map((r,a)=>Q(r,`${e}[${a}]`,t,n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I8="__op";function fe(s){const e=Object.keys(s);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const n=s[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+I8;const i=(...r)=>{me.startScope(t);try{const a=n(...r);return Ig(a)&&console.error("Cannot return a Promise inside of tidy."),me.endScope(a),a}catch(a){throw me.endScope(null),a}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ble(s,e){const t=Q(s,"real","complex"),n=Q(e,"imag","complex");zo(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);const i={real:t,imag:n};return me.runKernel(XO,i)}const op=fe({complex_:ble});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(s,e,t,n){if(n==null)n=Gx(s);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(T8(s)||A8(s)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return me.backend.createTensorFromGPUData(s,e||t,n)}if(!uu(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Tl(e);const i=Xe(e),r=Xe(t);K(i===r,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);for(let a=0;a<t.length;++a){const o=t[a],l=a===t.length-1?o!==Xe(e.slice(a)):!0;K(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!uu(s)&&!Array.isArray(s)&&(s=[s]),e=e||t,s=n!=="string"?Jg(s,n):Dg(s,[],!0),me.makeTensor(s,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(s,e,t){const n=Sp(s,t);return Ap(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Og={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class cc{static join(e){return new cc(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(n=>uu(n)?n.buffer:n),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const i=e[n];n!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+i.byteLength;this.shards.push({buffer:i,start:t,end:r}),t=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(n===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,r=new ArrayBuffer(i),a=new Uint8Array(r);let o=0;for(let l=n;l<this.shards.length;l++){const u=this.shards[l],f=e+o-u.start,d=o,x=Math.min(t,u.end)-u.start,S=new Uint8Array(u.buffer,f,x-f);if(a.set(S,d),o+=S.length,t<u.end)break}return r}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const n=_le(this.shards,t);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function _le(s,e){let t=0,n=s.length;for(;t<=n;){const i=Math.floor((n-t)/2)+t,r=e(s[i]);if(r===0)return i;r<0?n=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qc(){return me}function MU(){return me.memory()}function we(s,e){return me.tidy(s,e)}function Bn(s){w8(s).forEach(t=>t.dispose())}function xr(s){return me.keep(s)}function Sle(s){return me.setBackend(s)}function Ale(){return me.ready()}function D8(){return me.backendName}function O8(s,e,t=1){return me.registerBackend(s,e,t)}function B8(){return me.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lp=4;async function ID(s,e){const t=[],n=[],i=Array.isArray(s)?s.map(a=>a.name):Object.keys(s);for(let a=0;a<i.length;++a){const o=i[a],l=Array.isArray(s)?s[a].tensor:s[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async f=>{const d=await l.bytes(),g=d.reduce((b,_)=>b+_.length,0)+lp*d.length,x=new Uint8Array(g);let S=0;for(let b=0;b<d.length;b++){const _=d[b],T=new Uint8Array(new Uint32Array([_.length]).buffer);x.set(T,S),S+=lp,x.set(_,S),S+=_.length}f(x)});n.push(c)}else n.push(l.data());e!=null&&(u.group=e),t.push(u)}const r=await Promise.all(n);return{data:Cle(r),specs:t}}function k8(s,e){const t=new cc(s),n={};let i=0;for(const r of e){const a=Tle(r,(o,l)=>t.slice(i+o,i+l));n[r.name]=L8(r,t.slice(i,i+a)),i+=a}return n}function Tle(s,e){const t=Xe(s.shape);let n;if("quantization"in s){const i=s.quantization;n=Og[i.dtype]}else if(s.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=lp+new Uint32Array(e(i,i+lp))[0];return i}else n=Og[s.dtype];return t*n}async function wle(s,e){const t=Xe(s.shape);let n;if("quantization"in s){const i=s.quantization;n=Og[i.dtype]}else if(s.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=lp+new Uint32Array(await e(i,i+lp))[0];return i}else n=Og[s.dtype];return t*n}function L8(s,e){const t=s.name,n=s.dtype,i=s.shape,r=Xe(i);let a,o=0;if("quantization"in s){const l=s.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${s.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(n!=="float32")throw new Error(`Weight ${s.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${n}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Og[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(n==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(c.length);for(let f=0;f<c.length;f++){const d=c[f];a[f]=d*l.scale+l.min}}else if(l.dtype==="float16")a=Dle()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(n==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(c.length);for(let f=0;f<c.length;f++){const d=c[f];a[f]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${n}`);o+=r*u}else if(n==="string"){const l=Xe(s.shape);a=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(o,o+lp))[0];o+=lp;const f=new Uint8Array(e.slice(o,o+c));a.push(f),o+=c}}else{const l=Og[n];if(n==="float32")a=new Float32Array(e);else if(n==="int32")a=new Int32Array(e);else if(n==="bool")a=new Uint8Array(e);else if(n==="complex64"){a=new Float32Array(e);const u=new Float32Array(a.length/2),c=new Float32Array(a.length/2);for(let x=0;x<u.length;x++)u[x]=a[x*2],c[x]=a[x*2+1];const f=Qu(u,i,"float32"),d=Qu(c,i,"float32"),g=op(f,d);return f.dispose(),d.dispose(),g}else throw new Error(`Unsupported dtype in weight '${t}': ${n}`);o+=r*l}return Qu(a,i,n)}async function NU(s,e,t){let n=new Uint8Array(e);for(;n.byteLength<t;){const{done:i,value:r}=await s.read();if(i&&r==null){const o=t-n.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(n.length+r.byteLength);a.set(n,0),a.set(new Uint8Array(r),n.length),n=a}return n.buffer}async function F8(s,e){const t={},n=s.getReader();let i=new ArrayBuffer(0);for(const r of e){const a=await wle(r,async(u,c)=>(i=await NU(n,i,c),i.slice(u,c)));i=await NU(n,i,a);const o=i.slice(0,a);i=i.slice(a);const l=L8(r,o);if(t[r.name]=l,D8()==="webgpu"){const u=B8();"uploadToGPU"in u&&Xe(l.shape)>=Ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function Cle(s){if(s===null)throw new Error(`Invalid input value: ${JSON.stringify(s)}`);let e=0;const t=[];s.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const n=new Uint8Array(e);let i=0;return t.forEach(r=>{n.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),n.buffer}const WB=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function RU(s){return WB?Buffer.byteLength(s,"utf8"):new Blob([s]).size}function Ele(s){if(WB)return Buffer.from(s).toString("base64");const e=new Uint8Array(s);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function Mle(s){if(WB){const n=Buffer.from(s,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(s),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function P8(s){return cc.join(s)}function IU(s){const e="/";for(s=s.trim();s.endsWith(e);)s=s.slice(0,s.length-1);const t=s.split(e);return t[t.length-1]}function U8(s,e){const t={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy,weightsManifest:e};return s.signature!=null&&(t.signature=s.signature),s.userDefinedMetadata!=null&&(t.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(t.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(t.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(t.trainingConfig=s.trainingConfig),t}function $8(s,e,t){const n={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy};if(s.trainingConfig!=null&&(n.trainingConfig=s.trainingConfig),s.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return s.signature!=null&&(n.signature=s.signature),s.userDefinedMetadata!=null&&(n.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(n.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(n.initializerSignature=s.initializerSignature),n}async function XB(s,e){let t,n;return s.weightsManifest!=null&&([t,n]=await e(s.weightsManifest)),$8(s,t,n)}function uS(s){if(s.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:s.modelTopology==null?0:RU(JSON.stringify(s.modelTopology)),weightSpecsBytes:s.weightSpecs==null?0:RU(JSON.stringify(s.weightSpecs)),weightDataBytes:s.weightData==null?0:new cc(s.weightData).byteLength}}function DD(s){const e=[];for(const t of s)e.push(...t.weights);return e}function Nle(){const s=t=>{let n=t<<13,i=0;for(;(n&8388608)===0;)i-=8388608,n<<=1;return n&=-8388609,i+=947912704,n|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=s(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Rle(){const s=new Uint32Array(64);s[0]=0,s[31]=1199570944,s[32]=2147483648,s[63]=3347054592;for(let e=1;e<31;e++)s[e]=e<<23;for(let e=33;e<63;e++)s[e]=2147483648+(e-32<<23);return s}function Ile(){const s=new Uint32Array(64);for(let e=0;e<64;e++)s[e]=1024;return s[0]=s[32]=0,s}function Dle(){const s=Nle(),e=Rle(),t=Ile();return n=>{const i=new ArrayBuffer(4*n.length),r=new Uint32Array(i);for(let a=0;a<n.length;a++){const o=n[a],l=s[t[o>>10]+(o&1023)]+e[o>>10];r[a]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ti{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ti.instance==null&&(ti.instance=new ti),ti.instance}static registerSaveRouter(e){ti.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ti.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ti.getHandlers(e,"save")}static getLoadHandlers(e,t){return ti.getHandlers(e,"load",t)}static getHandlers(e,t,n){const i=[];return(t==="load"?ti.getInstance().loadRouters:ti.getInstance().saveRouters).forEach(a=>{const o=a(e,n);o!==null&&i.push(o)}),i}}const Ole=s=>ti.registerSaveRouter(s),Ble=s=>ti.registerLoadRouter(s),z8=s=>ti.getSaveHandlers(s),kle=(s,e)=>ti.getLoadHandlers(s,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OD="tensorflowjs",BD=1,ug="models_store",Gd="model_info_store";function G8(){if(!Ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window>"u"?self:window,e=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function kD(s){const e=s.result;e.createObjectStore(ug,{keyPath:"modelPath"}),e.createObjectStore(Gd,{keyPath:"modelPath"})}class Bg{constructor(e){if(this.indexedDB=G8(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,i)=>{const r=this.indexedDB.open(OD,BD);r.onupgradeneeded=()=>kD(r),r.onsuccess=()=>{const a=r.result;if(t==null){const o=a.transaction(ug,"readonly"),u=o.objectStore(ug).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=c=>(a.close(),i(u.error)),o.oncomplete=()=>a.close()}else{t.weightData=cc.join(t.weightData);const o=uS(t),l=a.transaction(Gd,"readwrite");let u=l.objectStore(Gd),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(d){return i(d)}let f;c.onsuccess=()=>{f=a.transaction(ug,"readwrite");const d=f.objectStore(ug);let g;try{g=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(x){return i(x)}g.onsuccess=()=>n({modelArtifactsInfo:o}),g.onerror=x=>{u=l.objectStore(Gd);const S=u.delete(this.modelPath);S.onsuccess=()=>(a.close(),i(g.error)),S.onerror=b=>(a.close(),i(g.error))}},c.onerror=d=>(a.close(),i(c.error)),l.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},r.onerror=a=>i(r.error)})}}Bg.URL_SCHEME="indexeddb://";const H8=s=>Ie().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Bg.URL_SCHEME)?Lle(s.slice(Bg.URL_SCHEME.length)):null;ti.registerSaveRouter(H8);ti.registerLoadRouter(H8);function Lle(s){return new Bg(s)}function Fle(s){return s.startsWith(Bg.URL_SCHEME)?s.slice(Bg.URL_SCHEME.length):s}class Ple{constructor(){this.indexedDB=G8()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(OD,BD);n.onupgradeneeded=()=>kD(n),n.onsuccess=()=>{const i=n.result,r=i.transaction(Gd,"readonly"),o=r.objectStore(Gd).getAll();o.onsuccess=()=>{const l={};for(const u of o.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},o.onerror=l=>(i.close(),t(o.error)),r.oncomplete=()=>i.close()},n.onerror=i=>t(n.error)})}async removeModel(e){return e=Fle(e),new Promise((t,n)=>{const i=this.indexedDB.open(OD,BD);i.onupgradeneeded=()=>kD(i),i.onsuccess=()=>{const r=i.result,a=r.transaction(Gd,"readwrite"),o=a.objectStore(Gd),l=o.get(e);let u;l.onsuccess=()=>{if(l.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=o.delete(e),f=()=>{u=r.transaction(ug,"readwrite");const g=u.objectStore(ug).delete(e);g.onsuccess=()=>t(l.result.modelArtifactsInfo),g.onerror=x=>n(l.error)};c.onsuccess=f,c.onerror=d=>(f(),r.close(),n(l.error))}},l.onerror=c=>(r.close(),n(l.error)),a.oncomplete=()=>{u==null?r.close():u.oncomplete=()=>r.close()}},i.onerror=r=>n(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const af="/",Ly="tensorflowjs_models",V8="info",Ule="model_topology",$le="weight_specs",zle="weight_data",Gle="model_metadata";function W8(s){return{info:[Ly,s,V8].join(af),topology:[Ly,s,Ule].join(af),weightSpecs:[Ly,s,$le].join(af),weightData:[Ly,s,zle].join(af),modelMetadata:[Ly,s,Gle].join(af)}}function X8(s){for(const e of Object.values(s))window.localStorage.removeItem(e)}function Hle(s){const e=s.split(af);if(e.length<3)throw new Error(`Invalid key format: ${s}`);return e.slice(1,e.length-1).join(af)}function Vle(s){return s.startsWith(kg.URL_SCHEME)?s.slice(kg.URL_SCHEME.length):s}class kg{constructor(e){if(!Ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=W8(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),i=uS(e),r=cc.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Ele(r));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw X8(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const o=JSON.parse(r);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Mle(a),t}}kg.URL_SCHEME="localstorage://";const q8=s=>Ie().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(kg.URL_SCHEME)?Wle(s.slice(kg.URL_SCHEME.length)):null;ti.registerSaveRouter(q8);ti.registerLoadRouter(q8);function Wle(s){return new kg(s)}class Xle{constructor(){K(Ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),K(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Ly+af,n=af+V8;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(n)){const a=Hle(r);e[a]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=Vle(e);const t=W8(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return X8(t),n}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yy="://";class ba{constructor(){this.managers={}}static getInstance(){return ba.instance==null&&(ba.instance=new ba),ba.instance}static registerManager(e,t){K(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Yy)&&(e=e.slice(0,e.indexOf(Yy))),K(e.length>0,()=>"scheme must not be an empty string.");const n=ba.getInstance();K(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=ba.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ba.getInstance().managers)}}function Dw(s){if(s.indexOf(Yy)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ba.getSchemes().join(",")}`);return{scheme:s.split(Yy)[0],path:s.split(Yy)[1]}}async function j8(s,e,t=!1){K(s!==e,()=>`Old path and new path are the same: '${s}'`);const n=ti.getLoadHandlers(s);K(n.length>0,()=>`Copying failed because no load handler is found for source URL ${s}.`),K(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${s}.`);const i=n[0],r=ti.getSaveHandlers(e);K(r.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),K(r.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);const a=r[0],o=Dw(s).scheme,l=Dw(s).path,u=o===Dw(s).scheme,c=await i.load();t&&u&&await ba.getManager(o).removeModel(l);const f=await a.save(c);return t&&!u&&await ba.getManager(o).removeModel(l),f.modelArtifactsInfo}async function qle(){const s=ba.getSchemes(),e={};for(const t of s){const n=await ba.getManager(t).listModels();for(const i in n){const r=t+Yy+i;e[r]=n[i]}}return e}async function jle(s){const e=Dw(s);return ba.getManager(e.scheme).removeModel(e.path)}async function Kle(s,e){return j8(s,e,!1)}async function Yle(s,e){return j8(s,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jle{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();const i=this.functionRefs[n.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return y8(e)}}if(Ie().get("IS_BROWSER")){Ie().setPlatform("browser",new Jle);try{ba.registerManager(kg.URL_SCHEME,new Xle)}catch{}try{ba.registerManager(Bg.URL_SCHEME,new Ple)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zle={importFetch:()=>require("node-fetch")};let cI;class Qle{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ie().global.fetch!=null?Ie().global.fetch(e,t):(cI==null&&(cI=Zle.importFetch()),cI(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ie().get("IS_NODE")&&!Ie().get("IS_BROWSER")&&Ie().setPlatform("node",new Qle);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(s,e="float32",t){return e=e||"float32",Tl(s),new nr(s,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eue(s,e){const t=Q(s,"x","cast");if(!Loe(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},i={dtype:e};return me.runKernel(__,n,i)}const Ct=fe({cast_:eue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(s){const t={x:Q(s,"x","clone","string_or_numeric")};return me.runKernel(B_,t)}const pf=fe({clone_:tue});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8(s,e=!1){console.log(s.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */E8();const nue={buffer:Mn,cast:Ct,clone:pf,print:K8};dle(nue);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sue(s,e){let t=Q(s,"a","add"),n=Q(e,"b","add");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(Vx,i)}const it=fe({add_:sue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iue(s,e){let t=Q(s,"a","floorDiv"),n=Q(e,"b","floorDiv");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(D_,i)}const qB=fe({floorDiv_:iue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rue(s,e){let t=Q(s,"a","div"),n=Q(e,"b","div");if([t,n]=yi(t,n),t.dtype==="int32"&&n.dtype==="int32")return qB(t,n);const i={a:t,b:n},r={};return me.runKernel(C_,i,r)}const Ut=fe({div_:rue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aue(s,e){let t=Q(s,"a","mul"),n=Q(e,"b","mul");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(H_,i)}const pe=fe({mul_:aue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oue(s){const e=Q(s,"x","abs");if(e.dtype==="complex64"){const t={x:e};return me.runKernel(fE,t)}else{const t={x:e};return me.runKernel(sE,t)}}const Ji=fe({abs_:oue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lue(s){const t={x:Q(s,"x","acos")};return me.runKernel(p_,t)}const Y8=fe({acos_:lue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uue(s){const t={x:Q(s,"x","acosh")};return me.runKernel(m_,t)}const J8=fe({acosh_:uue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cue(s){K(Array.isArray(s),()=>"The argument passed to tf.addN() must be a list of tensors"),K(s.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${s.length}`);const e=s.map((i,r)=>Q(i,`tensors${r}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Wn(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return me.runKernel(iE,n)}const hue=fe({addN_:cue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fue(s,e=null,t=!1){const i={x:Q(s,"x","all","bool")},r={axis:e,keepDims:t};return me.runKernel($O,i,r)}const jB=fe({all_:fue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function due(s,e=null,t=!1){const i={x:Q(s,"x","any","bool")},r={axis:e,keepDims:t};return me.runKernel(zO,i,r)}const K2=fe({any_:due});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pue(s,e=0){const n={x:Q(s,"x","argMax")},i={axis:e};return me.runKernel(rE,n,i)}const Sx=fe({argMax_:pue});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(s,e=0){const n={x:Q(s,"x","argMin")},i={axis:e};return me.runKernel(aE,n,i)}const Z8=fe({argMin_:mue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gue(s){const t={x:Q(s,"x","asin")};return me.runKernel(g_,t)}const Q8=fe({asin_:gue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yue(s){const t={x:Q(s,"x","asinh")};return me.runKernel(y_,t)}const eG=fe({asinh_:yue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xue(s){const t={x:Q(s,"x","atan")};return me.runKernel(x_,t)}const tG=fe({atan_:xue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vue(s,e){let t=Q(s,"a","atan2"),n=Q(e,"b","atan2");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(b_,i)}const nG=fe({atan2_:vue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bue(s){const t={x:Q(s,"x","atanh")};return me.runKernel(v_,t)}const sG=fe({atanh_:bue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(s,e,t,n,i="NHWC",r){const a=s[3],o=[...e,a],l=Nf(i);return Ar(s,o,t,r,n,null,null,l)}function pu(s,e,t,n,i,r,a="channelsLast"){const[o,l]=Db(e);let u;if(a==="channelsLast")u=[o,l,s[3],s[3]];else if(a==="channelsFirst")u=[o,l,s[1],s[1]];else throw new Error(`Unknown dataFormat ${a}`);return Ar(s,u,t,n,i,r,!1,a)}function Mf(s,e,t,n,i,r,a="NDHWC"){const[o,l,u]=LD(e);let c,f;if(a==="NDHWC")f="channelsLast",c=[o,l,u,s[4],s[4]];else if(a==="NCDHW")f="channelsFirst",c=[o,l,u,s[1],s[1]];else throw new Error(`Unknown dataFormat ${a}`);return Tp(s,c,t,n,i,!1,f,r)}function Ar(s,e,t,n,i,r,a=!1,o="channelsLast"){let[l,u,c,f]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,f]=s;else if(o==="channelsFirst")[l,f,u,c]=s;else throw new Error(`Unknown dataFormat ${o}`);const[d,g,,x]=e,[S,b]=Db(t),[_,T]=Db(n),E=Jy(d,_),C=Jy(g,T),{padInfo:R,outHeight:I,outWidth:L}=Aue(i,u,c,S,b,E,C,r,o),P=a?x*f:x;let D;return o==="channelsFirst"?D=[l,P,I,L]:o==="channelsLast"&&(D=[l,I,L,P]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:f,outHeight:I,outWidth:L,outChannels:P,padInfo:R,strideHeight:S,strideWidth:b,filterHeight:d,filterWidth:g,effectiveFilterHeight:E,effectiveFilterWidth:C,dilationHeight:_,dilationWidth:T,inShape:s,outShape:D,filterShape:e}}function Tp(s,e,t,n,i,r=!1,a="channelsLast",o){let[l,u,c,f,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,f,d]=s;else if(a==="channelsFirst")[l,d,u,c,f]=s;else throw new Error(`Unknown dataFormat ${a}`);const[g,x,S,,b]=e,[_,T,E]=LD(t),[C,R,I]=LD(n),L=Jy(g,C),P=Jy(x,R),D=Jy(S,I),{padInfo:O,outDepth:F,outHeight:X,outWidth:q}=Tue(i,u,c,f,_,T,E,L,P,D,o),J=r?b*d:b;let Y;return a==="channelsFirst"?Y=[l,J,F,X,q]:a==="channelsLast"&&(Y=[l,F,X,q,J]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:f,inChannels:d,outDepth:F,outHeight:X,outWidth:q,outChannels:J,padInfo:O,strideDepth:_,strideHeight:T,strideWidth:E,filterDepth:g,filterHeight:x,filterWidth:S,effectiveFilterDepth:L,effectiveFilterHeight:P,effectiveFilterWidth:D,dilationDepth:C,dilationHeight:R,dilationWidth:I,inShape:s,outShape:Y,filterShape:e}}function _ue(s,e,t,n,i){n==null&&(n=KB(s,e,t));const r=s[0],a=s[1],o=Ob((r-e+2*n)/t+1,i),l=Ob((a-e+2*n)/t+1,i);return[o,l]}function Sue(s,e,t,n,i,r){i==null&&(i=KB(s,e[0],n[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)s[o]+2*i>=e[o]&&(a[o]=Ob((s[o]-e[o]+2*i)/n[o]+1,r));return a}function KB(s,e,t,n=1){const i=Jy(e,n);return Math.floor((s[0]*(t-1)-t+i)/2)}function Db(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function LD(s){return typeof s=="number"?[s,s,s]:s}function Jy(s,e){return e<=1?s:s+(s-1)*(e-1)}function Aue(s,e,t,n,i,r,a,o,l){let u,c,f;if(typeof s=="number"){u={top:s,bottom:s,left:s,right:s,type:s===0?"VALID":"NUMBER"};const g=_ue([e,t],r,n,s,o);c=g[0],f=g[1]}else if(s==="same"){c=Math.ceil(e/n),f=Math.ceil(t/i);const d=Math.max(0,(c-1)*n+r-e),g=Math.max(0,(f-1)*i+a-t),x=Math.floor(d/2),S=d-x,b=Math.floor(g/2),_=g-b;u={top:x,bottom:S,left:b,right:_,type:"SAME"}}else if(s==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-r+1)/n),f=Math.ceil((t-a+1)/i);else if(typeof s=="object"){const d=l==="channelsLast"?s[1][0]:s[2][0],g=l==="channelsLast"?s[1][1]:s[2][1],x=l==="channelsLast"?s[2][0]:s[3][0],S=l==="channelsLast"?s[2][1]:s[3][1];u={top:d,bottom:g,left:x,right:S,type:d===0&&g===0&&x===0&&S===0?"VALID":"EXPLICIT"},c=Ob((e-r+d+g)/n+1,o),f=Ob((t-a+x+S)/i+1,o)}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:u,outHeight:c,outWidth:f}}function Tue(s,e,t,n,i,r,a,o,l,u,c){let f,d,g,x;if(s==="valid"&&(s=0),typeof s=="number"){f={top:s,bottom:s,left:s,right:s,front:s,back:s,type:s===0?"VALID":"NUMBER"};const b=Sue([e,t,n,1],[o,l,u],1,[i,r,a],s,c);d=b[0],g=b[1],x=b[2]}else if(s==="same"){d=Math.ceil(e/i),g=Math.ceil(t/r),x=Math.ceil(n/a);const S=(d-1)*i+o-e,b=(g-1)*r+l-t,_=(x-1)*a+u-n,T=Math.floor(S/2),E=S-T,C=Math.floor(b/2),R=b-C,I=Math.floor(_/2),L=_-I;f={top:C,bottom:R,left:I,right:L,front:T,back:E,type:"SAME"}}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:f,outDepth:d,outHeight:g,outWidth:x}}function Ob(s,e){if(!e)return Math.trunc(s);switch(e){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error(`Unknown roundingMode ${e}`)}}function up(s){const[e,t,n]=Db(s);return e===1&&t===1&&n===1}function Ur(s,e){return up(s)||up(e)}function Lg(s){return Db(s).every(e=>e>0)}function Nf(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${s}`)}function Da(s,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")K(bx(e),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(i=>{K(bx(i),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${s}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wue(s,e){const n={x:Q(s,"x","reshape","string_or_numeric")},i={shape:e};return me.runKernel(XE,n,i)}const xe=fe({reshape_:wue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cue(s,e,t,n,i){const r=Q(s,"x","avgPool","float32"),a=1;K(Ur(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=r,l=!1;r.rank===3&&(l=!0,o=xe(r,[1,r.shape[0],r.shape[1],r.shape[2]])),K(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Da("avgPool",n,i);const u={x:o},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i};let f=me.runKernel(oE,u,c);return f=Ct(f,r.dtype),l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const oM=fe({avgPool_:Cue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eue(s,e,t,n,i,r="NDHWC"){const a=Q(s,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=xe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),K(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),K(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Da("avgPool3d",n,i);const u={x:o},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:r};let f=me.runKernel(lE,u,c);return f=Ct(f,o.dtype),l?xe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const iG=fe({avgPool3d_:Eue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mue(s,e=0){K(s.length>=1,()=>"Pass at least one tensor to concat");const t=j2(s,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),t.length===1)return pf(t[0]);const n=t,i={axis:e};return me.runKernel(dE,n,i)}const js=fe({concat_:Mue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nue(s,e,t=!1,n=!1){let i=Q(s,"a","matMul"),r=Q(e,"b","matMul");[i,r]=yi(i,r);const a={a:i,b:r},o={transposeA:t,transposeB:n};return me.runKernel(uE,a,o)}const Un=fe({matMul_:Nue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rue(s){const t={x:Q(s,"x","sigmoid","float32")};return me.runKernel(eS,t)}const ec=fe({sigmoid_:Rue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(s,e,t){const n=Q(s,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const i={x:n},r={begin:e,size:t};return me.runKernel(JE,i,r)}const bn=fe({slice_:Iue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Due(s){const t={x:Q(s,"x","tanh","float32")};return me.runKernel(aS,t)}const Fg=fe({tanh_:Due});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oue(s,e,t,n,i,r){const a=Q(s,"forgetBias","basicLSTMCell"),o=Q(e,"lstmKernel","basicLSTMCell"),l=Q(t,"lstmBias","basicLSTMCell"),u=Q(n,"data","basicLSTMCell"),c=Q(i,"c","basicLSTMCell"),f=Q(r,"h","basicLSTMCell"),d=js([u,f],1),g=Un(d,o),x=it(g,l),S=x.shape[0],b=x.shape[1]/4,_=[S,b],T=bn(x,[0,0],_),E=bn(x,[0,b],_),C=bn(x,[0,b*2],_),R=bn(x,[0,b*3],_),I=it(pe(ec(T),Fg(E)),pe(c,ec(it(a,C)))),L=pe(Fg(I),ec(R));return[I,L]}const Bue=fe({basicLSTMCell_:Oue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kue(s,e,t){const n=Q(s,"x","batchToSpaceND"),i=e.reduce((o,l)=>o*l);K(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),K(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),K(n.shape[0]%i===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const r={x:n},a={blockShape:e,crops:t};return me.runKernel(cE,r,a)}const lM=fe({batchToSpaceND_:kue});function Lue(s){let e;return s.rank===0||s.rank===1?e=xe(s,[1,1,1,s.size]):s.rank===2?e=xe(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?e=xe(s,[1,s.shape[0],s.shape[1],s.shape[2]]):e=s,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fue(s,e,t,n,i,r){r==null&&(r=.001);const a=Q(s,"x","batchNorm"),o=Q(e,"mean","batchNorm"),l=Q(t,"variance","batchNorm");let u;i!=null&&(u=Q(i,"scale","batchNorm"));let c;n!=null&&(c=Q(n,"offset","batchNorm")),K(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Lue(a),scale:u,offset:c,mean:o,variance:l},g={varianceEpsilon:r},x=me.runKernel(SE,d,g);return xe(x,a.shape)}const hS=fe({batchNorm_:Fue});function Pue(s,e,t,n,i,r){const a=Q(s,"x","batchNorm"),o=Q(e,"mean","batchNorm"),l=Q(t,"variance","batchNorm");let u;i!=null&&(u=Q(i,"scale","batchNorm"));let c;return n!=null&&(c=Q(n,"offset","batchNorm")),K(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),K(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),K(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&K(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&K(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),hS(a,o,l,c,u,r)}const rG=fe({batchNorm2d_:Pue});function Uue(s,e,t,n,i,r){const a=Q(s,"x","batchNorm"),o=Q(e,"mean","batchNorm"),l=Q(t,"variance","batchNorm");let u;i!=null&&(u=Q(i,"scale","batchNorm"));let c;return n!=null&&(c=Q(n,"offset","batchNorm")),K(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),K(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),K(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&K(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&K(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),hS(a,o,l,c,u,r)}const aG=fe({batchNorm3d_:Uue});function $ue(s,e,t,n,i,r){const a=Q(s,"x","batchNorm"),o=Q(e,"mean","batchNorm"),l=Q(t,"variance","batchNorm");let u;i!=null&&(u=Q(i,"scale","batchNorm"));let c;return n!=null&&(c=Q(n,"offset","batchNorm")),K(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),K(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),K(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&K(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&K(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),hS(a,o,l,c,u,r)}const oG=fe({batchNorm4d_:$ue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zue(s,e,t){const n=Q(s,"x","bincount"),i=Q(e,"weights","bincount");K(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),K(t>=0,()=>`size must be non-negative, but got ${t}.`),K(i.size===n.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${i.shape}.`);const r={x:n,weights:i},a={size:t};return me.runKernel(VO,r,a)}const lG=fe({bincount_:zue});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gue(s,e){const t=Q(s,"x","bitwiseAnd"),n=Q(e,"y","bitwiseAnd");if(!Wn(t.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${n.shape}`);if(t.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${n.dtype}`);const i={a:t,b:n};return me.runKernel(hE,i)}const Hue=fe({bitwiseAnd_:Gue});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vue(s,e){const t=Q(s,"s0","broadcastArgs","int32"),n=Q(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const i={s0:t,s1:n};return me.runKernel(WO,i)}const Wue=fe({broadcastArgs_:Vue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xue(s,e){let t=Q(s,"broadcastTo","x");const n=t.shape;if(Tl(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=xe(t,u)}const i=t.shape,r=Array.from(e);for(let u=e.length-1;u>=0;u--)if(i[u]===e[u])r[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(r.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return pf(t);const o={x:t},l={reps:r};return me.runKernel(oS,o,l)}const Zy=fe({broadcastTo_:Xue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function que(s){const t={x:Q(s,"x","ceil","float32")};return me.runKernel(S_,t)}const uG=fe({ceil_:que});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(s,e,t){Tl(s),t=t||Gx(e);const n={shape:s,value:e,dtype:t};return me.runKernel(aB,{},n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jue(s,e,t){const n=Q(s,"x","clipByValue");if(K(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Wx(n.shape,e,n.dtype);const i={x:n},r={clipValueMin:e,clipValueMax:t};return me.runKernel(A_,i,r)}const Lo=fe({clipByValue_:jue});function Kue(s){return js(s,0)}const cG=fe({concat1d_:Kue});function Yue(s,e){return js(s,e)}const uM=fe({concat2d_:Yue});function Jue(s,e){return js(s,e)}const hG=fe({concat3d_:Jue});function Zue(s,e){return js(s,e)}const fG=fe({concat4d_:Zue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Que(s,e,t,n,i="NHWC",r=[1,1],a){const o=Q(s,"x","conv2d","float32"),l=Q(e,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),K(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Da("conv2d",n,a);const f=i==="NHWC"?u.shape[3]:u.shape[1];K(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),K(Ur(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),K(Lg(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),K(Lg(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},g={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a},x=me.runKernel(pE,d,g);return c?xe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const cp=fe({conv2d_:Que});function ece(s,e,t,n,i="NWC",r=1,a){const o=Q(s,"x","conv1d"),l=Q(e,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=xe(o,[1,o.shape[0],o.shape[1]])),K(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),K(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Da("conv1d",n,a),K(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),K(Ur(t,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${r}'`),K(Lg(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),K(Lg(t),()=>"Error in conv1D: Stride should be larger than 0."),K(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const f=xe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=xe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),b=cp(d,f,[1,t],n,"NHWC",[1,r],a);return c?xe(b,[b.shape[2],b.shape[3]]):xe(b,[b.shape[0],b.shape[2],b.shape[3]])}const YB=fe({conv1d_:ece});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tce(s,e,t,n,i,r="NHWC",a){K(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let o=s,l=e,u=!1;e.rank===3&&(u=!0,l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,s[0],s[1],s[2]]),K(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),K(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),K(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=r==="NHWC"?o[3]:o[1],f=r==="NHWC"?l.shape[3]:l.shape[1];K(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),K(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),Da("conv2dDerInput",i,a);const d={dy:l,filter:t},g={strides:n,pad:i,dataFormat:r,dimRoundingMode:a,inputShape:o},x=me.runKernel(mE,d,g);return u?xe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const JB=fe({conv2DBackpropInput_:tce});function nce(s,e,t,n,i,r){const a=Q(s,"x","conv2dTranspose"),o=Q(e,"filter","conv2dTranspose");return JB(t,a,o,n,i,"NHWC",r)}const ZB=fe({conv2dTranspose_:nce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sce(s,e,t,n,i="NDHWC",r=[1,1,1]){const a=Q(s,"x","conv3d"),o=Q(e,"filter","conv3d");let l=a,u=!1;a.rank===4&&(u=!0,l=xe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),K(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),K(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),K(Ur(t,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),K(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),K(Lg(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),K(Lg(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},f={strides:t,pad:n,dataFormat:i,dilations:r},d=me.runKernel(gE,c,f);return u?xe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const dG=fe({conv3d_:sce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ice(s,e,t,n,i){K(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let r=s,a=e,o=!1;e.rank===4&&(o=!0,a=xe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),r=[1,s[0],s[1],s[2],s[3]]);const l=r[4],u=a.shape[4];K(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),K(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),K(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),K(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),K(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:a,filter:t},f={pad:i,strides:n,inputShape:r},d=me.runKernel(KO,c,f);return o?xe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const pG=fe({conv3DBackpropInput_:ice});function rce(s,e,t,n,i){const r=Q(s,"x","conv3dTranspose"),a=Q(e,"filter","conv3dTranspose");return pG(t,r,a,n,i)}const mG=fe({conv3dTranspose_:rce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ace(s){const t={x:Q(s,"x","cos","float32")};return me.runKernel(T_,t)}const cM=fe({cos_:ace});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oce(s){const t={x:Q(s,"x","cosh","float32")};return me.runKernel(w_,t)}const QB=fe({cosh_:oce});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lce(s,e=0,t=!1,n=!1){const r={x:Q(s,"x","cumprod")},a={axis:e,exclusive:t,reverse:n};return me.runKernel(YO,r,a)}const Y2=fe({cumprod_:lce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uce(s,e=0,t=!1,n=!1){const r={x:Q(s,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return me.runKernel(yE,r,a)}const ek=fe({cumsum_:uce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cce(s,e,t,n=!1){const i=Q(s,"x","denseBincount"),r=Q(e,"weights","denseBincount");K(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),K(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),K(t>=0,()=>`size must be non-negative, but got ${t}.`),K(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const a={x:i,weights:r},o={size:t,binaryOutput:n};return me.runKernel(ZO,a,o)}const FD=fe({denseBincount_:cce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hce(s,e,t="NHWC"){const n=Q(s,"x","depthToSpace","float32"),i=t==="NHWC"?n.shape[1]:n.shape[2],r=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];K(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),K(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${n.shape}`),K(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${n.shape}`),K(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);const o={x:n},l={blockSize:e,dataFormat:t};return me.runKernel(QO,o,l)}const gG=fe({depthToSpace_:hce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fce(s,e,t,n,i="NHWC",r=[1,1],a){const o=Q(s,"x","depthwiseConv2d","float32"),l=Q(e,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),K(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=i==="NHWC"?u.shape[3]:u.shape[1];K(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),Da("depthwiseConv2d",n,a);const d={x:u,filter:l},g={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a},x=me.runKernel(xE,d,g);return c?xe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const fS=fe({depthwiseConv2d_:fce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dce(s){const t={x:Q(s,"x","diag")};return me.runKernel(nB,t)}const pce=fe({diag_:dce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mce(s,e,t,n,i=[1,1],r="NHWC"){const a=Q(s,"x","dilation2d"),o=Q(e,"filter","dilation2d");K(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),K(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),K(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=a,u=!1;a.rank===3&&(l=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0),K(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},f={strides:t,pad:n,dilations:i},d=me.runKernel(vE,c,f);return u?xe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const yG=fe({dilation2d_:mce});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(s,e){const t=s.length,n=[];for(let i=0;i<t;i++){const r=t-1-i,a=s[r]||1;(e[e.length-1-i]||1)>1&&a===1&&n.unshift(r)}return n}function rr(s,e){const t=[];for(let n=0;n<e.length;n++){const i=s[s.length-n-1],r=e.length-n-1,a=e[r];(i==null||i===1&&a>1)&&t.unshift(r)}return t}function gn(s,e){const t=Math.max(s.length,e.length),n=new Array(t);for(let i=0;i<t;i++){let r=s[s.length-i-1];r==null&&(r=1);let a=e[e.length-i-1];if(a==null&&(a=1),r===1)n[t-i-1]=a;else if(a===1)n[t-i-1]=r;else if(r!==a){const o=`Operands could not be broadcast together with shapes ${s} and ${e}.`;throw Error(o)}else n[t-i-1]=r}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gce(s,e){let t=Q(s,"a","equal","string_or_numeric"),n=Q(e,"b","equal","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(bE,i)}const ic=fe({equal_:gce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yce(s,e,t){const n=Q(e,"a","where"),i=Q(t,"b","where"),r=Q(s,"condition","where","bool"),a=gn(gn(r.shape,n.shape),i.shape),o=Zy(r,a),l=Zy(n,a),u=Zy(i,a),c={condition:o,t:l,e:u};return me.runKernel(YE,c)}const na=fe({where_:yce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xce(s){const t={x:Q(s,"x","zerosLike")};return me.runKernel(rM,t)}const Kn=fe({zerosLike_:xce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vce(s,e){let t=Q(s,"a","div"),n=Q(e,"b","div");[t,n]=yi(t,n);const i=Ut(t,n),r=Kn(i),a=ic(n,r);return na(a,r,i)}const xG=fe({divNoNan_:vce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bce(s,e){const t=Q(s,"t1","dot"),n=Q(e,"t2","dot");K((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);const i=t.rank===1?t.size:t.shape[1],r=n.rank===1?n.size:n.shape[0];if(K(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),t.rank===1&&n.rank===1){const a=xe(t,[1,-1]),o=xe(n,[-1,1]),l=Un(a,o);return xe(l,[])}else if(t.rank===1&&n.rank===2){const a=xe(t,[1,-1]),o=xe(n,[n.shape[0],n.shape[1]]),l=Un(a,o);return xe(l,[l.size])}else if(t.rank===2&&n.rank===1){const a=xe(n,[-1,1]),o=Un(t,a);return xe(o,[o.size])}else{const a=xe(n,[n.shape[0],n.shape[1]]);return Un(t,a)}}const vG=fe({dot_:bce});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ce(s,...e){const t=e.map((i,r)=>Q(i,`tensors${r}`,"einsum")),n={equation:s};return me.runKernel(sB,t,n)}const Fy=fe({einsum_:_ce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sce(s){const t={x:Q(s,"x","elu","float32")};return me.runKernel(E_,t)}const dS=fe({elu_:Sce});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ace(s,e){const t=Q(s,"x","ensureShape","string_or_numeric");if(!Boe(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return s}const Tce=fe({ensureShape_:Ace});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wce(s){let e=Q(s,"x","erf");K(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ct(e,"float32"));const t={x:e};return me.runKernel(M_,t)}const tk=fe({erf_:wce});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(s,e){for(let t=0;t<s.length;++t)if(s[s.length-t-1]!==e-1-t)return!1;return!0}function bG(s,e,t){const n=s.length+e.length,i=[];let r=0,a=0;for(let o=0;o<n;o++)t.indexOf(o)===-1?i.push(s[r++]):i.push(e[a++]);return i}function Tr(s,e){const t=[],n=s.length;for(let r=0;r<n;r++)e.indexOf(r)===-1&&t.push(s[r]);const i=e.map(r=>s[r]);return[t,i]}function Ni(s,e){const t=e.map(n=>1);return bG(s,t,e)}function $r(s,e,t){K(nk(e,t),()=>`${s} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ri(s,e){if(nk(s,e))return null;const t=[];for(let n=0;n<e;++n)s.indexOf(n)===-1&&t.push(n);return s.forEach(n=>t.push(n)),t}function wp(s){return s.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Ri(s,e){const t=[];for(let n=e-s;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cce(s,e=null,t=!1){const i={x:Q(s,"x","max")},r={reductionIndices:e,keepDims:t};return me.runKernel(DE,i,r)}const ou=fe({max_:Cce});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ece(s,e=null,t=!1){const i={x:Q(s,"x","min")},r={axis:e,keepDims:t};return me.runKernel(LE,i,r)}const Bb=fe({min_:Ece});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mce(s,e){let t=Q(s,"base","pow"),n=Q(e,"exp","pow");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(V_,i)}const Sf=fe({pow_:Mce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jt(s,e){if((uu(s)&&e!=="string"||Array.isArray(s))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&uu(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ap(s,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nce(s){const t={x:Q(s,"x","sqrt","float32")};return me.runKernel(nS,t)}const Pr=fe({sqrt_:Nce});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rce(s){const e=Q(s,"x","square"),t={};return me.runKernel("Square",{x:e},t)}const Os=fe({square_:Rce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ice(s,e=null,t=!1){let n=Q(s,"x","sum");n.dtype==="bool"&&(n=Ct(n,"int32"));const i={x:n},r={axis:e,keepDims:t};return me.runKernel(ZE,i,r)}const $t=fe({sum_:Ice});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dce(s,e="euclidean",t=null,n=!1){s=Q(s,"x","norm");const i=_G(s,e,t);let r=i.shape;if(n){const a=kn(t,s.shape);r=Ni(i.shape,a)}return xe(i,r)}function _G(s,e,t=null){if(s.rank===0)return Ji(s);if(s.rank!==1&&t===null)return _G(xe(s,[-1]),e,t);if(s.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return $t(Ji(s),t);if(e===1/0)return ou(Ji(s),t);if(e===-1/0)return Bb(Ji(s),t);if(e==="euclidean"||e===2)return Pr($t(Sf(Ji(s),Jt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return ou($t(Ji(s),t[0]),t[1]-1);if(e===1/0)return ou($t(Ji(s),t[1]),t[0]);if(e===-1/0)return Bb($t(Ji(s),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Pr($t(Os(s),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const pS=fe({norm_:Dce});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oce(s,e=null,t=!1){return pS(s,"euclidean",e,t)}const SG=fe({euclideanNorm_:Oce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bce(s){const t={x:Q(s,"x","exp")};return me.runKernel(N_,t)}const Fo=fe({exp_:Bce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kce(s,e=0){const t=Q(s,"x","expandDims","string_or_numeric");K(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},i={dim:e};return me.runKernel(_E,n,i)}const Sa=fe({expandDims_:kce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(s){const t={x:Q(s,"x","expm1")};return me.runKernel(R_,t)}const AG=fe({expm1_:Lce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fce(s,e){const t=Q(s,"x","tile","string_or_numeric");K(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},i={reps:e};return me.runKernel(oS,n,i)}const su=fe({tile_:Fce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pce(s,e,t,n="float32"){e==null&&(e=s);const i=Mn([s,e],n),r=s<=e?s:e;for(let o=0;o<r;++o)i.set(1,o,o);const a=xe(i.toTensor(),[s,e]);if(t==null)return a;if(t.length===1)return su(Sa(a,0),[t[0],1,1]);if(t.length===2)return su(Sa(Sa(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return su(Sa(Sa(Sa(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const sk=fe({eye_:Pce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uce(s){const t={x:Q(s,"x","floor","float32")};return me.runKernel(I_,t)}const mS=fe({floor_:Uce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ce(s,e,t=0,n=0){const i=Q(s,"x","gather"),r=Q(e,"indices","gather","int32"),a={x:i,indices:r},o={axis:t,batchDims:n};return me.runKernel(AE,a,o)}const gS=fe({gather_:$ce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zce(s,e){let t=Q(s,"a","greater","string_or_numeric"),n=Q(e,"b","greater","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(TE,i)}const Go=fe({greater_:zce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gce(s,e){let t=Q(s,"a","greaterEqual","string_or_numeric"),n=Q(e,"b","greaterEqual","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(O_,i)}const Cp=fe({greaterEqual_:Gce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hce(s){const t={input:Q(s,"input","imag")};return me.runKernel(cB,t)}const hM=fe({imag_:Hce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vce(s){const t={x:Q(s,"x","isFinite")};return me.runKernel(k_,t)}const TG=fe({isFinite_:Vce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wce(s){const t={x:Q(s,"x","isInf")};return me.runKernel(L_,t)}const wG=fe({isInf_:Wce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xce(s){const t={x:Q(s,"x","isNaN")};return me.runKernel(F_,t)}const CG=fe({isNaN_:Xce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qce(s,e=.2){const n={x:Q(s,"x","leakyRelu")},i={alpha:e};return me.runKernel(wE,n,i)}const fM=fe({leakyRelu_:qce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jce(s,e){let t=Q(s,"a","less","string_or_numeric"),n=Q(e,"b","less","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(CE,i)}const kb=fe({less_:jce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kce(s,e){let t=Q(s,"a","lessEqual","string_or_numeric"),n=Q(e,"b","lessEqual","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(EE,i)}const Zg=fe({lessEqual_:Kce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yce(s,e,t){if(t<=0)throw new Error("The number of values should be positive.");const n={start:s,stop:e,num:t};return me.runKernel(hB,{},n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jce(s,e=5,t=1,n=1,i=.5){const r=Q(s,"x","localResponseNormalization");K(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),K(bx(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=r,o=!1;r.rank===3&&(o=!0,a=xe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:a},u={depthRadius:e,bias:t,alpha:n,beta:i},c=me.runKernel(IE,l,u);return o?xe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const EG=fe({localResponseNormalization_:Jce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zce(s){const t={x:Q(s,"x","log","float32")};return me.runKernel(P_,t)}const Sl=fe({log_:Zce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qce(s){const t={x:Q(s,"x","log1p")};return me.runKernel(U_,t)}const dM=fe({log1p_:Qce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ehe(s,e){K(vD(s),()=>"The f passed in variableGrads(f) must be a function"),K(e==null||Array.isArray(e)&&e.every(u=>u instanceof q2),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in me.registeredVariables)e.push(me.registeredVariables[u])}const n=t?e.filter(u=>!u.trainable):null,i=e.length;e=e.filter(u=>u.trainable),K(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:a,grads:o}=me.gradients(s,e,null,r);K(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),K(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),n!=null&&n.forEach(u=>l[u.name]=null),{value:a,grads:l}}function Af(s){return me.customGrad(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function the(s){const t={x:Q(s,"x","neg")};return me.runKernel(PE,t)}const Hs=fe({neg_:the});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nhe(s){const t={x:Q(s,"x","softplus")};return me.runKernel(tS,t)}const Xx=fe({softplus_:nhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function she(s){const e=Q(s,"x","logSigmoid");return Af(n=>({value:Hs(Xx(Hs(n))),gradFunc:a=>pe(a,ec(Hs(n)))}))(e)}const MG=fe({logSigmoid_:she});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ihe(s,e){let t=Q(s,"a","sub"),n=Q(e,"b","sub");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(iS,i)}const wt=fe({sub_:ihe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rhe(s,e=-1){const t=Q(s,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Af((i,r)=>{const o=ou(i,e,!0),l=wt(i,o),u=wt(Ct(l,"float32"),Sl($t(Fo(l),e,!0)));return r([u]),{value:u,gradFunc:(f,d)=>{const[g]=d,x=!0,S=Fo(g);return wt(f,pe($t(f,e,x),S))}}})(t)}const ik=fe({logSoftmax_:rhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ahe(s,e=null,t=!1){const n=Q(s,"x","logSumExp"),i=kn(e,n.shape),r=ou(n,i,!0),a=wt(n,r),o=Fo(a),l=$t(o,i),u=Sl(l),c=it(xe(r,u.shape),u);if(t){const f=Ni(c.shape,i);return xe(c,f)}return c}const pM=fe({logSumExp_:ahe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ohe(s,e){const t=Q(s,"a","logicalAnd","bool"),n=Q(e,"b","logicalAnd","bool");gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(ME,i)}const dh=fe({logicalAnd_:ohe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lhe(s){const t={x:Q(s,"x","logicalNot","bool")};return me.runKernel(NE,t)}const mM=fe({logicalNot_:lhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(s,e){const t=Q(s,"a","logicalOr","bool"),n=Q(e,"b","logicalOr","bool");gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(RE,i)}const rk=fe({logicalOr_:uhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function che(s,e){const t=Q(s,"a","logicalXor","bool"),n=Q(e,"b","logicalXor","bool");return gn(t.shape,n.shape),dh(rk(s,e),mM(dh(s,e)))}const NG=fe({logicalXor_:che});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aw=2147483648;function hhe(s,e,t="left"){const n=Q(s,"sortedSequence","searchSorted"),i=Q(e,"values","searchSorted"),r=n.shape[n.shape.length-1],a=i.shape[i.shape.length-1],o=xe(n,[-1,r]),l=xe(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Xe(l.shape)>=aw)throw new Error(`values tensor size must less than ${aw}`);if(o.shape[1]>=aw)throw new Error(`trailing dim_size must less than ${aw} for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:t};return me.runKernel(NB,u,c)}const ak=fe({searchSorted_:hhe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fhe(s,e){return ak(s,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dhe(s,e,t,n,i){const r=Q(s,"x","maxPool"),a=1;let o=r,l=!1;r.rank===3&&(l=!0,o=xe(r,[1,r.shape[0],r.shape[1],r.shape[2]])),K(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),K(Ur(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Da("maxPool",n,i);const u={x:o},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i},f=me.runKernel(OE,u,c);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gM=fe({maxPool_:dhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function phe(s,e=[1,1,1],t,n,i,r="NDHWC"){const a=Q(s,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=xe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),K(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),K(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),Da("maxPool3d",n,i);const u={x:o},c={filterSize:e,strides:t,pad:n,dimRoundingMode:i,dataFormat:r},f=me.runKernel(BE,u,c);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const RG=fe({maxPool3d_:phe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mhe(s,e,t,n,i=!1){const a={x:Q(s,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:n,includeBatchInIndex:i},l=me.runKernel(mB,a,o);return{result:l[0],indexes:l[1]}}const ghe=fe({maxPoolWithArgmax_:mhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yhe(s,e){let t=Q(s,"a","maximum"),n=Q(e,"b","maximum");[t,n]=yi(t,n),t.dtype==="bool"&&(t=Ct(t,"int32"),n=Ct(n,"int32")),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel($_,i)}const Rf=fe({maximum_:yhe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xhe(s,e=null,t=!1){const i={x:Q(s,"x","mean")},r={axis:e,keepDims:t};return me.runKernel(kE,i,r)}const pi=fe({mean_:xhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(s,e="float32"){if(Tl(s),e==="complex64"){const n=Qi(s,"float32"),i=Qi(s,"float32");return op(n,i)}const t=sa(Xe(s),e);return me.makeTensor(t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(s,e="float32"){if(Tl(s),e==="complex64"){const n=Mo(s,"float32"),i=Qi(s,"float32");return op(n,i)}const t=PO(Xe(s),e);return me.makeTensor(t,s,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vhe(s,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(s===void 0)return[];let n=Q(s,"x","meshgrid",s instanceof ls?s.dtype:"float32");if(e===void 0)return[n];let i=Q(e,"y","meshgrid",e instanceof ls?e.dtype:"float32");const r=Xe(n.shape),a=Xe(i.shape);return t==="xy"?(n=xe(n,[1,-1]),i=xe(i,[-1,1]),[Un(Mo([a,1],n.dtype),n),Un(i,Mo([1,r],i.dtype))]):(n=xe(n,[-1,1]),i=xe(i,[1,-1]),[Un(n,Mo([1,a],n.dtype)),Un(Mo([r,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(s,e){let t=Q(s,"a","minimum"),n=Q(e,"b","minimum");[t,n]=yi(t,n),t.dtype==="bool"&&(t=Ct(t,"int32"),n=Ct(n,"int32")),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(z_,i)}const Pg=fe({minimum_:bhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _he(s,e,t){K(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=Q(s,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");K(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let o=0;o<n.rank;o++)K(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),K(e[o][0]>=0&&e[o][0]<=n.shape[o]-i&&e[o][1]>=0&&e[o][1]<=n.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${n.shape[o]-i} or less than 0 for input of shape ${n.shape}`);const r={paddings:e,mode:t},a={x:n};return me.runKernel(FE,a,r)}const IG=fe({mirrorPad_:_he});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function She(s,e){let t=Q(s,"a","mod"),n=Q(e,"b","mod");[t,n]=yi(t,n);const i={a:t,b:n};return me.runKernel(G_,i)}const DG=fe({mod_:She});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ahe(s,e=null,t=!1){s=Q(s,"x","moments");const n=kn(e,s.shape),i=pi(s,n,t);let r=i.shape;t||(r=Ni(i.shape,n));const a=Os(wt(Ct(s,"float32"),xe(i,r))),o=pi(a,n,t);return{mean:i,variance:o}}const yM=fe({moments_:Ahe});function The(s,e,t,n){const i=Q(e,"data","multiRNNCell"),r=j2(t,"c","multiRNNCell"),a=j2(n,"h","multiRNNCell");let o=i;const l=[];for(let f=0;f<s.length;f++){const d=s[f](o,r[f],a[f]);l.push(d[0]),l.push(d[1]),o=d[1]}const u=[],c=[];for(let f=0;f<l.length;f+=2)u.push(l[f]),c.push(l[f+1]);return[u,c]}const whe=fe({multiRNNCell_:The});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(s,e,t,n=!1){const i=Q(s,"logits","multinomial"),r=i.size,a=i.rank;if(r<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${r}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const l={logits:a===1?xe(i,[1,-1]):i},u={numSamples:e,seed:t,normalized:n},c=me.runKernel(gB,l,u);return a===1?xe(c,[c.size]):c}const Ehe=fe({multinomial_:Che});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mhe(s,e){let t=Q(s,"a","notEqual","string_or_numeric"),n=Q(e,"b","notEqual","string_or_numeric");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n};return me.runKernel(UE,i)}const Tx=fe({notEqual_:Mhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nhe(s,e,t=1,n=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:Q(s,"indices","oneHot","int32")},o={dtype:i,depth:e,onValue:t,offValue:n};return me.runKernel(zE,a,o)}const ok=fe({oneHot_:Nhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rhe(s){const t={x:Q(s,"x","onesLike")};return me.runKernel($E,t)}const Al=fe({onesLike_:Rhe});function Ihe(s,e){const t=Q(s,"v1","outerProduct"),n=Q(e,"v2","outerProduct");K(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);const i=xe(t,[-1,1]),r=xe(n,[1,-1]);return Un(i,r)}const Dhe=fe({outerProduct_:Ihe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ohe(s,e,t=0){const n=Q(s,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:n};return me.runKernel(HE,r,i)}const Ep=fe({pad_:Ohe});function Bhe(s,e,t=0){return K(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ep(s,[e],t)}const khe=fe({pad1d_:Bhe});function Lhe(s,e,t=0){return K(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ep(s,e,t)}const Fhe=fe({pad2d_:Lhe});function Phe(s,e,t=0){return K(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ep(s,e,t)}const Uhe=fe({pad3d_:Phe});function $he(s,e,t=0){return K(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ep(s,e,t)}const zhe=fe({pad4d_:$he});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ghe(s,e,t){const n=Q(s,"x","spaceToBatchND");K(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),K(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),K(n.shape.reduce((a,o,l)=>l>0&&l<=e.length?a&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:n},r={blockShape:e,paddings:t};return me.runKernel(QE,i,r)}const xM=fe({spaceToBatchND_:Ghe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hhe(s,e,t,n,i,r,a){i==null&&(i=[1,1]),r==null&&(r=1),n===0&&(n="valid");const o=Q(s,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),K(Ur(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const c=pu(l.shape,e,r,i,n),f=[c.dilationHeight,c.dilationWidth];let d;n==="same"?d=Whe([c.filterHeight,c.filterWidth],f):d=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[x,S]=Vhe([c.inHeight,c.inWidth],f,d),b=g?n:"valid",_=g?l:xM(l,f,x),E=(t==="avg"?()=>oM(_,e,r,b,a):()=>gM(_,e,r,b,a))(),C=g?E:lM(E,f,S);return u?xe(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function Vhe(s,e,t){const n=t.map(c=>c[0]),i=t.map(c=>c[1]),r=s.concat(n,i),a=e.map((c,f)=>(c-r[f]%c)%c),o=i.map((c,f)=>c+a[f]),l=e.map((c,f)=>[n[f],o[f]]),u=e.map((c,f)=>[0,a[f]]);return[l,u]}function Whe(s,e){const n=s.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),i=n.map(a=>Math.floor(a/2)),r=n.map((a,o)=>a-i[o]);return n.map((a,o)=>[i[o],r[o]])}const OG=fe({pool_:Hhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xhe(s,e){const t=Q(s,"x","prelu"),n=Q(e,"alpha","prelu"),i={x:t,alpha:n};return me.runKernel(VE,i)}const vM=fe({prelu_:Xhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qhe(s,e=null,t=!1){let n=Q(s,"x","prod");n.dtype==="bool"&&(n=Ct(n,"int32"));const i={x:n},r={axis:e,keepDims:t};return me.runKernel(WE,i,r)}const BG=fe({prod_:qhe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(s,e,t,n){const i=s.map((c,f)=>Q(c,`tensors${f}`,"raggedGather","int32")),r=Q(e,"paramsDenseValues","raggedGather"),a=Q(t,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:r,indices:a},l={outputRaggedRank:n},u=me.runKernel(bB,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const Khe=fe({raggedGather_:jhe});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yhe(s,e,t){const n=Q(s,"starts","raggedRange"),i=Q(e,"limits","raggedRange",n.dtype),r=Q(t,"deltas","raggedRange",n.dtype),a={starts:n,limits:i,deltas:r},o=me.runKernel(_B,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const Jhe=fe({raggedRange_:Yhe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zhe(s,e,t,n,i){const r=Q(s,"shape","raggedTensorToTensor","int32"),a=Q(e,"values","raggedTensorToTensor"),o=Q(t,"defaultValue","raggedTensorToTensor",a.dtype),l=n.map((f,d)=>Q(f,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:r,values:a,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:i};return me.runKernel(SB,u,c)}const Qhe=fe({raggedTensorToTensor_:Zhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function efe(s,e,t){Tl(s);const n=Xe(s);let i=null;if(t==null||t==="float32")i=new Float32Array(n);else if(t==="int32")i=new Int32Array(n);else if(t==="bool")i=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let r=0;r<n;r++)i[r]=e();return me.makeTensor(i,s,t)}const tfe=fe({rand_:efe});var Ow={exports:{}},nfe=Ow.exports,DU;function sfe(){return DU||(DU=1,function(s){(function(e,t,n){function i(l){var u=this,c=o();u.next=function(){var f=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=f-(u.c=f|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function r(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function a(l,u){var c=new i(l),f=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,f&&(typeof f=="object"&&r(f,c),d.state=function(){return r(c,{})}),d}function o(){var l=4022871197,u=function(c){c=String(c);for(var f=0;f<c.length;f++){l+=c.charCodeAt(f);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=a:this.alea=a})(nfe,s)}(Ow)),Ow.exports}var Bw={exports:{}},ife=Bw.exports,OU;function rfe(){return OU||(OU=1,function(s){(function(e,t,n){function i(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function a(o,l){var u=new i(o),c=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var d=u.next()>>>11,g=(u.next()>>>0)/4294967296,x=(d+g)/(1<<21);while(x===0);return x},f.int32=u.next,f.quick=f,c&&(typeof c=="object"&&r(c,u),f.state=function(){return r(u,{})}),f}t&&t.exports?t.exports=a:this.xor128=a})(ife,s)}(Bw)),Bw.exports}var kw={exports:{}},afe=kw.exports,BU;function ofe(){return BU||(BU=1,function(s){(function(e,t,n){function i(o){var l=this,u="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function a(o,l){var u=new i(o),c=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var d=u.next()>>>11,g=(u.next()>>>0)/4294967296,x=(d+g)/(1<<21);while(x===0);return x},f.int32=u.next,f.quick=f,c&&(typeof c=="object"&&r(c,u),f.state=function(){return r(u,{})}),f}t&&t.exports?t.exports=a:this.xorwow=a})(afe,s)}(kw)),kw.exports}var Lw={exports:{}},lfe=Lw.exports,kU;function ufe(){return kU||(kU=1,function(s){(function(e,t,n){function i(o){var l=this;l.next=function(){var c=l.x,f=l.i,d,g;return d=c[f],d^=d>>>7,g=d^d<<24,d=c[f+1&7],g^=d^d>>>10,d=c[f+3&7],g^=d^d>>>3,d=c[f+4&7],g^=d^d<<7,d=c[f+7&7],d=d^d<<13,g^=d^d<<9,c[f]=g,l.i=f+1&7,g};function u(c,f){var d,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,d=0;d<f.length;++d)g[d&7]=g[d&7]<<15^f.charCodeAt(d)+g[d+1&7]<<13;for(;g.length<8;)g.push(0);for(d=0;d<8&&g[d]===0;++d);for(d==8?g[7]=-1:g[d],c.x=g,c.i=0,d=256;d>0;--d)c.next()}u(l,o)}function r(o,l){return l.x=o.x.slice(),l.i=o.i,l}function a(o,l){o==null&&(o=+new Date);var u=new i(o),c=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var d=u.next()>>>11,g=(u.next()>>>0)/4294967296,x=(d+g)/(1<<21);while(x===0);return x},f.int32=u.next,f.quick=f,c&&(c.x&&r(c,u),f.state=function(){return r(u,{})}),f}t&&t.exports?t.exports=a:this.xorshift7=a})(lfe,s)}(Lw)),Lw.exports}var Fw={exports:{}},cfe=Fw.exports,LU;function hfe(){return LU||(LU=1,function(s){(function(e,t,n){function i(o){var l=this;l.next=function(){var c=l.w,f=l.X,d=l.i,g,x;return l.w=c=c+1640531527|0,x=f[d+34&127],g=f[d=d+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,x=f[d]=x^g,l.i=d,x+(c^c>>>16)|0};function u(c,f){var d,g,x,S,b,_=[],T=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,T=Math.max(T,f.length)),x=0,S=-32;S<T;++S)f&&(g^=f.charCodeAt((S+32)%f.length)),S===0&&(b=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,S>=0&&(b=b+1640531527|0,d=_[S&127]^=g+b,x=d==0?x+1:0);for(x>=128&&(_[(f&&f.length||0)&127]=-1),x=127,S=4*128;S>0;--S)g=_[x+34&127],d=_[x=x+1&127],g^=g<<13,d^=d<<17,g^=g>>>15,d^=d>>>12,_[x]=g^d;c.w=b,c.X=_,c.i=x}u(l,o)}function r(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function a(o,l){o==null&&(o=+new Date);var u=new i(o),c=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var d=u.next()>>>11,g=(u.next()>>>0)/4294967296,x=(d+g)/(1<<21);while(x===0);return x},f.int32=u.next,f.quick=f,c&&(c.X&&r(c,u),f.state=function(){return r(u,{})}),f}t&&t.exports?t.exports=a:this.xor4096=a})(cfe,s)}(Fw)),Fw.exports}var Pw={exports:{}},ffe=Pw.exports,FU;function dfe(){return FU||(FU=1,function(s){(function(e,t,n){function i(o){var l=this,u="";l.next=function(){var f=l.b,d=l.c,g=l.d,x=l.a;return f=f<<25^f>>>7^d,d=d-g|0,g=g<<24^g>>>8^x,x=x-f|0,l.b=f=f<<20^f>>>12^d,l.c=d=d-g|0,l.d=g<<16^d>>>16^x,l.a=x-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function r(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function a(o,l){var u=new i(o),c=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var d=u.next()>>>11,g=(u.next()>>>0)/4294967296,x=(d+g)/(1<<21);while(x===0);return x},f.int32=u.next,f.quick=f,c&&(typeof c=="object"&&r(c,u),f.state=function(){return r(u,{})}),f}t&&t.exports?t.exports=a:this.tychei=a})(ffe,s)}(Pw)),Pw.exports}var Uw={exports:{}};const pfe={},mfe=Object.freeze(Object.defineProperty({__proto__:null,default:pfe},Symbol.toStringTag,{value:"Module"})),gfe=sj(mfe);var yfe=Uw.exports,PU;function xfe(){return PU||(PU=1,function(s){(function(e,t,n){var i=256,r=6,a=52,o="random",l=n.pow(i,r),u=n.pow(2,a),c=u*2,f=i-1,d;function g(C,R,I){var L=[];R=R==!0?{entropy:!0}:R||{};var P=_(b(R.entropy?[C,E(t)]:C??T(),3),L),D=new x(L),O=function(){for(var F=D.g(r),X=l,q=0;F<u;)F=(F+q)*i,X*=i,q=D.g(1);for(;F>=c;)F/=2,X/=2,q>>>=1;return(F+q)/X};return O.int32=function(){return D.g(4)|0},O.quick=function(){return D.g(4)/4294967296},O.double=O,_(E(D.S),t),(R.pass||I||function(F,X,q,J){return J&&(J.S&&S(J,D),F.state=function(){return S(D,{})}),q?(n[o]=F,X):F})(O,P,"global"in R?R.global:this==n,R.state)}function x(C){var R,I=C.length,L=this,P=0,D=L.i=L.j=0,O=L.S=[];for(I||(C=[I++]);P<i;)O[P]=P++;for(P=0;P<i;P++)O[P]=O[D=f&D+C[P%I]+(R=O[P])],O[D]=R;(L.g=function(F){for(var X,q=0,J=L.i,Y=L.j,$=L.S;F--;)X=$[J=f&J+1],q=q*i+$[f&($[J]=$[Y=f&Y+X])+($[Y]=X)];return L.i=J,L.j=Y,q})(i)}function S(C,R){return R.i=C.i,R.j=C.j,R.S=C.S.slice(),R}function b(C,R){var I=[],L=typeof C,P;if(R&&L=="object")for(P in C)try{I.push(b(C[P],R-1))}catch{}return I.length?I:L=="string"?C:C+"\0"}function _(C,R){for(var I=C+"",L,P=0;P<I.length;)R[f&P]=f&(L^=R[f&P]*19)+I.charCodeAt(P++);return E(R)}function T(){try{var C;return d&&(C=d.randomBytes)?C=C(i):(C=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(C)),E(C)}catch{var R=e.navigator,I=R&&R.plugins;return[+new Date,e,I,e.screen,E(t)]}}function E(C){return String.fromCharCode.apply(0,C)}if(_(n.random(),t),s.exports){s.exports=g;try{d=gfe}catch{}}else n["seed"+o]=g})(typeof self<"u"?self:yfe,[],Math)}(Uw)),Uw.exports}var hI,UU;function vfe(){if(UU)return hI;UU=1;var s=sfe(),e=rfe(),t=ofe(),n=ufe(),i=hfe(),r=dfe(),a=xfe();return a.alea=s,a.xor128=e,a.xorwow=t,a.xorshift7=n,a.xor4096=i,a.tychei=r,hI=a,hI}var bM=vfe();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lk{constructor(e,t,n,i,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=r||Math.random();this.random=bM.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,n=!1;for(;!n;){let i,r,a;do i=2*this.random()-1,r=2*this.random()-1,a=i*i+r*r;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*i*o,t=this.mean+this.stdDev*r*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class bfe{constructor(e,t,n,i){this.alpha=e,this.beta=1/t,this.dtype=n;const r=i||Math.random();this.randu=bM.alea(r.toString()),this.randn=new lk(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,i,r,a;for(;;){do i=this.randn.nextValue(),a=1+this.c*i;while(a<=0);if(a*=a*a,e=i*i,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),r=this.randu(),r<t||Math.log(r)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class _fe{constructor(e=0,t=1,n,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=bM.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sfe(s,e,t=1,n="float32",i){if(Tl(s),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);const r=new bfe(e,t,n,i),a=Mn(s,n);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const Afe=fe({randomGamma_:Sfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(s,e=0,t=1,n,i){if(Tl(s),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const r=new lk(e,t,n,!1,i),a=Mn(s,n);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const uk=fe({randomNormal_:Tfe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(s,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return uk(s,0,1,e,t)}const Cfe=fe({randomStandardNormal_:wfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(s,e=0,t=1,n="float32",i){Tl(s);const r=Mn(s,n),a=new _fe(e,t,null,i);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const Qg=fe({randomUniform_:Efe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(s,e,t,n){return Qg(s,e,t,"int32",n)}const Nfe=fe({randomUniformInt_:Mfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(s,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:s,stop:e,step:t,dtype:n};return me.runKernel(AB,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rfe(s){const t={input:Q(s,"input","real")};return me.runKernel(TB,t)}const Lb=fe({real_:Rfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(s){const t={x:Q(s,"x","reciprocal")};return me.runKernel(W_,t)}const kG=fe({reciprocal_:Ife});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dfe(s){const t={x:Q(s,"x","relu")};return me.runKernel(X_,t)}const xh=fe({relu_:Dfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(s){const t={x:Q(s,"x","relu6")};return me.runKernel(q_,t)}const ck=fe({relu6_:Ofe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(s,e){const n={x:Q(s,"x","reverse")},i={dims:e};return me.runKernel(KE,n,i)}const cu=fe({reverse_:Bfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kfe(s){const e=Q(s,"x","reverse");return K(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),cu(e,0)}const Lfe=fe({reverse1d_:kfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe(s,e){const t=Q(s,"x","reverse");return K(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),cu(t,e)}const Pfe=fe({reverse2d_:Ffe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ufe(s,e){const t=Q(s,"x","reverse");return K(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),cu(t,e)}const $fe=fe({reverse3d_:Ufe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zfe(s,e){const t=Q(s,"x","reverse");return K(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),cu(t,e)}const Gfe=fe({reverse4d_:zfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hfe(s){const t={x:Q(s,"x","round")};return me.runKernel(j_,t)}const hk=fe({round_:Hfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vfe(s){const t={x:Q(s,"x","rsqrt","float32")};return me.runKernel(K_,t)}const fk=fe({rsqrt_:Vfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wfe(s){const t={x:Q(s,"x","selu")};return me.runKernel(Y_,t)}const dk=fe({selu_:Wfe});function Xfe(s,e,t,n,i,r=[1,1],a="NHWC"){const o=Q(s,"x","separableConv2d"),l=Q(e,"depthwiseFilter","separableConv2d"),u=Q(t,"pointwiseFilter","separableConv2d");let c=o,f=!1;if(o.rank===3&&(f=!0,c=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");K(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),K(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),K(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),K(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),K(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],g=l.shape[3];K(u.shape[2]===d*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*g}, but got ${u.shape[2]}.`);const x=fS(c,l,n,i,a,r),b=cp(x,u,1,"valid",a);return f?xe(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const pk=fe({separableConv2d_:Xfe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function qfe(s,e){const t=Q(s,"x","setdiff1d"),n=Q(e,"y","setdiff1d");K(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),K(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),K(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const i=await t.data(),r=await n.data(),a=new Set(r);let o=0;for(let c=0;c<i.length;c++)a.has(i[c])||o++;const l=new nr([o],t.dtype),u=new nr([o],"int32");for(let c=0,f=0;c<i.length;c++)a.has(i[c])||(l.values[f]=i[c],u.values[f]=c,f++);return[l.toTensor(),u.toTensor()]}const jfe=qfe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(s){const t={x:Q(s,"x","sign")};return me.runKernel(Q_,t)}const LG=fe({sign_:Kfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yfe(s){const t={x:Q(s,"x","sin","float32")};return me.runKernel(J_,t)}const mk=fe({sin_:Yfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jfe(s){const t={x:Q(s,"x","sinh")};return me.runKernel(Z_,t)}const gk=fe({sinh_:Jfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(s,e,t){const n=Q(s,"x","slice1d");return K(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),bn(n,[e],[t])}const _M=fe({slice1d_:Zfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(s,e,t){const n=Q(s,"x","slice2d");return K(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),bn(n,e,t)}const yk=fe({slice2d_:Qfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ede(s,e,t){const n=Q(s,"x","slice3d");return K(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),bn(n,e,t)}const SM=fe({slice3d_:ede});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(s,e,t){const n=Q(s,"x","slice4d");return K(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),bn(n,e,t)}const Fb=fe({slice4d_:tde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nde(s,e=-1){const t=Q(s,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},i={dim:e};return me.runKernel(tM,n,i)}const AM=fe({softmax_:nde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sde(s){K(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const e={input:s};return me.runKernel(rB,e)}const TM=fe({fft_:sde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(s){K(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const e={input:s};return me.runKernel(uB,e)}const Pb=fe({ifft_:ide});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rde(s){const e=s.shape[s.shape.length-1],t=s.size/e;let n;if(e<=2){const i=xe(s,[t,e]);n=Pb(i)}else{const i=[t,2*(e-1)],r=xe(Lb(s),[t,e]),a=xe(hM(s),[t,e]),o=cu(bn(r,[0,1],[t,e-2]),1),l=pe(cu(bn(a,[0,1],[t,e-2]),1),Jt(-1)),u=js([r,o],1),c=js([a,l],1),f=xe(op(u,c),[i[0],i[1]]);n=Pb(f)}if(n=Lb(n),s.rank===3&&s.shape[0]!==0){const i=n,r=s.shape[0];n=xe(n,[r,n.shape[0]/r,n.shape[1]]),i.dispose()}return n}const xk=fe({irfft_:rde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(s,e,t=0){const i={x:Q(s,"x","split")},r={numOrSizeSplits:e,axis:t};return me.runKernel(eM,i,r)}const Oo=fe({split_:ade});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ode(s,e){K(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let t=s.shape[s.shape.length-1];const n=s.size/t;let i;if(e!=null&&e<t){const x=s.shape.map(b=>0),S=s.shape.map(b=>b);S[s.shape.length-1]=e,i=bn(s,x,S),t=e}else if(e!=null&&e>t){const x=s.shape.map(S=>S);x[s.shape.length-1]=e-t,i=js([s,Qi(x)],s.shape.length-1),t=e}else i=s;const r=Kn(i),a=xe(op(i,r),[n,t]),o=TM(a),l=Math.floor(t/2)+1,u=Lb(o),c=hM(o),f=Oo(u,[l,t-l],u.shape.length-1),d=Oo(c,[l,t-l],c.shape.length-1),g=i.shape.slice();return g[i.shape.length-1]=l,xe(op(f[0],d[0]),g)}const wM=fe({rfft_:ode});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lde(s,e){let t=Q(s,"a","squaredDifference"),n=Q(e,"b","squaredDifference");[t,n]=yi(t,n),gn(t.shape,n.shape);const i={a:t,b:n},r={};return me.runKernel(sS,i,r)}const vk=fe({squaredDifference_:lde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ude(s,e){const t=Q(s,"x","squeeze","string_or_numeric");return xe(t,bp(t.shape,e).newShape)}const e0=fe({squeeze_:ude});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cde(s,e=0){const t=j2(s,"tensors","stack","string_or_numeric");K(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&K(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,i={axis:e};return me.runKernel(GE,n,i)}const Po=fe({stack_:cde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(s,e=0){const n={x:Q(s,"x","step")},i={alpha:e};return me.runKernel(lS,n,i)}const qx=fe({step_:hde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fde(s,e,t,n,i=0,r=0,a=0,o=0,l=0){const c={x:Q(s,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:n,beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return me.runKernel(LB,c,f)}const FG=fe({stridedSlice_:fde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dde(s){const t={x:Q(s,"x","tan","float32")};return me.runKernel(rS,t)}const PG=fe({tan_:dde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(s,e){zx(s);const t=Sp(s,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ap(s,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jd(s,e,t){if(zx(s),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=Sp(s,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ap(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UG(s,e,t){if(zx(s),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=Sp(s,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ap(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pde(s,e,t){if(zx(s),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const n=Sp(s,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ap(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mde(s,e,t){if(zx(s),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const n=Sp(s,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ap(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gde(s,e,t){if(zx(s),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const n=Sp(s,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,Ap(s,e,n,t)}function $G(s,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${s}, sliceDim: ${n}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(r+` update.rank < ${i}. `);if(s.length<n+(t.rank-i))throw new Error(r+` Output shape length < ${n+(t.rank-i)}`);if(t.rank!==i+s.length-n)throw new Error(r+` update.rank != ${i+s.length-n}`);for(let a=0;a<i;++a)if(t.shape[a]!==e.shape[a])throw new Error(r+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-i;++a)if(t.shape[a+i]!==s[a+n])throw new Error(r+` updates.shape[${a+i}] (${t.shape[a+i]}) != shape[${a+i}] (${s[a+i]})`)}function bk(s,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(s.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${s.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(s.size===0)throw new Error(`Updates specified for empty output. updates shape: ${s.shape}`)}$G(t,e,s)}function t0(s,e,t){const n=e.shape.length,i=n>1?e.shape[n-1]:1,r=t.length;let a=1;for(let f=i;f<r;++f)a*=t[f];const o=i<1?1:i,l=Xe(e.shape)/o,u=[...jt(t.slice(0,i)),1],c=Xe(t);return{sliceRank:i,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yde(s,e,t){const n=Q(s,"tensor","tensorScatterupdate"),i=Q(e,"indices","tensorScatterupdate","int32"),r=Q(t,"updates","tensorScatterupdate");if(bk(r,i,n.shape),n.dtype!==r.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${r.dtype}.`);const a={tensor:n,indices:i,updates:r},o={};return me.runKernel(MB,a,o)}const xde=fe({tensorScatterUpdate_:yde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vde(s,e=1,t=!0){const n=Q(s,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const r={x:n},a={k:e,sorted:t},[o,l]=me.runKernel($B,r,a);return{values:o,indices:l}}const zG=fe({topk_:vde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(s,e=0,t=1,n,i){if(Tl(s),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new lk(e,t,n,!0,i),a=Mn(s,n);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const _k=fe({truncatedNormal_:bde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _de(s,e=0){const t=Q(s,"x","unique","string_or_numeric");K(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},i={axis:e},[r,a]=me.runKernel(GB,n,i);return{values:r,indices:a}}const GG=fe({unique_:_de});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sde(s,e,t){const n=Q(s,"x","unsortedSegmentSum"),i=Q(e,"segmentIds","unsortedSegmentSum","int32");K(bx(t),()=>"numSegments must be of dtype int");const r={x:n,segmentIds:i},a={numSegments:t};return me.runKernel(iM,r,a)}const Sk=fe({unsortedSegmentSum_:Sde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ade(s,e=0){const t=Q(s,"x","unstack","string_or_numeric");K(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},i={axis:e};return me.runKernel(sM,n,i)}const hu=fe({unstack_:Ade});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tde(s,e){return ak(s,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(s,e=!0,t,n){return me.makeVariable(s,e,t,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ak(s,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const n=Mn(s,"int32"),i=Mn([t.length,s.length],"int32");for(let r=0;r<t.length;r++){const a=n.indexToLoc(t[r]),o=r*s.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wde(s){const e=Q(s,"condition","whereAsync","bool"),t=await e.data(),n=Ak(e.shape,t);return s!==e&&e.dispose(),n}const VG=wde;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cde(s,e,t){const n=Q(s,"tensor","boolMask"),i=Q(e,"mask","boolMask","bool"),r=t??0,a=i.rank,o=n.shape;K(a>0,()=>"mask cannot be scalar"),zo(o.slice(r,r+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let S=r;S<r+a;S++)l*=o[S];const u=o.slice(0,r).concat([l],o.slice(r+a)),c=xe(n,u),f=xe(i,[-1]),d=await VG(f),g=e0(d,[1]),x=gS(c,g,r);return s!==n&&n.dispose(),e!==i&&i.dispose(),g.dispose(),c.dispose(),f.dispose(),d.dispose(),x}const Ede=Cde;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mde(s,e,t){const n=Q(s,"x","transpose");if(e==null&&(e=n.shape.map((a,o)=>o).reverse()),K(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(a=>{K(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const i={x:n},r={perm:e};return n.dtype==="complex64"?we(()=>{let a=Lb(n),o=hM(n);return a=me.runKernel(Ky,{x:a},r),o=me.runKernel(Ky,{x:o},r),t&&(o=Hs(o)),op(a,o)}):me.runKernel(Ky,i,r)}const jn=fe({transpose_:Mde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nde(s,e,t,n,i=!0){const r=Q(s,"v","movingAverage"),a=Q(e,"x","movingAverage"),o=Q(t,"decay","movingAverage");mle(r,a),K(Wn(r.shape,a.shape),()=>"Shape mismatch in v and x");const l=Jt(1),u=wt(l,o);let c=pe(wt(a,r),u);if(i){K(n!=null,()=>"When using zeroDebias: true, step is required.");const f=Q(n,"step","movingAverage");c=Ut(c,wt(l,Sf(o,f)))}return it(r,c)}const Rde=fe({movingAverage_:Nde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ide(s,e,t){Tl(t);const n=Q(s,"indices","scatterND","int32"),i=Q(e,"updates","scatterND");bk(i,n,t);const r={indices:n,updates:i},a={shape:t};return me.runKernel(EB,r,a)}const Dde=fe({scatterND_:Ide});function Ode(s,e,t,n){if(s.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${s.dtype}.`);if(s.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${s.shape}.`);const i=s.rank>0?s.shape[0]:1,r=s.rank>1?s.shape[1]:1;if(t.length!==r)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${r}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bde(s,e,t,n=0){Tl(t);const i=Q(s,"sparseIndices","sparseToDense","int32"),r=Q(e,"sparseValues","sparseToDense","string_or_numeric"),a=Q(n,"defaultValue","sparseToDense",r.dtype);Ode(i,r,t,a);const o={sparseIndices:i,sparseValues:r,defaultValue:a},l={outputShape:t};return me.runKernel(BB,o,l)}const kde=fe({sparseToDense_:Bde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lde(s,e){const t=Q(e,"indices","gatherND","int32"),i={params:Q(s,"x","gatherND","string_or_numeric"),indices:t};return me.runKernel(lB,i)}const Fde=fe({gatherND_:Lde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pde(s,e){if(e==null)return s.shape.slice();if(Wn(s.shape,e))return e;if(s.shape.length===e.length){const t=[];for(let n=0;n<s.shape.length;n++)e[n]==null&&s.shape[n]!=null?t.push(s.shape[n]):t.push(e[n]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(s,e,t,n){const i=Q(s,"x","dropout");if(K(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),K(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return s instanceof ls?i.clone():i;const r=Pde(i,t),a=1-e,o=Ut(mS(it(Qg(r,0,1,"float32",n),a)),a);return pe(i,o)}const WG=fe({dropout_:Ude});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(s){return Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2))))}function Tk(s,e,t){const n=1-s%2,i=new Float32Array(s);for(let r=0;r<s;++r){const a=2*Math.PI*r/(s+n-1);i[r]=e-t*Math.cos(a)}return mi(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $de(s,e,t=1){const n=Q(s,"predictions","inTopK"),i=Q(e,"targets","inTopK");K(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),K(n.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${i.rank}`),zo(n.shape.slice(0,n.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=n.shape[n.shape.length-1];K(t>0&&t<=r,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${r}), but got ${t}`);const a=await n.data(),o=await i.data(),[l,u]=[a.length/r,r],c=Fr("bool",l);for(let f=0;f<l;f++){const d=f*u,g=a.subarray(d,d+u),x=[];for(let S=0;S<g.length;S++)x.push({value:g[S],index:S});x.sort((S,b)=>b.value-S.value),c[f]=0;for(let S=0;S<t;S++)if(x[S].index===o[f]){c[f]=1;break}}return s!==n&&n.dispose(),e!==i&&i.dispose(),Qu(c,i.shape,"bool")}const zde=$de;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gde(s,e,t,n,i,r="NHWC",a){let o=s;s.rank===3&&(o=xe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l=e;l.rank===3&&(l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),K(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),K(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),K(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=r==="NHWC"?o.shape[3]:o.shape[1],c=r==="NHWC"?l.shape[3]:l.shape[1];K(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),K(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Da("conv2dDerFilter",i,a);const f={x:o,dy:l},d={strides:n,pad:i,dataFormat:r,dimRoundingMode:a,filterShape:t};return me.runKernel(qO,f,d)}const wk=fe({conv2DBackpropFilter_:Gde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CM(s,e,t){if(t==null||t==="linear")return s;if(t==="relu")return pe(s,qx(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function EM(s,e){let t=e;const n=rr(s.shape,e.shape);return n.length>0&&(t=$t(t,n)),xe(t,s.shape)}function MM(s,e,t,n){if(e==="linear")return s;if(e==="relu")return xh(s);if(e==="elu")return dS(s);if(e==="relu6")return ck(s);if(e==="prelu")return vM(s,t);if(e==="leakyrelu")return fM(s,n);if(e==="sigmoid")return ec(s);throw new Error(`Unknown fused activation ${e}.`)}const NM=(s,e)=>!(s>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hde({x:s,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",NM(me.state.gradientDepth,l)===!1){K(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=cp(s,e,t,n,i,r,a);return o!=null&&(I=it(I,o)),MM(I,l,u,c)}const f=Q(s,"x","conv2d","float32"),d=Q(e,"filter","conv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=xe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),K(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),K(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Da("fused conv2d",n,a);const S=i==="NHWC"?g.shape[3]:g.shape[1];K(d.shape[2]===S,()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${d.shape[2]}.`),K(Ur(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);const b=Ar(g.shape,d.shape,t,r,n,a);let _;o!=null&&(_=Q(o,"bias","fused conv2d"),[_]=yi(_,f),i==="NHWC"?gn(b.outShape,_.shape):(K(_.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`),K(_.shape.length===0||_.shape[0]===b.outChannels||_.shape[0]===1,()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let T;if(u!=null){const I=u.shape;if(K(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)K(I[0]===1||I[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${b.outChannels}).`);else if(I.length===3)try{gn(I,b.outShape)}catch{const P=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(P)}T=Q(u,"prelu weights","fused conv2d")}const E=(I,L)=>{K(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[P,D,O,F]=L,X=CM(I,O,l);K(up(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const q=JB(D.shape,X,P,t,n),J=wk(D,X,P.shape,t,n),Y=[q,J];if(F!=null){const $=EM(F,X);Y.push($)}return Y},C={x:g,filter:d,bias:_,preluActivationWeights:T},R={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return o==null?Af((L,P,D)=>{let O=me.runKernel(V2,C,R);return D([P,L,O]),x&&(O=xe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:E}})(g,d):Af((L,P,D,O)=>{let F=me.runKernel(V2,C,R);return O([P,L,F,D]),x&&(F=xe(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:E}})(g,d,_)}const qG=fe({fusedConv2d_:Hde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vde(s,e,t,n,i,r=[1,1],a){let o=s;s.rank===3&&(o=xe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l=e;l.rank===3&&(l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:o,dy:l},c={strides:n,pad:i,dimRoundingMode:a,dilations:r,filterShape:t};return me.runKernel(eB,u,c)}const jG=fe({depthwiseConv2dNativeBackpropFilter_:Vde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wde(s,e,t,n,i,r=[1,1],a){let o=e,l=!1;e.rank===3&&(l=!0,o=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:o,filter:t},c={strides:n,pad:i,dimRoundingMode:a,dilations:r,inputShape:s},f=me.runKernel(tB,u,c);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const KG=fe({depthwiseConv2dNativeBackpropInput_:Wde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xde({x:s,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(NM(me.state.gradientDepth,l)===!1){let R=fS(s,e,t,n,i,r,a);return o!=null&&(R=it(R,o)),MM(R,l,u,c)}const f=Q(s,"x","depthwiseConv2d","float32"),d=Q(e,"filter","depthwiseConv2d","float32");let g=f,x=!1;f.rank===3&&(x=!0,g=xe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),K(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),K(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),K(g.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),r==null&&(r=[1,1]),K(Ur(t,r),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),Da("fused depthwiseConv2d",n,a);const S=Ar(g.shape,d.shape,t,r,n,a,!0);let b;o!=null&&(b=Q(o,"bias","fused conv2d"),[b]=yi(b,f),gn(S.outShape,b.shape));let _;u!=null&&(_=Q(u,"prelu weights","fused depthwiseConv2d"));const T=(R,I)=>{K(up(r),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${r}'`);const[L,P,D,O]=I,F=CM(R,D,l),X=KG(P.shape,F,L,t,n,r,a),q=jG(P,F,L.shape,t,n,r,a);if(O!=null){const J=EM(b,F);return[X,q,J]}return[X,q]},E={x:g,filter:d,bias:b,preluActivationWeights:_},C={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return o==null?Af((I,L,P)=>{let D=me.runKernel(W2,E,C);return P([L,I,D]),x&&(D=xe(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:T}})(g,d):Af((I,L,P,D)=>{let O=me.runKernel(W2,E,C);return D([L,I,O,P]),x&&(O=xe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:T}})(g,d,b)}const qde=fe({fusedDepthwiseConv2d_:Xde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jde({a:s,b:e,transposeA:t=!1,transposeB:n=!1,bias:i,activation:r="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(NM(me.state.gradientDepth,r)===!1){let F=Un(s,e,t,n);return i!=null&&(F=it(F,i)),MM(F,r,a,o)}let l=Q(s,"a","fused matMul"),u=Q(e,"b","fused matMul");[l,u]=yi(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],f=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],g=n?u.shape[u.rank-2]:u.shape[u.rank-1],x=l.shape.slice(0,-2),S=u.shape.slice(0,-2),b=Xe(x),_=Xe(S);K(c===f,()=>`Error in fused matMul: inner shapes (${c}) and (${f}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${n} must match.`);const E=gn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,g]),C=t?xe(l,[b,c,d]):xe(l,[b,d,c]),R=n?xe(u,[_,g,f]):xe(u,[_,f,g]);let I;i!=null&&(I=Q(i,"bias","fused matMul"),[I]=yi(I,l),gn(E,I.shape));let L;a!=null&&(L=Q(a,"prelu weights","fused matMul"));const P=(F,X)=>{const[q,J,Y,$]=X,W=CM(xe(F,Y.shape),Y,r);let V,se;if(!t&&!n?(V=Un(W,J,!1,!0),se=Un(q,W,!0,!1)):!t&&n?(V=Un(W,J,!1,!1),se=Un(W,q,!0,!1)):t&&!n?(V=Un(J,W,!1,!0),se=Un(q,W,!1,!1)):(V=Un(J,W,!0,!0),se=Un(W,q,!0,!0)),i!=null){const G=EM($,W);return[V,se,G]}else return[V,se]},D={a:C,b:R,bias:I,preluActivationWeights:L},O={transposeA:t,transposeB:n,activation:r,leakyreluAlpha:o};return i==null?Af((X,q,J)=>{const Y=me.runKernel(H2,D,O);return J([X,q,Y]),{value:xe(Y,E),gradFunc:P}})(C,R):Af((X,q,J,Y)=>{const $=me.runKernel(H2,D,O);return Y([X,q,$,J]),{value:xe($,E),gradFunc:P}})(C,R,I)}const PD=fe({fusedMatMul_:jde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kde=Object.freeze(Object.defineProperty({__proto__:null,conv2d:qG,depthwiseConv2d:qde,matMul:PD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yde(s){return Tk(s,.54,.46)}const Jde=fe({hammingWindow_:Yde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zde(s){return Tk(s,.5,.5)}const YG=fe({hannWindow_:Zde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qde(s,e,t,n=!1,i=0){let r=0;const a=[];for(;r+e<=s.size;)a.push(bn(s,r,e)),r+=t;if(n)for(;r<s.size;){const o=r+e-s.size,l=js([bn(s,r,e-o),Wx([o],i)]);a.push(l),r+=t}return a.length===0?Jd([],[0,e]):xe(js(a),[a.length,e])}const JG=fe({frame_:Qde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function epe(s,e,t,n,i=YG){n==null&&(n=XG(e));const r=JG(s,e,t),a=pe(r,i(e));return wM(a,n)}const tpe=fe({stft_:epe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function npe(s,e,t,n,i="bilinear",r=0){const a=Q(s,"image","cropAndResize"),o=Q(e,"boxes","cropAndResize","float32"),l=Q(t,"boxInd","cropAndResize","int32"),u=o.shape[0];K(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),K(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),K(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),K(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),K(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),K(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const c={image:a,boxes:o,boxInd:l},f={method:i,extrapolationValue:r,cropSize:n};return me.runKernel(JO,c,f)}const spe=fe({cropAndResize_:npe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ipe(s){const e=Q(s,"image","flipLeftRight","float32");K(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return me.runKernel(oB,t,{})}const rpe=fe({flipLeftRight_:ipe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ape(s){const e=Q(s,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];K(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),K(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,su(e,i)}const ope=fe({grayscaleToRGB_:ape});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lpe(s){const e=Q(s,"image","RGBToGrayscale"),t=e.rank-1,n=e.shape[t];K(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),K(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);const i=e.dtype,r=Ct(e,"float32"),a=mi([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Fy("ij,j->i",r,a);break;case 3:o=Fy("ijk,k->ij",r,a);break;case 4:o=Fy("ijkl,l->ijk",r,a);break;case 5:o=Fy("ijklm,m->ijkl",r,a);break;case 6:o=Fy("ijklmn,n->ijklm",r,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Sa(o,-1),Ct(o,i)}const upe=fe({rgbToGrayscale_:lpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cpe(s,e,t=0,n=.5){const i=Q(s,"image","rotateWithOffset","float32");K(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},a={radians:e,fillValue:t,center:n};return me.runKernel(HB,r,a)}const hpe=fe({rotateWithOffset_:cpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(s,e,t,n,i,r){n==null&&(n=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const a=s.shape[0];return t=Math.min(t,a),K(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),K(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),K(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),K(e.rank===1,()=>"scores must be a 1D tensor"),K(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),K(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fpe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const r=Q(s,"boxes","nonMaxSuppression","float32"),a=Q(e,"scores","nonMaxSuppression","float32"),o=jx(r,a,t,n,i);t=o.maxOutputSize,n=o.iouThreshold,i=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:n,scoreThreshold:i};return me.runKernel(yB,{boxes:r,scores:a},l)}const dpe=fe({nonMaxSuppression_:fpe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ppe(s,e,t){const n=mpe(s,e,t),i=n<0?-(n+1):n;s.splice(i,0,e)}function mpe(s,e,t){return ype(s,e,t||gpe)}function gpe(s,e){return s>e?1:s<e?-1:0}function ype(s,e,t){let n=0,i=s.length,r=0,a=!1;for(;n<i;){r=n+(i-n>>>1);const o=t(e,s[r]);o>0?n=r+1:(i=r,a=!o)}return a?n:-n-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(s,e,t,n,i){return Nk(s,e,t,n,i,0)}function Ek(s,e,t,n,i,r){return Nk(s,e,t,n,i,0,!1,r,!0)}function Mk(s,e,t,n,i,r){return Nk(s,e,t,n,i,r,!0)}function Nk(s,e,t,n,i,r,a=!1,o=!1,l=!1){const u=[];for(let b=0;b<e.length;b++)e[b]>i&&u.push({score:e[b],boxIndex:b,suppressBeginIndex:0});u.sort($U);const c=r>0?-.5/r:0,f=[],d=[];for(;f.length<t&&u.length>0;){const b=u.pop(),{score:_,boxIndex:T,suppressBeginIndex:E}=b;if(_<i)break;let C=!1;for(let R=f.length-1;R>=E;--R){const I=xpe(s,T,f[R]);if(I>=n){C=!0;break}if(b.score=b.score*vpe(n,c,I),b.score<=i)break}b.suppressBeginIndex=f.length,C||(b.score===_?(f.push(T),d.push(b.score)):b.score>i&&ppe(u,b,$U))}const g=f.length,x=t-g;o&&x>0&&(f.push(...new Array(x).fill(0)),d.push(...new Array(x).fill(0)));const S={selectedIndices:f};return a&&(S.selectedScores=d),l&&(S.validOutputs=g),S}function xpe(s,e,t){const n=s.subarray(e*4,e*4+4),i=s.subarray(t*4,t*4+4),r=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),o=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),u=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),f=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),g=(o-r)*(l-a),x=(f-u)*(d-c);if(g<=0||x<=0)return 0;const S=Math.max(r,u),b=Math.max(a,c),_=Math.min(o,f),T=Math.min(l,d),E=Math.max(_-S,0)*Math.max(T-b,0);return E/(g+x-E)}function vpe(s,e,t){const n=Math.exp(e*t*t);return t<=s?n:0}function $U(s,e){return s.score-e.score||s.score===e.score&&e.boxIndex-s.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bpe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const r=Q(s,"boxes","nonMaxSuppressionAsync"),a=Q(e,"scores","nonMaxSuppressionAsync"),o=jx(r,a,t,n,i);t=o.maxOutputSize,n=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([r.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:f}=Ck(u,c,t,n,i);return r!==s&&r.dispose(),a!==e&&a.dispose(),mi(f,"int32")}const _pe=bpe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Spe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=Q(s,"boxes","nonMaxSuppression"),o=Q(e,"scores","nonMaxSuppression"),l=jx(a,o,t,n,i,r);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const u={boxes:a,scores:o},c={maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:r},f=me.runKernel(vB,u,c);return{selectedIndices:f[0],selectedScores:f[1]}}const Ape=fe({nonMaxSuppressionWithScore_:Spe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Tpe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=Q(s,"boxes","nonMaxSuppressionAsync"),o=Q(e,"scores","nonMaxSuppressionAsync"),l=jx(a,o,t,n,i,r);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const u=await Promise.all([a.data(),o.data()]),c=u[0],f=u[1],{selectedIndices:d,selectedScores:g}=Mk(c,f,t,n,i,r);return a!==s&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:mi(d,"int32"),selectedScores:mi(g)}}const wpe=Tpe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cpe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=Q(s,"boxes","nonMaxSuppression"),o=Q(e,"scores","nonMaxSuppression"),l=jx(a,o,t,n,i,null),u=l.maxOutputSize,c=l.iouThreshold,f=l.scoreThreshold,d={boxes:a,scores:o},g={maxOutputSize:u,iouThreshold:c,scoreThreshold:f,padToMaxOutputSize:r},x=me.runKernel(xB,d,g);return{selectedIndices:x[0],validOutputs:x[1]}}const Epe=fe({nonMaxSuppressionPadded_:Cpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Mpe(s,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=Q(s,"boxes","nonMaxSuppressionAsync"),o=Q(e,"scores","nonMaxSuppressionAsync"),l=jx(a,o,t,n,i,null),u=l.maxOutputSize,c=l.iouThreshold,f=l.scoreThreshold,[d,g]=await Promise.all([a.data(),o.data()]),{selectedIndices:x,validOutputs:S}=Ek(d,g,u,c,f,r);return a!==s&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:mi(x,"int32"),validOutputs:Jt(S,"int32")}}const Npe=Mpe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rpe(s,e,t=!1,n=!1){const i=Q(s,"images","resizeBilinear");K(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),K(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),K(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=xe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:t,halfPixelCenters:n,size:e},u=me.runKernel(jE,o,l);return a?xe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const ZG=fe({resizeBilinear_:Rpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ipe(s,e,t=!1,n=!1){const i=Q(s,"images","resizeNearestNeighbor");K(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),K(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),K(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),K(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=xe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:t,halfPixelCenters:n,size:e},u=me.runKernel(qE,o,l);return a?xe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const QG=fe({resizeNearestNeighbor_:Ipe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dpe(s,e="binary",t=!1,n=.5){const i=Q(s,"image","threshold"),r=.2989,a=.587,o=.114,l=i.shape[0]*i.shape[1];let u=pe(mi([n]),255),c,f,d,g;if(K(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),K(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),K(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),K(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[c,f,d]=Oo(i,[1,1,1],-1);const b=pe(c,r),_=pe(f,a),T=pe(d,o);g=it(it(b,_),T)}else g=s;if(e==="otsu"){const b=lG(Ct(hk(g),"int32"),Qu([]),256);u=Ope(b,l)}const x=t?Zg(g,u):Go(g,u);return Ct(pe(x,255),"int32")}function Ope(s,e){let t=mi([-1]),n=mi([0]),i=mi([0]),r,a,o,l,u,c;for(let f=0;f<s.size-1;f++){r=bn(s,0,f+1),a=bn(s,f+1),u=Ut($t(r),e),c=Ut($t(a),e);const d=$t(pe(r,wx(0,r.size)));o=Ut(d,$t(r));const g=Wx(a.shape,r.size),x=it(wx(0,a.size),g),S=pe(a,x);l=Ut($t(S),$t(a));const b=wt(o,l),_=wt(o,l),T=pe(u,c);i=pe(pe(T,b),_);const E=Go(i,n);n=na(E,i,n),t=na(E,mi([f]),t)}return t}const Bpe=fe({threshold_:Dpe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kpe(s,e,t="nearest",n="constant",i=0,r){const a=Q(s,"image","transform","float32"),o=Q(e,"transforms","transform","float32");K(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),K(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),K(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:a,transforms:o},u={interpolation:t,fillMode:n,fillValue:i,outputShape:r};return me.runKernel(zB,l,u)}const Lpe=fe({transform_:kpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fpe(s,e,t){const n=Q(s,"a","bandPart");K(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const i=n.shape,[r,a]=n.shape.slice(-2);let o,l;typeof e=="number"?(K(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),K(e<=r,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`),o=Q(e<0?r:e,"numLower","bandPart")):(K(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=na(kb(e,0),r,Pg(e,r))),typeof t=="number"?(K(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),K(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),l=Q(t<0?a:t,"numUpper","bandPart")):(K(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=na(kb(t,0),a,Pg(t,a)));const u=xe(wx(0,r,1,"int32"),[-1,1]),c=wx(0,a,1,"int32"),f=wt(u,c),d=dh(Zg(f,o),Cp(f,Hs(l))),g=Qi([r,a],n.dtype);return xe(Po(hu(xe(n,[-1,r,a])).map(x=>na(d,x,g))),i)}const Ppe=fe({bandPart_:Fpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Upe(s){let e;if(Array.isArray(s)){e=!1,K(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=s[0].shape[0];for(let r=1;r<s.length;++r)K(s[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[r].shape[0]} vs. ${i})`)}else e=!0,s=Oo(s,s.shape[0],0).map(i=>e0(i,[0]));K(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const t=[],n=s;for(let i=0;i<s.length;++i)t.push(me.tidy(()=>{let r=n[i];if(i>0)for(let a=0;a<i;++a){const o=pe($t(pe(t[a],r)),t[a]);r=wt(r,o)}return Ut(r,pS(r,"euclidean"))}));return e?Po(t,0):t}const $pe=fe({gramSchmidt_:Upe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zpe(s,e=!1){if(K(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return zU(s,e);{const t=s.shape.slice(0,s.shape.length-2).reduce((l,u)=>l*u),n=hu(xe(s,[t,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),i=[],r=[];n.forEach(l=>{const[u,c]=zU(l,e);i.push(u),r.push(c)});const a=xe(Po(i,0),s.shape),o=xe(Po(r,0),s.shape);return[a,o]}}function zU(s,e=!1){return me.tidy(()=>{K(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const t=s.shape[0],n=s.shape[1];let i=sk(t),r=pf(s);const a=Jd([[1]],[1,1]);let o=pf(a);const l=t>=n?n:t;for(let u=0;u<l;++u){const c=r,f=o,d=i;[o,r,i]=me.tidy(()=>{const g=bn(r,[u,u],[t-u,1]),x=pS(g),S=bn(r,[u,u],[1,1]),b=na(Go(S,0),Jd([[-1]]),Jd([[1]])),_=wt(S,pe(b,x)),T=Ut(g,_);T.shape[0]===1?o=pf(a):o=js([a,bn(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const E=Hs(Ut(Un(b,_),x)),C=bn(r,[u,0],[t-u,n]),R=pe(E,o),I=jn(o);if(u===0)r=wt(C,Un(R,Un(I,C)));else{const D=wt(C,Un(R,Un(I,C)));r=js([bn(r,[0,0],[u,n]),D],0)}const L=jn(R),P=bn(i,[0,u],[t,i.shape[1]-u]);if(u===0)i=wt(P,Un(Un(P,o),L));else{const D=wt(P,Un(Un(P,o),L));i=js([bn(i,[0,0],[t,u]),D],1)}return[o,r,i]}),Bn([c,f,d])}return!e&&t>n&&(i=bn(i,[0,0],[t,n]),r=bn(r,[0,0],[n,n])),[i,r]})}const Gpe=fe({qr_:zpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var no;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(no||(no={}));function Hpe(s,e,t=no.SUM_BY_NONZERO_WEIGHTS){const n=Q(s,"losses","computeWeightedLoss");let i=null;e!=null&&(i=Q(e,"weights","computeWeightedLoss"));const r=i==null?n:pe(n,i);if(t===no.NONE)return r;if(t===no.SUM)return $t(r);if(t===no.MEAN){if(i==null)return pi(r);{const a=n.size/i.size,o=Ut($t(r),$t(i));return a>1?Ut(o,Jt(a)):o}}if(t===no.SUM_BY_NONZERO_WEIGHTS){if(i==null)return Ut($t(r),Jt(n.size));{const a=pe(i,Mo(n.shape)),o=Ct($t(Tx(a,Jt(0))),"float32");return Ut($t(r),o)}}throw Error(`Unknown reduction: ${t}`)}const If=fe({computeWeightedLoss_:Hpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vpe(s,e,t,n=no.SUM_BY_NONZERO_WEIGHTS){const i=Q(s,"labels","absoluteDifference"),r=Q(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=Q(t,"weights","absoluteDifference")),zo(i.shape,r.shape,"Error in absoluteDifference: ");const o=Ji(wt(i,r));return If(o,a,n)}const Wpe=fe({absoluteDifference_:Vpe});function Xpe(s,e,t,n,i=no.SUM_BY_NONZERO_WEIGHTS){const r=Q(s,"labels","cosineDistance"),a=Q(e,"predictions","cosineDistance");let o=null;n!=null&&(o=Q(n,"weights","cosineDistance")),zo(r.shape,a.shape,"Error in cosineDistance: ");const l=Jt(1),u=wt(l,$t(pe(r,a),t,!0));return If(u,o,i)}const qpe=fe({cosineDistance_:Xpe});function jpe(s,e,t,n=no.SUM_BY_NONZERO_WEIGHTS){let i=Q(s,"labels","hingeLoss");const r=Q(e,"predictions","hingeLoss");let a=null;t!=null&&(a=Q(t,"weights","hingeLoss")),zo(i.shape,r.shape,"Error in hingeLoss: ");const o=Jt(1);i=wt(pe(Jt(2),i),o);const l=xh(wt(o,pe(i,r)));return If(l,a,n)}const Kpe=fe({hingeLoss_:jpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ype(s,e,t,n=1,i=no.SUM_BY_NONZERO_WEIGHTS){const r=Q(s,"labels","huberLoss"),a=Q(e,"predictions","huberLoss");let o=null;t!=null&&(o=Q(t,"weights","huberLoss")),zo(r.shape,a.shape,"Error in huberLoss: ");const l=Jt(n),u=Ji(wt(a,r)),c=Pg(u,l),f=wt(u,c),d=it(pe(Jt(.5),Os(c)),pe(l,f));return If(d,o,i)}const Jpe=fe({huberLoss_:Ype});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zpe(s,e,t,n=1e-7,i=no.SUM_BY_NONZERO_WEIGHTS){const r=Q(s,"labels","logLoss"),a=Q(e,"predictions","logLoss");let o=null;t!=null&&(o=Q(t,"weights","logLoss")),zo(r.shape,a.shape,"Error in logLoss: ");const l=Jt(1),u=Jt(n),c=Hs(pe(r,Sl(it(a,u)))),f=pe(wt(l,r),Sl(it(wt(l,a),u))),d=wt(c,f);return If(d,o,i)}const Qpe=fe({logLoss_:Zpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(s,e,t,n=no.SUM_BY_NONZERO_WEIGHTS){const i=Q(s,"labels","meanSquaredError"),r=Q(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=Q(t,"weights","meanSquaredError")),zo(i.shape,r.shape,"Error in meanSquaredError: ");const o=vk(i,r);return If(o,a,n)}const tme=fe({meanSquaredError_:eme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(s,e){const t=Q(s,"labels","sigmoidCrossEntropyWithLogits"),n=Q(e,"logits","sigmoidCrossEntropyWithLogits");zo(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=xh(n),r=pe(n,t),a=dM(Fo(Hs(Ji(n))));return it(wt(i,r),a)}function sme(s,e,t,n=0,i=no.SUM_BY_NONZERO_WEIGHTS){let r=Q(s,"multiClassLabels","sigmoidCrossEntropy");const a=Q(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=Q(t,"weights","sigmoidCrossEntropy")),zo(r.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){const u=Jt(n),c=Jt(1),f=Jt(.5);r=it(pe(r,wt(c,u)),pe(f,u))}const l=nme(r,a);return If(l,o,i)}const ime=fe({sigmoidCrossEntropy_:sme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rme(s,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Af((i,r,a)=>{const l=pM(r,[t],!0),u=wt(Ct(r,"float32"),l);a([i,u]);const c=Hs(pe(u,i));return{value:$t(c,[t]),gradFunc:(g,x)=>{const[S,b]=x,_=Ni(g.shape,[t]);return[pe(xe(g,_),wt(Ct(S,"float32"),Fo(b))),pe(xe(g,_),wt(Fo(b),Ct(S,"float32")))]}}})(s,e)}function ame(s,e,t,n=0,i=no.SUM_BY_NONZERO_WEIGHTS){let r=Q(s,"onehotLabels","softmaxCrossEntropy");const a=Q(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=Q(t,"weights","softmaxCrossEntropy")),zo(r.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){const u=Jt(n),c=Jt(1),f=Jt(r.shape[1]);r=it(pe(r,wt(c,u)),Ut(u,f))}const l=rme(r,a);return If(l,o,i)}const ome=fe({softmaxCrossEntropy_:ame});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(s,e,t,n){const i=Q(s,"indices","sparseFillEmptyRows","int32"),r=Q(e,"values","sparseFillEmptyRows"),a=Q(t,"denseShape","sparseFillEmptyRows","int32"),o=Q(n,"defaultValue","sparseFillEmptyRows",r.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:r,denseShape:a,defaultValue:o},u=me.runKernel(RB,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const ume=fe({sparseFillEmptyRows_:lme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cme(s,e,t){const n=Q(s,"inputIndices","sparseReshape","int32"),i=Q(e,"inputShape","sparseReshape","int32"),r=Q(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(r.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);const a={inputIndices:n,inputShape:i,newShape:r},o=me.runKernel(IB,a);return{outputIndices:o[0],outputShape:o[1]}}const hme=fe({sparseReshape_:cme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fme(s,e,t){const n=Q(s,"data","sparseSegmentMean"),i=Q(e,"indices","sparseSegmentMean","int32"),r=Q(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);const a={data:n,indices:i,segmentIds:r};return me.runKernel(DB,a)}const dme=fe({sparseSegmentMean_:fme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(s,e,t){const n=Q(s,"data","sparseSegmentSum"),i=Q(e,"indices","sparseSegmentSum","int32"),r=Q(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);const a={data:n,indices:i,segmentIds:r};return me.runKernel(OB,a)}const mme=fe({sparseSegmentSum_:pme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gme(s,e,t,n,i,r,a,o){const l=Q(s,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Q(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:n,leftPad:i,rightPad:r,padWidth:a,preserveShortSequences:o},f={data:l,dataSplits:u},d=me.runKernel(FB,f,c);return{nGrams:d[0],nGramsSplits:d[1]}}const yme=fe({stringNGrams_:gme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xme(s,e,t=!0){const n=Q(s,"input","stringSplit","string"),i=Q(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const r={skipEmpty:t},a={input:n,delimiter:i},o=me.runKernel(PB,a,r);return{indices:o[0],values:o[1],shape:o[2]}}const vme=fe({stringSplit_:xme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bme(s,e){const t=Q(s,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return me.runKernel(UB,i,n)}const _me=fe({stringToHashBucketFast_:bme});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sme(s,e,t,n=!0){const i=Q(s,"input","staticRegexReplace","string"),r={pattern:e,rewrite:t,replaceGlobal:n};return me.runKernel(nM,{x:i},r)}const Ame=fe({staticRegexReplace_:Sme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tme={fft:TM,ifft:Pb,rfft:wM,irfft:xk},wme={hammingWindow:Jde,hannWindow:YG,frame:JG,stft:tpe},pl={flipLeftRight:rpe,grayscaleToRGB:ope,resizeNearestNeighbor:QG,resizeBilinear:ZG,rgbToGrayscale:upe,rotateWithOffset:hpe,cropAndResize:spe,nonMaxSuppression:dpe,nonMaxSuppressionAsync:_pe,nonMaxSuppressionWithScore:Ape,nonMaxSuppressionWithScoreAsync:wpe,nonMaxSuppressionPadded:Epe,nonMaxSuppressionPaddedAsync:Npe,threshold:Bpe,transform:Lpe},eH={bandPart:Ppe,gramSchmidt:$pe,qr:Gpe},Cme={absoluteDifference:Wpe,computeWeightedLoss:If,cosineDistance:qpe,hingeLoss:Kpe,huberLoss:Jpe,logLoss:Qpe,meanSquaredError:tme,sigmoidCrossEntropy:ime,softmaxCrossEntropy:ome},Eme={sparseFillEmptyRows:ume,sparseReshape:hme,sparseSegmentMean:dme,sparseSegmentSum:mme},Mme={stringNGrams:yme,stringSplit:vme,stringToHashBucketFast:_me,staticRegexReplace:Ame};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nme=new Map,Rme=new Map;class Kx{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class eu{constructor(){this.classNameMap={}}static getMap(){return eu.instance==null&&(eu.instance=new eu),eu.instance}static register(e){eu.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function rt(s,e,t){K(s.className!=null,()=>"Class being registered does not have the static className property defined."),K(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),K(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=s.className);const n=t,i=e+">"+n;return eu.register(s),Nme.set(i,s),Rme.set(s,i),s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mp extends Kx{minimize(e,t=!1,n){const{value:i,grads:r}=this.computeGradients(e,n);if(n!=null){const a=n.map(o=>({name:o.name,tensor:r[o.name]}));this.applyGradients(a)}else this.applyGradients(r);return Bn(r),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return ehe(e,t)}dispose(){this.iterations_!=null&&Bn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Jt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Mp,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tH extends Mp{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=me.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const r=me.registeredVariables[n],a=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accum_grad`,variable:we(()=>Kn(r).variable(a))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${n}/accum_var`,variable:we(()=>Kn(r).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[n];if(o==null)return;const l=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;we(()=>{const c=it(pe(l,this.rho),pe(Os(o),1-this.rho)),f=pe(Ut(Pr(it(u,this.epsilon)),Pr(it(l,this.epsilon))),o),d=it(pe(u,this.rho),pe(Os(f),1-this.rho));l.assign(c),u.assign(d);const g=it(pe(f,-this.learningRate),r);r.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Bn(this.accumulatedGrads.map(e=>e.variable)),Bn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nH extends Mp{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const r=me.registeredVariables[n];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${n}/accumulator`,variable:we(()=>Wx(r.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[n];if(a==null)return;const o=this.accumulatedGrads[i].variable;we(()=>{const l=it(o,Os(a));o.assign(l);const u=it(pe(Ut(a,Pr(it(l,me.backend.epsilon()))),-this.learningRate),r);r.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Bn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sH extends Mp{static get className(){return"Adam"}constructor(e,t,n,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],we(()=>{this.accBeta1=Jt(t).variable(),this.accBeta2=Jt(n).variable()}),i==null&&(this.epsilon=me.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);we(()=>{const n=wt(1,this.accBeta1),i=wt(1,this.accBeta2);t.forEach((r,a)=>{const o=me.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:we(()=>Kn(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${r}/v`,variable:we(()=>Kn(o).variable(l))});const u=Array.isArray(e)?e[a].tensor:e[r];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,d=it(pe(c,this.beta1),pe(u,1-this.beta1)),g=it(pe(f,this.beta2),pe(Os(u),1-this.beta2)),x=Ut(d,n),S=Ut(g,i);c.assign(d),f.assign(g);const b=it(pe(Ut(x,it(Pr(S),this.epsilon)),-this.learningRate),o);o.assign(b)}),this.accBeta1.assign(pe(this.accBeta1,this.beta1)),this.accBeta2.assign(pe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Bn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Bn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),we(()=>{this.accBeta1.assign(Sf(this.beta1,this.iterations_+1)),this.accBeta2.assign(Sf(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iH extends Mp{static get className(){return"Adamax"}constructor(e,t,n,i=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],we(()=>{this.iteration=Jt(0).variable(),this.accBeta1=Jt(t).variable()}),i==null&&(this.epsilon=me.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);we(()=>{const n=wt(1,this.accBeta1),i=Ut(-this.learningRate,it(pe(this.iteration,this.decay),1));t.forEach((r,a)=>{const o=me.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:Kn(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${r}/v`,variable:Kn(o).variable(l)});const u=Array.isArray(e)?e[a].tensor:e[r];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,d=it(pe(c,this.beta1),pe(u,1-this.beta1)),g=pe(f,this.beta2),x=Ji(u),S=Rf(g,x);c.assign(d),f.assign(S);const b=it(pe(Ut(i,n),Ut(d,it(S,this.epsilon))),o);o.assign(b)}),this.iteration.assign(it(this.iteration,1)),this.accBeta1.assign(pe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Bn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Bn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rk extends Mp{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const r=Array.isArray(e)?e[i].tensor:e[n];if(r==null)return;const a=me.registeredVariables[n];we(()=>{const o=it(pe(this.c,r),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=xr(Jt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rH extends Rk{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Jt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const r=me.registeredVariables[n];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${n}/momentum`,variable:we(()=>Kn(r).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[n];o!=null&&we(()=>{let l;const u=it(pe(this.m,a),o);this.useNesterov?l=it(pe(this.c,it(o,pe(u,this.m))),r):l=it(pe(this.c,u),r),a.assign(u),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Bn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aH extends Mp{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,i=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=me.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,i)=>{const r=me.registeredVariables[n],a=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${n}/rms`,variable:we(()=>Kn(r).variable(a))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${n}/momentum`,variable:we(()=>Kn(r).variable(a))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${n}/mg`,variable:we(()=>Kn(r).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[n];if(o==null)return;const l=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;we(()=>{const c=it(pe(l,this.decay),pe(Os(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[i].variable,d=it(pe(f,this.decay),pe(o,1-this.decay)),g=Ut(pe(o,this.learningRate),Pr(wt(c,it(Os(d),this.epsilon)))),x=it(pe(u,this.momentum),g);l.assign(c),f.assign(d),u.assign(x);const S=wt(r,x);r.assign(S)}else{const f=it(pe(l,this.decay),pe(Os(o),1-this.decay)),d=it(pe(u,this.momentum),Ut(pe(o,this.learningRate),Pr(it(f,this.epsilon))));l.assign(f),u.assign(d);const g=wt(r,d);r.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Bn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Bn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Bn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ime=[tH,nH,sH,iH,rH,aH,Rk];function Dme(){for(const s of Ime)rt(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ome="model",Bme=".json",kme=".weights.bin";function GU(s){return new Promise(e=>setTimeout(e)).then(s)}class Ug{constructor(e){if(!Ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ug.URL_SCHEME)&&(e=e.slice(Ug.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ome),this.modelJsonFileName=e+Bme,this.weightDataFileName=e+kme}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=cc.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=U8(e,i),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await GU(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=n,await GU(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:uS(e)}}}}Ug.URL_SCHEME="downloads://";class Lme{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=i=>{const r=JSON.parse(i.target.result),a=r.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=XB(r,u=>this.loadWeights(u));e(l)},n.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const i=this.checkManifestAndWeightFiles(e),r=n.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(r).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,i)=>{const r=new FileReader;r.onload=a=>{const o=a.target.result;n(o)},r.onerror=a=>i(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(r=>IU(r.name)),i={};for(const r of e)r.paths.forEach(a=>{const o=IU(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),n.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);i[a]=this.weightsFiles[n.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const Fme=s=>Ie().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Ug.URL_SCHEME)?Pme(s.slice(Ug.URL_SCHEME.length)):null;ti.registerSaveRouter(Fme);function Pme(s="model"){return new Ug(s)}function Ume(s){return new Lme(s)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(s,e,t,n){a(s),t=t??0,n=n??1,o(t,n);let i=0;const r=l=>(l.then(u=>{const c=t+ ++i/s.length*(n-t);return e(c),u}),l);function a(l){K(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){K(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),K(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),K(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(s.map(r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function oH(s,e){e==null&&(e={});const t=e.fetchFunc==null?Ie().platform.fetch:e.fetchFunc,n=s.map(f=>t(f,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(n):await HU(n,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(o):await HU(o,e.onProgress,.5,1)}function $me(s,e){var t;const n=e.fetchFunc==null?Ie().platform.fetch:e.fetchFunc;let i=0,r;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;i<s.length;){r||(r=(await n(s[i],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await r.read();if(l){i++,r=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,i/s.length);continue}a.enqueue(u);return}a.close()}})}async function zme(s,e="",t,n){return lH(a=>oH(a,{requestInit:n}))(s,e,t)}function lH(s){return async(e,t="",n)=>{const i=e.map(()=>!1),r={},a=n!=null?n.map(()=>!1):[],o=[];if(e.forEach((g,x)=>{let S=0;g.weights.forEach(b=>{const _="quantization"in b?b.quantization.dtype:b.dtype,T=Og[_]*Xe(b.shape),E=()=>{i[x]=!0,r[x]==null&&(r[x]=[]),r[x].push({manifestEntry:b,groupOffset:S,sizeBytes:T})};n!=null?n.forEach((C,R)=>{C===b.name&&(E(),a[R]=!0)}):E(),o.push(b.name),S+=T})}),!a.every(g=>g)){const g=n.filter((x,S)=>!a[S]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=i.reduce((g,x,S)=>(x&&g.push(S),g),[]),u=[];l.forEach(g=>{e[g].paths.forEach(x=>{const S=t+(t.endsWith("/")?"":"/")+x;u.push(S)})});const c=await s(u),f={};let d=0;return l.forEach(g=>{const x=e[g].paths.length,S=new cc(c.slice(d,d+x));r[g].forEach(_=>{const T=S.slice(_.groupOffset,_.groupOffset+_.sizeBytes),E=k8(T,[_.manifestEntry]);for(const C in E)f[C]=E[C]}),d+=x}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gme="application/octet-stream",Hme="application/json";class Ik{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(K(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ie().platform.fetch,K(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&K(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=U8(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:Hme}),"model.json"),e.weightData!=null){const a=cc.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:Gme}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:uS(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const n=t.modelTopology,i=t.weightsManifest;if(n==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return XB(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=DD(e.weightsManifest),i=()=>$me(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:i})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=Vme(t),r=this.weightPathPrefix||n,a=[],o=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(u)):a.push(r+u+i);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),n=DD(e),i=await oH(t,this.loadOptions);return[n,i]}}Ik.URL_SCHEME_REGEX=/^https?:\/\//;function Vme(s){const e=s.lastIndexOf("/"),t=s.lastIndexOf("?"),n=s.substring(0,e),i=t>e?s.substring(t):"";return[n+"/",i]}function UD(s){return s.match(Ik.URL_SCHEME_REGEX)!=null}const uH=(s,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(s)?t=s.every(n=>UD(n)):t=UD(s),t)return Dk(s,e)}return null};ti.registerSaveRouter(uH);ti.registerLoadRouter(uH);function Dk(s,e){return new Ik(s,e)}function Wme(s,e){return Dk(s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fI{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class cH{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Xme{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function qme(s,e,t,n){const i=arguments;return new Xme(hH(...i))}function hH(s,e,t,n){return arguments.length===1?s.modelTopology!=null||s.weightSpecs!=null?new fI(s):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new fI({modelTopology:s})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new fI({modelTopology:s,weightSpecs:e,weightData:t,trainingConfig:n}))}function jme(s){return new cH(s)}function Kme(s){return new cH(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fH=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:cc,browserFiles:Ume,browserHTTPRequest:Wme,concatenateArrayBuffers:P8,copyModel:Kle,decodeWeights:k8,decodeWeightsStream:F8,encodeWeights:ID,fromMemory:qme,fromMemorySync:hH,getLoadHandlers:kle,getModelArtifactsForJSON:XB,getModelArtifactsForJSONSync:$8,getModelArtifactsInfoForJSON:uS,getSaveHandlers:z8,getWeightSpecs:DD,http:Dk,isHTTPScheme:UD,listModels:qle,loadWeights:zme,moveModel:Yle,registerLoadRouter:Ble,registerSaveRouter:Ole,removeModel:jle,weightsLoaderFactory:lH,withSaveHandler:jme,withSaveHandlerSync:Kme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $m;function Yme(s,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,i=!1,r=!1,a=!1,o=!1;if(s.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&s instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)r=!0;else if(s.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&s instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${s.constructor.name}`);if(wD(AD,me.backendName)!=null){const x={pixels:s},S={numChannels:e};return me.runKernel(AD,x,S)}const[u,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height];let f;if(a)f=s.getContext("2d").getImageData(0,0,u,c).data;else if(n||t)f=s.data;else if(r||i||o){if($m==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")$m=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else $m=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});$m.canvas.width=u,$m.canvas.height=c,$m.drawImage(s,0,0,u,c),f=$m.getImageData(0,0,u,c).data}let d;if(e===4)d=new Int32Array(f);else{const x=u*c;d=new Int32Array(x*e);for(let S=0;S<x;S++)for(let b=0;b<e;++b)d[S*e+b]=f[S*4+b]}return UG(d,[c,u,e],"int32")}const dH=fe({fromPixels_:Yme});function Ok(s,e){const t=s.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(Xe(s.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${s.shape}.`);const i=e.shape,r=i[i.length-1];let a=1;for(let f=0;f<i.length-1;++f)a*=i[f];const o=s.shape,l=i.slice();l.pop();let u=1;for(let f=r;f<t;++f)u*=o[f],l.push(o[f]);const c=[...jt(s.shape).map(f=>f/u),1].slice(0,r);return[l,a,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D=-2,Jme=-1;function Bk(s,e,t){const n=s.shape.length;K(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),K(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let i=0;i<n;++i)K(e[i]+t[i]<=s.shape[i],()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${s.shape[i]})`)}function Zme(s){const e=[];let t=0;for(;s>0;)s&1&&e.push(t),s/=2,t++;return e}function kk(s,e,t){const n=[];for(let i=0;i<s.length;i++)n[i]=Math.ceil((e[i]-s[i])/t[i]);return n}function pH(s,e,t,n){const i=[...s];for(let r=i.length;r<n.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function mH(s,e,t){return t<=s?t:t-(e-1)}function gH(s,e){const t=[];for(let n=0;n<s;n++)t.push(e+n);return t}function Qme(s,e,t,n,i,r,a,o,l){const u=s.length;let c=new Array(u),f=new Array(u),d=new Array(u);if(e.length&&t>0){const g=e[0],x=t+1;c=yH(a,g,x,n,s),f=xH(o,g,x,i,s),d=pH(r,g,x,s)}else for(let g=0;g<u;g++)c[g]=bH(a,n,r,s,g,l),f[g]=_H(o,i,r,s,g,l),d[g]=vH(r,g,l);return{begin:c,end:f,strides:d}}function yH(s,e,t,n,i){const r=[...i],a=gH(t,e);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=0;else{const l=mH(e,t,o);let u=n[l];s&1<<l&&(u=0),r[o]=u}return r}function xH(s,e,t,n,i){const r=[...i],a=gH(t,e);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const l=mH(e,t,o);let u=n[l];s&1<<l&&(u=Number.MAX_SAFE_INTEGER),r[o]=u}for(let o=0;o<r.length;o++){const l=i[o];r[o]<0&&(r[o]+=l),r[o]=Rg(0,r[o],i[o])}return r}function vH(s,e,t){let n=s[e];return(t&1<<e||n==null)&&(n=1),n}function bH(s,e,t,n,i,r){let a=e[i];const o=t[i]||1;(s&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=n[i];return a<0&&(a+=l),a=Rg(0,a,l-1),a}function _H(s,e,t,n,i,r){let a=e[i];const o=t[i]||1;(s&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=n[i];return a<0&&(a+=l),o>0?a=Rg(0,a,l):a=Rg(-1,a,l-1),a}function Lk(s,e,t){let n=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){n=i;break}for(let i=n+1;i<t.length;i++)if(e[i]>0||t[i]!==s[i])return!1;return!0}function Fk(s,e){let t=s.length>0?s[s.length-1]:1;for(let n=0;n<s.length-1;n++)t+=s[n]*e[n];return t}function RM(s,e,t){let n;const i=s.shape.length;typeof e=="number"?n=[e,...new Array(i-1).fill(0)]:e.length<i?n=e.concat(new Array(i-e.length).fill(0)):n=e.slice(),n.forEach(a=>{K(a!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((a,o)=>a>=0?a:(K(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),s.shape[o]-n[o])),[n,r]}function Pk(s,e,t,n,i,r,a,o,l){let u;if(n==null?(u=new Array(e.length),u.fill(1)):u=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const f={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let E=0;E<f.dims;E++)c&&(1<<E&o)!==0&&f.numAddAxisAfterEllipsis++,1<<E&a&&(c=!0);c||(f.ellipsisMask|=1<<f.dims,f.dims++);const d={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};ege(f,d);let g=!0,x=!0,S=!0;const b=[],_=[];for(let E=0;E<s.length;++E){if(d.strides[E]===0)throw Error(`strides[${E}] must be non-zero`);const C=!!(d.shrinkAxisMask&1<<E),R=s[E];if(R===-1){b.push(C?1:-1);continue}const I=[d.beginMask&1<<E,d.endMask&1<<E],L=[d.strides[E]>0?0:-1,d.strides[E]>0?R:R-1];if(C&&d.strides[E]<=0)throw Error("only stride 1 allowed on non-range indexing.");S=S&&d.strides[E]===1;const P=!!(d.beginMask&1<<E&&d.endMask&1<<E);if(d.beginValid&&d.endValid){if(C){const X=d.begin[E]<0?R+d.begin[E]:d.begin[E];if(d.begin[E]=X,d.end[E]=d.begin[E]+1,X<0||X>=R)throw Error(`slice index ${d.begin[E]} of dimension ${E} out of bounds.`)}else d.begin[E]=VU(d.begin[E],0,d.strides[E],R,I,L),d.end[E]=VU(d.end[E],1,d.strides[E],R,I,L);const F=d.strides[E]===1&&d.begin[E]===0&&d.end[E]===R;g=g&&F,x=x&&(E===0&&d.strides[E]===1||F)}else g=g&&d.strides[E]===1&&P,x=x&&(E===0&&d.strides[E]===1||P);let D,O=!1;if(d.beginValid&&d.endValid?(D=d.end[E]-d.begin[E],O=!0):C?(D=1,O=!0):P&&R>=0&&(d.strides[E]<0?D=-R:D=R,O=!0),O){let F;D===0||D<0!=d.strides[E]<0?F=0:F=Math.trunc(D/d.strides[E])+(D%d.strides[E]!==0?1:0),b.push(F)}else b.push(-1)}for(let E=0;E<d.finalShapeGatherIndices.length;++E){const C=d.finalShapeGatherIndices[E];C>=0?_.push(b[C]):C===$D&&_.push(1)}return{finalShapeSparse:_.filter((E,C)=>d.finalShapeGatherIndices[C]!==$D),finalShape:_,isIdentity:g,sliceDim0:x,isSimpleSlice:S,begin:d.begin,end:d.end,strides:d.strides}}function ege(s,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=s.begin!=null,e.endValid=s.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<s.dims;n++)if(1<<n&s.ellipsisMask){const i=Math.min(e.dims-(s.dims-n)+1+s.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&s.newAxisMask)e.finalShapeGatherIndices.push($D),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);s.begin!=null&&(e.begin[t]=s.begin[n]),s.end!=null&&(e.end[t]=s.end[n]),e.strides[t]=s.strides[n],s.beginMask&1<<n&&(e.beginMask|=1<<t),s.endMask&1<<n&&(e.endMask|=1<<t),s.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(Jme),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function VU(s,e,t,n,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const a=s<0?n+s:s;return a<r[0]?r[0]:a>r[1]?r[1]:a}}const tge=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Bk,computeFlatOffset:Fk,computeOutShape:kk,getNormalizedAxes:Qme,isSliceContinous:Lk,maskToAxes:Zme,parseSliceParams:RM,sliceInfo:Pk,startForAxis:bH,startIndicesWithElidedDims:yH,stopForAxis:_H,stopIndicesWithElidedDims:xH,stridesForAxis:vH,stridesWithElidedDims:pH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nge{static sgd(e){return new Rk(e)}static momentum(e,t,n=!1){return new rH(e,t,n)}static rmsprop(e,t=.9,n=0,i=null,r=!1){return new aH(e,t,n,i,r)}static adam(e=.001,t=.9,n=.999,i=null){return new sH(e,t,n,i)}static adadelta(e=.001,t=.95,n=null){return new tH(e,t,n)}static adamax(e=.002,t=.9,n=.999,i=null,r=0){return new iH(e,t,n,i,r)}static adagrad(e,t=.1){return new nH(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iy=nge;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sge=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:s=>s();function SH(){return new Promise(s=>sge(()=>s()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(s,e){const t=s[0].length;s.forEach((i,r)=>{K(i.length===t,()=>`Error in concat${t}D: rank of tensors[${r}] must be the same as the rank of the rest (${t})`)}),K(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const n=s[0];s.forEach((i,r)=>{for(let a=0;a<t;a++)K(a===e||i[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${n}) along the non-concatenated axis ${r}.`)})}function oh(s,e){const t=s[0].slice();for(let n=1;n<s.length;n++)t[e]+=s[n][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yu;(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(Yu||(Yu={}));function AH(s,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<s+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(s+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${s+t.length}, but shape.rank = ${n.length}`);for(let i=1;i<t.length;++i){const r=t[i],a=n[n.length-t.length+i],o=n[a];if(r>=0)if(o>=0){if(o!==r)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+s}] = ${r} but shape[${i+s}] = ${o}`)}else n[a]=r}return n}function TH(s){const e={FIRST_DIM_SIZE:Yu.FIRST_DIM_SIZE,VALUE_ROWIDS:Yu.VALUE_ROWIDS,ROW_LENGTHS:Yu.ROW_LENGTHS,ROW_SPLITS:Yu.ROW_SPLITS,ROW_LIMITS:Yu.ROW_LIMITS,ROW_STARTS:Yu.ROW_STARTS},t=[];for(const n of s)if(n in e)t.push(e[n]);else break;return t}function wH(s){return s.length===0?0:s[0]===Yu.FIRST_DIM_SIZE?s.length-1:s.length}function CH(s,e){if(s==null||e==null)return;const t=s.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${s} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let i=0;i<Math.min(t,n-1);++i){const r=s[i],a=e[i+1];if(r>=0&&a>=0&&r!==1&&r!==a)throw new Error(`defaultValue.shape=${s}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-s.length}] = ${r} but ragged tensor input.flatValues.shape[${i-s.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=30;function IM(s){return s<=$k?s:bD(s,Math.floor(Math.sqrt(s)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(s,e,t){const n=t*(typeof s=="number"?s:s[0]),i=e*(typeof s=="number"?s:s[1]);return[n,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(s,e,t,n=!0){let i=[];if(n)i=i.concat(e.slice(0)),i.push(s[0]/t),i=i.concat(s.slice(1));else{i=i.concat(s[0]);const r=e.length;for(let a=0;a<r;++a)i=i.concat([s[a+1]/e[a],e[a]]);i=i.concat(s.slice(r+1))}return i}function xS(s,e,t=!0){const n=[];if(t){n.push(e);for(let i=e+1;i<s;++i)i<=2*e?(n.push(i),n.push(i-(e+1))):n.push(i)}else{const i=[],r=[];for(let a=1;a<s;++a)a>=e*2+1||a%2===1?r.push(a):i.push(a);n.push(...i),n.push(0),n.push(...r)}return n}function vS(s,e,t,n=!0){const i=[];n?i.push(s[0]/t):i.push(s[0]*t);for(let r=1;r<s.length;++r)r<=e.length?n?i.push(e[r-1]*s[r]):i.push(s[r]/e[r-1]):i.push(s[r]);return i}function Gk(s,e){const t=[0];for(let n=0;n<e;++n)t.push(s[n][0]);return t}function Hk(s,e,t){const n=s.slice(0,1);for(let i=0;i<t;++i)n.push(s[i+1]-e[i][0]-e[i][1]);return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DM=1.7580993408473768,OM=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vk=.3275911,Wk=.254829592,Xk=-.284496736,qk=1.421413741,jk=-1.453152027,Kk=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tf(s,e){if(s.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${s.length}, imag: ${e.length}.`);const t=new Float32Array(s.length*2);for(let n=0;n<t.length;n+=2)t[n]=s[n/2],t[n+1]=e[n/2];return t}function EH(s){const e=new Float32Array(s.length/2),t=new Float32Array(s.length/2);for(let n=0;n<s.length;n+=2)e[n/2]=s[n],t[n/2]=s[n+1];return{real:e,imag:t}}function MH(s){const e=Math.ceil(s.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=0;i<s.length;i+=4)t[Math.floor(i/4)]=s[i],n[Math.floor(i/4)]=s[i+1];return{real:t,imag:n}}function NH(s){const e=Math.floor(s.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=2;i<s.length;i+=4)t[Math.floor(i/4)]=s[i],n[Math.floor(i/4)]=s[i+1];return{real:t,imag:n}}function Yk(s,e){const t=s[e*2],n=s[e*2+1];return{real:t,imag:n}}function RH(s,e,t,n){s[n*2]=e,s[n*2+1]=t}function IH(s,e){const t=new Float32Array(s/2),n=new Float32Array(s/2);for(let i=0;i<Math.ceil(s/2);i++){const r=(e?2:-2)*Math.PI*(i/s);t[i]=Math.cos(r),n[i]=Math.sin(r)}return{real:t,imag:n}}function DH(s,e,t){const n=(t?2:-2)*Math.PI*(s/e),i=Math.cos(n),r=Math.sin(n);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI="->",ige=/->/g,WU=",",XU="...";function Jk(s,e){s=s.replace(/\s/g,"");const t=(s.length-s.replace(ige,"").length)/dI.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${dI}").`);const[n,i]=s.split(dI);K(n.indexOf(XU)===-1,()=>`The ellipsis notation ("${XU}") is not supported yet.`);const r=n.split(WU),a=r.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<i.length;++d){const g=i[d];if(!r.some(x=>x.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let d=0;d<n.length;++d){const g=n[d];o.indexOf(g)===-1&&g!==WU&&o.push(g)}const l=new Array(r.length);for(let d=0;d<a;++d){if(new Set(r[d].split("")).size!==r[d].length)throw new Error(`Found duplicate axes in input component ${r[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let g=0;g<r[d].length;++g)l[d].push(o.indexOf(r[d][g]))}const u=o.length,c=i.length,f=[];for(let d=c;d<u;++d)f.push(d);return{allDims:o,summedDims:f,idDims:l}}function Zk(s,e){let t=new Array(s);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const n=[];for(let i=0;i<s;++i)t[i]===-1&&n.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:n}}function Qk(s,e,t){const n=new Array(s);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let a=0;a<e[i].length;++a)n[e[i][a]]===void 0?n[e[i][a]]=r[a]:K(n[e[i][a]]===r[a],()=>`Expected dimension ${n[e[i][a]]} at axis ${a} of input shaped ${JSON.stringify(r)}, but got dimension ${r[a]}`)}}function eL(s,e){const t=s,n=[];let i=0;s.length===0&&t.push(-1),i=s.length+1;for(let a=0;a<i;++a)n.push([]);const r=[];for(let a=0;a<t.length;++a){const o=t[a],l=rge(e,o);for(const u of l)r.indexOf(u)===-1&&(n[a].push(u),r.push(u))}return{path:t,steps:n}}function tL(s){return s.every((e,t)=>e===t)}function rge(s,e){const t=[];for(let n=0;n<s.length;++n)(s[n].length===0||s[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function nL(s,e,t=0){let n=[];if(typeof e=="number")K(s.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(s.shape[t]/e);else{const i=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);K(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const a=e.reduce((o,l)=>l>0?o+l:o);e[r]=s.shape[t]-a}K(s.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${s}`}function BH(s,e){return`indices(${s}, 0) is invalid: ${e} < 0`}function kH(s,e,t){return`indices(${s}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(s,e){return`only one output dimension may be -1, not both ${s} and ${e}`}function FH(s,e){return`size ${s} must be non-negative, not ${e}`}function PH(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function UH(s,e){const t=Xe(s),n=Xe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${s} outputShape= ${e}`}function $H(s,e){const t=Xe(s),n=Xe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${s} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(){return"segment ids must be >= 0"}function zH(){return"segment ids are not increasing"}function GH(s,e){return`Segment id ${s} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function HH(s,e,t){return`Bad: indices[${s}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(s,e){let t=!1,n;for(s<=$k?(n=s,t=!0):n=bD(s,Math.floor(Math.sqrt(s)));!t;)n>e||n===s?t=!0:n=bD(s,n+1);return n}function WH(s,e,t){const n=[],i=s.length;for(let r=0;r<i;r++)r!==e?n.push(s[r]):n.push(t);return n}function sL(s,e,t,n){const i=e.shape.length,r=s.shape.length;if(n!==0&&(n<-i||n>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${n}`);if(n<0&&(n+=i),n>r)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${r}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let f=0;f<n;++f)if(s.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${s.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const a=s.shape[t],o=[];let l=1,u=1,c=1;for(let f=0;f<n;++f)o.push(s.shape[f]),l*=s.shape[f];for(let f=n;f<t;f++)o.push(s.shape[f]),u*=s.shape[f];for(let f=n;f<i;f++)o.push(e.shape[f]);for(let f=t+1;f<r;f++)o.push(s.shape[f]),c*=s.shape[f];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}const age=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:sL,computeOutShape:WH,segOpComputeOptimalWindowSize:VH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(s){try{return s.map(e=>ap(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function XH(s){return s.map(e=>Yd(e))}const oge=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Wk,ERF_A2:Xk,ERF_A3:qk,ERF_A4:jk,ERF_A5:Kk,ERF_P:Vk,PARALLELIZE_THRESHOLD:$k,get RowPartitionType(){return Yu},SELU_SCALE:OM,SELU_SCALEALPHA:DM,applyActivation:MM,assertAndGetBroadcastShape:gn,assertAxesAreInnerMostDims:$r,assertParamsConsistent:Uk,assignToTypedArray:RH,axesAreInnerMostDims:nk,calculateShapes:t0,checkEinsumDimSizes:Qk,checkPadOnDimRoundingMode:Da,combineLocations:bG,combineRaggedTensorToTensorShapes:AH,complexWithEvenIndex:MH,complexWithOddIndex:NH,computeConv2DInfo:Ar,computeConv3DInfo:Tp,computeDefaultPad:KB,computeDilation2DInfo:cS,computeOptimalWindowSize:IM,computeOutAndReduceShapes:Tr,computeOutShape:oh,computePool2DInfo:pu,computePool3DInfo:Mf,convertConv2DDataFormat:Nf,decodeEinsumEquation:Jk,eitherStridesOrDilationsAreOne:Ur,expandShapeToKeepDim:Ni,exponent:DH,exponents:IH,fromStringArrayToUint8:XH,fromUint8ToStringArray:wf,getAxesPermutation:ri,getBroadcastDims:Ax,getComplexWithIndex:Yk,getEinsumComputePath:eL,getEinsumPermutation:Zk,getFusedBiasGradient:EM,getFusedDyActivation:CM,getImageCenter:zk,getInnerMostAxes:Ri,getPermuted:xS,getRaggedRank:wH,getReductionAxes:rr,getReshaped:yS,getReshapedPermuted:vS,getRowPartitionTypesHelper:TH,getSliceBeginCoords:Gk,getSliceSize:Hk,getSparseFillEmptyRowsIndicesDenseShapeMismatch:OH,getSparseFillEmptyRowsNegativeIndexErrorMessage:BH,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:kH,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:PH,getSparseReshapeInputOutputMismatchErrorMessage:$H,getSparseReshapeInputOutputMultipleErrorMessage:UH,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:LH,getSparseReshapeNegativeOutputDimErrorMessage:FH,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:HH,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:zD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:zH,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:GH,getUndoAxesPermutation:wp,isIdentityPermutation:tL,log:Koe,mergeRealAndImagArrays:Tf,prepareAndValidate:Ok,prepareSplitSize:nL,segment_util:age,shouldFuse:NM,slice_util:tge,splitRealAndImagArrays:EH,stridesOrDilationsArePositive:Lg,tupleValuesAreOne:up,upcastType:ko,validateDefaultValueShape:CH,validateInput:bk,validateUpdateShape:$G,warn:cl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dme();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH={kernelName:sE,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,qx(Ct(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lge={kernelName:p_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Os(Ct(t,"float32")),i=Pr(wt(Jt(1),n));return Hs(Ut(s,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uge={kernelName:m_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Pr(wt(Os(Ct(t,"float32")),1));return Ut(s,n)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cge={kernelName:Vx,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{let o=s;const l=rr(t.shape,i);return l.length>0&&(o=$t(o,l)),xe(o,t.shape)},b:()=>{let o=s;const l=rr(n.shape,i);return l.length>0&&(o=$t(o,l)),xe(o,n.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hge={kernelName:iE,saveAllInputs:!0,gradFunc:(s,e)=>{const t={};return e.forEach((n,i)=>{t[i]=()=>s.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fge={kernelName:rE,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Kn(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dge={kernelName:aE,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Kn(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pge={kernelName:g_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,Pr(wt(Jt(1),Os(Ct(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mge={kernelName:y_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Pr(it(Jt(1),Os(Ct(t,"float32"))));return Ut(s,n)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gge={kernelName:b_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{const o=it(Os(t),Os(n));let l=pe(s,Ut(n,o));const u=rr(t.shape,i);return u.length>0&&(l=$t(l,u)),xe(l,t.shape)},b:()=>{const o=it(Os(t),Os(n));let l=Hs(pe(s,Ut(t,o)));const u=rr(n.shape,i);return u.length>0&&(l=$t(l,u)),xe(l,n.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yge={kernelName:x_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,it(Os(Ct(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xge={kernelName:v_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,wt(Jt(1),Os(Ct(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vge(s,e,t,n,i,r){const a=Q(s,"dy","avgPool3dGrad"),o=Q(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;o.rank===4&&(c=!0,l=xe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=xe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),K(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),K(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Da("avgPool3dGrad",i,r);const f={dy:l,input:u},d={filterSize:t,strides:n,pad:i,dimRoundingMode:r},g=me.runKernel(HO,f,d);return c?xe(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const bge=fe({avgPool3dGrad_:vge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ge={kernelName:lE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{filterSize:i,strides:r,pad:a,dimRoundingMode:o}=t;return{x:()=>bge(s,n,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sge(s,e,t,n,i){const r=Q(s,"dy","avgPoolGrad"),a=Q(e,"input","avgPoolGrad");K(a.rank===r.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${r.rank})`);let o=a,l=r,u=!1;a.rank===3&&(u=!0,o=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=xe(r,[1,r.shape[0],r.shape[1],r.shape[2]])),K(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),K(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},f={filterSize:t,strides:n,pad:i},d=me.runKernel(GO,c,f);return u?xe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Age=fe({avgPoolGrad_:Sge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tge={kernelName:oE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{filterSize:i,strides:r,pad:a}=t;return{x:()=>Age(s,n,i,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wge={kernelName:uE,inputsToSave:["a","b"],gradFunc:(s,e,t)=>{const[n,i]=e,{transposeA:r,transposeB:a}=t;return!r&&!a?{a:()=>Un(s,i,!1,!0),b:()=>Un(n,s,!0,!1)}:!r&&a?{a:()=>Un(s,i,!1,!1),b:()=>Un(s,n,!0,!1)}:r&&!a?{a:()=>Un(i,s,!1,!0),b:()=>Un(n,s,!1,!1)}:{a:()=>Un(i,s,!0,!0),b:()=>Un(s,n,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cge={kernelName:cE,gradFunc:(s,e,t)=>{const{blockShape:n,crops:i}=t;return{x:()=>xM(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ege={kernelName:Xoe,gradFunc:(s,e,t)=>{const n=t,i=n.inputShape,r=n.shape,a=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])a[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>$t(s,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mge={kernelName:__,gradFunc:s=>({x:()=>s.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nge={kernelName:S_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rge={kernelName:A_,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{clipValueMin:i,clipValueMax:r}=t;return{x:()=>na(dh(Cp(n,i),Zg(n,r)),s,Kn(s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ige={kernelName:fE,inputsToSave:["x"],gradFunc:qH.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dge={kernelName:dE,saveAllInputs:!0,gradFunc:(s,e,t)=>{const n=e.map(l=>l.shape),{axis:i}=t,r=kn(i,e[0].shape)[0],a=n.map(l=>l[r]);return Oo(s,a,r).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oge={kernelName:pE,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const[n,i]=e,{dilations:r,strides:a,pad:o,dataFormat:l}=t;return K(up(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>JB(n.shape,s,i,a,o,l),filter:()=>wk(n,s,i.shape,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bge={kernelName:mE,inputsToSave:["dy","filter"],gradFunc:(s,e,t)=>{const[n,i]=e,{strides:r,pad:a,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>cp(s,i,r,a,o,1,l),filter:()=>wk(s,n,i.shape,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kge(s,e,t,n,i){let r=s;s.rank===4&&(r=xe(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));let a=e;a.rank===4&&(a=xe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),K(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),K(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),K(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),K(r.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${t[3]}.`),K(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:r,dy:a},l={strides:n,pad:i,filterShape:t};return me.runKernel(jO,o,l)}const Lge=fe({conv3DBackpropFilter_:kge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fge={kernelName:gE,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const{dilations:n,strides:i,pad:r}=t;K(up(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);const[a,o]=e;return{x:()=>pG(a.shape,s,o,i,r),filter:()=>Lge(a,s,o.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pge={kernelName:T_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(Hs(mk(Ct(t,"float32"))),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uge={kernelName:w_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(gk(Ct(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ge={kernelName:yE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:i,exclusive:r,reverse:a}=t;return{x:()=>{const o=ri([i],n.rank);let l=ek(s,i,r,!a);return o!=null&&(l=jn(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zge={kernelName:xE,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const{dilations:n,strides:i,pad:r,dimRoundingMode:a}=t,o=n??[1,1];K(up(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=e;return K(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),K(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),K(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),K(Ur(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),Da("depthwiseConv2d",r,a),{x:()=>KG(l.shape,s,u,i,r,o,a),filter:()=>jG(l,s,u.shape,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gge={kernelName:vE,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const[n,i]=e,r={x:n,filter:i,dy:s},a={x:n,filter:i,dy:s};return{x:()=>me.runKernel(_D,r,t),filter:()=>me.runKernel(SD,a,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hge={kernelName:E_,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e,n={dy:s,y:t};return{x:()=>me.runKernel(iB,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vge={kernelName:M_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e,n=pe(Fo(Hs(Os(t))),2/Math.sqrt(Math.PI));return{x:()=>pe(s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wge={kernelName:N_,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xge={kernelName:_E,inputsToSave:["input"],gradFunc:(s,e)=>{const[t]=e;return{input:()=>xe(s,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qge={kernelName:R_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,Fo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jge={kernelName:I_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kge={kernelName:D_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{const o=Ut(s,Ct(n,"float32")),l=rr(t.shape,i);return l.length>0?xe($t(o,l),t.shape):o},b:()=>{let o=pe(s,Ct(t,"float32"));const l=rr(n.shape,i);l.length>0&&(o=xe($t(o,l),n.shape));const u=Os(n);return Hs(Ut(o,Ct(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yge={kernelName:SE,inputsToSave:["x","mean","variance","scale"],gradFunc:(s,e,t)=>{const{varianceEpsilon:n}=t,[i,r,a,o]=e,l=o??Jt(1),u=rr(r.shape,i.shape),c=[];if(r.rank===1){for(let C=0;C<i.shape.length-1;++C)c.push(i.shape[C]);c.push(1)}const f=wt(i,r),d=pe(s,l),g=fk(it(a,Jt(n))),x=pe(pe(pe(g,g),g),Jt(-.5));return{x:()=>r.rank===1?xe(pe(pe(s,su(xe(g,[1,1,1,r.shape[0]]),c)),l),i.shape):xe(pe(pe(s,g),l),i.shape),mean:()=>{let C=pe(pe(g,Jt(-1)),d);return r.rank===1&&(C=$t(C,u)),xe(C,r.shape)},variance:()=>{let C=pe(pe(x,f),d);return r.rank===1&&(C=$t(C,u)),xe(C,r.shape)},scale:()=>{const C=pe(f,g);let R=pe(s,C);return r.rank===1&&(R=$t(R,u)),xe(R,r.shape)},offset:()=>{let C=s;return r.rank===1&&(C=$t(C,u)),xe(C,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jge={kernelName:AE,inputsToSave:["x","indices"],gradFunc:(s,e,t)=>{const[n,i]=e,{axis:r,batchDims:a}=t,o=kn(r,n.shape)[0],l=(u,c,f)=>()=>{const d=u.shape,g=c.size,x=d.slice(0,o),S=x.length,b=d.slice(r,d.length).slice(1),_=b.length,T=qU(0,S),E=qU(S+1,S+1+_),C=jU([x,[g],b]),R=xe(f,C),I=xe(c,[g]),L=jU([[S],T,E]),P=jn(R,L);let D=Sk(P,I,u.shape[o]);const O=wp(L);return D=jn(D,O),D};if(a===1){const u=n.shape[0],c=n.split(u,0);return{x:()=>Po(c.map((g,x)=>l(g,i.slice(x,1),s.slice(x,1))())).reshape(n.shape),indices:()=>i}}else return{x:l(n,i,s),indices:()=>i}}};function qU(s,e){const t=[];for(let n=s;n<e;++n)t.push(n);return t}function jU(s){const e=[];for(let t=0;t<s.length;++t)for(let n=0;n<s[t].length;++n)e.push(s[t][n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zge={kernelName:O_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>Kn(t),b:()=>Kn(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qge={kernelName:B_,gradFunc:s=>({x:()=>Ct(s,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0e={kernelName:k_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t0e={kernelName:L_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e={kernelName:F_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0e={kernelName:wE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{alpha:i}=t,r=Go(n,0);return{x:()=>na(r,s,pe(s,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e={kernelName:U_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,it(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0e={kernelName:P_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,Ct(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e={kernelName:joe,inputsToSave:[],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n]=e,{axis:i}=t;return{logits:()=>{const a=Fo(n);return wt(s,pe($t(s,i,!0),a))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(s,e,t,n=5,i=1,r=1,a=.5){const o={x:s,y:e,dy:t},l={depthRadius:n,bias:i,alpha:r,beta:a};return me.runKernel(fB,o,l)}const l0e=fe({localResponseNormalizationBackprop_:o0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e={kernelName:IE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,i]=e,{depthRadius:r,bias:a,alpha:o,beta:l}=t;return{x:()=>l0e(n,i,s,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jH(s,e,t,n){return e.rank<t.rank&&(e=xe(e,Ni(e.shape,n))),s.rank<t.rank&&(s=xe(s,Ni(s.shape,n))),{x:()=>pe(s,Ct(ic(t,e),s.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KU={kernelName:DE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const n=t,{reductionIndices:i}=n,r=e[0],a=e[1],o=kn(i,r.shape),l=jH(s,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e={kernelName:$_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>pe(s,Ct(Cp(t,n),"float32")),b:()=>pe(s,Ct(kb(t,n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0e(s,e,t,n,i,r,a){const o=Q(s,"dy","maxPool3dGrad"),l=Q(e,"input","maxPool3dGrad"),u=Q(t,"output","maxPool3dGrad");let c=o,f=l,d=u,g=!1;l.rank===4&&(g=!0,c=xe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=xe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=xe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),K(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),K(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),K(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Da("maxPool3dGrad",r,a);const x={dy:c,input:f,output:d},S={filterSize:n,strides:i,pad:r,dimRoundingMode:a},b=me.runKernel(pB,x,S);return g?xe(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const f0e=fe({maxPool3dGrad_:h0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d0e={kernelName:BE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,i]=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=t;return{x:()=>f0e(s,n,i,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(s,e,t,n,i,r,a){const o=Q(s,"dy","maxPoolGrad"),l=Q(e,"input","maxPoolGrad"),u=Q(t,"output","maxPoolGrad");K(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),K(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),K(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Da("maxPoolGrad",r,a);const c={dy:o,input:l,output:u},f={filterSize:n,strides:i,pad:r,dimRoundingMode:a};return me.runKernel(dB,c,f)}const m0e=fe({maxPoolGrad_:p0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e={kernelName:OE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,i]=e,{filterSize:r,strides:a,pad:o}=t;return{x:()=>m0e(s,n,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e={kernelName:kE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:i}=t,r=kn(i,n.shape),o=Tr(n.shape,r)[1],l=Xe(o);return{x:()=>{const c=n.shape.slice();r.forEach(g=>{c[g]=1});const f=xe(s,c);return Ut(pe(f,Mo(n.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e={kernelName:LE,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const n=t,{axis:i}=n,[r,a]=e,o=kn(i,r.shape),l=jH(s,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0e={kernelName:z_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>pe(s,Ct(Zg(t,n),"float32")),b:()=>pe(s,Ct(Go(t,n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e={kernelName:FE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const n=e[0],{paddings:i}=t,r=i.map(a=>a[0]);return{x:()=>bn(s,r,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0e={kernelName:G_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{const o=rr(t.shape,i);return o.length>0?xe($t(s,o),t.shape):s},b:()=>{const o=pe(s,Hs(mS(Ut(t,n)))),l=rr(n.shape,i);return l.length>0?xe($t(o,l),n.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S0e={kernelName:H_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{const o=pe(s,Ct(n,"float32")),l=rr(t.shape,i);return l.length>0?xe($t(o,l),t.shape):o},b:()=>{const o=pe(s,Ct(t,"float32")),l=rr(n.shape,i);return l.length>0?xe($t(o,l),n.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A0e={kernelName:PE,gradFunc:s=>({x:()=>Hs(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T0e={kernelName:zE,inputsToSave:["indices"],gradFunc:(s,e)=>{const t=e[0];return{indices:()=>Qi(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e={kernelName:$E,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e={kernelName:GE,saveAllInputs:!0,gradFunc:(s,e,t)=>{const{axis:n}=t;return hu(s,n).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU={kernelName:HE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const n=e[0],{paddings:i}=t,r=i.map(a=>a[0]);return{x:()=>bn(s,r,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E0e={kernelName:V_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(s,e)=>{const[t,n,i]=e,r=t,a=n,o=gn(r.shape,a.shape);return{a:()=>{const c=Ct(a,"float32");let f=pe(s,pe(c,Sf(r,wt(c,Jt(1)))));const d=rr(r.shape,o);return d.length>0&&(f=$t(f,d)),xe(f,r.shape)},b:()=>{const c=Go(r,0),f=na(c,Sl(r),Kn(r));let d=pe(s,pe(i,f));const g=rr(a.shape,o);return g.length>0&&(d=$t(d,g)),xe(d,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M0e={kernelName:VE,inputsToSave:["x","alpha"],gradFunc:(s,e)=>{const[t,n]=e,i=Go(t,0);return{x:()=>na(i,s,pe(s,n)),alpha:()=>{let r=na(i,Kn(s),pe(s,t));const a=rr(n.shape,s.shape);return a.length>0&&(r=$t(r,a)),xe(r,n.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(s,e,t){const n=s.shape.slice();n[t]=1;const i=xe(e,n),r=Y2(s,t,!0,!1),a=Y2(s,t,!0,!0),o=pe(r,a);return pe(i,o)}function R0e(s,e,t){const n=s.shape.length,i=n-t.length,r=ri(t,n);let a=s;r!=null&&(a=jn(s,r));const o=a.shape.slice(),u=o.splice(n-t.length,t.length).reduce((d,g)=>d*g,1);o.push(u);const c=a.reshape(o);let f=N0e(c,e,i);if(f=f.reshape(a.shape),r!=null){const d=wp(r);f=jn(f,d)}return f}const I0e={kernelName:WE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:i}=t;let r=[];return i==null?r=n.shape.map((a,o)=>o):typeof i=="number"?r=[i]:r=i,{x:()=>R0e(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D0e={kernelName:C_,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{const o=Ut(s,Ct(n,"float32")),l=rr(t.shape,i);return l.length>0?xe($t(o,l),t.shape):o},b:()=>{let o=pe(s,Ct(t,"float32"));const l=rr(n.shape,i);l.length>0&&(o=xe($t(o,l),n.shape));const u=Os(n);return Hs(Ut(o,Ct(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O0e={kernelName:W_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,Hs(Os(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B0e={kernelName:q_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e,n=pe(Zg(t,6),qx(t));return{x:()=>pe(s,Ct(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0e={kernelName:X_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,Ct(qx(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0e={kernelName:XE,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>xe(s,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F0e={kernelName:jE,inputsToSave:["images"],gradFunc:(s,e,t)=>{const[n]=e,i={dy:s,images:n};return{images:()=>me.runKernel(CB,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P0e={kernelName:qE,inputsToSave:["images"],gradFunc:(s,e,t)=>{const[n]=e,i={dy:s,images:n};return{images:()=>me.runKernel(wB,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U0e={kernelName:KE,gradFunc:(s,e,t)=>{const{dims:n}=t,i=kn(n,s.shape);return{x:()=>cu(s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0e={kernelName:j_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e={kernelName:K_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Hs(Ut(s,pe(Sf(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G0e={kernelName:YE,inputsToSave:["condition"],gradFunc:(s,e)=>{const[t]=e;return{condition:()=>Ct(Kn(t),"float32"),t:()=>pe(s,Ct(t,s.dtype)),e:()=>pe(s,Ct(mM(t),s.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0e={kernelName:Y_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Go(t,Jt(0)),i=Jt(DM),r=Jt(OM),a=pe(s,r),o=pe(pe(s,i),Fo(Ct(t,"float32")));return na(n,a,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e={kernelName:eS,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,pe(t,wt(Jt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W0e={kernelName:Q_,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X0e={kernelName:J_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(cM(Ct(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0e={kernelName:Z_,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(QB(Ct(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j0e={kernelName:JE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{begin:i,size:r}=t,a=n.shape,[o,l]=RM(n,i,r),u=[];for(let c=0;c<s.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>Ep(s,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0e={kernelName:tM,outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n]=e,{dim:i}=t,r=!0,a=pe(s,n);return{logits:()=>wt(a,pe($t(a,[i],r),n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y0e={kernelName:tS,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,ec(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JU={kernelName:QE,gradFunc:(s,e,t)=>{const{blockShape:n,paddings:i}=t;return{x:()=>lM(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU={kernelName:eM,gradFunc:(s,e,t)=>{const{axis:n}=t;return{x:()=>js(s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J0e={kernelName:nS,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,pe(Pr(Ct(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0e={kernelName:kB,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(s,pe(Ct(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q0e={kernelName:sS,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=Jt(2);return{a:()=>pe(s,pe(i,wt(t,n))),b:()=>pe(s,pe(i,wt(n,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eye={kernelName:lS,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tye={kernelName:iS,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,i=gn(t.shape,n.shape);return{a:()=>{let o=s;const l=rr(t.shape,i);return l.length>0&&(o=$t(o,l)),xe(o,t.shape)},b:()=>{let o=s;const l=rr(n.shape,i);return l.length>0&&(o=$t(o,l)),xe(Hs(o),n.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nye={kernelName:ZE,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,i=n.shape.slice(),{axis:r}=t;kn(r,n.shape).forEach(u=>{i[u]=1});const o=xe(s,i),l=pe(o,Mo(n.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sye={kernelName:rS,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ut(s,Os(cM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iye={kernelName:aS,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>pe(wt(Jt(1),Os(t)),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rye={kernelName:oS,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{reps:i}=t;return{x:()=>{let a=Kn(n);if(n.rank===1)for(let o=0;o<i[0];++o)a=it(a,bn(s,[o*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)a=it(a,bn(s,[o*n.shape[0],l*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let u=0;u<i[2];++u)a=it(a,bn(s,[o*n.shape[0],l*n.shape[1],u*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let u=0;u<i[2];++u)for(let c=0;c<i[3];++c)a=it(a,bn(s,[o*n.shape[0],l*n.shape[1],u*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aye={kernelName:Ky,gradFunc:(s,e,t)=>{const n=t,{perm:i}=n,r=wp(i);return{x:()=>jn(s,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oye={kernelName:sM,gradFunc:(s,e,t)=>{const n=t,{axis:i}=n;return{value:()=>Po(s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lye={kernelName:iM,inputsToSave:["segmentIds"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>uye(s,t)}}};function uye(s,e){const t=Rf(e,Kn(e)),n=gS(s,t);let i=Cp(e,Jt(0,"int32"));const r=n.rank-i.rank;for(let o=0;o<r;++o)i=Sa(i,o+1);i=dh(i,Mo(n.shape,"bool"));const a=Kn(n);return na(i,n,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cye={kernelName:rM,gradFunc:s=>({x:()=>Kn(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hye=[qH,lge,uge,cge,hge,fge,dge,pge,mge,gge,yge,xge,_ge,Tge,wge,Cge,Ege,Mge,Nge,Rge,Ige,Dge,Bge,Oge,Fge,Pge,Uge,$ge,zge,Gge,D0e,Hge,Vge,Wge,Xge,qge,Kge,jge,Yge,Jge,Zge,Qge,e0e,t0e,n0e,s0e,i0e,r0e,a0e,u0e,KU,KU,c0e,d0e,g0e,y0e,x0e,v0e,b0e,_0e,S0e,A0e,T0e,w0e,C0e,YU,YU,E0e,M0e,I0e,O0e,B0e,k0e,L0e,F0e,P0e,U0e,$0e,z0e,G0e,H0e,V0e,W0e,X0e,q0e,j0e,K0e,Y0e,JU,JU,ZU,ZU,J0e,Q0e,Z0e,eye,tye,nye,sye,iye,rye,aye,oye,lye,cye];for(const s of hye)Yoe(s);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.abs=function(){return this.throwIfDisposed(),Ji(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.acos=function(){return this.throwIfDisposed(),Y8(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.acosh=function(){return this.throwIfDisposed(),J8(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.add=function(s){return this.throwIfDisposed(),it(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.all=function(s,e){return this.throwIfDisposed(),jB(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.any=function(s,e){return this.throwIfDisposed(),K2(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.argMax=function(s){return this.throwIfDisposed(),Sx(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.argMin=function(s){return this.throwIfDisposed(),Z8(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.asScalar=function(){return this.throwIfDisposed(),K(this.size===1,()=>"The array must have only 1 element."),xe(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.asType=function(s){return this.throwIfDisposed(),Ct(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.as1D=function(){return this.throwIfDisposed(),xe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.as2D=function(s,e){return this.throwIfDisposed(),xe(this,[s,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.as3D=function(s,e,t){return this.throwIfDisposed(),xe(this,[s,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.as4D=function(s,e,t,n){return this.throwIfDisposed(),xe(this,[s,e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.as5D=function(s,e,t,n,i){return this.throwIfDisposed(),xe(this,[s,e,t,n,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.asin=function(){return this.throwIfDisposed(),Q8(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.asinh=function(){return this.throwIfDisposed(),eG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.atan=function(){return this.throwIfDisposed(),tG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.atan2=function(s){return this.throwIfDisposed(),nG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.atanh=function(){return this.throwIfDisposed(),sG(this)};je().prototype.avgPool=function(s,e,t,n){return this.throwIfDisposed(),oM(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.batchToSpaceND=function(s,e){return this.throwIfDisposed(),lM(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.batchNorm=function(s,e,t,n,i){return this.throwIfDisposed(),hS(this,s,e,t,n,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.broadcastTo=function(s){return this.throwIfDisposed(),Zy(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.cast=function(s){return this.throwIfDisposed(),Ct(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.ceil=function(){return this.throwIfDisposed(),uG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.clipByValue=function(s,e){return this.throwIfDisposed(),Lo(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.concat=function(s,e){return this.throwIfDisposed(),s instanceof ls&&(s=[s]),js([this,...s],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.conv1d=function(s,e,t,n,i,r){return this.throwIfDisposed(),YB(this,s,e,t,n,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.conv2dTranspose=function(s,e,t,n,i){return this.throwIfDisposed(),ZB(this,s,e,t,n,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.conv2d=function(s,e,t,n,i,r){return this.throwIfDisposed(),cp(this,s,e,t,n,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.cos=function(){return this.throwIfDisposed(),cM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.cosh=function(){return this.throwIfDisposed(),QB(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.cumprod=function(s,e,t){return this.throwIfDisposed(),Y2(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.cumsum=function(s,e,t){return this.throwIfDisposed(),ek(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.depthToSpace=function(s,e){return this.throwIfDisposed(),gG(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.depthwiseConv2d=function(s,e,t,n,i,r){return this.throwIfDisposed(),fS(this,s,e,t,n,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.dilation2d=function(s,e,t,n,i){return this.throwIfDisposed(),yG(this,s,e,t,n,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.divNoNan=function(s){return this.throwIfDisposed(),xG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.div=function(s){return this.throwIfDisposed(),Ut(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.dot=function(s){return this.throwIfDisposed(),vG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.elu=function(){return this.throwIfDisposed(),dS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.equal=function(s){return this.throwIfDisposed(),ic(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.erf=function(){return this.throwIfDisposed(),tk(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.euclideanNorm=function(s,e){return this.throwIfDisposed(),SG(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.exp=function(){return this.throwIfDisposed(),Fo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.expandDims=function(s){return this.throwIfDisposed(),Sa(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.expm1=function(){return this.throwIfDisposed(),AG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.fft=function(){return this.throwIfDisposed(),TM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.flatten=function(){return this.throwIfDisposed(),xe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.floor=function(){return this.throwIfDisposed(),mS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.floorDiv=function(s){return this.throwIfDisposed(),qB(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.gather=function(s,e,t){return this.throwIfDisposed(),gS(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.greaterEqual=function(s){return this.throwIfDisposed(),Cp(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.greater=function(s){return this.throwIfDisposed(),Go(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.ifft=function(){return this.throwIfDisposed(),Pb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.irfft=function(){return this.throwIfDisposed(),xk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.isFinite=function(){return this.throwIfDisposed(),TG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.isInf=function(){return this.throwIfDisposed(),wG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.isNaN=function(){return this.throwIfDisposed(),CG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.leakyRelu=function(s){return this.throwIfDisposed(),fM(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.lessEqual=function(s){return this.throwIfDisposed(),Zg(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.less=function(s){return this.throwIfDisposed(),kb(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.localResponseNormalization=function(s,e,t,n){return this.throwIfDisposed(),EG(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logSigmoid=function(){return this.throwIfDisposed(),MG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logSoftmax=function(s){return this.throwIfDisposed(),ik(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logSumExp=function(s,e){return this.throwIfDisposed(),pM(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.log=function(){return this.throwIfDisposed(),Sl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.log1p=function(){return this.throwIfDisposed(),dM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logicalAnd=function(s){return this.throwIfDisposed(),dh(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logicalNot=function(){return this.throwIfDisposed(),mM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logicalOr=function(s){return this.throwIfDisposed(),rk(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.logicalXor=function(s){return this.throwIfDisposed(),NG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.matMul=function(s,e,t){return this.throwIfDisposed(),Un(this,s,e,t)};je().prototype.maxPool=function(s,e,t,n){return this.throwIfDisposed(),gM(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.max=function(s,e){return this.throwIfDisposed(),ou(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.maximum=function(s){return this.throwIfDisposed(),Rf(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.mean=function(s,e){return this.throwIfDisposed(),pi(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.min=function(s,e){return this.throwIfDisposed(),Bb(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.minimum=function(s){return this.throwIfDisposed(),Pg(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.mirrorPad=function(s,e){return this.throwIfDisposed(),IG(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.mod=function(s){return this.throwIfDisposed(),DG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.mul=function(s){return this.throwIfDisposed(),pe(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.neg=function(){return this.throwIfDisposed(),Hs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.norm=function(s,e,t){return this.throwIfDisposed(),pS(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.notEqual=function(s){return this.throwIfDisposed(),Tx(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.oneHot=function(s,e=1,t=0){return this.throwIfDisposed(),ok(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.onesLike=function(){return this.throwIfDisposed(),Al(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.pad=function(s,e){return this.throwIfDisposed(),Ep(this,s,e)};je().prototype.pool=function(s,e,t,n,i,r){return this.throwIfDisposed(),OG(this,s,e,t,n,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.pow=function(s){return this.throwIfDisposed(),Sf(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.prelu=function(s){return this.throwIfDisposed(),vM(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.prod=function(s,e){return this.throwIfDisposed(),BG(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.reciprocal=function(){return this.throwIfDisposed(),kG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.relu=function(){return this.throwIfDisposed(),xh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.relu6=function(){return this.throwIfDisposed(),ck(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.reshapeAs=function(s){return this.throwIfDisposed(),xe(this,s.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.reshape=function(s){return this.throwIfDisposed(),xe(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.resizeBilinear=function(s,e,t){return this.throwIfDisposed(),ZG(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.resizeNearestNeighbor=function(s,e,t){return this.throwIfDisposed(),QG(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.reverse=function(s){return this.throwIfDisposed(),cu(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.rfft=function(){return this.throwIfDisposed(),wM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.round=function(){return this.throwIfDisposed(),hk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.rsqrt=function(){return this.throwIfDisposed(),fk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.selu=function(){return this.throwIfDisposed(),dk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.separableConv2d=function(s,e,t,n,i,r){return this.throwIfDisposed(),pk(this,s,e,t,n,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sigmoid=function(){return this.throwIfDisposed(),ec(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sign=function(){return this.throwIfDisposed(),LG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sin=function(){return this.throwIfDisposed(),mk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sinh=function(){return this.throwIfDisposed(),gk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.slice=function(s,e){return this.throwIfDisposed(),bn(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.softmax=function(s){return this.throwIfDisposed(),AM(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.softplus=function(){return this.throwIfDisposed(),Xx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.spaceToBatchND=function(s,e){return this.throwIfDisposed(),xM(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.split=function(s,e){return this.throwIfDisposed(),Oo(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sqrt=function(){return this.throwIfDisposed(),Pr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.square=function(){return this.throwIfDisposed(),Os(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.squaredDifference=function(s){return this.throwIfDisposed(),vk(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.squeeze=function(s){return this.throwIfDisposed(),e0(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.stack=function(s,e){this.throwIfDisposed();const t=s instanceof ls?[this,s]:[this,...s];return Po(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.step=function(s){return this.throwIfDisposed(),qx(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.stridedSlice=function(s,e,t,n,i,r,a,o){return this.throwIfDisposed(),FG(this,s,e,t,n,i,r,a,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sub=function(s){return this.throwIfDisposed(),wt(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.sum=function(s,e){return this.throwIfDisposed(),$t(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.tan=function(){return this.throwIfDisposed(),PG(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.tanh=function(){return this.throwIfDisposed(),Fg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.tile=function(s){return this.throwIfDisposed(),su(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.toBool=function(){return this.throwIfDisposed(),Ct(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.toFloat=function(){return this.throwIfDisposed(),Ct(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.toInt=function(){return this.throwIfDisposed(),Ct(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.topk=function(s,e){return this.throwIfDisposed(),zG(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.transpose=function(s){return this.throwIfDisposed(),jn(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.unique=function(s){return this.throwIfDisposed(),GG(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.unsortedSegmentSum=function(s,e){return this.throwIfDisposed(),Sk(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.unstack=function(s){return this.throwIfDisposed(),hu(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.where=function(s,e){return this.throwIfDisposed(),na(s,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */je().prototype.zerosLike=function(){return this.throwIfDisposed(),Kn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Kc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Kc.prototype)}}class iu extends Error{constructor(e){super(e),Object.setPrototypeOf(this,iu.prototype)}}class ve extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ve.prototype)}}class En extends Error{constructor(e){super(e),Object.setPrototypeOf(this,En.prototype)}}class iL extends Error{constructor(e){super(e),Object.setPrototypeOf(this,iL.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KH{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $g(s,e){if(Array.isArray(s)){let t=[];for(let n=0;n<e;n++)t=t.concat(s);return t}else{const t=new Array(e);return t.fill(s),t}}function Yc(s,e){if(!s)throw new iL(e)}function QU(s,e){let t=0;for(const n of s)n===e&&t++;return t}function Qa(s){return s.length===1?s[0]:s}function vs(s){return Array.isArray(s)?s:[s]}function ef(s){const t=s.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Qm(s){return s.length<=1||s.indexOf("_")===-1?s:s.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let jl={};function rL(s){if(s==null)return null;const e={};return e.className=s.getClassName(),e.config=s.getConfig(),e}function GD(s){if(!(s==null||typeof s!="object"))if(Array.isArray(s))s.forEach(e=>GD(e));else{const e=Object.keys(s);for(const t of e){const n=s[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?s[t]=n.value:GD(n))}}}function bS(s,e={},t={},n="object",i=!1){if(typeof s=="string"){const r=s;let a;if(r in t)a=t[r];else if(r in jl)a=jl[r];else if(a=e[r],a==null)throw new ve(`Unknown ${n}: ${s}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const r=s;if(r.className==null||r.config==null)throw new ve(`${n}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const a=r.className;let o,l;if(a in t?[o,l]=t[a]:a in jl?[o,l]=jl.className:a in e&&([o,l]=e[a]),o==null)throw new ve(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const g of Object.keys(jl))u[g]=jl[g];for(const g of Object.keys(t))u[g]=t[g];const c=r.config;c.customObjects=u;const f=Object.assign({},jl);for(const g of Object.keys(t))jl[g]=t[g];GD(r.config);const d=l(o,r.config,t,i);return jl=Object.assign({},f),d}else{const u=Object.assign({},jl);for(const f of Object.keys(t))jl[f]=t[f];const c=new o(r.config);return jl=Object.assign({},u),c}}}function fye(s,e){return s<e?-1:s>e?1:0}function ow(s,e){return-1*fye(s,e)}function Zd(s){if(s==null)return s;const e=[];for(const t of s)e.indexOf(t)===-1&&e.push(t);return e}function dye(s){if(s==null)throw new ve(`Invalid value in obj: ${JSON.stringify(s)}`);for(const e in s)if(s.hasOwnProperty(e))return!1;return!0}function n0(s,e,t){if(t!=null&&s.indexOf(t)<0)throw new ve(`${t} is not a valid ${e}.  Valid values are ${s} or null/undefined.`)}function aL(s,e,t=0,n=1/0){return Yc(t>=0),Yc(n>=t),Array.isArray(s)&&s.length>=t&&s.length<=n&&s.every(i=>typeof i===e)}function vr(s,e){Array.isArray(s)?(K(s.length>0,()=>`${e} is unexpectedly an empty array.`),s.forEach((t,n)=>vr(t,`element ${n+1} of ${e}`))):K(Number.isInteger(s)&&s>0,()=>`Expected ${e} to be a positive integer, but got ${YH(s)}.`)}function YH(s){return s===null?"null":Array.isArray(s)?"["+s.map(e=>YH(e)).join(",")+"]":typeof s=="string"?`"${s}"`:`${s}`}function pye(s,e,t){let n=t!=null?t():Za(),i;return(...a)=>{const o=t!=null?t():Za();return o-n<e||(n=o,i=s(...a)),i}}function JH(s){return s==="relu"?"relu":s==="linear"?"linear":s==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let mye=0;function ZH(){return mye++}const lw={};function BM(s=""){return s in lw||(lw[s]=0),lw[s]+=1,s+lw[s].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gye=["channelsFirst","channelsLast"],yye=["nearest","bilinear"],xye=["valid","same","causal"],vye=["max","avg"],bye=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Dy=new Map;function Ii(s){n0(gye,"DataFormat",s)}function _ye(s){n0(yye,"InterpolationFormat",s)}function wl(s){n0(xye,"PaddingMode",s)}function QH(s){n0(vye,"PoolMode",s)}const cb=[],e$="/";function xg(s,e){cb.push(s);try{const t=e();return cb.pop(),t}catch(t){throw cb.pop(),t}}function Sye(){return cb.length===0?"":cb.join(e$)+e$}function eV(s){if(!nV(s))throw new Error("Not a valid tensor name: '"+s+"'");return Sye()+s}function tV(s){if(!nV(s))throw new Error("Not a valid tensor name: '"+s+"'");Dy.has(s)||Dy.set(s,0);const e=Dy.get(s);if(Dy.set(s,Dy.get(s)+1),e>0){const t=`${s}_${e}`;return Dy.set(t,1),t}else return s}const Aye=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function nV(s){return!!s.match(Aye)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Tye(s){return s===parseInt(s.toString(),10)}function Qd(s,e,t){e==null&&(e=0),t==null&&(t=s.length);let n=1;for(let i=e;i<t;++i)n*=s[i];return n}function Cx(s){if(s.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<s.length;t++){const n=s[t];n<e&&(e=n)}return e}function hp(s){if(s.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<s.length;t++){const n=s[t];n>e&&(e=n)}return e}function rc(s,e){if(e<s)throw new ve(`end (${e}) < begin (${s}) is forbidden.`);const t=[];for(let n=s;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let pI;function er(){return pI==null&&(pI=B8().epsilon()),pI}function ac(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lh(s,e){return Ct(s,e)}function _S(s,e=-1){const t=s.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),xe(s,t)}function wye(s,e){return we(()=>{if(s.shape.length!==2)throw new ve(`repeat() expects a rank-2 tensor, but received a rank-${s.shape.length} tensor.`);const t=_S(s,1);return HD(t,[1,e,1])})}function Cye(s){const e=[Qd(s.shape)];return xe(s,e)}function Eye(s){if(s.rank<=1)throw new ve(`batchFlatten requires a minimum rank of 2. Got rank: ${s.rank}.`);const e=[s.shape[0],Qd(s.shape,1)];return xe(s,e)}function vg(s,e,t){return we(()=>{switch(s.rank){case 1:return _M(s,e,t);case 2:return yk(s,[e,0],[t,s.shape[1]]);case 3:return SM(s,[e,0,0],[t,s.shape[1],s.shape[2]]);case 4:return Fb(s,[e,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3]]);case 5:return bn(s,[e,0,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3],s.shape[4]]);case 6:return bn(s,[e,0,0,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3],s.shape[4],s.shape[5]]);default:throw new ve(`sliceAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}})}function mI(s,e,t){return we(()=>{switch(s.rank){case 1:return _M(s,e,t);case 2:return yk(s,[0,e],[s.shape[0],t]);case 3:return SM(s,[0,0,e],[s.shape[0],s.shape[1],t]);case 4:return Fb(s,[0,0,0,e],[s.shape[0],s.shape[1],s.shape[2],t]);default:throw new ve(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function uw(s,e,t,n){return we(()=>{switch(s.rank){case 1:return _M(s,e,t);case 2:switch(n){case 1:return vg(s,e,t);case 2:return mI(s,e,t);default:throw new ve(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return vg(s,e,t);case 2:return SM(s,[0,e,0],[s.shape[0],t,s.shape[2]]);case 3:return mI(s,e,t);default:throw new ve(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return vg(s,e,t);case 2:return Fb(s,[0,e,0,0],[s.shape[0],t,s.shape[2],s.shape[3]]);case 3:return Fb(s,[0,0,e,0],[s.shape[0],s.shape[1],t,s.shape[3]]);case 4:return mI(s,e,t);default:throw new ve(`The axis is not within the rank of the tensor ${n}`)}default:throw new ve(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function oL(s,e=-1){let t;return e<0&&(t=s[0].rank,t!==0?e=t:e=0),e===s[0].rank&&(e=-1),js(s,e)}function t$(s,e){switch(s.rank){case 1:return cG([s,e]);case 2:return uM([s,e],0);case 3:return hG([s,e],0);case 4:return fG([s,e],0);default:throw new ve(`concatAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}}function HD(s,e){if(Array.isArray(e)||(e=[e]),s.rank!==e.length)throw new ve(`The length of input n (${e.length}) does not match the number of dimensions in input x (${s.rank})`);return su(s,e)}function kM(s,e=0,t=1,n,i){return uk(s,e,t,n,i)}function uh(s,e,t,n){if(s.rank<2||e.rank<2)throw new En(`dot requires both inputs to be rank >= 2 but got x shape = ${s.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=s.shape.slice(-1)[0],r=e.shape.slice(-2)[0];if(i!==r)throw new En(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${s.shape} and  y shape = ${e.shape}`)}if(s.rank===2&&e.rank===2)return PD({a:s,b:e,transposeA:!1,transposeB:!1,bias:n?VD(s.rank,n,ac()):null,activation:t});{const i=s.shape.slice(),r=i.pop();s=xe(s,[-1,r]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:e.rank},(x,S)=>S===0?e.rank-2:S<=e.rank-2?S-1:S);e=xe(jn(e,c),[l,-1]);const f=[...i,...u];return xe(PD({a:s,b:e,transposeA:!1,transposeB:!1,bias:n?VD(s.rank,n,ac()):null,activation:t}),f)}}function sV(s,e,t){return we(()=>(Array.isArray(e)?e=mi(e,"int32"):e=Ct(e,"int32"),gS(s,e,t)))}function SS(s){return pe(s,s)}function VD(s,e,t){const n=e.shape;if(e.rank!==1&&e.rank!==s)throw new ve(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${s}`);if(s===5){if(t==="channelsFirst")return n.length===1?xe(e,[1,n[0],1,1,1]):xe(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?xe(e,[1,1,1,1,n[0]]):xe(e,[1].concat(n))}else if(s===4){if(t==="channelsFirst")return n.length===1?xe(e,[1,n[0],1,1]):xe(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?xe(e,[1,1,1,n[0]]):xe(e,[1].concat(n))}else if(s===3){if(t==="channelsFirst")return n.length===1?xe(e,[1,n[0],1]):xe(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?xe(e,[1,1,n[0]]):xe(e,[1].concat(n))}else if(s<3)return e;throw new ve(`Unsupported input rank by biasAdd: ${e.rank}`)}function hc(s,e,t){return we(()=>(t==null&&(t=ac()),Ii(t),it(s,VD(s.rank,e,t))))}function Mye(s,e=1){if(e!==1)throw new En(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return dS(s)}function Nye(s){return we(()=>Ut(s,it(Ji(s),1)))}function iV(s,e,t,n){return we(()=>WG(s,e,t,n))}function Rye(s){return we(()=>{const e=it(.5,pe(.2,s));return Lo(e,0,1)})}function AS(s,e,t=!1){return t?s():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Iye=["fanIn","fanOut","fanAvg"],Dye=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oye(s){n0(Iye,"FanMode",s)}function Bye(s){n0(Dye,"Distribution",s)}class mu extends Kx{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class rV extends mu{apply(e,t){return Qi(e,t)}}rV.className="Zeros";rt(rV);class lL extends mu{apply(e,t){return Mo(e,t)}}lL.className="Ones";rt(lL);class aV extends mu{constructor(e){if(super(),typeof e!="object")throw new ve(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ve(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return we(()=>pe(Jt(this.value),Mo(e,t)))}getConfig(){return{value:this.value}}}aV.className="Constant";rt(aV);class oV extends mu{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Qg(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}oV.className="RandomUniform";rt(oV);class lV extends mu{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new En(`randomNormal does not support dType ${t}.`);return kM(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}lV.className="RandomNormal";rt(lV);class uV extends mu{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new En(`truncatedNormal does not support dType ${t}.`);return _k(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}uV.className="TruncatedNormal";rt(uV);class cV extends mu{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return we(()=>{if(e.length!==2||e[0]!==e[1])throw new ve("Identity matrix initializer can only be used for 2D square matrices.");return pe(this.gain,sk(e[0]))})}getConfig(){return{gain:this.gain}}}cV.className="Identity";rt(cV);function kye(s,e="channelsLast"){let t,n;if(Ii(e),s.length===2)t=s[0],n=s[1];else if([3,4,5].indexOf(s.length)!==-1){if(e==="channelsFirst"){const i=Qd(s,2);t=s[1]*i,n=s[0]*i}else if(e==="channelsLast"){const i=Qd(s,0,s.length-2);t=s[s.length-2]*i,n=s[s.length-1]*i}}else{const i=Qd(s);t=Math.sqrt(i),n=Math.sqrt(i)}return[t,n]}class Uo extends mu{constructor(e){if(super(),e.scale<0)throw new ve(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Oye(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Bye(this.distribution),this.seed=e.seed}apply(e,t){const n=kye(e),i=n[0],r=n[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,i):this.mode==="fanOut"?a/=Math.max(1,r):a/=Math.max(1,(i+r)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new En(`${this.getClassName()} does not support dType ${t}.`);return _k(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Qg(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Uo.className="VarianceScaling";rt(Uo);class uL extends Uo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}uL.className="GlorotUniform";rt(uL);class cL extends Uo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}cL.className="GlorotNormal";rt(cL);class hL extends Uo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}hL.className="HeNormal";rt(hL);class fL extends Uo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}fL.className="HeUniform";rt(fL);class dL extends Uo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}dL.className="LeCunNormal";rt(dL);class pL extends Uo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Uo.className}}pL.className="LeCunUniform";rt(pL);class hV extends mu{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return we(()=>{if(e.length<2)throw new En("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const n=Xe(e.slice(0,-1)),i=e[e.length-1],r=n*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const a=[Math.max(i,n),Math.min(i,n)],o=kM(a,0,1,t,this.seed),l=eH.qr(o,!1);let u=l[0];const f=l[1].flatten().stridedSlice([0],[Math.min(i,n)*Math.min(i,n)],[Math.min(i,n)+1]);return u=pe(u,f.sign()),n<i&&(u=u.transpose()),pe(Jt(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}hV.className="Orthogonal";rt(hV);const n$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function s$(s,e={}){return bS(s,eu.getMap().classNameMap,e,"initializer")}function si(s){return rL(s)}function qs(s){if(typeof s=="string"){const e=s in n$?n$[s]:s;if(e==="GlorotNormal")return new cL;if(e==="GlorotUniform")return new uL;if(e==="HeNormal")return new hL;if(e==="HeUniform")return new fL;if(e==="LeCunNormal")return new dL;if(e==="LeCunUniform")return new pL;{const t={};return t.className=e,t.config={},s$(t)}}else return s instanceof mu?s:s$(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function WD(s){return Array.isArray(s)&&Array.isArray(s[0])}function J2(s){return s.length===0?[]:Array.isArray(s[0])?s:[s]}function un(s){let e;if(Array.isArray(s)){if(s.length!==1)throw new ve(`Expected Tensor length to be 1; got ${s.length}`);e=s[0]}else e=s;return e}function as(s){if(Array.isArray(s)&&Array.isArray(s[0])){if(s.length===1)return s=s,s[0];throw new ve(`Expected exactly 1 Shape; got ${s.length}`)}else return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Z2(s){let e=0;for(const t of s)t.shape.length===0?e+=1:e+=t.shape.reduce((n,i)=>n*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const i$="Variable";class Lye{constructor(e,t="float32",n=i$,i=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=ZH(),n=n??i$,this.originalName=eV(n),this.name=tV(this.originalName),this.trainable_=i,this.constraint=r,this.val=HG(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Fye(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Fye(s,e){if(s.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(s.shape)+" vs. "+JSON.stringify(e.shape))}function XD(s){return s.map(e=>e.read())}function mL(s){s.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tr{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ph{constructor(e,t,n,i,r,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=i,this.callArgs=r,this.outputTensorIndex=o,this.id=ZH(),a!=null&&(this.originalName=eV(a),this.name=tV(this.originalName)),this.rank=t.length}}let Pye=0;class LM{constructor(e,t){this.callArgs=t,this.id=Pye++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Uye=0;class Ln extends Kx{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Uye++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const n=this.getClassName();t=ef(n)+"_"+BM(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new iu(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ve(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Qa(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Qa(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Kc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Kc(`Layer ${this.name} is not connected, no input to return.`);return Qa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Kc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Kc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Qa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=vs(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const n=vs(this.inputSpec);if(t.length!==n.length)throw new ve(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const r=t[i],a=n[i];if(a==null)continue;const o=r.rank;if(a.ndim!=null&&o!==a.ndim)throw new ve(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new ve(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new ve(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&r.dtype!==a.dtype)throw new ve(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){const l=r.shape;for(const u in a.axes){const c=Number(u),f=a.axes[u],d=c>=0?l[c]:l[l.length+c];if(f!=null&&[f,null].indexOf(d)===-1)throw new ve(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${f} but got shape ${l}.`)}}if(a.shape!=null)for(let l=0;l<a.shape.length;++l){const u=a.shape[l],c=r.shape[l];if(u!=null&&c!=null&&u!==c)throw new ve(`Input ${i} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=vs(e),i=Gye(e),r=Hye(e);if(i===r)throw new ve("Arguments to apply() must be all SymbolicTensors or all Tensors");return xg(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of vs(e))a.push(o.shape);this.build(Qa(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=vs(a),l=[];for(let u of o)n.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(a=Qa(l),this.activityRegularizer!=null)throw new En("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=$ye(e),o=this.computeOutputShape(a);let l;const u=zye(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,f)=>new ph(u,c,this,vs(e),t,this.name,f)):l=new ph(u,o,this,vs(e),t,this.name),this.addInboundNode(e,l,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new En("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,i)=>{n!=null&&e[i]!=null&&e[i]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Kc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Kc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new iu(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Z2(this.weights)}build(e){this.built=!0}getWeights(e=!1){return XD(e?this.trainableWeights:this.weights)}setWeights(e){we(()=>{const t=this.weights;if(t.length!==e.length)throw new ve(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const n=[],i=XD(t);for(let r=0;r<i.length;++r){const a=i[r],o=t[r],l=e[r];if(!Wn(a.shape,l.shape))throw new ve(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);n.push([o,l])}mL(n)})}addWeight(e,t,n,i,r,a,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ve(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():qs("zeros"));const u=i.apply(t,n),c=new Lye(u,n,e,a,o);return u.dispose(),r!=null&&this.addLoss(()=>r.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=vs(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const i=this.computeMask(e,n),r=vs(t),a=vs(i);if(r.length!==a.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let o=0;o<r.length;o++)r[o].kerasMask=a[o]}addInboundNode(e,t,n,i,r,a,o=null){const l=vs(e);t=vs(t),n=vs(n),i=vs(i),r=J2(r),a=J2(a);const u=[],c=[],f=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),f.push(d.tensorIndex);new LM({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:f,inputTensors:l,outputTensors:t,inputMasks:n,outputMasks:i,inputShapes:r,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function $ye(s){s=vs(s);const e=[];for(const t of s)e.push(t.shape);return Qa(e)}function zye(s){return"float32"}function fV(s,e,t){if((e==null||t!=null&&t>0)&&(e=s.sourceLayer,t=s.nodeIndex),e.inboundNodes.length===0)return[s];{const n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{const i=[];for(let r=0;r<n.inboundLayers.length;r++){const a=n.inputTensors[r],o=n.inboundLayers[r],l=n.nodeIndices[r],u=fV(a,o,l);for(const c of u)i.indexOf(c)===-1&&i.push(c)}return i}}}function Gye(s){let e=!0;for(const t of vs(s))if(!(t instanceof ph)){e=!1;break}return e}function Hye(s){let e=!0;for(const t of vs(s))if(t instanceof ph){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class TS extends Ln{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:BM("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ve("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ve("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ve("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const i=new ph(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new LM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ve(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}TS.className="InputLayer";rt(TS);function Vye(s){if(s.batchShape==null&&s.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(s.batchShape!=null&&s.shape!=null)throw new ve("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=s.batchShape;s.shape!=null&&e==null&&(e=[null].concat(s.shape));let t=s.dtype;return t==null&&(t="float32"),new TS({batchInputShape:e,name:s.name,dtype:t,sparse:s.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wye(s,e){if(s.dtype==null||s.dtype===e.dtype)return e;try{return Ct(e,s.dtype)}catch{throw new ve(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${s.name}' (${s.dtype}).`)}}class Hd{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Hd)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Wye(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new ve(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ph){if(this.id2Value[e.id]==null)throw new ve(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ve(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ph){if(this.id2Value[e.id]==null)throw new ve(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ve(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Bn(this.id2Mask)}}const Q2=new KH,eC=new KH;function Xye(s){Q2!=null&&Q2.setMaxEntries(s),eC!=null&&eC.setMaxEntries(s)}function q1(s,e,t,n){const i=t==null?!1:t.training,r=Array.isArray(s),a=r?s:[s],o=a.map(x=>x.name),l=[],u=e.names();for(const x of o)u.indexOf(x)!==-1?l.push(e.getValue(x)):l.push(null);const c=o.join(",")+"|"+e.names().sort().join(",");let f=Q2.get(c),d;if(f==null){const x=qye(a,e);f=x.sorted,d=x.recipientCounts,Q2.put(c,f),eC.put(c,d)}d={},i||Object.assign(d,eC.get(c));const g=new Hd(e);for(let x=0;x<f.length;++x){const S=f[x],b=S.sourceLayer;if(b instanceof TS)continue;const _=[],T=[],E=[];let C=!1;for(const D of S.inputs){const O=g.getValue(D),F=g.getMask(D);_.push(O),T.push(F),F!=null&&(C=!0),i||(d[D.name]--,d[D.name]===0&&!e.hasKey(D)&&o.indexOf(D.name)===-1&&!O.isDisposed&&D.sourceLayer.stateful!==!0&&E.push(O))}C&&(t=t||{},t.mask=T[0]);const R=vs(b.apply(_,t));let I=null;b.supportsMasking&&(I=b.computeMask(_,T));const L=Kye(S),P=Array.isArray(L)?L:[L];for(let D=0;D<P.length;++D){g.hasKey(P[D])||g.add(P[D],R[D],Array.isArray(I)?I[0]:I);const O=o.indexOf(P[D].name);O!==-1&&(l[O]=R[D])}i||Bn(E)}return g.disposeMasks(),r?l:l[0]}function qye(s,e){K(s!=null&&s.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(s.length===1){const i=r$(s[0],e);t=i.sorted,n=i.recipientMap}else{const i=new Set;for(const r of s){const{sorted:a,recipientMap:o}=r$(r,e);for(const l of a)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in o)n[l]==null&&(n[l]=new Set),o[l].forEach(u=>n[l].add(u))}}return{sorted:t,recipientCounts:jye(n)}}function jye(s){const e={};for(const t in s)e[t]=s[t].size;return e}function r$(s,e){const t=new Set,n=[],i={};for(const o of e.names())t.add(o);const r=[],a=[];for(r.push(s);r.length>0;){const o=r[r.length-1];if(t.has(o.name)){r.pop();continue}const l=a[a.length-1]===r.length-1;if(o.inputs.length===0||l)r.pop(),n.push(o),t.add(o.name),l&&a.pop();else{a.push(r.length-1);for(const u of o.inputs)i[u.name]==null&&(i[u.name]=new Set),i[u.name].add(o.name),!t.has(u.name)&&r.push(u)}}return{sorted:n,recipientMap:i}}function Kye(s){let e;if(s.sourceLayer.inboundNodes.length===1)e=s.sourceLayer.output;else{let t=null;for(let n=0;n<s.sourceLayer.inboundNodes.length;++n)for(const i of s.sourceLayer.inboundNodes[n].outputTensors)if(i.id===s.id){t=n;break}e=s.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yye=Ie();Yye.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Xye);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gL(s,e){return we(()=>Pr($t(pe(s,s),e,!0)))}class wS extends Kx{getConfig(){return{}}}class dV extends wS{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return we(()=>{const t=gL(e,this.axis),n=Lo(t,0,this.maxValue);return pe(e,Ut(n,it(er(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}dV.className="MaxNorm";rt(dV);class pV extends wS{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return we(()=>Ut(e,it(er(),gL(e,this.axis))))}getConfig(){return{axis:this.axis}}}pV.className="UnitNorm";rt(pV);class mV extends wS{apply(e){return xh(e)}}mV.className="NonNeg";rt(mV);class gV extends wS{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return we(()=>{const t=gL(e,this.axis),n=it(pe(this.rate,Lo(t,this.minValue,this.maxValue)),pe(1-this.rate,t));return pe(e,Ut(n,it(er(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}gV.className="MinMaxNorm";rt(gV);const a$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function sr(s){return rL(s)}function o$(s,e={}){return bS(s,eu.getMap().classNameMap,e,"constraint")}function ir(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in a$?a$[s]:s,config:{}};return o$(t)}else return s instanceof wS?s:o$(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function zm(s){if(s==null)return;const e=[],t=[],n=[];for(const i in s){const r=s[i];if(typeof r!="number"){const a=r;e.push(a.data()),t.push(i),n.push(a)}}if(e.length>0){const i=await Promise.all(e);for(let r=0;r<i.length;++r)s[t[r]]=i[r][0];Bn(n)}}function yV(s){if(s!=null)for(const e in s){const t=s[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var l$;(function(s){s[s.SILENT=0]="SILENT",s[s.VERBOSE=1]="VERBOSE"})(l$||(l$={}));const Jye=125;class Ub{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Zye{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Qye extends Ub{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const n=t.size==null?0:t.size;this.seen+=n;for(const i in t){const r=t[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*n;else{let a;i in this.totals?a=this.totals[i]:this.totals[i]=0;const o=we(()=>it(this.totals[i],pe(r,n)));this.totals[i]=o,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:we(()=>{const i=pe(Ut(1,this.seen),this.totals[n]);t[n]=i,this.totals[n].dispose(),xr(t[n])}))}}class exe extends Ub{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const l=a[o];e.push(l.data()),t.push(r),n.push(o)}}const i=await Promise.all(e);for(let r=0;r<i.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=i[r][0]}}class txe extends Ub{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||SH,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Jye),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");xD(this.yieldEvery)&&(this.maybeWait=pye(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const i=[];this.yield!=null&&(await zm(n),i.push(this.yield(e,t,n))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await zm(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];this.epochEnd!=null&&(await zm(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await zm(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];this.batchEnd!=null&&(await zm(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):xD(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await zm(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await zm(e),await this.trainEnd(e))}}function xV(s,e){return s==null&&(s={}),s instanceof Ub?[s]:Array.isArray(s)&&s[0]instanceof Ub?s:vs(s).map(n=>new txe(n,e))}class Zl{constructor(){}static registerCallbackConstructor(e,t){K(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Zl.checkForDuplicate(t),Zl.constructors[e]==null&&(Zl.constructors[e]=[]),Zl.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Zl.constructors)Zl.constructors[+t].forEach(i=>{if(i===e)throw new ve("Duplicate callback constructor.")})}static clear(){Zl.constructors={}}static createCallbacks(e){const t=[];for(const n in Zl.constructors){const i=+n;e>=i&&t.push(...Zl.constructors[i])}return t.map(n=>new n)}}Zl.constructors={};function vV(s,e,t,n,i,r,a,o,l){const u=new exe,c=[new Qye,...Zl.createCallbacks(e)];s!=null&&c.push(...s),c.push(u);const f=new Zye(c);return f.setParams({epochs:t,initialEpoch:n,samples:i,steps:r,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:f,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mf(s,e={},t=!1){return bS(s,eu.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tC(s,e){return we(()=>{s.dtype!=="float32"&&(s=Ct(s,"float32"));const t=$t(SS(s),e,!0),n=Wx(t.shape,er()),i=Pr(Rf(t,n));return Ut(s,i)})}function FM(s,e){return we(()=>pi(SS(wt(e,s)),-1))}function yL(s,e){return we(()=>pi(Ji(wt(e,s)),-1))}function xL(s,e){return we(()=>{const t=wt(s,e),n=Lo(Ji(s),er(),Number.MAX_VALUE),i=Ji(Ut(t,n));return pe(100,pi(i,-1))})}function nxe(s,e){return we(()=>{const t=Lo(e,er(),Number.MAX_VALUE),n=Sl(it(1,t)),i=Lo(s,er(),Number.MAX_VALUE),r=Sl(it(1,i));return pi(SS(wt(n,r)),-1)})}function sxe(s,e){return we(()=>{const t=Rf(0,wt(1,pe(s,e)));return pi(SS(t),-1)})}function ixe(s,e){return we(()=>{const t=Rf(0,wt(1,pe(s,e)));return pi(t,-1)})}function rxe(s,e){return we(()=>{const t=$t(pe(s,e),-1),n=ou(pe(wt(1,s),e),-1);return Rf(0,it(1,wt(n,t)))})}function axe(s,e){return we(()=>{const t=Math.log(2),n=wt(e,s),i=wt(it(n,Xx(pe(-2,n))),t);return pi(i,-1)})}function $b(s,e,t=!1){return we(()=>{if(t)e=AM(e);else{const n=$t(e,e.shape.length-1,!0);e=Ut(e,n)}return e=Lo(e,er(),1-er()),Hs($t(pe(Ct(s,"float32"),Sl(e)),e.shape.length-1))})}function nC(s,e,t=!1){return we(()=>{const n=Ct(mS(Cye(s)),"int32");e=Lo(e,er(),1-er());const i=e.shape,r=xe(ok(n,i[i.length-1]),i);return $b(r,e,t)})}function oxe(s,e){if(!Wn(s.shape,e.shape))throw new ve(`logits and labels must have the same shape, but got shapes ${JSON.stringify(s.shape)} and ${JSON.stringify(e.shape)}`);return we(()=>{const t=xh(e),n=Hs(Ji(e));return it(wt(t,pe(e,s)),dM(Fo(n)))})}function PM(s,e){return we(()=>{let t;return t=Lo(e,er(),1-er()),t=Sl(Ut(t,wt(1,t))),pi(oxe(s,t),-1)})}function lxe(s,e){return we(()=>{const t=Lo(s,er(),1),n=Lo(e,er(),1);return $t(pe(s,Sl(Ut(t,n))),-1)})}function uxe(s,e){return we(()=>{const t=Sl(it(er(),e));return pi(wt(e,pe(s,t)),-1)})}function bV(s,e){return we(()=>{const t=tC(s,-1),n=tC(e,-1),i=pe(t,n);return Hs($t(i,-1))})}const sC={meanSquaredError:FM,meanAbsoluteError:yL,meanAbsolutePercentageError:xL,meanSquaredLogarithmicError:nxe,squaredHinge:sxe,hinge:ixe,categoricalHinge:rxe,logcosh:axe,categoricalCrossentropy:$b,sparseCategoricalCrossentropy:nC,binaryCrossentropy:PM,kullbackLeiblerDivergence:lxe,poisson:uxe,cosineProximity:bV};function gI(s){if(typeof s=="string"){if(s in sC)return sC[s];let e=`Unknown loss ${s}`;throw s.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${s}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ve(e)}else return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _V(s,e){return we(()=>{const t=pe(.5,Al(e)),n=lh(Go(e,t),s.dtype);return pi(ic(s,n),-1)})}function SV(s,e){return we(()=>lh(ic(Sx(s,-1),Sx(e,-1)),"float32"))}function cxe(s,e){return we(()=>Ct($t(dh(ic(s,1),ic(e,1))),"float32"))}function hxe(s,e){return we(()=>Ct($t(dh(ic(s,0),ic(e,1))),"float32"))}function fxe(s,e){return we(()=>{const t=cxe(s,e),n=hxe(s,e),i=it(t,n);return Ct(na(Go(i,0),Ut(t,i),0),"float32")})}function dxe(s,e){return PM(s,e)}function pxe(s,e){return s.rank===e.rank&&(s=e0(s,[s.rank-1])),e=Sx(e,-1),e.dtype!==s.dtype&&(e=Ct(e,s.dtype)),Ct(ic(s,e),"float32")}const mxe=FM,gxe=FM,yxe=yL,xxe=yL,vxe=xL,bxe=xL,AV=$b,_xe=bV,TV=nC,iC={binaryAccuracy:_V,categoricalAccuracy:SV,precision:fxe,categoricalCrossentropy:AV,sparseCategoricalCrossentropy:TV,mse:mxe,MSE:gxe,mae:yxe,MAE:xxe,mape:vxe,MAPE:bxe,cosine:_xe};function Sxe(s){if(typeof s=="string"&&s in iC)return iC[s];if(typeof s!="string"&&s!=null)return s;throw new ve(`Unknown metric ${s}`)}function cw(s){if(Yc(s!==null,`Unknown LossOrMetricFn ${s}`),typeof s=="string")return s;{let e;for(const t of Object.keys(sC))if(sC[t]===s){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(iC))if(iC[t]===s){e=t;break}return e!==void 0?e:s.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Axe(s){const e={Adagrad:()=>Iy.adagrad(.01),Adadelta:()=>Iy.adadelta(1,.95,er()),Adam:()=>Iy.adam(.001,.9,.999,er()),Adamax:()=>Iy.adamax(.002,.9,.999,er(),0),RMSProp:()=>Iy.rmsprop(.001,.9,0,er()),SGD:()=>Iy.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,s in e)return e[s]();throw new ve(`Unknown Optimizer ${s}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const u$=1*1024*1024;function c$(s,e,t=!1){if(s==null||typeof s!="object"||Object.getPrototypeOf(s)!==Object.prototype||!qD(s))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const n=JSON.stringify(s);n.length>u$&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${u$}.`)}}function qD(s){if(s===null)return!0;if(typeof s=="object")if(Object.getPrototypeOf(s)===Object.prototype){const e=Object.keys(s);for(const t of e)if(typeof t!="string"||!qD(s[t]))return!1;return!0}else if(Array.isArray(s)){for(const e of s)if(!qD(e))return!1;return!0}else return!1;else{const e=typeof s;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Txe(s,e,t,n=console.log){const i=Cxe(s),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let a;if(!i){r.push("Receives inputs"),a=[];for(const c in s.nodesByDepth)a.push(...s.nodesByDepth[c])}n("_".repeat(e)),rC(r,t,n),n("=".repeat(e));const o=s.layers;for(let c=0;c<o.length;++c)i?Exe(o[c],t,n):Mxe(o[c],t,a,n),n((c===o.length-1?"=":"_").repeat(e));s.checkTrainableWeightsConsistency();const l=wxe(s),u=Z2(s.nonTrainableWeights);n(`Total params: ${l+u}`),n(`Trainable params: ${l}`),n(`Non-trainable params: ${u}`),n("_".repeat(e))}function wxe(s){let e;return s.collectedTrainableWeights!=null?e=Z2(s.collectedTrainableWeights):e=Z2(s.trainableWeights),e}function Cxe(s){let e=!0;const t=[],n=[];for(const i in s.nodesByDepth)t.push(s.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}n.push(...i)}if(e)for(const i of s.layers){let r=!1;for(const a of i.inboundNodes)if(n.indexOf(a)!==-1)if(r){e=!1;break}else r=!0;if(!e)break}return e}function rC(s,e,t=console.log){let n="";for(let i=0;i<s.length;++i)i>0&&(n=n.slice(0,n.length-1)+" "),n+=s[i],n=n.slice(0,e[i]),n+=" ".repeat(e[i]-n.length);t(n)}function Exe(s,e,t){let n,i;try{i=s.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{n=JSON.stringify(s.outputShape)}catch{n="multiple"}const r=s.name,a=s.getClassName(),o=[`${r} (${a})`,i,n,s.countParams().toString()];rC(o,e,t)}function Mxe(s,e,t,n){let i,r;try{r=s.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(s.outputShape)}catch{i="multiple"}const a=[];for(const f of s.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(f)===-1))for(let d=0;d<f.inboundLayers.length;++d){const g=f.inboundLayers[d].name,x=f.nodeIndices[d],S=f.tensorIndices[d];a.push(`${g}[${x}][${S}]`)}const o=s.name,l=s.getClassName(),u=a.length===0?"":a[0],c=[`${o} (${l})`,r,i,s.countParams().toString(),u];rC(c,e,n);for(let f=1;f<a.length;++f)rC(["","","","",a[f]],e,n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wV(s,e,t){return(s==="inboundNodes"||s==="outputLayers"||s==="inputLayers")&&e===0&&typeof t=="string"}function jD(s,e){if(s===null)return null;if(typeof s=="string")return Qm(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const t=[],n=s.length;for(let i=0;i<n;++i){const r=s[i];wV(e,i,r)?t.push(r):t.push(jD(r,e))}return t}else{const t={};for(const n of Object.keys(s)){const i=s[n];if(n==="name"&&typeof i=="string")t[n]=i;else{const r=Qm(n);t[r]=jD(i,r)}}return t}}function KD(s,e){if(s==null)return null;if(typeof s=="string")return ef(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const t=[],n=s.length;for(let i=0;i<n;++i){const r=s[i];wV(e,i,r)?t.push(r):t.push(KD(r,e))}return t}else{const t={};for(const n of Object.keys(s)){const i=s[n],r=ef(n);(n==="name"||n==="className")&&typeof i=="string"?t[r]=i:t[r]=KD(i,n)}return t}}/** @license See the LICENSE file. */const CV="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Nxe=s=>{const e=Object.keys(s);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Xu extends Ln{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=BM(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Zd(this.inputs).length!==this.inputs.length)throw new ve(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Zd(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const E=T.sourceLayer,C=T.nodeIndex,R=T.tensorIndex;this.outputLayers.push(E),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(R)}for(const T of this.inputs){const E=T.sourceLayer,C=T.nodeIndex,R=T.tensorIndex;Yc(C===0,"input layer has >1 nodes"),Yc(R===0,"input layer has >1 tensors"),this.inputLayers.push(E),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(R)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const E=this.inputLayers[T];if(!(E instanceof TS))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${T} (0-based) originates from layer type ${E.getClassName()}.`);this.inputNames.push(E.name),this.feedInputShapes.push(E.batchInputShape),this.feedInputNames.push(E.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const t={},n={},i={},r={},a={},o=[],l=(T,E,C,R,I,L)=>{(R==null||I==null||L==null)&&(R=T.sourceLayer,I=T.nodeIndex,L=T.tensorIndex);const P=R.inboundNodes[I];if(C.indexOf(P)!==-1)throw new iu(`The tensor ${T.name} at layer "${R.name}" is part of a cycle.`);if(E.indexOf(P)!==-1)return;this.containerNodes.add(Xu.nodeKey(R,I)),R.id in a||(a[R.id]=Object.keys(a).length),C.indexOf(P)===-1&&C.push(P);const D=P.inboundLayers.length;for(let O=0;O<D;O++){const F=P.inputTensors[O],X=P.inboundLayers[O],q=P.nodeIndices[O],J=P.tensorIndices[O];l(F,E,C,X,q,J)}for(E.push(P);C.indexOf(P)>=0;)C.splice(C.indexOf(P),1);o.push(P)},u=[],c=[];for(const T of this.outputs)l(T,u,c);const f=o.slice().reverse();for(const T of f){n[T.id]=T,T.id in t||(t[T.id]=0);let E=t[T.id];const C=i[T.outboundLayer.id]==null?0:i[T.outboundLayer.id];E=Math.max(E,C),i[T.outboundLayer.id]=E,r[T.outboundLayer.id]=T.outboundLayer,t[T.id]=E;for(let R=0;R<T.inboundLayers.length;R++){const I=T.inboundLayers[R],L=T.nodeIndices[R],P=I.inboundNodes[L],D=t[P.id]==null?0:t[P.id];t[P.id]=Math.max(E+1,D),n[P.id]=P}}const d={};for(const T in t){const E=t[T];E in d||(d[E]=[]),d[E].push(n[T])}const g={};for(const T in i){const E=i[T];E in g||(g[E]=[]),g[E].push(r[T])}let x=Object.keys(g).map(T=>parseInt(T,10)).sort(ow);this.layers=[];for(const T of x){const E=g[T];E.sort((C,R)=>{const I=a[C.id],L=a[R.id];return I<L?-1:I>L?1:0});for(const C of E)C instanceof Xu&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=g,x=Object.keys(d).map(T=>parseInt(T,10)).sort(ow);const S=this.inputs.slice(),b=[];for(const T of x)for(const E of d[T]){const C=E.outboundLayer;if(C!=null){for(const R of E.inputTensors)if(S.indexOf(R)===-1)throw new iu(`Graph disconnected: cannot obtain value for tensor ${R} at layer "${C.name}". The following previous layers were accessed without issue: ${b}`);for(const R of E.outputTensors)S.push(R);b.push(C.name)}}this.nodesByDepth=d;const _=this.layers.map(T=>T.name);for(const T of _){const E=_.filter(C=>C===T).length;if(E!==1)throw new iu(`The name "${T}" is used ${E} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(_))}this.outboundNodes=[],this.inboundNodes=[],new LM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ve("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let i=0;const r=Nxe(e);r&&this.parseWeights(e);for(const o of this.layers)for(const[l,u]of o.weights.entries()){const c=r?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(n[c]!=null)throw new ve(`Duplicate weight name: ${c}`);n[c]=u,i++}const a=[];for(const o in e){let l=o;if(n[o]==null){const u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[l]!=null)a.push([n[l],e[o]]);else if(t)throw new ve(`Provided weight data has no target variable: ${o}`);delete n[l]}if(t){const o=[];for(const l in n)o.push(l);if(o.length>0)throw new ve(`${o.length} of ${i} weights are not set: ${o}`)}mL(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),i=["vars","layer_checkpoint_dependencies"],r=n.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!i.includes(a)).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${CV}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=KD(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return we(()=>{e=vs(e);const n=new Hd;for(let i=0;i<this.inputs.length;++i)n.add(this.inputs[i],e[i]);return q1(this.outputs,n,t)})}computeMask(e,t){return we(()=>{e=vs(e);let n;return t==null?n=$g(null,e.length):n=vs(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=J2(e);if(t.length!==this.inputLayers.length)throw new ve(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],u=t[o],c=l.name+"_0_0";n[c]=u}const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(ow);if(i.length>1)for(const o of i){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(S=>S.id).indexOf(c.id)!==-1)continue;const f=[];for(let S=0;S<u.inboundLayers.length;S++){const b=u.inboundLayers[S],_=u.nodeIndices[S],T=u.tensorIndices[S],E=`${b.name}_${_}_${T}`,C=n[E];f.push(C)}const d=c.computeOutputShape(Qa(f)),g=J2(d),x=c.inboundNodes.indexOf(u);for(let S=0;S<g.length;S++){const b=`${c.name}_${x}_${S}`;n[b]=g[S]}}}const r=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],f=`${l.name}_${u}_${c}`;a.push(f)}for(let o=0;o<a.length;o++){const l=a[o];Yc(l in n),r.push(n[l])}return Qa(r)}runInternalGraph(e,t){t==null&&(t=$g(null,e.length));const n={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],f=t[l];n[u.id]=[c,f]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(ow);for(const l of i){const u=this.nodesByDepth[l];for(const c of u){const f=c.outboundLayer,d=c.inputTensors,g=c.outputTensors,x=new Array;for(const S of d)S.id in n&&x.push(n[S.id]);if(x.length===d.length){let S={},b,_,T,E;if(c.callArgs!=null&&(S=c.callArgs),x.length===1){const[C,R]=x[0];S.mask==null&&(S.mask=R),T=vs(f.call(C,S)),E=vs(f.computeMask(C,R)),b=[C],_=[R]}else b=x.map(C=>C[0]),_=x.map(C=>C[1]),S.mask==null&&(S.mask=_),T=vs(f.call(b,S)),E=vs(f.computeMask(b,_));if(f.activityRegularizer)throw new En("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<g.length;++C){const R=g[C],I=T[C],L=E[C];n[R.id]=[I,L]}}}}const r=[],a=[],o=[];for(const l of this.outputs){Yc(l.id in n,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=n[l.id];o.push(u.shape),r.push(u),a.push(c)}return[r,a,o]}buildNodeConversionMap(e){const t={};let n;for(const i of this.layers){n=i instanceof Xu?1:0;for(let r=0;r<i.inboundNodes.length;r++){const a=Xu.nodeKey(i,r);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new ve("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new ve(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ve(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return we(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const i=Xu.nodeKey(t,n);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),u=[];for(let f=0;f<a.inboundNodes.length;f++){const d=a.inboundNodes[f],g=Xu.nodeKey(a,f);let x={};if(this.containerNodes.has(g)){if(d.callArgs)try{JSON.stringify(d.callArgs),x=d.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),x={}}if(d.inboundLayers.length>0){const S=[];for(let b=0;b<d.inboundLayers.length;b++){const _=d.inboundLayers[b],T=d.nodeIndices[b],E=d.tensorIndices[b],C=Xu.nodeKey(_,T);let R=t[C];R==null&&(R=0),S.push([_.name,R,E,x])}u.push(S)}}}const c={};c.name=a.name,c.className=o,c.config=l,c.inboundNodes=u,n.push(c)}e.layers=n;const i=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Xu.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const f=this.inputLayersTensorIndices[a];i.push([o.name,c,f])}e.inputLayers=i;const r=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Xu.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const f=this.outputLayersTensorIndices[a];r.push([o.name,c,f])}return e.outputLayers=r,e}static fromConfig(e,t,n={},i=!1){const r={},a={};function o(b,_){b.name in a?a[b.name].push(_):a[b.name]=[_]}function l(b,_){const T=[];let E;for(const C of _){const R=C[0],I=C[1],L=C[2];if(E=C[3]==null?{}:C[3],!(R in r)){o(b,_);return}const P=r[R];if(P.inboundNodes.length<=I){o(b,_);return}const D=P.inboundNodes[I];T.push(D.outputTensors[L])}T.length>0&&b.apply(Qa(T),E)}function u(b){const _=b.name,T=mf(b,t.customObjects!=null?t.customObjects:{});T.setFastWeightInitDuringBuild(i),r[_]=T,b.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new ve(`Corrupted configuration, expected array for nodeData: ${C}`);o(T,C)})}const c=t.name,f=t.layers;for(const b of f)u(b);for(;!dye(a);)for(const b of f){const _=r[b.name];if(_.name in a){const T=a[_.name];delete a[_.name];for(const E of T)l(_,E)}}const d=[],g=[],x=t.inputLayers;for(const b of x){const _=b[0],T=b[1],E=b[2];Yc(_ in r);const R=r[_].inboundNodes[T].outputTensors;d.push(R[E])}const S=t.outputLayers;for(const b of S){const _=b[0],T=b[1],E=b[2];Yc(_ in r);const R=r[_].inboundNodes[T].outputTensors;g.push(R[E])}return new e({inputs:d,outputs:g,name:c})}get stateful(){if(this._stateful)throw new ve("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){we(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Rxe(s,e,t){const n=e.length;if(s==null||Array.isArray(s)&&s.length===0)return e.map(i=>null);if(n===1)return Array.isArray(s)&&s.length===1?s:typeof s=="object"&&e[0]in s?[s[e[0]]]:[s];if(Array.isArray(s)){if(s.length!==n)throw new Error(`Provided ${t} is an array of ${s.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return s}else if(typeof s=="object"&&Object.keys(s).length>0&&typeof s[Object.keys(s)[0]]=="object"){const i=[];return e.forEach(r=>{r in s?i.push(s[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(s)}`)}function EV(s,e){return Rxe(s,e,"classWeight")}async function MV(s,e,t,n){if(t!=null){const i=we(()=>{if(s.shape.length===1)return pf(s);if(s.shape.length===2){if(s.shape[1]>1)return Sx(s,1);if(s.shape[1]===1)return xe(s,[s.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${s.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${s.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());Bn(i);const a=[];return r.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),mi(a,"float32")}else return null}function Ixe(s,e){return pe(s,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Dxe=32;function NV(s,e){let t,n;const i=e;t=i.xs,n=i.ys,K(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=h$("input",s.inputNames,t),a=h$("output",s.outputNames,n),o=r[0].shape[0];K(r.length===s.inputs.length,()=>`LayersModel has ${s.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(s.inputNames)})`),K(a.length===s.outputs.length,()=>`LayersModel has ${s.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(s.outputNames)})`);for(let l=0;l<r.length;l++)K(r[l].shape[0]===o,()=>`Batch size mismatch: input ${s.inputNames[l]} has ${r[l].shape[0]}; expected  ${o} based on input ${s.inputNames[0]}.`);for(let l=0;l<a.length;l++)K(a[l].shape[0]===o,()=>`Batch size mismatch: output ${s.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${s.inputNames[0]}.`);return{xs:r,ys:a}}function h$(s,e,t){if(t instanceof ls)return[t];if(Array.isArray(t))return K(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${s} keys ${e}.`),t;{const n=[];for(const i of e){if(t[i]==null)throw new ve(`The feature data generated by the dataset lacks the required ${s} key '${i}'.`);n.push(t[i])}return n}}function Oxe(s){if(s.length===3)throw new En("Validation with sample weights is not implemented yet.");return{xs:s[0],ys:s[1]}}async function Bxe(s,e,t){const n=t.batchesPerEpoch!=null;if(K(s.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),K(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),K(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),K(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),K(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");s.isTraining=!0;try{const i=t.validationData!=null;let r,a;if(i)if(f$(t.validationData))K(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const b=Oxe(t.validationData);r=b.xs,a=b.ys}const o=s.makeTrainFunction(),l=s.getDedupedMetricsNames();let u;i?u=l.slice().concat(l.map(b=>"val_"+b)):u=l.slice();const c=xV(t.callbacks,t.yieldEvery),f=t.verbose==null?1:t.verbose,{callbackList:d,history:g}=vV(c,f,t.epochs,null,null,kxe(e,t),null,i,u);d.setModel(s),s.history=g,await d.onTrainBegin(),s.stopTraining_=!1;let x=t.initialEpoch==null?0:t.initialEpoch,S=await e.iterator();for(;x<t.epochs;){const b={};await d.onEpochBegin(x);let _=0,T=0;for(n||(S=await e.iterator());!n||_<t.batchesPerEpoch;){const E=await S.next();if(n&&E.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${_} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(E.value!=null){const{xs:C,ys:R}=NV(s,E.value),I={};I.batch=T,I.size=C[0].shape[0],await d.onBatchBegin(T,I);const L=[];if(t.classWeight!=null){const O=EV(t.classWeight,s.outputNames);for(let F=0;F<O.length;++F)L.push(await MV(R[F],null,O[F]))}const P=C.concat(R).concat(L),D=o(P);Bn(P);for(let O=0;O<l.length;++O){const F=l[O],X=D[O];I[F]=X,xr(X)}await d.onBatchEnd(T,I),yV(I),T++,_++}if(n?_>=t.batchesPerEpoch:E.done){if(i){let C;f$(t.validationData)?C=vs(await s.evaluateDataset(t.validationData,{batches:t.validationBatches})):C=vs(s.evaluate(r,a,{batchSize:t.validationBatchSize==null?Dxe:t.validationBatchSize,verbose:0}));for(let R=0;R<s.metricsNames.length;++R)b[`val_${s.metricsNames[R]}`]=C[R]}break}if(s.stopTraining_)break}if(await d.onEpochEnd(x,b),x++,s.stopTraining_)break}return await d.onTrainEnd(),await s.history.syncData(),s.history}finally{s.isTraining=!1}}function kxe(s,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(s.size)&&(t=s.size),t}function f$(s){return typeof s.iterator=="function"}function Lxe(s){return typeof s.next=="function"}async function Fxe(s,e,t){t=t||{};const n=t.batches!=null,i=s.testFunction;let r=[];if(t.verbose>0)throw new En("Verbose mode is not implemented yet.");K(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=Lxe(e)?e:await e.iterator();let o=0,l=0;for(;!n||l<t.batches;){const u=await a.next();if(r=we(()=>{if(u.value){const{xs:c,ys:f}=NV(s,u.value),d=c.concat(f),g=we(()=>i(d));if(Bn(d),l===0)for(let S=0;S<g.length;++S)r.push(Jt(0));const x=d[0].shape[0];for(let S=0;S<g.length;++S){const b=g[S],_=r[S];r[S]=we(()=>it(r[S],pe(x,b))),l>0&&Bn(_)}Bn(g),o+=x,++l}return r}),u.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<r.length;++u){const c=r[u];r[u]=Ut(r[u],o),Bn(c)}return Qa(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yI(s){K(s>0&&Number.isInteger(s),()=>`batchSize is required to be a positive integer, but got ${s}`)}function F1(s,e,t){return s==null?[null]:Array.isArray(s)?s.map(n=>vg(n,e,t-e)):vg(s,e,t-e)}function YD(s,e){return we(()=>s==null?null:Array.isArray(s)?s.map(t=>YD(t,e)):sV(s,e.dtype==="int32"?e:Ct(e,"int32")))}function xI(s,e){const t=[];let n=0,i=null;for(;n<s;)i=n+e,i>=s&&(i=s),t.push([n,i]),n=i;return t}function RV(s){const e=[];s instanceof ls&&(s=[s]);for(let t=0;t<s.length;++t){const n=s[t];if(n.rank===1)e.push(_S(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function Wu(s,e){if(s==null)return;const t=[];if(e instanceof ls)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const r=e[i];t.push(r.id)}const n=[];if(s instanceof ls)t.indexOf(s.id)===-1&&n.push(s);else if(Array.isArray(s))s.forEach(i=>{t.indexOf(i.id)===-1&&n.push(i)});else if(s!=null)for(const i in s){const r=s[i];t.indexOf(r.id)===-1&&n.push(r)}n.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pxe(s){return s instanceof ls}function JD(s){return Array.isArray(s)}function d$(s){return!Pxe(s)&&!JD(s)}function p$(s,e,t,n=!0,i=""){if(e==null||e.length===0){if(s!=null){let a=!1;if(JD(s)&&s.length>0)a=!0;else if(d$(s)){for(const o in s)if(s.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ve(`Error when checking model ${i} expected no data, but got ${s}`)}return[]}if(s==null)return e.map(a=>null);let r;if(d$(s)){s=s,r=[];for(const a of e){if(s[a]==null)throw new ve(`No data provided for "${a}". Need data for each key in: ${e}`);r.push(s[a])}}else if(JD(s)){if(s=s,s.length!==e.length)throw new ve(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${s}`);r=s}else{if(s=s,e.length>1)throw new ve(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${s.shape}`);r=[s]}if(r=RV(r),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=r[a];if(o.shape.length!==t[a].length)throw new ve(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!n)continue;const u=o.shape[l],c=t[a][l];if(c!=null&&c>=0&&u!==c)throw new ve(`${i} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return r}function Uxe(s,e,t){const n=Zd(s.map(r=>r.shape[0]));n.sort();const i=Zd(e.map(r=>r.shape[0]));if(i.sort(),n.length>1)throw new ve(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(r=>r.shape))}`);if(i.length>1)throw new ve(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(r=>r.shape))}`);if(n.length>0&&i.length>0&&!Wn(n,i))throw new ve(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${i[0]} target sample(s).`)}function $xe(s,e,t){const n=[FM,PM,$b];for(let i=0;i<s.length;++i){const r=s[i],a=e[i],o=t[i];if(a!=null){if(a===$b&&r.shape[r.shape.length-1]===1)throw new ve(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){const l=r.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const f=l[c],d=u[c];if(d!=null&&f!==d)throw new ve(`A target Tensor with shape ${r.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function m$(s,e,t,n=!0,i=""){let r;if(Array.isArray(s)){if(s.length!==e.length)throw new ve(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${s.length} Tensors(s).`);r=s}else{if(e.length>1)throw new ve(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(s.shape)}.`);r=[s]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=r[a];if(o.shape.length!==t[a].length)throw new ve(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!n)continue;const u=o.shape[l],c=t[a][l];if(c!=null&&c!==u)throw new ve(`Error when checking ${i}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function zxe(s,e){if(s==null||Array.isArray(s)&&s.length===0)return e.map(n=>[]);let t;if(typeof s=="string"||typeof s=="function")t=[s];else if(Array.isArray(s)||typeof s=="object")t=s;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${s}`);if(Array.isArray(t))return e.map(n=>t);{const n=[];for(const i of e){let r=t.hasOwnProperty(i)?t[i]:[];Array.isArray(r)||(r=[r]),n.push(r)}return n}}const Gxe="layers-model";class Qy extends Xu{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new ve("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Txe(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Axe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Mp))throw new ve("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new ve(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(gI(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ve(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>gI(o))}else{const a=gI(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],xg("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=zxe(e.metrics,this.outputNames),r=(a,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,a])};xg("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;const o=i[a];(u=>{const c="";let f,d,g;for(const x of u){if(typeof x=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(x)!==-1){const b=this.internalOutputShapes[a];b[b.length-1]===1||this.lossFunctions[a]===PM?["accuracy","acc"].indexOf(x)!==-1?d=_V:["crossentropy","ce"].indexOf(x)!==-1&&(d=dxe):this.lossFunctions[a]===nC?["accuracy","acc"].indexOf(x)!==-1?d=pxe:["crossentropy","ce"].indexOf(x)!==-1&&(d=TV):["accuracy","acc"].indexOf(x)!==-1?d=SV:["crossentropy","ce"].indexOf(x)!==-1&&(d=AV);let _;["accuracy","acc"].indexOf(x)!==-1?_="acc":["crossentropy","ce"].indexOf(x)!==-1&&(_="ce"),g=d,f=c+_}else g=Sxe(x),f=c+cw(x);let S;xg(f,()=>{S=g}),r(a,f,S)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const i=n.batchSize==null?32:n.batchSize;yI(i);const a=this.standardizeUserDataXY(e,t,!0,i);try{const o=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,o,i,n.verbose,n.steps);return Qa(u)}finally{Wu(a[0],e),Wu(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Fxe(this,e,t)}checkNumSamples(e,t,n,i="steps"){let r;if(n!=null){if(r=null,t!=null)throw new ve(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new ve(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ve("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),i=n?t:[t],r=this.retrieveSymbolicTensors(i),a=new Hd;if(e instanceof ls&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ve(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new ve(`No value is provided for the model's input ${l.name}`);a.add(l,u)}const o=q1(r,a);return n?o:o[0]}retrieveSymbolicTensors(e){const t=$g(null,e.length);let n=e.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],a=r.map(o=>o.name);for(let o=0;o<e.length;++o){const l=a.indexOf(e[o]);if(l!==-1&&(t[o]=r[l],n--),n===0)break}if(n===0)break}if(n>0){const i=[];throw t.forEach((r,a)=>{r==null&&i.push(e[a])}),new ve(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,n=!1){return we(()=>{const i=this.checkNumSamples(e);if(n)throw new En("Verbose predictLoop() is not implemented yet.");const r=xI(i,t),a=this.outputs.map(o=>[]);for(let o=0;o<r.length;++o)we(()=>{const u=r[o][0],c=r[o][1],f=F1(e,u,c),d=[];if(Array.isArray(f))for(let x=0;x<f.length;++x)d.push({key:this.inputs[x],value:f[x]});else d.push({key:this.inputs[0],value:f});const g=new Hd(d);return q1(this.outputs,g)}).forEach((u,c)=>a[c].push(u));return Qa(a.map(o=>js(o,0)))})}predict(e,t={}){const n=RV(e);m$(n,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return yI(i),this.predictLoop(n,i)}finally{Wu(n,e)}}predictOnBatch(e){m$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,i){if(this.optimizer_==null)throw new iu("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===nC?r.push(o.slice(0,o.length-1).concat([1])):r.push(o)}if(e=p$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=p$(t,this.feedOutputNames,r,!1,"target"),Uxe(e,t),$xe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new ve(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,i,r=!0,a){const[o,l]=this.standardizeUserDataXY(e,t,r,a);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(i!=null){const c=EV(i,this.outputNames);u=[];for(let f=0;f<c.length;++f)u.push(await MV(l[f],null,c[f]))}return[o,l,u]}testLoop(e,t,n,i=0,r){return we(()=>{const a=this.checkNumSamples(t,n,r,"steps"),o=[];if(i>0)throw new En("Verbose mode is not implemented yet.");if(r!=null)throw new En("steps mode in testLoop() is not implemented yet");{const l=xI(a,n),u=mi(rc(0,a));for(let c=0;c<l.length;++c){const f=l[c][0],d=l[c][1],g=vg(u,f,d-f),x=YD(t,g),S=e(x);if(c===0)for(let b=0;b<S.length;++b)o.push(Jt(0));for(let b=0;b<S.length;++b){const _=S[b];o[b]=it(o[b],pe(d-f,_))}}for(let c=0;c<o.length;++c)o[c]=Ut(o[c],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const i=e[n];let r=i;if(QU(e,i)>1){const a=QU(e.slice(0,n),i);r+=`_${a}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const f=[];for(let S=0;S<this.inputs.length;++S)f.push({key:this.inputs[S],value:n[S]});const d=new Hd(f),g=q1(this.outputs,d,{training:!0});let x;for(let S=0;S<this.lossFunctions.length;++S){const b=this.lossFunctions[S];let _=b(i[S],g[S]);r[S]!=null&&(_=Ixe(_,r[S]));const T=pi(_);t.push(T),S===0?x=_:x=it(x,_)}for(let S=0;S<this.metricsTensors.length;++S){let b;if(this.outputs.length>1&&S<this.outputs.length)b=t[S];else{const _=this.metricsTensors[S][0],T=this.metricsTensors[S][1];b=pi(_(i[T],g[T]))}xr(b),a.push(b)}return x=pi(x),this.calculateLosses().forEach(S=>{x=it(x,S)}),x},l=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(o,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>we(()=>{const t=[];let n;const i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:i[u]});const o=new Hd(a),l=q1(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],f=pi(c(r[u],l[u]));u===0?n=f:n=it(n,f),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],f=this.metricsTensors[u][1],d=pi(c(r[f],l[f]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,a,o,l,u,c,f,d;try{const g=n.batchSize==null?32:n.batchSize;yI(g);const S=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,g);i=S[0],r=S[1],d=S[2];let b=!1,_;if(n.validationData!=null&&n.validationData.length>0){if(b=!0,n.validationData.length===2)l=n.validationData[0],u=n.validationData[1];else throw n.validationData.length===3?new En("validationData including sample weights is not supported yet."):new ve(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);const O=await this.standardizeUserData(l,u,null,null,!0,g);c=O[0],f=O[1],_=c.concat(f)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){b=!0;const D=Math.floor(i[0].shape[0]*(1-n.validationSplit)),O=i[0].shape[0];c=F1(i,D,O),a=i,i=F1(i,0,D),f=F1(r,D,O),o=r,r=F1(r,0,D),_=c.concat(f)}else n.validationSteps!=null&&(b=!0);const T=i.concat(r).concat(d);this.checkTrainableWeightsConsistency();const E=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let R,I;b?(this.makeTestFunction(),R=this.testFunction,I=C.slice().concat(C.map(D=>"val_"+D))):(R=null,_=[],I=C.slice());const L=xV(n.callbacks,n.yieldEvery);return await this.fitLoop(E,T,C,g,n.epochs,n.verbose,L,R,_,n.shuffle,I,n.initialEpoch,null,null)}finally{this.isTraining=!1,Wu(i,e),Wu(r,t),Wu(a,e),Wu(o,t),Wu(c,l),Wu(f,u),d!=null&&Bn(d)}}async fitLoop(e,t,n,i,r,a,o,l,u,c,f,d,g,x){i==null&&(i=32),r==null&&(r=1),c==null&&(c=!0),d==null&&(d=0);let S=!1;if(l!=null&&u!=null&&(S=!0),x!=null&&(S=!0,g==null))throw new ve("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(t,i,g,"steps_per_epoch");let _;b!=null&&(_=rc(0,b)),a==null&&(a=1);const{callbackList:T,history:E}=vV(o,a,r,d,b,g,i,S,f);T.setModel(this),this.history=E,await T.onTrainBegin(),this.stopTraining_=!1;for(let C=d;C<r;++C){await T.onEpochBegin(C);const R={};if(g!=null)throw new En("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new En("batch shuffling is not implemneted yet");c&&Doe(_);const I=mi(_),L=xI(b,i);for(let P=0;P<L.length;++P){const D={};if(await T.onBatchBegin(P,D),we(()=>{const O=L[P][0],F=L[P][1],X=vg(I,O,F-O);D.batch=P,D.size=F-O;const q=YD(t,X),J=e(q);for(let Y=0;Y<n.length;++Y){const $=n[Y],W=J[Y];D[$]=W,xr(W)}if(P===L.length-1&&S){const Y=this.testLoop(l,u,i);for(let $=0;$<n.length;++$){const W=n[$],V=Y[$];xr(V),R["val_"+W]=V}}}),await T.onBatchEnd(P,D),yV(D),this.stopTraining_)break}I.dispose()}if(await T.onEpochEnd(C,R),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Bxe(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),i=n[0],r=n[1],o=this.makeTrainFunction()(i.concat(r)),l=[];for(const u of o){const c=await u.data();l.push(c[0])}return Bn(o),Wu(n[0],e),Wu(n[1],t),Qa(l)}getNamedWeights(e){const t=[],n=e!=null&&e.trainableOnly,i=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let a=0;a<i.length;++a)n&&!i[a].trainable||t.push({name:i[a].originalName,tensor:r[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=MU().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-MU().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ef(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ef(t))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const i of t)if(typeof n[i]=="string")e[i]=ef(n[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ef(cw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ef(cw(e)));{const e={};for(const t in this.metrics)e[t]=ef(cw(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=jD(e.optimizer_config),n=mf(t);let i;if(typeof e.loss=="string")i=Qm(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>Qm(a));else if(e.loss!=null){i={};for(const a in e.loss)i[a]=Qm(e.loss[a])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(a=>Qm(a));else if(e.metrics!=null){r={};for(const a in e.metrics)r[a]=Qm(e.metrics[a])}this.compile({loss:i,metrics:r,optimizer:n})}async save(e,t){if(typeof e=="string"){const u=z8(e);if(u.length===0)throw new ve(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new ve(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new ve("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await ID(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:Gxe,generatedBy:`TensorFlow.js tfjs-layers v${CV}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:f}=await ID(await this.optimizer.getWeights(),u);n.specs.push(...f),n.data=P8([n.data,c])}return this.userDefinedMetadata!=null&&(c$(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=n.data,o.weightSpecs=n.specs,e.save(o)}setUserDefinedMetadata(e){c$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Qy.className="Model";rt(Qy);class IV extends Qy{}IV.className="Functional";rt(IV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class zb extends Qy{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:BM("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new ve(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof zb||e instanceof Qy;let n;if(t){if(n=e,n.outputs.length!==1)throw new ve("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new ve("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ve("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=Vye({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new ve(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ve("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=fV(this.outputs[0])}this.inboundNodes=[],new LM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:$g(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(as(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new iu("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new iu("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new iu("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new iu("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},i=!1){let r,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ve("Legacy serialization format not supported yet.");r=t}else K(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof zb))throw new En(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of r){const c=mf(l,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(e){if(this.model==null)throw new ve("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ve("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}zb.className="Sequential";rt(zb);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ia=class extends Kx{getConfig(){return{}}};class DV extends ia{apply(e,t=1){return Mye(e,t)}}DV.className="elu";rt(DV);class OV extends ia{apply(e){return dk(e)}}OV.className="selu";rt(OV);class BV extends ia{apply(e){return xh(e)}}BV.className="relu";rt(BV);class kV extends ia{apply(e){return we(()=>Pg(6,xh(e)))}}kV.className="relu6";rt(kV);class LV extends ia{apply(e){return e}}LV.className="linear";rt(LV);class FV extends ia{apply(e){return ec(e)}}FV.className="sigmoid";rt(FV);class PV extends ia{apply(e){return Rye(e)}}PV.className="hardSigmoid";rt(PV);class UV extends ia{apply(e){return Xx(e)}}UV.className="softplus";rt(UV);class $V extends ia{apply(e){return Nye(e)}}$V.className="softsign";rt($V);class zV extends ia{apply(e){return Fg(e)}}zV.className="tanh";rt(zV);let vL=class extends ia{apply(e,t=-1){return AM(e,t)}};vL.className="softmax";rt(vL);class GV extends ia{apply(e,t=-1){return ik(e,t)}}GV.className="logSoftmax";rt(GV);class HV extends ia{apply(e){return we(()=>we(()=>{const t=Math.sqrt(2),n=pe(.5,it(1,tk(Ut(e,t))));return pe(e,n)}))}}HV.className="gelu";rt(HV);class VV extends ia{apply(e){return we(()=>pe(.5,pe(e,it(1,Fg(pe(Pr(Ut(2,Math.PI)),it(e,pe(.044715,Sf(e,3)))))))))}}VV.className="gelu_new";rt(VV);class WV extends ia{apply(e){return we(()=>pe(e,Fg(Xx(e))))}}WV.className="mish";rt(WV);class XV extends ia{apply(e,t=1){return we(()=>pe(ec(pe(e,t)),e))}}XV.className="swish";rt(XV);function fp(s){return s.getClassName()}function vI(s,e={}){return bS(s,eu.getMap().classNameMap,e,"activation")}function dp(s){if(s==null){const e={};return e.className="linear",e.config={},vI(e)}if(typeof s=="string"){const e={};return e.className=s,e.config={},vI(e)}else return s instanceof ia?s:vI(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hxe(s){if(s!=null&&typeof s!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${s}`)}class qV extends Kx{}class jV extends qV{constructor(e){super(),Hxe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return we(()=>{let t=Qi([1]);return this.hasL1&&(t=it(t,$t(pe(this.l1,Ji(e))))),this.hasL2&&(t=it(t,$t(pe(this.l2,SS(e))))),xe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}jV.className="L1L2";rt(jV);const g$={l1l2:"L1L2"};function Bs(s){return rL(s)}function y$(s,e={}){return bS(s,eu.getMap().classNameMap,e,"regularizer")}function Ks(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in g$?g$[s]:s,config:{}};return y$(t)}else return s instanceof qV?s:y$(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KV extends Ln{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=un(e);let n=xh(e);return this.maxValue!=null&&(n=Lo(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}KV.className="ReLU";rt(KV);class YV extends Ln{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=un(e);return fM(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}YV.className="LeakyReLU";rt(YV);class JV extends Ln{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=qs(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ks(e.alphaRegularizer),this.alphaConstraint=ir(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ve(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=as(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)n[i]=e[i];this.inputSpec=[new tr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=un(e),vM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:si(this.alphaInitializer),alphaRegularizer:Bs(this.alphaRegularizer),alphaConstraint:sr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}JV.className="PReLU";rt(JV);let ZV=class extends Ln{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new En(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=un(e);return dS(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};ZV.className="ELU";rt(ZV);class QV extends Ln{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const n=un(e);return pe(n,Ct(Go(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}QV.className="ThresholdedReLU";rt(QV);class e7 extends Ln{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new vL().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return we(()=>{let n=un(e);const i=t.mask;if(i!=null){const r=pe(wt(Mo(n.shape),Ct(i,n.dtype)),Jt(-1e9));n=it(n,r)}return this.axis instanceof Array?this.axis.length>1?Fo(wt(n,pM(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}e7.className="Softmax";rt(e7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ex(s,e,t){if(typeof s=="number")return $g(s,e);if(s.length!==e)throw new ve(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${s.length} elements.`);for(let n=0;n<e;++n){const i=s[n];if(!Tye(i))throw new ve(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(s)} including a non-integer number ${i}`)}return s}function tc(s,e,t,n,i=1){if(s==null)return s;const r=e+(e-1)*(i-1);let a;return t==="same"?a=s:a=s-r+1,Math.floor((a+n-1)/n)}function Jc(s,e,t,n){if(s==null)return null;if(n==="valid")s=s*e+hp([t-e,0]);else if(n==="same")s=s*e;else throw new ve(`Unsupport padding mode: ${n}.`);return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bL(s,e){return we(()=>(Ii(e),e==="channelsFirst"?jn(s,[0,2,3,1]):s))}function t7(s,e){return we(()=>(Ii(e),e==="channelsFirst"?jn(s,[0,2,3,4,1]):s))}function Vxe(s,e,t,n=1,i="valid",r,a=1){return we(()=>{if(r==null&&(r=ac()),Ii(r),s.shape.length!==3)throw new ve(`The input of a conv1dWithBias operation should be 3, but is ${s.shape.length} instead.`);if(e.shape.length!==3)throw new ve(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ve(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(r==="channelsFirst"&&(s=jn(s,[0,2,1])),i==="causal")throw new En("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=YB(s,e,n,i==="same"?"same":"valid","NWC",a);return t!=null&&(o=hc(o,t)),o})}function x$(s,e,t,n=[1,1],i="valid",r,a,o=null){return we(()=>{if(r==null&&(r=ac()),Ii(r),s.rank!==3&&s.rank!==4)throw new ve(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${s.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ve(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${s.rank}.`);let l=bL(s,r);if(i==="causal")throw new En("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=qG({x:l,filter:e,strides:n,pad:i==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),r==="channelsFirst"&&(l=jn(l,[0,3,1,2])),l})}function Wxe(s,e,t,n=[1,1,1],i="valid",r,a){return we(()=>{if(r==null&&(r=ac()),Ii(r),s.rank!==4&&s.rank!==5)throw new ve(`conv3dWithBias expects input to be of rank 4 or 5, but received ${s.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ve(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${s.rank}.`);let o=t7(s,r);if(i==="causal")throw new En("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=dG(o,e,n,i==="same"?"same":"valid","NDHWC",a),t!=null&&(o=hc(o,t)),r==="channelsFirst"&&(o=jn(o,[0,4,1,2,3])),o})}class UM extends Ln{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",UM.verifyArgs(t),this.rank=e,vr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new En(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ex(t.kernelSize,e,"kernelSize"),this.strides=ex(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,wl(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ii(this.dataFormat),this.activation=dp(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=qs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ir(t.biasConstraint),this.biasRegularizer=Ks(t.biasRegularizer),this.activityRegularizer=Ks(t.activityRegularizer),this.dilationRate=ex(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ve(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ve(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ve(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Yc("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!aL(e.kernelSize,"number",1,3))throw new ve(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:fp(this.activation),useBias:this.useBias,biasInitializer:si(this.biasInitializer),biasRegularizer:Bs(this.biasRegularizer),activityRegularizer:Bs(this.activityRegularizer),biasConstraint:sr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Yx extends UM{constructor(e,t){super(e,t),this.kernel=null,Yx.verifyArgs(t),this.filters=t.filters,vr(this.filters,"filters"),this.kernelInitializer=qs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ir(t.kernelConstraint),this.kernelRegularizer=Ks(t.kernelRegularizer)}build(e){e=as(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ve(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],i=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return we(()=>{e=un(e);let n;const i=this.bias==null?null:this.bias.read(),r=JH(this.activation.getClassName());if(r!=null&&this.rank===2)n=x$(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)n=Vxe(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=x$(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=Wxe(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new En("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=as(e);const t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const a=tc(n[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);t.push(a)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:si(this.kernelInitializer),kernelRegularizer:Bs(this.kernelRegularizer),kernelConstraint:sr(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ve(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class CS extends Yx{constructor(e){super(2,e),CS.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!aL(e.kernelSize,"number",1,2))throw new ve(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}CS.className="Conv2D";rt(CS);class ES extends Yx{constructor(e){super(3,e),ES.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ve(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}ES.className="Conv3D";rt(ES);class n7 extends CS{constructor(e){if(super(e),this.inputSpec=[new tr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ve(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=as(e),e.length!==4)throw new ve("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ve("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new tr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return we(()=>{let n=un(e);if(n.shape.length!==4)throw new ve(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const i=n.shape,r=i[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const l=i[a],u=i[o],c=this.kernelSize[0],f=this.kernelSize[1],d=this.strides[0],g=this.strides[1],x=Jc(l,d,c,this.padding),S=Jc(u,g,f,this.padding),b=[r,x,S,this.filters];this.dataFormat!=="channelsLast"&&(n=jn(n,[0,2,3,1]));let _=ZB(n,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=jn(_,[0,3,1,2])),this.bias!=null&&(_=hc(_,this.bias.read(),this.dataFormat)),this.activation!=null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=as(e);const t=e.slice();let n,i,r;this.dataFormat==="channelsFirst"?(n=1,i=2,r=3):(n=3,i=1,r=2);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[i]=Jc(t[i],l,a,this.padding),t[r]=Jc(t[r],u,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}n7.className="Conv2DTranspose";rt(n7);class s7 extends ES{constructor(e){if(super(e),this.inputSpec=[new tr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ve(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=as(e),e.length!==5)throw new ve("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ve("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new tr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return we(()=>{let n=un(e);if(n.shape.length!==5)throw new ve(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const i=n.shape,r=i[0];let a,o,l;this.dataFormat==="channelsFirst"?(l=2,a=3,o=4):(l=1,a=2,o=3);const u=i[l],c=i[a],f=i[o],d=this.kernelSize[0],g=this.kernelSize[1],x=this.kernelSize[2],S=this.strides[0],b=this.strides[1],_=this.strides[2],T=Jc(u,S,d,this.padding),E=Jc(c,b,g,this.padding),C=Jc(f,_,x,this.padding),R=[r,T,E,C,this.filters];this.dataFormat!=="channelsLast"&&(n=jn(n,[0,2,3,4,1]));let I=mG(n,this.kernel.read(),R,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=jn(I,[0,4,1,2,3])),this.bias!==null&&(I=hc(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=as(e);const t=e.slice();let n,i,r,a;this.dataFormat==="channelsFirst"?(n=1,i=2,r=3,a=4):(n=4,i=1,r=2,a=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],f=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[i]=Jc(t[i],c,o,this.padding),t[r]=Jc(t[r],f,l,this.padding),t[a]=Jc(t[a],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}s7.className="Conv3DTranspose";rt(s7);class i7 extends Yx{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ve("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ve("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ve(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=qs(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ks(t.depthwiseRegularizer),this.depthwiseConstraint=ir(t.depthwiseConstraint),this.pointwiseInitializer=qs(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ks(t.pointwiseRegularizer),this.pointwiseConstraint=ir(t.pointwiseConstraint)}build(e){if(e=as(e),e.length<this.rank+2)throw new ve(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ve(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],i=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new tr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return we(()=>{e=un(e);let n;if(this.rank===1)throw new En("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=jn(e,[0,2,3,1])),n=pk(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=hc(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=jn(n,[0,3,1,2])),n})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=si(this.depthwiseInitializer),e.pointwiseInitializer=si(this.pointwiseInitializer),e.depthwiseRegularizer=Bs(this.depthwiseRegularizer),e.pointwiseRegularizer=Bs(this.pointwiseRegularizer),e.depthwiseConstraint=sr(this.depthwiseConstraint),e.pointwiseConstraint=sr(this.pointwiseConstraint),e}}i7.className="SeparableConv";class r7 extends i7{constructor(e){super(2,e)}}r7.className="SeparableConv2D";rt(r7);class $M extends Yx{constructor(e){super(1,e),$M.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!aL(e.kernelSize,"number",1,1))throw new ve(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}$M.className="Conv1D";rt($M);class a7 extends Ln{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return we(()=>{if(e=un(e),this.dataFormat==="channelsLast"){const n=uw(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return uw(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const n=uw(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return uw(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}a7.className="Cropping2D";rt(a7);class o7 extends Ln{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ii(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,_ye(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{const t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return we(()=>{let n=un(e);const i=n.shape;if(this.dataFormat==="channelsFirst"){n=jn(n,[0,2,3,1]);const r=this.size[0]*i[2],a=this.size[1]*i[3],o=this.interpolation==="nearest"?pl.resizeNearestNeighbor(n,[r,a]):pl.resizeBilinear(n,[r,a]);return jn(o,[0,3,1,2])}else{const r=this.size[0]*i[1],a=this.size[1]*i[2];return this.interpolation==="nearest"?pl.resizeNearestNeighbor(n,[r,a]):pl.resizeBilinear(n,[r,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}o7.className="UpSampling2D";rt(o7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xxe(s,e,t=[1,1],n="valid",i,r){return we(()=>{i==null&&(i=ac()),Ii(i);let a=bL(s,i);if(s.rank!==4)throw new ve(`Input for depthwiseConv2d is required to be 4-D, but is instead ${s.rank}-D`);if(e.rank!==4)throw new ve(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=fS(a,e,t,n==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(a=jn(a,[0,3,1,2])),a})}class l7 extends UM{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=qs(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ir(e.depthwiseConstraint),this.depthwiseRegularizer=Ks(e.depthwiseRegularizer)}build(e){if(e=as(e),e.length<4)throw new ve(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ve(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],i=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return we(()=>{e=un(e);let n=Xxe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=hc(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=as(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=tc(t,this.kernelSize[0],this.padding,this.strides[0]),a=tc(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,r,a]:[e[0],r,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=si(this.depthwiseInitializer),e.depthwiseRegularizer=Bs(this.depthwiseRegularizer),e.depthwiseConstraint=sr(this.depthwiseRegularizer),e}}l7.className="DepthwiseConv2D";rt(l7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function u7(s,e,t,n){if(Array.isArray(s)){if(e!=null||t!=null)throw new ve("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=s.slice(s.length-n,s.length),s=s.slice(0,s.length-n)),s.length>1&&(e=s.slice(1,s.length)),s=s[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return e=i(e),t=i(t),{inputs:s,initialState:e,constants:t}}function c7(s,e,t,n=!1,i,r,a=!1,o=!1){return we(()=>{const l=e.shape.length;if(l<3)throw new ve(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(rc(2,l));e=jn(e,u),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Ct(Ct(i,"bool"),"float32"),i.rank===l-1&&(i=Sa(i,-1)),i=jn(i,u)),n&&(e=cu(e,0),i!=null&&(i=cu(i,0)));const c=[];let f,d=t;const g=e.shape[0],x=hu(e);let S;i!=null&&(S=hu(i));for(let _=0;_<g;++_){const T=x[_],E=we(()=>s(T,d));if(i==null)f=E[0],d=E[1];else{const C=we(()=>{const R=S[_],I=wt(Al(R),R),L=it(pe(E[0],R),pe(d[0],I)),P=d.map((D,O)=>it(pe(E[1][O],R),pe(D,I)));return{output:L,newStates:P}});f=C.output,d=C.newStates}o&&c.push(f)}let b;return o&&(b=Po(c,1)),[f,b,d]})}class Np extends Ln{constructor(e){super(e);let t;if(e.cell==null)throw new ve("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new AL({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ve("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new tr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return rc(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){WD(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let i;if(this.returnSequences?i=[e[0],e[1],n]:i=[e[0],n],this.returnState){const r=[];for(const a of t)r.push([e[0],a]);return[i].concat(r)}else return i}computeMask(e,t){return we(()=>{Array.isArray(t)&&(t=t[0]);const n=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(r=>null);return[n].concat(i)}else return n})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new En("Constants support is not implemented in RNN yet.");WD(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new tr({shape:[t,null,...n]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!Wn(this.stateSpec.map(a=>a.shape[a.shape.length-1]),r))throw new ve(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(a=>new tr({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){we(()=>{if(!this.stateful)throw new Kc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(n==null)throw new ve("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Qi([n,i])):this.states_=[Qi([n,this.cell.stateSize])];else if(e==null)Bn(this.states_),this.keptStates!=null&&(Bn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Qi([n,i])):this.states_[0]=Qi([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ve(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Bn(this.states_);for(let i=0;i<this.states_.length;++i){const r=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[n,a];if(!Wn(r.shape,o))throw new ve(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>xr(i.clone()))})}apply(e,t){let n=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=u7(e,n,i,this.numConstants);e=r.inputs,n=r.initialState,i=r.constants;let a=[],o=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const u of n)this.stateSpec.push(new tr({shape:u.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(t.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof ph){const u=[e].concat(a),c=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=f,d}else return super.apply(e,t)}call(e,t){return we(()=>{const n=t==null?null:t.mask,i=t==null?null:t.training;let r=t==null?null:t.initialState;e=un(e),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==a)throw new ve(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},u=c7((x,S)=>{const b=this.cell.call([x].concat(S),o);return[b[0],b.slice(1)]},e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=u[0],f=u[1],d=u[2];this.stateful&&this.resetStates(d,i);const g=this.returnSequences?f:c;return this.returnState?[g].concat(d):g})}getInitialState(e){return we(()=>{let t=Qi(e.shape);return t=$t(t,[1,2]),t=_S(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?HD(t,[1,n]):t):this.cell.stateSize>1?[HD(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Np.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const i=t.cell,r=mf(i,n);return new e(Object.assign(t,{cell:r}))}}Np.className="RNN";rt(Np);class zM extends Ln{}class _L extends zM{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vr(this.units,"units"),this.activation=dp(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=qs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ks(e.kernelRegularizer),this.recurrentRegularizer=Ks(e.recurrentRegularizer),this.biasRegularizer=Ks(e.biasRegularizer),this.kernelConstraint=ir(e.kernelConstraint),this.recurrentConstraint=ir(e.recurrentConstraint),this.biasConstraint=ir(e.biasConstraint),this.dropout=Cx([1,hp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Cx([1,hp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=as(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return we(()=>{if(e=e,e.length!==2)throw new ve(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pp({ones:()=>Al(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pp({ones:()=>Al(n),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?r=uh(pe(e,a),this.kernel.read()):r=uh(e,this.kernel.read()),this.bias!=null&&(r=hc(r,this.bias.read())),o!=null&&(n=pe(n,o));let l=it(r,uh(n,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:fp(this.activation),useBias:this.useBias,kernelInitializer:si(this.kernelInitializer),recurrentInitializer:si(this.recurrentInitializer),biasInitializer:si(this.biasInitializer),kernelRegularizer:Bs(this.kernelRegularizer),recurrentRegularizer:Bs(this.recurrentRegularizer),biasRegularizer:Bs(this.biasRegularizer),activityRegularizer:Bs(this.activityRegularizer),kernelConstraint:sr(this.kernelConstraint),recurrentConstraint:sr(this.recurrentConstraint),biasConstraint:sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}_L.className="SimpleRNNCell";rt(_L);class h7 extends Np{constructor(e){e.cell=new _L(e),super(e)}call(e,t){return we(()=>{this.cell.dropoutMask!=null&&(Bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:i,initialState:r})})}static fromConfig(e,t){return new e(t)}}h7.className="SimpleRNN";rt(h7);class SL extends zM{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ve("GRUCell does not support reset_after parameter set to true.");this.units=e.units,vr(this.units,"units"),this.activation=dp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=qs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ks(e.kernelRegularizer),this.recurrentRegularizer=Ks(e.recurrentRegularizer),this.biasRegularizer=Ks(e.biasRegularizer),this.kernelConstraint=ir(e.kernelConstraint),this.recurrentConstraint=ir(e.recurrentConstraint),this.biasConstraint=ir(e.biasConstraint),this.dropout=Cx([1,hp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Cx([1,hp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=as(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return we(()=>{if(e=e,e.length!==2)throw new ve(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pp({ones:()=>Al(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pp({ones:()=>Al(i),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(e=pe(e,r[0]));let c=uh(e,this.kernel.read());this.useBias&&(c=hc(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=pe(i,a[0]));const f=this.recurrentKernel.read(),[d,g]=Oo(f,[2*this.units,this.units],f.rank-1),x=uh(i,d),[S,b,_]=Oo(c,3,c.rank-1),[T,E]=Oo(x,2,x.rank-1);o=this.recurrentActivation.apply(it(S,T)),l=this.recurrentActivation.apply(it(b,E));const C=uh(pe(l,i),g);u=this.activation.apply(it(_,C));const R=it(pe(o,i),pe(it(1,Hs(o)),u));return[R,R]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:fp(this.activation),recurrentActivation:fp(this.recurrentActivation),useBias:this.useBias,kernelInitializer:si(this.kernelInitializer),recurrentInitializer:si(this.recurrentInitializer),biasInitializer:si(this.biasInitializer),kernelRegularizer:Bs(this.kernelRegularizer),recurrentRegularizer:Bs(this.recurrentRegularizer),biasRegularizer:Bs(this.biasRegularizer),activityRegularizer:Bs(this.activityRegularizer),kernelConstraint:sr(this.kernelConstraint),recurrentConstraint:sr(this.recurrentConstraint),biasConstraint:sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}SL.className="GRUCell";rt(SL);class f7 extends Np{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new SL(e),super(e)}call(e,t){return we(()=>{this.cell.dropoutMask!=null&&(Bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}f7.className="GRU";rt(f7);class GM extends zM{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vr(this.units,"units"),this.activation=dp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=qs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Ks(e.kernelRegularizer),this.recurrentRegularizer=Ks(e.recurrentRegularizer),this.biasRegularizer=Ks(e.biasRegularizer),this.kernelConstraint=ir(e.kernelConstraint),this.recurrentConstraint=ir(e.recurrentConstraint),this.biasConstraint=ir(e.biasConstraint),this.dropout=Cx([1,hp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Cx([1,hp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=as(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,a=this.units;i=new(t=class extends mu{apply(l,u){const c=r.apply([a]),f=new lL().apply([a]),d=r.apply([a*2]);return t$(t$(c,f),d)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return we(()=>{const n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ve(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pp({ones:()=>Al(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pp({ones:()=>Al(i),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,f;0<this.dropout&&this.dropout<1&&(e=pe(e,a[0]));let d=uh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=pe(i,o[0])),d=it(d,uh(i,this.recurrentKernel.read())),this.useBias&&(d=hc(d,this.bias.read()));const[g,x,S,b]=Oo(d,4,d.rank-1);l=this.recurrentActivation.apply(g),u=this.recurrentActivation.apply(x),c=it(pe(u,r),pe(l,this.activation.apply(S))),f=this.recurrentActivation.apply(b);const _=pe(f,this.activation.apply(c));return[_,_,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:fp(this.activation),recurrentActivation:fp(this.recurrentActivation),useBias:this.useBias,kernelInitializer:si(this.kernelInitializer),recurrentInitializer:si(this.recurrentInitializer),biasInitializer:si(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Bs(this.kernelRegularizer),recurrentRegularizer:Bs(this.recurrentRegularizer),biasRegularizer:Bs(this.biasRegularizer),activityRegularizer:Bs(this.activityRegularizer),kernelConstraint:sr(this.kernelConstraint),recurrentConstraint:sr(this.recurrentConstraint),biasConstraint:sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}GM.className="LSTMCell";rt(GM);class d7 extends Np{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GM(e),super(e)}call(e,t){return we(()=>{this.cell.dropoutMask!=null&&(Bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}d7.className="LSTM";rt(d7);class AL extends zM{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return we(()=>{e=e;let n=e.slice(1);const i=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?i.push(n.splice(0,o.stateSize.length)):i.push(n.splice(0,1));i.reverse();const r=[];let a;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];n=i[o],o===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=l.call(a,t),r.push(a.slice(1))}n=[];for(const o of r.slice().reverse())n.push(...o);return[a[0]].concat(n)})}build(e){WD(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,i)=>{xg(`RNNCell_${i}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,n={}){const i=[];for(const r of t.cells)i.push(mf(r,n));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return XD(e)}setWeights(e){const t=[];for(const n of this.cells){const i=n.weights.length,r=e.splice(i);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],r[a]])}mL(t)}}AL.className="StackedRNNCells";rt(AL);function pp(s){const{ones:e,rate:t,training:n=!1,count:i=1,dropoutFunc:r}=s,a=()=>r!=null?r(e(),t):iV(e(),t),o=()=>AS(a,e,n);return!i||i<=1?xr(o().clone()):Array(i).fill(void 0).map(o).map(u=>xr(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var qxe=function(s,e){var t={};for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&e.indexOf(n)<0&&(t[n]=s[n]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,n=Object.getOwnPropertySymbols(s);i<n.length;i++)e.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(s,n[i])&&(t[n[i]]=s[n[i]]);return t};class p7 extends Np{constructor(e){if(e.unroll)throw new En("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new En("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new tr({ndim:5})]}call(e,t){return we(()=>{if(this.cell.dropoutMask!=null&&(Bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ve("ConvRNN2D cell does not support constants");const n=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:i,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return we(()=>{const{stateSize:t}=this.cell,n=e.shape,i=this.computeSingleOutputShape(n),r=[i[0],...i.slice(2)],a=Qi(r);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){we(()=>{if(!this.stateful)throw new Kc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,i=this.computeSingleOutputShape(n),r=[i[0],...i.slice(2)];if(n[0]==null)throw new ve("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Qi(r)):this.states_=[Qi(r)];else if(e==null)Bn(this.states_),this.keptStates!=null&&(Bn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Qi(r)):this.states_[0]=Qi(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ve(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Bn(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],u=r;if(!Wn(l.shape,u))throw new ve(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>xr(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:i,padding:r,strides:a,dilationRate:o}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],f=tc(u,i[0],r,a[0],o[0]),d=tc(c,i[1],r,a[1],o[1]);return[...e.slice(0,2),...l?[n,f,d]:[f,d,n]]}}p7.className="ConvRNN2D";class TL extends GM{constructor(e){const{filters:t,kernelSize:n,strides:i,padding:r,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,vr(this.filters,"filters"),this.kernelSize=ex(n,2,"kernelSize"),this.kernelSize.forEach(l=>vr(l,"kernelSize")),this.strides=ex(i||1,2,"strides"),this.strides.forEach(l=>vr(l,"strides")),this.padding=r||"valid",wl(this.padding),this.dataFormat=a||"channelsLast",Ii(this.dataFormat),this.dilationRate=ex(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>vr(l,"dilationRate"))}build(e){var t;e=as(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ve(`The channel dimension of the input should be defined. Found ${e[n]}`);const i=e[n],r=4,a=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends mu{apply(d,g){const x=u.apply([c]),S=Mo([c]),b=u.apply([c*2]);return oL([x,S,b])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return we(()=>{if(e.length!==3)throw new ve(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,i=e[0],r=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pp({ones:()=>Al(i),rate:this.dropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(G,ne,oe)=>!ne||!ne[oe]?G:pe(ne[oe],G);let c=u(i,l,0),f=u(i,l,1),d=u(i,l,2),g=u(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pp({ones:()=>Al(r),rate:this.recurrentDropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));const x=this.recurrentDropoutMask;let S=u(r,x,0),b=u(r,x,1),_=u(r,x,2),T=u(r,x,3);const E=3,[C,R,I,L]=Oo(this.kernel.read(),o,E),[P,D,O,F]=this.useBias?Oo(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,C,P,this.padding),f=this.inputConv(f,R,D,this.padding),d=this.inputConv(d,I,O,this.padding),g=this.inputConv(g,L,F,this.padding);const[X,q,J,Y]=Oo(this.recurrentKernel.read(),o,E);S=this.recurrentConv(S,X),b=this.recurrentConv(b,q),_=this.recurrentConv(_,J),T=this.recurrentConv(T,Y);const $=this.recurrentActivation.apply(it(c,S)),W=this.recurrentActivation.apply(it(f,b)),V=it(pe(W,a),pe($,this.activation.apply(it(d,_)))),se=pe(this.recurrentActivation.apply(it(g,T)),this.activation.apply(V));return[se,se,V]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=qxe(e,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),i)}inputConv(e,t,n,i){const r=cp(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?hc(r,n,this.dataFormat):r}recurrentConv(e,t){return cp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}TL.className="ConvLSTM2DCell";rt(TL);class m7 extends p7{constructor(e){const t=new TL(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}m7.className="ConvLSTM2D";rt(m7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wL extends Ln{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,n=[];for(let i=0;i<this.noiseShape.length;++i)n.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return n}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,r=this.getNoiseShape(n);return AS(()=>iV(n,this.rate,r,this.seed),()=>n,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}wL.className="Dropout";rt(wL);class g7 extends wL{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}g7.className="SpatialDropout1D";rt(g7);class y7 extends Ln{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,vr(this.units,"units"),this.activation=dp(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=qs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=qs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ir(e.kernelConstraint),this.biasConstraint=ir(e.biasConstraint),this.kernelRegularizer=Ks(e.kernelRegularizer),this.biasRegularizer=Ks(e.biasRegularizer),this.activityRegularizer=Ks(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=as(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=as(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e),i=JH(this.activation.getClassName());let r;return i!=null?r=uh(n,this.kernel.read(),i,this.bias?this.bias.read():null):(r=uh(n,this.kernel.read()),this.bias!=null&&(r=hc(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:fp(this.activation),useBias:this.useBias,kernelInitializer:si(this.kernelInitializer),biasInitializer:si(this.biasInitializer),kernelRegularizer:Bs(this.kernelRegularizer),biasRegularizer:Bs(this.biasRegularizer),activityRegularizer:Bs(this.activityRegularizer),kernelConstraint:sr(this.kernelConstraint),biasConstraint:sr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}y7.className="Dense";rt(y7);class x7 extends Ln{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=as(e);for(const t of e.slice(1))if(t==null)throw new ve(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Qd(e,1)]}call(e,t){return we(()=>{this.invokeCallHook(e,t);let n=un(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){const i=[0];for(let r=2;r<n.rank;++r)i.push(r);i.push(1),n=jn(n,i)}return Eye(n)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}x7.className="Flatten";rt(x7);class v7 extends Ln{constructor(e){super(e),this.supportsMasking=!0,this.activation=dp(e.activation)}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e);return this.activation.apply(n)})}getConfig(){const e={activation:fp(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}v7.className="Activation";rt(v7);class b7 extends Ln{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return we(()=>(e=un(e),wye(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}b7.className="RepeatVector";rt(b7);class _7 extends Ln{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",i=t.slice();let r=1,a=null;for(let l=0;l<i.length;++l){const u=i[l];if(this.isUnknown(u))if(a===null)a=l;else throw new ve("Can only specifiy one unknown dimension.");else r*=u}const o=Qd(e);if(a!==null){if(r===0||o%r!==0)throw new ve(n);i[a]=o/r}else if(o!==r)throw new ve(n);return i}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e),i=n.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return xe(n,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}_7.className="Reshape";rt(_7);class S7 extends Ln{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=rc(1,e.dims.length+1);if(!Wn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new tr({ndim:this.dims.length+1})]}computeOutputShape(e){e=as(e);const t=e.slice();return this.dims.forEach((n,i)=>{t[i+1]=e[n]}),t}call(e,t){return jn(un(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}S7.className="Permute";rt(S7);class A7 extends Ln{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=un(e);return K2(Tx(n,this.maskValue),-1)}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e),a=K2(Tx(n,this.maskValue),-1,!0);return pe(n,Ct(a,n.dtype))})}}A7.className="Masking";rt(A7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class T7 extends Ln{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(vs(e.inputLength))}this.inputDim=e.inputDim,vr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,vr(this.outputDim,"outputDim"),this.embeddingsInitializer=qs(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ks(e.embeddingsRegularizer),this.activityRegularizer=Ks(e.activityRegularizer),this.embeddingsConstraint=ir(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return we(()=>this.maskZero?(e=un(e),Tx(e,Kn(e))):null)}computeOutputShape(e){if(e=as(e),this.inputLength==null)return[...e,this.outputDim];const t=vs(this.inputLength);if(t.length!==e.length-1)throw new ve(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let i=0;i<t.length;++i){const r=t[i],a=e[i+1];if(r!=null&&a!=null&&r!==a)throw new ve(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return we(()=>{this.invokeCallHook(e,t);let n=un(e);n.dtype!=="int32"&&(n=lh(n,"int32"));const i=sV(this.embeddings.read(),xe(n,[n.size]));return xe(i,as(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:si(this.embeddingsInitializer),embeddingsRegularizer:Bs(this.embeddingsRegularizer),activityRegularizer:Bs(this.activityRegularizer),embeddingsConstraint:sr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}T7.className="Embedding";rt(T7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class s0 extends Ln{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new En}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const n=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const r=e[e.length-t.length+i],a=t[i];if(r==null||a==null||r<0||a<0)n.push(null);else if(r===1)n.push(a);else if(a===1)n.push(r);else{if(r!==a)throw new ve("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[as(e)]),e=e,e.length<2)throw new ve(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=Zd(t),t.length>1)throw new ve(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}const i=e.map(r=>r.length);e.indexOf(null)===-1&&Zd(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return we(()=>{if(e=e,this.reshapeRequired){const n=[],i=e.map(r=>r.rank);if(i.indexOf(null)===-1){const r=hp(i);for(let a of e){const o=a.rank;for(let l=0;l<r-o;++l)a=_S(a,1);n.push(a)}return this.mergeFunction(n)}else{let r=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,f=c[0],d=c.slice(1).concat([f]);let g=xe(l,[f].concat(Qd(c.slice(1))));g=jn(g,[1,0]),g=xe(g,d),n.push(g),r=!0}else if(u>1){const c=rc(1,u).concat([0]);n.push(jn(l,c)),r=!0}else n.push(l)}let a=this.mergeFunction(n);const o=a.rank;if(r){if(o==null){const l=a.shape,u=l.length,c=l[u-1],f=[c].concat(l.slice(0,l.length-1));a=xe(jn(xe(a,[-1,c]),[1,0]),f)}else if(o>1){const l=[o-1].concat(rc(0,o-1));a=jn(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const r=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const i of e)i!=null&&i[0]!==null&&n.push(i[0]);return n=Zd(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return we(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ve("`mask` should be an Array");if(!Array.isArray(e))throw new ve("`inputs` should be an Array");if(t.length!==e.length)throw new ve(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:Sa(i,0));let n=t[0];for(let i=1;i<t.length-1;++i)n=dh(n,t[i]);return n})}}class w7 extends s0{constructor(e){super(e)}mergeFunction(e){return we(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=it(t,e[n]);return t})}}w7.className="Add";rt(w7);class C7 extends s0{constructor(e){super(e)}mergeFunction(e){return we(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=pe(t,e[n]);return t})}}C7.className="Multiply";rt(C7);class E7 extends s0{constructor(e){super(e)}mergeFunction(e){return we(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=it(t,e[n]);return pe(1/e.length,t)})}}E7.className="Average";rt(E7);class M7 extends s0{constructor(e){super(e)}mergeFunction(e){return we(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Rf(t,e[n]);return t})}}M7.className="Maximum";rt(M7);class N7 extends s0{constructor(e){super(e)}mergeFunction(e){return we(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Pg(t,e[n]);return t})}}N7.className="Minimum";rt(N7);class R7 extends s0{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ve("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const n=[];for(let i=0;i<e.length;++i){const r=e[i].slice();r.splice(this.axis,1);let a=!1;for(const o of n)if(Wn(o,r)){a=!0;break}a||n.push(r)}if(n.length>1)throw new ve("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return we(()=>oL(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ve("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),i=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(n[i]==null||r[i]==null){n[i]=null;break}n[i]+=r[i]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ve("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ve("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ve(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return we(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;const i=[];for(let a=0;a<e.length;++a)t[a]==null?i.push(Ct(Al(e[a]),"bool")):t[a].rank<e[a].rank?i.push(Sa(t[a],-1)):i.push(t[a]);const r=js(i,this.axis);return jB(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}R7.className="Concatenate";rt(R7);function P1(s,e){for(;s<0;)s+=e;return s}function jxe(s,e,t){if(s.shape.length>3||e.shape.length>3)throw new En("batchDot is not implemented for tensors of 4D or higher rank yet");if(K(s.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${s.shape.length}`),K(s.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),s.dtype==="complex64"||e.dtype==="complex64")throw new En("batchDot is not implemented for complex64-type Tensors yet.");const n=s.shape.length,i=e.shape.length;t==null&&(t=[n-1,i-2]);const r=t;return we(()=>{let a;if(n>i){a=n-i;const l=[];for(let u=0;u<a;++u)l.push(1);e=xe(e,e.shape.concat(l))}else if(i>n){a=i-n;const l=[];for(let u=0;u<a;++u)l.push(1);s=xe(s,s.shape.concat(l))}else a=0;let o;if(s.shape.length===2&&e.shape.length===2)r[0]===r[1]?o=$t(pe(s,e),r[0]):o=$t(pe(jn(s,[1,0]),e),r[1]);else{const l=r[0]!==s.shape.length-1,u=r[1]===e.shape.length-1;o=Un(s,e,l,u)}if(a>0){let l;n>i?l=n+i-3:l=n-1;const u=[];for(let c=l;c<l+a;++c)u.push(c);o=e0(o,u)}return o.shape.length===1&&(o=Sa(o,1)),o})}class I7 extends s0{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){K(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new En("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,n);if(t[i[0]]!==n[i[1]])throw new ve(`Dimension incompatibility: ${t[i[0]]} !== ${n[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ve(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,a)=>P1(r,e[a].shape.length)):i=[P1(this.axes,t.shape.length),P1(this.axes,n.shape.length)],this.normalize&&(t=tC(t,i[0]),n=tC(n,i[1])),jxe(t,n,i)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[P1(this.axes,e.length),P1(this.axes,t.length)],n}computeOutputShape(e){K(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new En("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,n);t.splice(i[0],1),n.splice(i[1],1),n.splice(0,1);const r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}I7.className="Dot";rt(I7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class D7 extends Ln{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e);return AS(()=>it(kM(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}D7.className="GaussianNoise";rt(D7);class O7 extends Ln{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return we(()=>{this.invokeCallHook(e,t);const n=un(e);return this.rate>0&&this.rate<1?AS(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return pe(n,kM(n.shape,1,r))},()=>n,t.training||!1):n})}}O7.className="GaussianDropout";rt(O7);class B7 extends Ln{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||un(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return we(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return AS(()=>{const r=un(e),o=-1.6732632423543772*1.0507009873554805;let l=Cp(Qg(n),this.rate);l=lh(l,"float32");const u=((1-this.rate)*(1+this.rate*o**2))**-.5,c=-u*o*this.rate,f=it(pe(r,l),pe(it(l,-1),o));return it(pe(f,u),c)},()=>un(e),t.training||!1)}return e})}}B7.className="AlphaDropout";rt(B7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gb(s,e,t,n,i,r=.001){let a;if(s.rank===2)a=rG(s,e,t,n,i,r);else if(s.rank===3)a=aG(s,e,t,n,i,r);else if(s.rank===4)a=oG(s,e,t,n,i,r);else throw new En(`batchNormalization is not implemented for array of rank ${s.rank} yet`);return a}function Kxe(s,e,t,n,i=.001){return we(()=>{const r=yM(s,n),a=r.mean,o=r.variance;return[Gb(s,a,o,t,e,i),a,o]})}function Yxe(s,e,t,n,i=.001){return we(()=>{const r=yM(s,n),a=r.mean,o=r.variance,l=[];for(const x of rc(0,s.rank))n.indexOf(x)!==-1?l.push(1):l.push(s.shape[x]);const u=xe(a,l),c=xe(o,l),f=e==null?null:xe(e,l),d=t==null?null:xe(t,l);return[Gb(s,u,c,d,f,i),a,o]})}function Jxe(s,e,t,n,i=.001){return Wn(n.slice().sort(),rc(0,s.rank-1))?Kxe(s,e,t,n,i):Yxe(s,e,t,n,i)}class k7 extends Ln{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=qs(e.betaInitializer||"zeros"),this.gammaInitializer=qs(e.gammaInitializer||"ones"),this.movingMeanInitializer=qs(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=qs(e.movingVarianceInitializer||"ones"),this.betaConstraint=ir(e.betaConstraint),this.gammaConstraint=ir(e.gammaConstraint),this.betaRegularizer=Ks(e.betaRegularizer),this.gammaRegularizer=Ks(e.gammaRegularizer)}build(e){e=as(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new ve(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new tr({ndim:e.length,axes:{[t]:n}})];const i=[n];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return we(()=>{const n=t.training==null?!1:t.training,i=un(e),r=i.shape,a=r.length,o=rc(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const u=$g(1,a);u[l]=r[l];const c=o.slice();c.sort();const f=!Wn(c,rc(0,a).slice(0,a-1)),d=()=>{if(f){const T=xe(this.movingMean.read(),u),E=xe(this.movingVariance.read(),u),C=this.center?xe(this.beta.read(),u):null,R=this.scale?xe(this.gamma.read(),u):null;return Gb(i,T,E,C,R,this.epsilon)}else return Gb(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();const[g,x,S]=Jxe(i,this.gamma.read(),this.beta.read(),o,this.epsilon),b=(T,E,C)=>{we(()=>{const R=1-C,I=T.read(),L=pe(wt(I,E),R);T.write(wt(I,L))})};return(()=>{b(this.movingMean,x,this.momentum),b(this.movingVariance,S,this.momentum)})(),g})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:si(this.betaInitializer),gammaInitializer:si(this.gammaInitializer),movingMeanInitializer:si(this.movingMeanInitializer),movingVarianceInitializer:si(this.movingVarianceInitializer),betaRegularizer:Bs(this.betaRegularizer),gammaRegularizer:Bs(this.gammaRegularizer),betaConstraint:sr(this.betaConstraint),gammaConstraint:sr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}k7.className="BatchNormalization";rt(k7);class L7 extends Ln{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=qs(e.betaInitializer||"zeros"),this.gammaInitializer=qs(e.gammaInitializer||"ones"),this.betaRegularizer=Ks(e.betaRegularizer),this.gammaRegularizer=Ks(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=as(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Zd(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(r=>e[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const n=un(e),i=n.shape,r=i.length;return we(()=>{let{mean:o,variance:l}=yM(n,this.axis,!0);const u=$g(1,r);for(const S of this.axis)u[S]=i[S];const c=S=>S!=null&&S.shape.length!==r?xe(S,u):S;let f=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const g=[],x=[];for(let S=0;S<r;++S)this.axis.indexOf(S)!==-1?(g.push(i[S]),x.push(1)):(g.push(1),x.push(i[S]));return o=su(o,g),l=su(l,g),f!=null&&(f=su(f,x)),d!=null&&(d=su(d,x)),Gb(n,o,l,d,f,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:si(this.betaInitializer),gammaInitializer:si(this.gammaInitializer),betaRegularizer:Bs(this.betaRegularizer),gammaRegularizer:Bs(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}L7.className="LayerNormalization";rt(L7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zxe(s,e,t){return we(()=>{if(s.rank!==4)throw new ve(`temporalPadding expects input tensor to be 4-D, but received a ${s.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ve("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=ac()),t!=="channelsLast"&&t!=="channelsFirst")throw new ve(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Ep(s,n)})}class F7 extends Ln{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ac():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ve(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ve(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ve(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new tr({ndim:4})]}computeOutputShape(e){e=as(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return we(()=>Zxe(un(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}F7.className="ZeroPadding2D";rt(F7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HM(s,e,t,n,i,r){return we(()=>{Ii(i),QH(r),wl(n),t==null&&(t=[1,1]),n==null&&(n="valid"),i==null&&(i=ac()),r==null&&(r="max"),s=bL(s,i);let a;const o=n==="same"?"same":"valid";return r==="max"?a=gM(s,e,t,o):a=oM(s,e,t,o),i==="channelsFirst"&&(a=jn(a,[0,3,1,2])),a})}function P7(s,e,t,n,i,r){return we(()=>{Ii(i),QH(r),wl(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),i==null&&(i=ac()),r==null&&(r="max"),s=t7(s,i);let a;const o=n==="same"?"same":"valid";return r==="max"?a=RG(s,e,t,o):a=iG(s,e,t,o),i==="channelsFirst"&&(a=jn(a,[0,4,1,2,3])),a})}class U7 extends Ln{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ve(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(vr(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ve(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);vr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,wl(this.padding),this.inputSpec=[new tr({ndim:3})]}computeOutputShape(e){e=as(e);const t=tc(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return we(()=>{this.invokeCallHook(e,t),e=_S(un(e),2);const n=this.poolingFunction(un(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return e0(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class $7 extends U7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),HM(e,t,n,i,r,"max")}}$7.className="MaxPooling1D";rt($7);class z7 extends U7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),HM(e,t,n,i,r,"avg")}}z7.className="AveragePooling1D";rt(z7);class G7 extends Ln{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ve(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ii(this.dataFormat),wl(this.padding),this.inputSpec=[new tr({ndim:4})]}computeOutputShape(e){e=as(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=tc(t,this.poolSize[0],this.padding,this.strides[0]),n=tc(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return we(()=>(this.invokeCallHook(e,t),this.poolingFunction(un(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class H7 extends G7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),HM(e,t,n,i,r,"max")}}H7.className="MaxPooling2D";rt(H7);class V7 extends G7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),HM(e,t,n,i,r,"avg")}}V7.className="AveragePooling2D";rt(V7);class W7 extends Ln{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ve(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ii(this.dataFormat),wl(this.padding),this.inputSpec=[new tr({ndim:5})]}computeOutputShape(e){e=as(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=tc(t,this.poolSize[0],this.padding,this.strides[0]),n=tc(n,this.poolSize[1],this.padding,this.strides[1]),i=tc(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,i]:[e[0],t,n,i,e[4]]}call(e,t){return we(()=>(this.invokeCallHook(e,t),this.poolingFunction(un(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class X7 extends W7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),P7(e,t,n,i,r,"max")}}X7.className="MaxPooling3D";rt(X7);class q7 extends W7{constructor(e){super(e)}poolingFunction(e,t,n,i,r){return Ii(r),wl(i),P7(e,t,n,i,r,"avg")}}q7.className="AveragePooling3D";rt(q7);class j7 extends Ln{constructor(e){super(e),this.inputSpec=[new tr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new En}}class K7 extends j7{constructor(e){super(e||{})}call(e,t){return we(()=>{const n=un(e);return pi(n,1)})}}K7.className="GlobalAveragePooling1D";rt(K7);class Y7 extends j7{constructor(e){super(e||{})}call(e,t){return we(()=>{const n=un(e);return ou(n,1)})}}Y7.className="GlobalMaxPooling1D";rt(Y7);class J7 extends Ln{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ii(this.dataFormat),this.inputSpec=[new tr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new En}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Z7 extends J7{call(e,t){return we(()=>{const n=un(e);return this.dataFormat==="channelsLast"?pi(n,[1,2]):pi(n,[2,3])})}}Z7.className="GlobalAveragePooling2D";rt(Z7);class Q7 extends J7{call(e,t){return we(()=>{const n=un(e);return this.dataFormat==="channelsLast"?ou(n,[1,2]):ou(n,[2,3])})}}Q7.className="GlobalMaxPooling2D";rt(Q7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eW extends Ln{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const i=t.layer,r=mf(i,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class tW extends eW{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=as(e),e.length<3)throw new ve(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=as(e);const t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),i=e[1];return[n[0],i].concat(n.slice(1))}call(e,t){return we(()=>(e=un(e),c7((a,o)=>[un(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}tW.className="TimeDistributed";rt(tW);function Qxe(s){n0(bye,"BidirectionalMergeMode",s)}const eve="concat";class nW extends eW{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=mf(n),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=mf(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?eve:e.mergeMode,Qxe(this.mergeMode),e.weights)throw new En("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,i,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,i=[n]):this.mergeMode==null?i=[n,n.slice()]:i=[n],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):Qa(i)}apply(e,t){let n=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=u7(e,n,i,this.numConstants);if(e=r.inputs,n=r.initialState,i=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&i==null)return super.apply(e,t);const a=[],o=[];if(n!=null){const u=n.length;if(u%2>0)throw new ve("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const c=n.map(f=>new tr({shape:f.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(i!=null)throw new En("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof ph;for(const u of a)if(u instanceof ph!==l)throw new ve("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(a),c=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=f,d}else return super.apply(e,t)}call(e,t){return we(()=>{const n=t.initialState;let i,r;if(n==null)i=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const l=n.slice(0,n.length/2),u=n.slice(n.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=cu(r,1));let o;return this.mergeMode==="concat"?o=oL([i,r]):this.mergeMode==="sum"?o=it(i,r):this.mergeMode==="ave"?o=pe(.5,it(i,r)):this.mergeMode==="mul"?o=pe(i,r):this.mergeMode==null&&(o=[i,r]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){xg(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),xg(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){const r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=mf(t.layer);if(delete t.layer,t.numConstants!=null)throw new En("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=n,new e(i)}}nW.className="Bidirectional";rt(nW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sW extends Ln{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return we(()=>(e=un(e),e.dtype!=="float32"&&(e=lh(e,"float32")),it(pe(e,this.scale),this.offset)))}}sW.className="Rescaling";rt(sW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:tve,cropAndResize:nve}=pl;class iW extends Ln{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,i,r,a,o,l){return we(()=>{let u,c=!1;const f=t/a,d=n/o,g=(i+t)/a,x=(r+n)/o,S=[f,d,g,x],b=[];e.rank===3?(c=!0,u=Po([e])):u=e;for(let R=0;R<u.shape[0];R++)b.push(S);const _=Qu(b,[b.length,4]),T=wx(0,b.length,1,"int32"),C=nve(u,_,T,[i,r],"nearest");return lh(c?un(hu(C)):C,l)})}upsize(e,t,n,i){return we(()=>{const r=tve(e,[t,n]);return lh(r,i)})}call(e,t){return we(()=>{const n=un(e),i=n.dtype,r=n.shape,a=r[r.length-3],o=r[r.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(n,l,u,this.height,this.width,a,o,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=as(e);const t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}iW.className="CenterCrop";rt(iW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sve(s,e,t,n){let i=un(s);if(i.dtype!=="int32"&&(i=lh(i,"int32")),e==="int")return i;const r=i.shape;if(i.rank===0&&(i=Sa(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=Sa(i,-1)),i.rank>2)throw new ve(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);const a=["multiHot","oneHot"].includes(e),o=i;let l;if(typeof n<"u"&&e==="count"?l=FD(o,n,t,a):l=FD(o,[],t,a),e!=="tfIdf")return l;if(n)return pe(l,n);throw new ve("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rW extends Ln{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=as(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return we(()=>{e=un(e),e.dtype!=="int32"&&(e=lh(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ve(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=un(t.countWeights)}const i=ou(e),r=Bb(e),a=Go(this.numTokens,i).bufferSync().get(0),o=Cp(r,0).bufferSync().get(0);if(!(a&&o))throw new ve(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return sve(e,this.outputMode,this.numTokens,n)})}}rW.className="CategoryEncoding";rt(rW);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ive=["bilinear","nearest"],v$=new Set(ive);class aW extends Ln{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(v$.has(e.interpolation))this.interpolation=e.interpolation;else throw new ve(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=as(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return we(()=>{const n=[this.height,this.width];if(this.interpolation==="bilinear")return pl.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return pl.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...v$]} are supported`)})}}aW.className="Resizing";rt(aW);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oW{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}oW.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lW extends Ln{constructor(e){super(e),this.randomGenerator=new oW(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}lW.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const rve=["bilinear","nearest"],b$=new Set(rve);class uW extends lW{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ve(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ve(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ve(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(b$.has(n))this.interpolation=n;else throw new ve(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=as(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return we(()=>{const n=un(e);this.imgHeight=n.shape[n.shape.length-3];const i=n.shape[n.shape.length-2];this.widthFactor=Qg([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*i;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return pl.resizeBilinear(e,a);case"nearest":return pl.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...b$]} are supported`)}})}}uW.className="RandomWidth";rt(uW);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ave=Ie();ave.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Ao;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ao||(Ao={}));var _$;(function(s){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(_$||(_$={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ove={};function cW(s){return ove[s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z(s,e,t,n,i){const r=e.inputParams[s];if(r&&r.inputIndexStart!==void 0){const o=r.inputIndexStart,l=r.inputIndexEnd===0?void 0:r.inputIndexEnd===void 0?o+1:r.inputIndexEnd,u=o<0?e.inputNames.length+o:o;if(r.type==="tensor")return Dr(e.inputNames[u],t,n,i);if(r.type==="tensors"){const d=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((x,S)=>{var b;return((b=d[S])===null||b===void 0?void 0:b.op)!=="NoOp"}).map(x=>Dr(x,t,n,i))}const c=Dr(e.inputNames[u],t,n,i),f=c.dataSync();return r.type==="number"?f[0]:au(c.shape,f)}const a=e.attrParams[s];return a&&a.value}function Dr(s,e,t,n){const[i,r]=To(s,t);if(n!=null){const o=n.getHashTableHandleByName(i);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[aC(i,o)]);return a!==void 0?e[aC(i,a)][r]:void 0}function S$(s,e,t){return e[aC(s,t.currentContextId)]}function tf(s,e){const[t,n,i]=To(s,e);return[aC(t,e&&e.currentContextId),n,i]}function aC(s,e){return e?`${s}-${e}`:s}function To(s,e){if(s==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const r=e.parseNodeNameCache.get(s);if(r!=null)return r}const n=s.split(":");let i;if(n.length===1)i=[s,0,void 0];else{const r=n[0],a=n.length===3?n[1]:void 0,o=Number(n[n.length-1]);i=[r,o,a]}return t&&e.parseNodeNameCache.set(s,i),i}function $w(s,e,t){let n=z("pad",s,e,t);if(n==="explicit"){n=z("explicitPaddings",s,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let r=0;r<4;r++)i[r][0]=n[r*2],i[r][1]=n[r*2+1];return i}return n}function nf(s){return s.kept?s:pf(s)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lve=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uve=Object.freeze(Object.defineProperty({__proto__:null,json:lve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cve=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hve=Object.freeze(Object.defineProperty({__proto__:null,json:cve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fve=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],dve=Object.freeze(Object.defineProperty({__proto__:null,json:fve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pve=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],mve=Object.freeze(Object.defineProperty({__proto__:null,json:pve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gve=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],yve=Object.freeze(Object.defineProperty({__proto__:null,json:gve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xve=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vve=Object.freeze(Object.defineProperty({__proto__:null,json:xve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bve=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_ve=Object.freeze(Object.defineProperty({__proto__:null,json:bve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sve=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ave=Object.freeze(Object.defineProperty({__proto__:null,json:Sve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tve=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wve=Object.freeze(Object.defineProperty({__proto__:null,json:Tve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cve=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Eve=Object.freeze(Object.defineProperty({__proto__:null,json:Cve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mve=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Nve=Object.freeze(Object.defineProperty({__proto__:null,json:Mve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rve=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Ive=Object.freeze(Object.defineProperty({__proto__:null,json:Rve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dve=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Ove=Object.freeze(Object.defineProperty({__proto__:null,json:Dve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bve=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],kve=Object.freeze(Object.defineProperty({__proto__:null,json:Bve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lve=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Fve=Object.freeze(Object.defineProperty({__proto__:null,json:Lve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pve=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Uve=Object.freeze(Object.defineProperty({__proto__:null,json:Pve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ve=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],zve=Object.freeze(Object.defineProperty({__proto__:null,json:$ve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Hve=Object.freeze(Object.defineProperty({__proto__:null,json:Gve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vve=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Wve=Object.freeze(Object.defineProperty({__proto__:null,json:Vve},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A${static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[uve,hve,dve,mve,yve,vve,_ve,Ave,wve,Eve,Nve,Ive,Ove,kve,Fve,Uve,zve,Hve,Wve],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,i)=>(n[i.tfOpName]=i,n),{})}transformGraph(e,t={}){const n=e.node,i=[],r=[],a=[],o=n.reduce((S,b)=>(S[b.name]=this.mapNode(b),b.op.startsWith("Placeholder")?i.push(S[b.name]):b.op==="Const"?r.push(S[b.name]):(b.input==null||b.input.length===0)&&a.push(S[b.name]),S),{});let l=[];const u=[];let c={},f={};t!=null&&(c=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach(S=>{const b=o[S];b.inputNames.forEach((_,T)=>{const[E,,C]=tf(_),R=o[E];if(R.outputs!=null){const I=R.outputs.indexOf(C);if(I!==-1){const L=`${E}:${I}`;b.inputNames[T]=L}}b.inputs.push(R),R.children.push(b)})}),Object.keys(f).length===0?d.forEach(S=>{const b=o[S];b.children.length===0&&u.push(b)}):Object.keys(f).forEach(S=>{const[b]=tf(S),_=o[b];_!=null&&(_.signatureKey=f[S],u.push(_))}),Object.keys(c).length>0?Object.keys(c).forEach(S=>{const[b]=tf(S),_=o[b];_&&(_.signatureKey=c[S],l.push(_))}):l=i;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((S,b)=>(S[b.signature.name]=this.mapFunction(b),S),{}));const x={nodes:o,inputs:l,outputs:u,weights:r,placeholders:i,signature:t,functions:g};return a.length>0&&(x.initNodes=a),x}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=cW(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((i,r)=>(i[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},i),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((i,r)=>{const a=r.type;let o;switch(r.type){case"string":o=ZD(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=ZD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":o=r3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=r3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":o=e3(e.attr,r.tfName,r.defaultValue||0),o===void 0&&r.tfDeprecatedName&&(o=e3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":o=i3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=i3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":o=QD(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=QD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":o=o3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=o3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":o=s3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=s3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":o=a3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=a3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":o=t3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=t3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":o=n3(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=n3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":o=T$(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=T$(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return i[r.name]={value:o,type:a},i},{})),n}mapFunction(e){const t=e.nodeDef,n=[],i=[];let r={};t!=null&&(r=t.reduce((f,d)=>(f[d.name]=this.mapNode(d),d.op==="Const"&&i.push(f[d.name]),f),{}));const a=[],o=[];e.signature.inputArg.forEach(f=>{const[d]=tf(f.name),g={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:CL(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,a.push(g),r[d]=g}),Object.keys(r).forEach(f=>{const d=r[f];d.inputNames.forEach((g,x)=>{const[S,,b]=tf(g),_=r[S];if(_.outputs!=null){const T=_.outputs.indexOf(b);if(T!==-1){const E=`${S}:${T}`;d.inputNames[x]=E}}d.inputs.push(_),_.children.push(d)})});const u=e.ret;e.signature.outputArg.forEach(f=>{const[d,g]=tf(u[f.name]),x=r[d];x!=null&&(x.defaultOutput=g,o.push(x))});const c=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:o,weights:i,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}function Xve(s){const e=Ie().global;if(typeof e.atob<"u")return e.atob(s);if(typeof Buffer<"u")return new Buffer(s,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function hW(s,e){const t=Array.isArray(s)?String.fromCharCode.apply(null,s):Xve(s);return e?t:t.toLowerCase()}function ZD(s,e,t,n=!1){const i=s[e];return i!=null?hW(i.s,n):t}function QD(s,e,t){const n=s[e];return n?n.b:t}function e3(s,e,t){const n=s[e]||{},i=n.i!=null?n.i:n.f!=null?n.f:t;return typeof i=="number"?i:parseInt(i,10)}function CL(s){switch(typeof s=="string"&&(s=Ao[s]),s){case Ao.DT_FLOAT:case Ao.DT_HALF:return"float32";case Ao.DT_INT32:case Ao.DT_INT64:case Ao.DT_INT8:case Ao.DT_UINT8:return"int32";case Ao.DT_BOOL:return"bool";case Ao.DT_DOUBLE:return"float32";case Ao.DT_STRING:return"string";case Ao.DT_COMPLEX64:case Ao.DT_COMPLEX128:return"complex64";default:return null}}function T$(s,e,t){const n=s[e];return n&&n.func?n.func.name:t}function t3(s,e,t){const n=s[e];return n&&n.type?CL(n.type):t}function n3(s,e,t){const n=s[e];return n&&n.list&&n.list.type?n.list.type.map(i=>CL(i)):t}function fW(s){if(!s.unknownRank)return s.dim!=null?s.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function s3(s,e,t){const n=s[e];return n&&n.shape?fW(n.shape):t}function i3(s,e,t){const n=s[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function r3(s,e,t,n=!1){const i=s[e];return i&&i.list&&i.list.s?i.list.s.map(r=>hW(r,n)):t}function a3(s,e,t){const n=s[e];return n&&n.list&&n.list.shape?n.list.shape.map(i=>fW(i)):t}function o3(s,e,t){const n=s[e];return n&&n.list&&n.list.b?n.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qve{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,r)=>(i[r]=this.getAttr(r),i),{}))}getInput(e){return Dr(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return Dr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return e3(this.node.rawAttrs,e,t);if(n.s!=null)return ZD(this.node.rawAttrs,e,t);if(n.b!=null)return QD(this.node.rawAttrs,e,t);if(n.shape!=null)return s3(this.node.rawAttrs,e,t);if(n.type!=null)return t3(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return i3(this.node.rawAttrs,e,t);if(n.list.s!=null)return r3(this.node.rawAttrs,e,t);if(n.list.shape!=null)return a3(this.node.rawAttrs,e,t);if(n.list.b!=null)return o3(this.node.rawAttrs,e,t);if(n.list.type!=null)return n3(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:I8,abs:Ji,acos:Y8,acosh:J8,add:it,addN:hue,all:jB,any:K2,argMax:Sx,argMin:Z8,asin:Q8,asinh:eG,atan:tG,atan2:nG,atanh:sG,avgPool:oM,avgPool3d:iG,basicLSTMCell:Bue,batchNorm:hS,batchNorm2d:rG,batchNorm3d:aG,batchNorm4d:oG,batchToSpaceND:lM,bincount:lG,bitwiseAnd:Hue,booleanMaskAsync:Ede,broadcastArgs:Wue,broadcastTo:Zy,buffer:Mn,cast:Ct,ceil:uG,clipByValue:Lo,clone:pf,complex:op,concat:js,concat1d:cG,concat2d:uM,concat3d:hG,concat4d:fG,conv1d:YB,conv2d:cp,conv2dTranspose:ZB,conv3d:dG,conv3dTranspose:mG,cos:cM,cosh:QB,cosineWindow:Tk,cumprod:Y2,cumsum:ek,denseBincount:FD,depthToSpace:gG,depthwiseConv2d:fS,diag:pce,dilation2d:yG,div:Ut,divNoNan:xG,dot:vG,dropout:WG,einsum:Fy,elu:dS,enclosingPowerOfTwo:XG,ensureShape:Tce,equal:ic,erf:tk,euclideanNorm:SG,exp:Fo,expandDims:Sa,expm1:AG,eye:sk,fft:TM,fill:Wx,floor:mS,floorDiv:qB,fused:Kde,gather:gS,gatherND:Fde,greater:Go,greaterEqual:Cp,ifft:Pb,imag:hM,image:pl,inTopKAsync:zde,irfft:xk,isFinite:TG,isInf:wG,isNaN:CG,leakyRelu:fM,less:kb,lessEqual:Zg,linalg:eH,linspace:Yce,localResponseNormalization:EG,log:Sl,log1p:dM,logSigmoid:MG,logSoftmax:ik,logSumExp:pM,logicalAnd:dh,logicalNot:mM,logicalOr:rk,logicalXor:NG,losses:Cme,lowerBound:fhe,matMul:Un,max:ou,maxPool:gM,maxPool3d:RG,maxPoolWithArgmax:ghe,maximum:Rf,mean:pi,meshgrid:vhe,min:Bb,minimum:Pg,mirrorPad:IG,mod:DG,moments:yM,movingAverage:Rde,mul:pe,multiRNNCell:whe,multinomial:Ehe,neg:Hs,norm:pS,notEqual:Tx,oneHot:ok,ones:Mo,onesLike:Al,op:fe,outerProduct:Dhe,pad:Ep,pad1d:khe,pad2d:Fhe,pad3d:Uhe,pad4d:zhe,pool:OG,pow:Sf,prelu:vM,print:K8,prod:BG,raggedGather:Khe,raggedRange:Jhe,raggedTensorToTensor:Qhe,rand:tfe,randomGamma:Afe,randomNormal:uk,randomStandardNormal:Cfe,randomUniform:Qg,randomUniformInt:Nfe,range:wx,real:Lb,reciprocal:kG,relu:xh,relu6:ck,reshape:xe,reverse:cu,reverse1d:Lfe,reverse2d:Pfe,reverse3d:$fe,reverse4d:Gfe,rfft:wM,round:hk,rsqrt:fk,scalar:Jt,scatterND:Dde,searchSorted:ak,selu:dk,separableConv2d:pk,setdiff1dAsync:jfe,sigmoid:ec,sign:LG,signal:wme,sin:mk,sinh:gk,slice:bn,slice1d:_M,slice2d:yk,slice3d:SM,slice4d:Fb,softmax:AM,softplus:Xx,spaceToBatchND:xM,sparse:Eme,sparseToDense:kde,spectral:Tme,split:Oo,sqrt:Pr,square:Os,squaredDifference:vk,squeeze:e0,stack:Po,step:qx,stridedSlice:FG,string:Mme,sub:wt,sum:$t,tan:PG,tanh:Fg,tensor:Qu,tensor1d:mi,tensor2d:Jd,tensor3d:UG,tensor4d:pde,tensor5d:mde,tensor6d:gde,tensorScatterUpdate:xde,tile:su,topk:zG,transpose:jn,truncatedNormal:_k,unique:GG,unsortedSegmentSum:Sk,unstack:hu,upperBound:Tde,variable:HG,where:na,whereAsync:VG,zeros:Qi,zerosLike:Kn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jve=(s,e,t,n=zr)=>{switch(s.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(z("a",s,e,t),z("b",s,e,t))];case"AddN":return[n.addN(z("tensors",s,e,t))];case"FloorMod":case"Mod":return[n.mod(z("a",s,e,t),z("b",s,e,t))];case"Mul":return[n.mul(z("a",s,e,t),z("b",s,e,t))];case"RealDiv":case"Div":return[n.div(z("a",s,e,t),z("b",s,e,t))];case"DivNoNan":return[n.divNoNan(z("a",s,e,t),z("b",s,e,t))];case"FloorDiv":return[n.floorDiv(z("a",s,e,t),z("b",s,e,t))];case"Sub":return[n.sub(z("a",s,e,t),z("b",s,e,t))];case"Minimum":return[n.minimum(z("a",s,e,t),z("b",s,e,t))];case"Maximum":return[n.maximum(z("a",s,e,t),z("b",s,e,t))];case"Pow":return[n.pow(z("a",s,e,t),z("b",s,e,t))];case"SquaredDifference":return[n.squaredDifference(z("a",s,e,t),z("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kve=(s,e,t,n=zr)=>{switch(s.op){case"Abs":case"ComplexAbs":return[n.abs(z("x",s,e,t))];case"Acos":return[n.acos(z("x",s,e,t))];case"Acosh":return[n.acosh(z("x",s,e,t))];case"Asin":return[n.asin(z("x",s,e,t))];case"Asinh":return[n.asinh(z("x",s,e,t))];case"Atan":return[n.atan(z("x",s,e,t))];case"Atan2":return[n.atan2(z("x",s,e,t),z("y",s,e,t))];case"Atanh":return[n.atanh(z("x",s,e,t))];case"Ceil":return[n.ceil(z("x",s,e,t))];case"Complex":return[n.complex(z("real",s,e,t),z("imag",s,e,t))];case"Cos":return[n.cos(z("x",s,e,t))];case"Cosh":return[n.cosh(z("x",s,e,t))];case"Elu":return[n.elu(z("x",s,e,t))];case"Erf":return[n.erf(z("x",s,e,t))];case"Exp":return[n.exp(z("x",s,e,t))];case"Expm1":return[n.expm1(z("x",s,e,t))];case"Floor":return[n.floor(z("x",s,e,t))];case"Log":return[n.log(z("x",s,e,t))];case"Log1p":return[n.log1p(z("x",s,e,t))];case"Imag":return[n.imag(z("x",s,e,t))];case"Neg":return[n.neg(z("x",s,e,t))];case"Reciprocal":return[n.reciprocal(z("x",s,e,t))];case"Real":return[n.real(z("x",s,e,t))];case"Relu":return[n.relu(z("x",s,e,t))];case"Round":return[n.round(z("x",s,e,t))];case"Selu":return[n.selu(z("x",s,e,t))];case"Sigmoid":return[n.sigmoid(z("x",s,e,t))];case"Sin":return[n.sin(z("x",s,e,t))];case"Sign":return[n.sign(z("x",s,e,t))];case"Sinh":return[n.sinh(z("x",s,e,t))];case"Softplus":return[n.softplus(z("x",s,e,t))];case"Sqrt":return[n.sqrt(z("x",s,e,t))];case"Square":return[n.square(z("x",s,e,t))];case"Tanh":return[n.tanh(z("x",s,e,t))];case"Tan":return[n.tan(z("x",s,e,t))];case"ClipByValue":return[n.clipByValue(z("x",s,e,t),z("clipValueMin",s,e,t),z("clipValueMax",s,e,t))];case"Relu6":return[n.relu6(z("x",s,e,t))];case"Rsqrt":return[n.rsqrt(Dr(s.inputNames[0],e,t))];case"LeakyRelu":return[n.leakyRelu(z("x",s,e,t),z("alpha",s,e,t))];case"Prelu":return[n.prelu(z("x",s,e,t),z("alpha",s,e,t))];case"IsNan":return[n.isNaN(Dr(s.inputNames[0],e,t))];case"IsInf":return[n.isInf(Dr(s.inputNames[0],e,t))];case"IsFinite":return[n.isFinite(Dr(s.inputNames[0],e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(s,e,t=""){if(!(typeof s=="number"||typeof e=="number")){K(s.length===e.length,()=>t+` Shapes ${s} and ${e} must match`);for(let n=0;n<s.length;n++){const i=s[n],r=e[n];K(i<0||r<0||i===r,()=>t+` Shapes ${s} and ${e} must match`)}}}function w$(s){return!(typeof s=="number"||s.some(e=>e<0))}function U1(s,e,t){let n=l3(s,t);const i=!w$(n);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(i&&e.forEach(r=>{n=l3(r.shape,n)}),!w$(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function l3(s,e){if(typeof s=="number")return e;if(typeof e=="number")return s;if(s.length!==e.length)throw new Error(`Incompatible ranks during merge: ${s} vs. ${e}`);const t=[];for(let n=0;n<s.length;++n){const i=s[n],r=e[n];if(i>=0&&r>=0&&i!==r)throw new Error(`Incompatible shape during merge: ${s} vs. ${e}`);t[n]=i>=0?i:r}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yve{constructor(e,t,n,i,r,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Jt(0),xr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ql(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,xr(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,i)=>this.write(n,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Qu([],[0].concat(this.elementShape));const n=this.readMany(e);return Ql(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Po(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Qu([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const n=this.readMany(t);return Ql(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),js(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,hu(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const i=e.map(l=>(n+=l,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=n===0?0:t.size/n,a=[];we(()=>{t=xe(t,[1,n,r]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],f=[1,e[l],r];a[l]=xe(bn(t,c,f),this.elementShape)}return a});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zg{get id(){return this.idTensor.id}constructor(e,t,n,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(r=>{if(n!==r.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${r.dtype}`);Ql(t,r.shape,"TensorList shape mismatch: "),xr(r)}),this.idTensor=Jt(0),this.maxNumElements=i,xr(this.idTensor)}copy(){return new zg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Ql(e,this.elementShape,"TensorList shape mismatch: ");const i=U1(this.elementShape,this.tensors,e);return we(()=>{const r=this.tensors.map(a=>xe(a,i));return Po(r,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=U1(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Ql(i.shape,e,"TensorList shape mismatch: "),xe(i,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ql(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");xr(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new zg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ql(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=U1(this.elementShape,this.tensors,t);return xe(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ql(this.elementShape,t.shape,"TensorList shape mismatch: "),xr(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ql(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=U1(this.elementShape,this.tensors,n);return e.length===0?Qu([],[0].concat(i)):we(()=>{const r=e.map(a=>xe(this.tensors[a],i));return Po(r,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ql(this.elementShape,t,"TensorList shape mismatch: ");const n=U1(this.elementShape,this.tensors,t);return this.size()===0?Qu([],[0].concat(n)):we(()=>{const i=this.tensors.map(r=>xe(r,n));return js(i,0)})}}function Jve(s,e,t){const n=s.dtype;if(s.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${s.shape}`);if(s.dtype!==t)throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${t}`);const i=s.shape.slice(1);Ql(i,e,"TensorList shape mismatch: ");const r=hu(s);return new zg(r,e,n)}function Zve(s,e,t,n){return new zg([],s,e,n)}function Qve(s,e,t,n){if(e.length!==s.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${s.shape[0]}`);const i=Math.max(...e);if(n!=null&&n!==-1&&i>=n)throw new Error(`Max index must be < array size (${i}  vs. ${n})`);const r=new zg([],t,s.dtype,n),a=hu(s,0);return e.forEach((o,l)=>{r.setItem(o,a[l])}),r}function e1e(s,e,t){let n=0;const i=e.map(c=>(n+=c,n));if(n!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${s.shape}`);const r=s.shape.slice(1),a=l3(r,t),o=n===0?0:s.size/n,l=we(()=>{const c=[];s=xe(s,[1,n,o]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:i[f-1],0],x=[1,e[f],o];c[f]=xe(bn(s,g,x),a)}return s.dispose(),c}),u=new zg([],t,s.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t1e=async(s,e,t)=>{switch(s.op){case"If":case"StatelessIf":{const n=z("thenBranch",s,e,t),i=z("elseBranch",s,e,t),r=z("cond",s,e,t),a=z("args",s,e,t);return(await r.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=z("body",s,e,t),i=z("cond",s,e,t),r=z("args",s,e,t),a=await t.functionMap[i].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap),o=r.map(c=>c.id);let l=await a[0].data();a.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=r;for(;l[0];){const c=u;u=await t.functionMap[n].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const f=u.map(g=>g.id);c.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const d=await t.functionMap[i].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return u}case"LoopCond":{const n=z("pred",s,e,t);return[nf(n)]}case"Switch":{const n=z("pred",s,e,t);let i=z("data",s,e,t);return i.kept||(i=nf(i)),(await n.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const n=s.inputNames.find(i=>Dr(i,e,t)!==void 0);if(n){const i=Dr(n,e,t);return[nf(i)]}return}case"Enter":{const n=z("frameName",s,e,t),i=z("tensor",s,e,t);return t.enterFrame(n),[nf(i)]}case"Exit":{const n=z("tensor",s,e,t);return t.exitFrame(),[nf(n)]}case"NextIteration":{const n=z("tensor",s,e,t);return t.nextIteration(),[nf(n)]}case"TensorArrayV3":{const n=z("size",s,e,t),i=z("dtype",s,e,t),r=z("elementShape",s,e,t),a=z("dynamicSize",s,e,t),o=z("clearAfterRead",s,e,t),l=z("identicalElementShapes",s,e,t),u=z("name",s,e,t),c=new Yve(u,i,n,r,l,a,o);return t.addTensorArray(c),[c.idTensor,Jt(1)]}case"TensorArrayWriteV3":{const n=z("tensorArrayId",s,e,t),i=z("index",s,e,t),r=z("tensor",s,e,t),a=t.getTensorArray(n.id);return a.write(i,r),[a.idTensor]}case"TensorArrayReadV3":{const n=z("tensorArrayId",s,e,t),i=z("index",s,e,t);return[t.getTensorArray(n.id).read(i)]}case"TensorArrayGatherV3":{const n=z("tensorArrayId",s,e,t),i=z("indices",s,e,t),r=z("dtype",s,e,t);return[t.getTensorArray(n.id).gather(i,r)]}case"TensorArrayScatterV3":{const n=z("tensorArrayId",s,e,t),i=z("indices",s,e,t),r=z("tensor",s,e,t),a=t.getTensorArray(n.id);return a.scatter(i,r),[a.idTensor]}case"TensorArrayConcatV3":{const n=z("tensorArrayId",s,e,t),i=t.getTensorArray(n.id),r=z("dtype",s,e,t);return[i.concat(r)]}case"TensorArraySplitV3":{const n=z("tensorArrayId",s,e,t),i=z("tensor",s,e,t),r=z("lengths",s,e,t),a=t.getTensorArray(n.id);return a.split(r,i),[a.idTensor]}case"TensorArraySizeV3":{const n=z("tensorArrayId",s,e,t),i=t.getTensorArray(n.id);return[Jt(i.size(),"int32")]}case"TensorArrayCloseV3":{const n=z("tensorArrayId",s,e,t),i=t.getTensorArray(n.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const n=z("tensorListId",s,e,t),i=z("index",s,e,t),r=z("tensor",s,e,t),a=t.getTensorList(n.id);return a.setItem(i,r),[a.idTensor]}case"TensorListGetItem":{const n=z("tensorListId",s,e,t),i=z("index",s,e,t),r=z("elementShape",s,e,t),a=z("elementDType",s,e,t);return[t.getTensorList(n.id).getItem(i,r,a)]}case"TensorListScatterV2":case"TensorListScatter":{const n=z("indices",s,e,t),i=z("tensor",s,e,t),r=z("elementShape",s,e,t),a=z("numElements",s,e,t),o=Qve(i,n,r,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=z("elementShape",s,e,t),i=z("elementDType",s,e,t);let r;s.op==="TensorListReserve"?r="numElements":r="maxNumElements";const a=z(r,s,e,t),o=s.op==="TensorListReserve"?-1:a,l=Zve(n,i,a,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const n=z("tensorListId",s,e,t),i=z("indices",s,e,t),r=z("elementShape",s,e,t),a=z("elementDType",s,e,t);return[t.getTensorList(n.id).gather(i,a,r)]}case"TensorListStack":{const n=z("tensorListId",s,e,t),i=z("elementShape",s,e,t),r=z("elementDType",s,e,t),a=z("numElements",s,e,t);return[t.getTensorList(n.id).stack(i,r,a)]}case"TensorListFromTensor":{const n=z("tensor",s,e,t),i=z("elementShape",s,e,t),r=z("elementDType",s,e,t),a=Jve(n,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=z("tensorListId",s,e,t),i=t.getTensorList(n.id),r=z("dtype",s,e,t),a=z("elementShape",s,e,t);return[i.concat(r,a)]}case"TensorListPushBack":{const n=z("tensorListId",s,e,t),i=z("tensor",s,e,t),r=t.getTensorList(n.id);return r.pushBack(i),[r.idTensor]}case"TensorListPopBack":{const n=z("tensorListId",s,e,t),i=z("elementShape",s,e,t),r=z("elementDType",s,e,t);return[t.getTensorList(n.id).popBack(i,r)]}case"TensorListSplit":{const n=z("tensor",s,e,t),i=z("elementShape",s,e,t),r=z("lengths",s,e,t),a=e1e(n,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const n=z("tensorListId",s,e,t),i=t.getTensorList(n.id);return[Jt(i.size(),"int32")]}case"TensorListResize":{const n=z("tensorListId",s,e,t),i=z("size",s,e,t),a=t.getTensorList(n.id).resize(i);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$(s,e,t){const[n,i]=z("fusedOps",s,e,t),r=n==="biasadd",a=!r,o=i==="prelu",l=n==="fusedbatchnorm",u=z("numArgs",s,e,t);if(r){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&r&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=z("strides",s,e,t),f=$w(s,e,t),d=z("dataFormat",s,e,t).toUpperCase(),g=z("dilations",s,e,t);let[x,S]=z("args",s,e,t);a&&(S=x,x=void 0);const b=z("leakyreluAlpha",s,e,t);return{stride:c,pad:f,dataFormat:d,dilations:g,biasArg:x,preluArg:S,activationFunc:i,leakyreluAlpha:b}}const n1e=(s,e,t,n=zr)=>{switch(s.op){case"Conv1D":{const i=z("stride",s,e,t),r=z("pad",s,e,t),a=z("dataFormat",s,e,t).toUpperCase(),o=z("dilation",s,e,t);return[n.conv1d(z("x",s,e,t),z("filter",s,e,t),i,r,a,o)]}case"Conv2D":{const i=z("strides",s,e,t),r=$w(s,e,t),a=z("dataFormat",s,e,t).toUpperCase(),o=z("dilations",s,e,t);return[n.conv2d(z("x",s,e,t),z("filter",s,e,t),[i[1],i[2]],r,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:f}=C$(s,e,t);return[n.fused.conv2d({x:z("x",s,e,t),filter:z("filter",s,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:f}=C$(s,e,t);return[n.fused.depthwiseConv2d({x:z("x",s,e,t),filter:z("filter",s,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=z("outputShape",s,e,t),r=z("strides",s,e,t),a=$w(s,e,t);return[n.conv2dTranspose(z("x",s,e,t),z("filter",s,e,t),i,[r[1],r[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=z("strides",s,e,t),r=$w(s,e,t),a=z("dilations",s,e,t),o=z("dataFormat",s,e,t).toUpperCase();return[n.depthwiseConv2d(z("input",s,e,t),z("filter",s,e,t),[i[1],i[2]],r,o,[a[1],a[2]])]}case"Conv3D":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("dataFormat",s,e,t).toUpperCase(),o=z("dilations",s,e,t);return[n.conv3d(z("x",s,e,t),z("filter",s,e,t),[i[1],i[2],i[3]],r,a,[o[1],o[2],o[3]])]}case"AvgPool":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("kernelSize",s,e,t);return[n.avgPool(z("x",s,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("kernelSize",s,e,t);return[n.maxPool(z("x",s,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("kernelSize",s,e,t),o=z("includeBatchInIndex",s,e,t),{result:l,indexes:u}=n.maxPoolWithArgmax(z("x",s,e,t),[a[1],a[2]],[i[1],i[2]],r,o);return[l,u]}case"AvgPool3D":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("kernelSize",s,e,t);return[n.avgPool3d(z("x",s,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("kernelSize",s,e,t);return[n.maxPool3d(z("x",s,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=z("strides",s,e,t),r=z("pad",s,e,t),a=z("dilations",s,e,t),o=i[1],l=i[2],u=a[1],c=a[2];return[n.dilation2d(z("x",s,e,t),z("filter",s,e,t),[o,l],r,[u,c],"NHWC")]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s1e=(s,e,t,n=zr)=>{switch(s.op){case"Fill":{const i=z("shape",s,e,t),r=z("dtype",s,e,t),a=z("value",s,e,t);return[n.fill(i,a,r)]}case"LinSpace":{const i=z("start",s,e,t),r=z("stop",s,e,t),a=z("num",s,e,t);return[n.linspace(i,r,a)]}case"Multinomial":{const i=z("logits",s,e,t),r=z("numSamples",s,e,t),a=z("seed",s,e,t);return[n.multinomial(i,r,a)]}case"OneHot":{const i=z("indices",s,e,t),r=z("depth",s,e,t),a=z("onValue",s,e,t),o=z("offValue",s,e,t),l=z("dtype",s,e,t);return[n.oneHot(i,r,a,o,l)]}case"Ones":return[n.ones(z("shape",s,e,t),z("dtype",s,e,t))];case"OnesLike":return[n.onesLike(z("x",s,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(z("shape",s,e,t),z("dtype",s,e,t),z("seed",s,e,t))];case"RandomUniform":return[n.randomUniform(z("shape",s,e,t),z("minval",s,e,t),z("maxval",s,e,t),z("dtype",s,e,t))];case"RandomUniformInt":return[n.randomUniformInt(z("shape",s,e,t),z("minval",s,e,t),z("maxval",s,e,t),z("seed",s,e,t))];case"Range":{const i=z("start",s,e,t),r=z("stop",s,e,t),a=z("step",s,e,t);return[n.range(i,r,a,z("dtype",s,e,t))]}case"TruncatedNormal":{const i=z("shape",s,e,t),r=z("mean",s,e,t),a=z("stdDev",s,e,t),o=z("seed",s,e,t);return[n.truncatedNormal(i,r,a,z("dtype",s,e,t),o)]}case"Zeros":return[n.zeros(z("shape",s,e,t),z("dtype",s,e,t))];case"ZerosLike":return[n.zerosLike(z("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(s,e,t){const n=z("boxes",s,e,t),i=z("scores",s,e,t),r=z("maxOutputSize",s,e,t),a=z("iouThreshold",s,e,t),o=z("scoreThreshold",s,e,t),l=z("softNmsSigma",s,e,t);return{boxes:n,scores:i,maxOutputSize:r,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}const i1e=async(s,e,t,n,i=zr)=>{switch(s.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=bI(s,e,t),f=await i.image.nonMaxSuppressionWithScoreAsync(r,a,o,l,u,c);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=bI(s,e,t),c=z("padToMaxOutputSize",s,e,t),f=await i.image.nonMaxSuppressionPaddedAsync(r,a,o,l,u,c);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=bI(s,e,t);return[await i.image.nonMaxSuppressionAsync(r,a,o,l,u)]}case"Where":{const r=i.cast(z("condition",s,e,t),"bool"),a=[await i.whereAsync(r)];return r.dispose(),a}case"ListDiff":return i.setdiff1dAsync(z("x",s,e,t),z("y",s,e,t));default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1e=(s,e,t,n=zr)=>{switch(s.op){case"LowerBound":{const i=z("sortedSequence",s,e,t),r=z("values",s,e,t);return[n.lowerBound(i,r)]}case"TopKV2":{const i=z("x",s,e,t),r=z("k",s,e,t),a=z("sorted",s,e,t),o=n.topk(i,r,a);return[o.values,o.indices]}case"UpperBound":{const i=z("sortedSequence",s,e,t),r=z("values",s,e,t);return[n.upperBound(i,r)]}case"Unique":{const i=z("x",s,e,t),r=n.unique(i);return[r.values,r.indices]}case"UniqueV2":{const i=z("x",s,e,t),r=z("axis",s,e,t),a=n.unique(i,r);return[a.values,a.indices]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a1e=(s,e,t,n=zr)=>{switch(s.op){case"Const":return e[s.name];case"PlaceholderWithDefault":const i=z("default",s,e,t);return[Dr(s.name,e,t)||i];case"Placeholder":return[Dr(s.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=z("x",s,e,t);return[nf(c)]}case"IdentityN":return z("x",s,e,t).map(c=>nf(c));case"Snapshot":const r=z("x",s,e,t);return[nf(r)];case"Shape":return[n.tensor1d(z("x",s,e,t).shape,"int32")];case"ShapeN":return z("x",s,e,t).map(c=>n.tensor1d(c.shape));case"Size":return[n.scalar(z("x",s,e,t).size,"int32")];case"Rank":return[n.scalar(z("x",s,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const a=z("x",s,e,t),o=z("data",s,e,t),l=z("message",s,e,t),u=z("summarize",s,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o1e{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Jt(0),this.tensorMap=new Map,xr(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Jt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),we(()=>{const i=hu(t),r=n.length,a=i.length;K(r===a,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`);for(let o=0;o<r;o++){const l=n[o],u=i[o];xr(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return we(()=>{const i=[];for(let r=0;r<n.length;r++){const a=n[r],o=this.findWithDefault(a,t);i.push(o)}return Po(i)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l1e=async(s,e,t,n)=>{switch(s.op){case"HashTable":case"HashTableV2":{const i=n.getHashTableHandleByName(s.name);if(i!=null)return[i];{const r=z("keyDType",s,e,t),a=z("valueDType",s,e,t),o=new o1e(r,a);return n.addHashTable(s.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=z("tableHandle",s,e,t,n),r=z("keys",s,e,t),a=z("values",s,e,t);return[await n.getHashTableById(i.id).import(r,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=z("tableHandle",s,e,t,n),r=z("keys",s,e,t),a=z("defaultValue",s,e,t);return[await n.getHashTableById(i.id).find(r,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=z("tableHandle",s,e,t,n);return[n.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u1e=(s,e,t,n=zr)=>{switch(s.op){case"ResizeBilinear":{const i=z("images",s,e,t),r=z("size",s,e,t),a=z("alignCorners",s,e,t),o=z("halfPixelCenters",s,e,t);return[n.image.resizeBilinear(i,[r[0],r[1]],a,o)]}case"ResizeNearestNeighbor":{const i=z("images",s,e,t),r=z("size",s,e,t),a=z("alignCorners",s,e,t),o=z("halfPixelCenters",s,e,t);return[n.image.resizeNearestNeighbor(i,[r[0],r[1]],a,o)]}case"CropAndResize":{const i=z("image",s,e,t),r=z("boxes",s,e,t),a=z("boxInd",s,e,t),o=z("cropSize",s,e,t),l=z("method",s,e,t),u=z("extrapolationValue",s,e,t);return[n.image.cropAndResize(i,r,a,o,l,u)]}case"ImageProjectiveTransformV3":{const i=z("images",s,e,t),r=z("transforms",s,e,t),a=z("outputShape",s,e,t),o=z("fillValue",s,e,t),l=z("interpolation",s,e,t),u=z("fillMode",s,e,t);return[n.image.transform(i,r,l.toLowerCase(),u.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c1e=(s,e,t,n=zr)=>{switch(s.op){case"Equal":return[n.equal(z("a",s,e,t),z("b",s,e,t))];case"NotEqual":return[n.notEqual(z("a",s,e,t),z("b",s,e,t))];case"Greater":return[n.greater(z("a",s,e,t),z("b",s,e,t))];case"GreaterEqual":return[n.greaterEqual(z("a",s,e,t),z("b",s,e,t))];case"Less":return[n.less(z("a",s,e,t),z("b",s,e,t))];case"LessEqual":return[n.lessEqual(z("a",s,e,t),z("b",s,e,t))];case"LogicalAnd":return[n.logicalAnd(z("a",s,e,t),z("b",s,e,t))];case"LogicalNot":return[n.logicalNot(z("a",s,e,t))];case"LogicalOr":return[n.logicalOr(z("a",s,e,t),z("b",s,e,t))];case"Select":case"SelectV2":return[n.where(z("condition",s,e,t),z("a",s,e,t),z("b",s,e,t))];case"BitwiseAnd":return[n.bitwiseAnd(z("a",s,e,t),z("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1e=(s,e,t,n=zr)=>{switch(s.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(z("a",s,e,t),z("b",s,e,t),z("transposeA",s,e,t),z("transposeB",s,e,t))];case"Einsum":return[n.einsum(z("equation",s,e,t),...z("tensors",s,e,t))];case"Transpose":return[n.transpose(z("x",s,e,t),z("perm",s,e,t))];case"_FusedMatMul":const[i,r]=z("fusedOps",s,e,t),a=i==="biasadd",o=r==="prelu",l=z("numArgs",s,e,t),u=z("leakyreluAlpha",s,e,t);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,f]=z("args",s,e,t);return[n.fused.matMul({a:z("a",s,e,t),b:z("b",s,e,t),transposeA:z("transposeA",s,e,t),transposeB:z("transposeB",s,e,t),bias:c,activation:r,preluActivationWeights:f,leakyreluAlpha:u})];case"MatrixBandPart":return[n.linalg.bandPart(z("a",s,e,t),z("numLower",s,e,t),z("numUpper",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1e=(s,e,t,n=zr)=>{switch(s.op){case"EuclideanNorm":return[n.euclideanNorm(z("x",s,e,t),z("axis",s,e,t),z("keepDims",s,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(z("x",s,e,t),z("mean",s,e,t),z("variance",s,e,t),z("offset",s,e,t),z("scale",s,e,t),z("epsilon",s,e,t))];case"FusedBatchNormV3":return[n.batchNorm(z("x",s,e,t),z("mean",s,e,t),z("variance",s,e,t),z("offset",s,e,t),z("scale",s,e,t),z("epsilon",s,e,t))];case"LRN":return[n.localResponseNormalization(z("x",s,e,t),z("radius",s,e,t),z("bias",s,e,t),z("alpha",s,e,t),z("beta",s,e,t))];case"Softmax":return[n.softmax(z("x",s,e,t))];case"LogSoftmax":return[n.logSoftmax(z("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d1e=(s,e,t,n=zr)=>{switch(s.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:r}=n.raggedGather(z("paramsNestedSplits",s,e,t),z("paramsDenseValues",s,e,t),z("indices",s,e,t),z("outputRaggedRank",s,e,t));return i.concat(r)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:r}=n.raggedRange(z("starts",s,e,t),z("limits",s,e,t),z("splits",s,e,t));return[i,r]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(z("shape",s,e,t),z("values",s,e,t),z("defaultValue",s,e,t),z("rowPartitionTensors",s,e,t),z("rowPartitionTypes",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p1e=(s,e,t,n=zr)=>{switch(s.op){case"Max":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.max(z("x",s,e,t),o,l)]}case"Mean":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.mean(z("x",s,e,t),o,l)]}case"Min":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.min(z("x",s,e,t),o,l)]}case"Sum":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.sum(z("x",s,e,t),o,l)]}case"All":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.all(z("x",s,e,t),o,l)]}case"Any":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.any(z("x",s,e,t),o,l)]}case"ArgMax":{const o=z("axis",s,e,t);return[n.argMax(z("x",s,e,t),o)]}case"ArgMin":{const o=z("axis",s,e,t);return[n.argMin(z("x",s,e,t),o)]}case"Prod":{const o=z("axis",s,e,t),l=z("keepDims",s,e,t);return[n.prod(z("x",s,e,t),o,l)]}case"Cumprod":{const o=z("axis",s,e,t),l=z("exclusive",s,e,t),u=z("reverse",s,e,t);return[n.cumprod(z("x",s,e,t),o,l,u)]}case"Cumsum":{const o=z("axis",s,e,t),l=z("exclusive",s,e,t),u=z("reverse",s,e,t);return[n.cumsum(z("x",s,e,t),o,l,u)]}case"Bincount":const i=z("x",s,e,t),r=z("weights",s,e,t),a=z("size",s,e,t);return[n.bincount(i,r,a)];case"DenseBincount":{const o=z("x",s,e,t),l=z("weights",s,e,t),u=z("size",s,e,t),c=z("binaryOutput",s,e,t);return[n.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1e=(s,e,t,n=zr)=>{switch(s.op){case"ConcatV2":case"Concat":{const i=z("n",s,e,t),r=z("axis",s,e,t);let a=z("tensors",s,e,t);return a=a.slice(0,i),[n.concat(a,r)]}case"Gather":{const i=z("x",s,e,t),r=z("indices",s,e,t);return[n.gather(i,n.cast(r,"int32"),0)]}case"GatherV2":{const i=z("axis",s,e,t),r=z("batchDims",s,e,t),a=z("x",s,e,t),o=z("indices",s,e,t);return[n.gather(a,n.cast(o,"int32"),i,r)]}case"Reverse":{const i=z("dims",s,e,t),r=[];for(let o=0;o<i.length;o++)i[o]&&r.push(o);const a=z("x",s,e,t);return[n.reverse(a,r)]}case"ReverseV2":{const i=z("axis",s,e,t),r=z("x",s,e,t);return[n.reverse(r,i)]}case"Slice":{const i=z("begin",s,e,t),r=z("size",s,e,t);return[n.slice(z("x",s,e,t),i,r)]}case"StridedSlice":{const i=z("begin",s,e,t),r=z("end",s,e,t),a=z("strides",s,e,t),o=z("beginMask",s,e,t),l=z("endMask",s,e,t),u=z("ellipsisMask",s,e,t),c=z("newAxisMask",s,e,t),f=z("shrinkAxisMask",s,e,t),d=z("x",s,e,t);return[n.stridedSlice(d,i,r,a,o,l,u,c,f)]}case"Pack":return we(()=>{const i=z("axis",s,e,t),r=z("tensors",s,e,t),a=r[0].shape,o=n.squeeze(r[0]).shape,l=r.map(u=>{const c=Wn(u.shape,a);if(!c&&!Wn(n.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:n.reshape(u,a)});return[n.stack(l,i)]});case"Unpack":{const i=z("axis",s,e,t),r=z("tensor",s,e,t);return n.unstack(r,i)}case"Tile":{const i=z("reps",s,e,t);return[n.tile(z("x",s,e,t),i)]}case"Split":case"SplitV":{const i=z("axis",s,e,t),r=z("numOrSizeSplits",s,e,t),a=z("x",s,e,t);return n.split(a,r,i)}case"ScatterNd":{const i=z("indices",s,e,t),r=z("values",s,e,t),a=z("shape",s,e,t);return[n.scatterND(i,r,a)]}case"GatherNd":{const i=z("x",s,e,t),r=z("indices",s,e,t);return[n.gatherND(i,r)]}case"SparseToDense":{const i=z("sparseIndices",s,e,t),r=z("outputShape",s,e,t),a=z("sparseValues",s,e,t),o=z("defaultValue",s,e,t);return[n.sparseToDense(i,a,r,a.dtype===o.dtype?o:n.cast(o,a.dtype))]}case"TensorScatterUpdate":{const i=z("indices",s,e,t),r=z("values",s,e,t),a=z("tensor",s,e,t);return[n.tensorScatterUpdate(a,i,r)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g1e=(s,e,t,n=zr)=>{switch(s.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:a,reverseIndexMap:o}=n.sparse.sparseFillEmptyRows(z("indices",s,e,t),z("values",s,e,t),z("denseShape",s,e,t),z("defaultValue",s,e,t));return[i,r,a,o]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=n.sparse.sparseReshape(z("inputIndices",s,e,t),z("inputShape",s,e,t),z("newShape",s,e,t));return[i,r]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(z("data",s,e,t),z("indices",s,e,t),z("segmentIds",s,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(z("data",s,e,t),z("indices",s,e,t),z("segmentIds",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y1e=(s,e,t,n=zr)=>{switch(s.op){case"FFT":return[n.fft(z("x",s,e,t))];case"IFFT":return[n.ifft(z("x",s,e,t))];case"RFFT":return[n.rfft(z("x",s,e,t))];case"IRFFT":return[n.irfft(z("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1e=(s,e,t,n=zr)=>{switch(s.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(z("input",s,e,t),z("pattern",s,e,t),z("rewrite",s,e,t),z("replaceGlobal",s,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=n.string.stringNGrams(z("data",s,e,t),z("dataSplits",s,e,t),z("separator",s,e,t),z("nGramWidths",s,e,t),z("leftPad",s,e,t),z("rightPad",s,e,t),z("padWidth",s,e,t),z("preserveShortSequences",s,e,t));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:a}=n.string.stringSplit(z("input",s,e,t),z("delimiter",s,e,t),z("skipEmpty",s,e,t));return[i,r,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(z("input",s,e,t),z("numBuckets",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1e=(s,e,t,n=zr)=>{switch(s.op){case"Cast":return[n.cast(z("x",s,e,t),z("dtype",s,e,t))];case"ExpandDims":{const i=z("axis",s,e,t);return[n.expandDims(z("x",s,e,t),i)]}case"Squeeze":{const i=z("axis",s,e,t);return[n.squeeze(z("x",s,e,t),i)]}case"Reshape":return[n.reshape(z("x",s,e,t),z("shape",s,e,t))];case"EnsureShape":return[n.ensureShape(z("x",s,e,t),z("shape",s,e,t))];case"MirrorPad":return[n.mirrorPad(z("x",s,e,t),z("padding",s,e,t),z("mode",s,e,t))];case"PadV2":case"Pad":return[n.pad(z("x",s,e,t),z("padding",s,e,t),z("constantValue",s,e,t))];case"SpaceToBatchND":{const i=z("blockShape",s,e,t),r=z("paddings",s,e,t);return[n.spaceToBatchND(z("x",s,e,t),i,r)]}case"BatchToSpaceND":{const i=z("blockShape",s,e,t),r=z("crops",s,e,t);return[n.batchToSpaceND(z("x",s,e,t),i,r)]}case"DepthToSpace":{const i=z("blockSize",s,e,t),r=z("dataFormat",s,e,t).toUpperCase();return[n.depthToSpace(z("x",s,e,t),i,r)]}case"BroadcastTo":return[n.broadcastTo(z("x",s,e,t),z("shape",s,e,t))];case"BroadcastArgs":return[n.broadcastArgs(z("s0",s,e,t),z("s1",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(s,e,t,n,i=we){const r=((a,o,l)=>{switch(a.category){case"arithmetic":return i(()=>jve(a,o,l));case"basic_math":return i(()=>Kve(a,o,l));case"control":return t1e(a,o,l);case"convolution":return i(()=>n1e(a,o,l));case"creation":return i(()=>s1e(a,o,l));case"dynamic":return i1e(a,o,l);case"evaluation":return i(()=>r1e(a,o,l));case"image":return i(()=>u1e(a,o,l));case"graph":return i(()=>a1e(a,o,l));case"logical":return i(()=>c1e(a,o,l));case"matrices":return i(()=>h1e(a,o,l));case"normalization":return i(()=>f1e(a,o,l));case"ragged":return i(()=>d1e(a,o,l));case"reduction":return i(()=>p1e(a,o,l));case"slice_join":return i(()=>m1e(a,o,l));case"sparse":return i(()=>g1e(a,o,l));case"spectral":return i(()=>y1e(a,o,l));case"string":return i(()=>x1e(a,o,l));case"transformation":return i(()=>v1e(a,o,l));case"hash_table":return l1e(a,o,l,n);case"custom":const u=cW(a.op);if(u&&u.customExecutor)return u.customExecutor(new qve(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(s,e,t);return Ig(r)?r.then(a=>[].concat(a)):[].concat(r)}class M${constructor(e={},t={},n={},i={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=i,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(s,e,t,n){const i=new Set,r=[];let a=null,o=null;const l=new Set,u=new Set(Object.keys(s).map(d=>To(d)[0]));n=n||[];const c=new Set(n.map(d=>To(d.name)[0])),f=[...e];for(;f.length>0;){const d=f.pop();if((eg(d)||E1e(d)||M1e(d))&&a==null&&(a=d,o=a.children.map(g=>g.name).filter(g=>i.has(g))),i.add(d.name),t[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){r.push(d.name);continue}d.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:s,outputs:e,usedNodes:i,missingInputs:r,dynamicNode:a,syncInputs:o}}function b1e(s,e){const{usedNodes:t,inputs:n}=e,i=Object.keys(n).map(b=>To(b)[0]).map(b=>s.nodes[b]),r=s.initNodes||[],a=b=>t.has(typeof b=="string"?b:b.name);function o(b){return[...new Map(b.map(_=>[_.name,_])).values()]}const l=o([...i,...s.weights,...r]).filter(a),u=o([...l,...Object.values(s.nodes)]).filter(a),c=new Map(u.map(b=>[b.name,b])),f={};for(const b of u){f[b.name]=f[b.name]||0;for(const _ of b.children)a(_)||(f[_.name]=Number.POSITIVE_INFINITY),f[_.name]=(f[_.name]||0)+1}const d=Object.entries(f).filter(([,b])=>b===0).map(([b])=>b),g=[...d];for(;d.length>0;){const b=d.pop(),_=c.get(b);for(const T of _.children.filter(a))--f[T.name]===0&&(g.push(T.name),d.push(T.name))}const x=g.map(b=>c.get(b)),S=_1e(x,l);return S1e(S,l),S}function _1e(s,e){const t=new Map(s.map(a=>[a.name,a])),n=e.map(a=>a.name),i=new Set(n);for(;n.length>0;){const a=n.pop(),o=t.get(a);for(const l of o.children)!t.has(l.name)||i.has(l.name)||(i.add(l.name),n.push(l.name))}return s.filter(a=>i.has(a.name))}class hw extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function S1e(s,e){const t=new Map(s.map((o,l)=>[o.name,l])),n=new Set(e.map(o=>o.name)),i=o=>n.has(typeof o=="string"?o:o.name),r=new Set(s.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name);for(const o of s){for(const l of o.children.filter(a)){if(!t.has(l.name))throw new hw(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new hw(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!i(o))for(const l of o.inputs){if(!t.has(l.name))throw new hw(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new hw(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function A1e(s){const e=new Map(s.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,n=s.map((o,l)=>eg(o)?t:l),i=o=>{const l=n[e.get(o.name)];return l??-1},r=s.map((o,l)=>o.children.map(i).reduce((u,c)=>Math.max(u,c),n[l])),a=new Map;for(let o=0;o<s.length;++o){const l=r[o];if(l===t)continue;const u=s[o],c=s[l];a.has(c.name)||a.set(c.name,[]),a.get(c.name).push(u)}return a}const T1e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),w1e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),C1e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function eg(s){return T1e.has(s.op)}function E1e(s){return w1e.has(s.op)}function M1e(s){return C1e.has(s.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oC{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new oC(e.functions[n],this)})}getCompilationKey(e,t){const n=e.map(r=>r.name).sort(),i=t.map(r=>r.name).sort();return n.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const n=N$(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:a}=n;if(r!=null)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){const u=t.map(f=>f.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${i}]`)}const o=b1e(this.graph,n),l=A1e(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return xr(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=n.map(d=>this.graph.nodes[To(d)[0]]),r=t.map(d=>To(d)[0]),a=new Set(r);let o=r.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(i,o);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},f={};return we(()=>{const d=new M$(this.weightMap,c,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(_=>{const[T,E]=To(_,d),C=[];C[E]=e[_],g[T]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(C))});const x=this.getFrozenTensorIds(g),{orderedNodes:S,nodeLiveUntilMap:b}=u;for(const _ of S){if(g[_.name])continue;const T=E$(_,g,d,this._resourceManager);if(Ig(T))throw new Error(`The execution of the op '${_.op}' returned a promise. Please use model.executeAsync() instead.`);g[_.name]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[_.name]=this.cloneTensorList(T)),this.checkTensorForDisposalWithNodeLiveUntilInfo(_,g,d,x,a,b.get(_.name))}return this.parent==null&&d.dispose(x),t.map(_=>Dr(_,g,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,n,i,r,a,o){if(!(eg(t)||a.has(e))){for(const l of n[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(eg(l))continue;const u=S$(l.name,n,i);if(u!=null)for(const c of u){if(!c||c.kept||r.has(c.id))continue;const f=o[c.id];f===1?(c.dispose(),delete o[c.id]):f!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,i,r,a){function o(l){return eg(l)||r.has(l.name)}if(!(eg(e)||a==null))for(const l of a){if(o(l))continue;const u=S$(l.name,t,n);for(const c of u)!c||c.kept||i.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,i={},r={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const a=new M$(this.weightMap,i,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,n),l=t.map(d=>Dr(d,o,a)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),f=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&a.dispose(f),l}async executeFunctionAsync(e,t,n){const i=e.reduce((r,a,o)=>(r[this.inputs[o].name]=a,r),{});return this._executeAsync(i,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,i){const r=Object.keys(e),a=r.map(C=>this.graph.nodes[To(C)[0]]),o=n.map(C=>To(C)[0]),l=new Set(o);let u=o.map(C=>this.graph.nodes[C]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:f,dynamicNode:d,syncInputs:g}=N$(e,u,this.weightMap,this._initNodes),x=[...a,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:t.currentContext})),S=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[R,I]=To(C),L=[];L[I]=e[C],S[R]=L});const b={},_=this.getFrozenTensorIds(S),T={};for(;x.length>0;){const C=this.processStack(a,x,t,S,T,_,l,b,c);await Promise.all(C)}d==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const E=u.filter(C=>!eg(C)&&!Dr(C.name,S,t)).map(C=>C.name);if(E.length>0){let C="";throw d!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${E}] from the provided inputs [${r}]. Consider providing the following inputs: [${f}]. ${C}`)}return S}processStack(e,t,n,i,r,a,o,l,u){const c=[];for(;t.length>0;){const f=t.pop();n.currentContext=f.contexts;let d="";if(f.node.op==="Enter"&&z("isConstant",f.node,i,n)&&([d]=tf(f.node.name,n)),i[f.node.name]==null){const g=E$(f.node,i,n,this._resourceManager);d||([d]=tf(f.node.name,n));const x=n.currentContext;Ig(g)?c.push(g.then(S=>(i[d]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(S)),n.currentContext=x,this.checkTensorForDisposal(d,f.node,i,n,a,o,l),this.processChildNodes(f.node,t,n,i,r,u),S))):(i[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),this.checkTensorForDisposal(d,f.node,i,n,a,o,l),this.processChildNodes(f.node,t,n,i,r,u))}else this.processChildNodes(f.node,t,n,i,r,u)}return c}processChildNodes(e,t,n,i,r,a){e.children.forEach(o=>{const[l]=tf(o.name,n);r[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!Dr(u,i,n))&&(r[l]=!0,t.push({contexts:n.currentContext,node:o})):o.inputNames.every(u=>!!Dr(u,i,n))&&(r[l]=!0,t.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[i]=To(t),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const a=r.attrParams.shape.value,o=a.length===n.shape.length&&n.shape.every((l,u)=>a[u]===-1||a[u]===l);K(o,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&K(n.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const i={};for(const r in e){const a=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[r];a!=null?i[a.name]=e[r]:i[r]=e[r]}return i}checkInputs(e){const t=Object.keys(e).filter(n=>{const[i]=To(n);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,i;const r=(i=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||i===void 0?void 0:i[t];return r!=null?r.name:t},{})}checkOutputs(e){e.forEach(t=>{const[n]=To(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}}class N1e{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1e="?tfjs-format=file",I1e="model.json";class D1e{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=fH){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new N1e}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ig(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await F8(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const r=this.artifacts.userDefinedMetadata;r.signature!=null&&(i=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=i,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new oC(A$.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const r=A$.Instance.transformGraph(e.modelInitializer);this.initializer=new oC(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof ls?[e]:e,n={};return t.forEach((i,r)=>n[this.structuredOutputKeys[r]]=i),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof ls)&&!Array.isArray(e)){const r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(const a in r){const o=r[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((r,a)=>{var o,l,u;const c=(u=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[a])===null||u===void 0?void 0:u.resourceId;return c!=null?r[a]=this.resourceIdToCapturedInput[c]:r[a]=e[i++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let i=0;i<n.length;i++){const r=n[i],a=t[r];this.resourceIdToCapturedInput[a.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Bn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function dW(s,e={},t=fH){if(s==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof s=="string"&&(s=O1e(s));const n=new D1e(s,e,t);return await n.load(),n}function O1e(s){return s.endsWith("/")||(s=s+"/"),`${s}${I1e}${R1e}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var R$;(function(s){s[s.FAIL=0]="FAIL",s[s.SHORTEST=1]="SHORTEST",s[s.LONGEST=2]="LONGEST"})(R$||(R$={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(s,e){Array.isArray(s)||(s=[s]),s.forEach(t=>{t!=null&&K(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B1e=Ak;class VM extends LO{nextDataId(){return VM.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new l8(this,qc())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Ie().get("IS_NODE")&&cl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:n,refCount:1}),i}makeTensorInfo(e,t,n){let i;if(t==="string"&&n!=null&&n.length>0&&d_(n[0])){const r=n.map(a=>Yd(a));i=this.write(r,e,t)}else i=this.write(n,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,n,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){const i=this.readSync(n.real.dataId),r=this.readSync(n.imag.dataId);return Tf(i,r)}return Uoe(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(i=>ap(i));return Mn(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Mn(e.shape,e.dtype,t)}makeOutput(e,t,n){return qc().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Za();return e(),{kernelMs:Za()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){zt([e],"where");const t=this.readSync(e.dataId);return B1e(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}VM.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(s){const e=new Float32Array(s.length);for(let t=0;t<s.length;++t)e[t]=Math.abs(s[t]);return e}const k1e=s=>{const{x:e}=s.inputs,t=s.backend;zt(e,"abs");let n=new Float32Array(Xe(e.shape));const i=t.data.get(e.dataId).values;return n=pW(i),t.makeOutput(n,e.shape,e.dtype)},L1e={kernelName:sE,backendName:"cpu",kernelFunc:k1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(s){return(e,t,n,i,r)=>{const a=gn(e,t),o=a.length,l=jt(a),u=Xe(a),c=Fr(r,u),f=e.length,d=t.length,g=jt(e),x=jt(t),S=Ax(e,a),b=Ax(t,a);if(S.length+b.length===0)for(let _=0;_<c.length;++_)c[_]=s(n[_%n.length],i[_%i.length]);else for(let _=0;_<c.length;++_){const T=Hx(_,o,l),E=T.slice(-f);S.forEach(L=>E[L]=0);const C=ah(E,f,g),R=T.slice(-d);b.forEach(L=>R[L]=0);const I=ah(R,d,x);c[_]=s(n[C],i[I])}return[c,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(s){const{inputs:e,backend:t}=s,{real:n,imag:i}=e,r=t.data.get(n.dataId).values,a=t.data.get(i.dataId).values,o=t.makeTensorInfo(n.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",a)},o}const F1e={kernelName:XO,backendName:"cpu",kernelFunc:Co};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lC(s,e,t="float32"){if(t==="complex64"){const i=lC(s,e,"float32"),r=lC(s,e,"float32");return Co({inputs:{real:i,imag:r},backend:s})}const n=sa(Xe(e),t);return s.makeTensorInfo(e,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(s){const{inputs:e,backend:t}=s,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const P1e={kernelName:B_,backendName:"cpu",kernelFunc:mh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gg(s){const{inputs:e,backend:t}=s,{input:n}=e,i=t.data.get(n.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const U1e={kernelName:TB,backendName:"cpu",kernelFunc:Gg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(s,e,t,n){if(n==="int32"){const i=Int32Array.from(s);return[e,"int32",i]}if(n==="bool"){const i=Jg([0],t),[r,a]=Di((o,l)=>o!==l?1:0)(e,[],s,i,"bool");return[a,"bool",r]}throw new Error(`Error in Cast: failed to cast ${t} to ${n}`)}function mp(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{dtype:r}=n;if(r==="complex64"){if(i.dtype==="complex64")return mh({inputs:{x:i},backend:t});const c=lC(t,i.shape,i.dtype),f=mp({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),d=Co({inputs:{real:f,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(f),d}if(i.dtype==="complex64"){const c=Gg({inputs:{input:i},backend:t}),f=mp({inputs:{x:c},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(c),f}if(!c8(i.dtype,r)){const c=mh({inputs:{x:i},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:r}}const a=t.data.get(i.dataId).values,[o,l,u]=mW(a,i.shape,i.dtype,r);return t.makeTensorInfo(o,l,u)}const $1e={kernelName:__,backendName:"cpu",kernelFunc:mp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(s,e,t,n){return t==null?({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;zt([a,o],s);const u=l.data.get(a.dataId).values,c=l.data.get(o.dataId).values,f=a.dtype==="string"?wf(u):u,d=a.dtype==="string"?wf(c):c,g=n||a.dtype,[x,S]=e(a.shape,o.shape,f,d,g);return l.makeTensorInfo(S,g,x)}:({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;if(a.dtype==="complex64"||o.dtype==="complex64"){const u=mp({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),f=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,g=l.data.get(f.dataId).values,x=l.data.get(d.dataId).values,S=mp({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),b=l.data.get(S.dataId),_=b.complexTensorInfos.real,T=b.complexTensorInfos.imag,E=l.data.get(_.dataId).values,C=l.data.get(T.dataId).values,[R,I,L]=t(a.shape,o.shape,g,x,E,C),P=l.makeTensorInfo(L,"float32",R),D=l.makeTensorInfo(L,"float32",I),O=Co({inputs:{real:P,imag:D},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(S),l.disposeIntermediateTensorInfo(P),l.disposeIntermediateTensorInfo(D),O}else{const u=l.data.get(a.dataId).values,c=l.data.get(o.dataId).values,f=n||a.dtype,[d,g]=e(a.shape,o.shape,u,c,f);return l.makeTensorInfo(g,f,d)}}}function EL(s){return(e,t,n,i,r,a)=>{const o=gn(e,t),l=Xe(o),u=o.length,c=jt(o),f=Fr("float32",l),d=Fr("float32",l),g=Ax(e,o),x=Ax(t,o),S=Tf(n,i),b=Tf(r,a),_=e.length,T=jt(e),E=t.length,C=jt(t);if(g.length+x.length===0)for(let R=0;R<f.length;R++){const I=R%S.length,L=R%b.length,P=s(S[I*2],S[I*2+1],b[L*2],b[L*2+1]);f[R]=P.real,d[R]=P.imag}else for(let R=0;R<f.length;R++){const I=Hx(R,u,c),L=I.slice(-_);g.forEach(X=>L[X]=0);const P=ah(L,_,T),D=I.slice(-E);x.forEach(X=>D[X]=0);const O=ah(D,E,C),F=s(S[P*2],S[P*2+1],b[O*2],b[O*2+1]);f[R]=F.real,d[R]=F.imag}return[f,d,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gW=Di((s,e)=>s+e),z1e=EL((s,e,t,n)=>({real:s+t,imag:e+n})),Ex=ar(Vx,gW,z1e),G1e={kernelName:Vx,backendName:"cpu",kernelFunc:Ex};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(s,e,t,n,i){const r=Xe(n),a=sa(i,t);for(let o=0;o<s.length;o++){const l=s[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?a[l]+=e[o]:a[l]+=1)}return a}function yW(s,e,t,n=!1){const i=s.shape[0],r=s.shape[1],a=Mn([i,t],e.dtype);for(let o=0;o<i;o++)for(let l=0;l<r;l++){const u=s.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(n?a.set(1,o,u):e.size>0?a.set(a.get(o,u)+e.get(o,l),o,u):a.set(a.get(o,u)+1,o,u))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xW=Di((s,e)=>s&e),H1e=ar(hE,xW),V1e={kernelName:hE,backendName:"cpu",kernelFunc:H1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(s){return(e,t,n)=>{const i=Mi(t,e.length);for(let r=0;r<e.length;++r)i[r]=s(e[r],n);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(s,e,t){const n=vh(e);return Rp(s,n,t)}function Rp(s,e,t){return({inputs:n,attrs:i,backend:r})=>{const{x:a}=n;zt(a,s);const o=r,l=o.data.get(a.dataId).values;let u;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=wf(l)}else u=l;const c=t||a.dtype,f=e(u,c,i);return o.makeTensorInfo(a.shape,c,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=vh(s=>Math.ceil(s)),W1e=Rp(S_,vW),X1e={kernelName:S_,backendName:"cpu",kernelFunc:W1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(s,e,t,n){const i=Mi(t,Xe(e));if(n&&t!=="string"){let r=0;s.forEach(a=>{const o=Xe(a.shape);i.set(a.vals,r),r+=o})}else{let r=0;s.forEach(a=>{const o=t==="string"?wf(a.vals):a.vals;let l=0;for(let u=0;u<a.shape[0];++u){const c=u*e[1]+r;for(let f=0;f<a.shape[1];++f)i[c+f]=o[l++]}r+=a.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _W=Di((s,e)=>s===e?1:0),SW=ar(bE,_W,null,"bool"),q1e={kernelName:bE,backendName:"cpu",kernelFunc:SW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AW=vh(s=>Math.exp(s)),TW=Rp(N_,AW,"float32"),j1e={kernelName:N_,backendName:"cpu",kernelFunc:TW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wW=vh(s=>Math.expm1(s)),K1e=Rp(R_,wW),Y1e={kernelName:R_,backendName:"cpu",kernelFunc:K1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CW=vh(s=>Math.floor(s)),J1e=Rp(I_,CW),Z1e={kernelName:I_,backendName:"cpu",kernelFunc:J1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EW=Di((s,e)=>Math.floor(s/e)),Q1e=ar(D_,EW,null,"int32"),ebe={kernelName:D_,backendName:"cpu",kernelFunc:Q1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(s,e,t,n,i,r,a,o,l){const u=Mn([n,r],t);for(let c=0;c<n;c++){const f=[];let d=0;for(let g=0;g<i;g++){const x=s[c*i+g];d+=x*a[g],f.push(x)}if(d<0||d>=l/r)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let g=0;g<r;g++)u.values[c*r+g]=e.get(...e.indexToLoc(d*r+g))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NW(s,e,t){const n=Mn(t,s.dtype);for(let i=0;i<n.size;++i){const a=n.indexToLoc(i).slice(),o=a[0],l=a[2],u=e.locToIndex([o,l]);a[2]=e.values[u];const c=s.locToIndex(a);0<=c&&c<s.values.length&&(n.values[i]=s.values[c])}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RW=Di((s,e)=>s>e?1:0),tbe=ar(TE,RW,null,"bool"),nbe={kernelName:TE,backendName:"cpu",kernelFunc:tbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW=Di((s,e)=>s>=e?1:0),sbe=ar(O_,IW,null,"bool"),ibe={kernelName:O_,backendName:"cpu",kernelFunc:sbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW=Di((s,e)=>s<e?1:0),rbe=ar(CE,DW,null,"bool"),abe={kernelName:CE,backendName:"cpu",kernelFunc:rbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OW=Di((s,e)=>s<=e?1:0),obe=ar(EE,OW,null,"bool"),lbe={kernelName:EE,backendName:"cpu",kernelFunc:obe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BW(s,e,t){const n=(e-s)/(t-1),i=sa(t,"float32");i[0]=s;for(let r=1;r<i.length;r++)i[r]=i[r-1]+n;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kW=vh(s=>Math.log(s)),ube=Rp(P_,kW),cbe={kernelName:P_,backendName:"cpu",kernelFunc:ube};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(s,e,t,n){const i=Fr(n,Xe(t));for(let r=0;r<i.length;++r){const a=r*e;let o=s[a];for(let l=0;l<e;++l){const u=s[a+l];(Number.isNaN(u)||u>o)&&(o=u)}i[r]=o}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FW=Di((s,e)=>Math.max(s,e)),hbe=ar($_,FW),fbe={kernelName:$_,backendName:"cpu",kernelFunc:hbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=Di((s,e)=>Math.min(s,e)),dbe=ar(z_,PW),pbe={kernelName:z_,backendName:"cpu",kernelFunc:dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NL=Di((s,e)=>s*e),mbe=EL((s,e,t,n)=>({real:s*t-e*n,imag:s*n+e*t})),WM=ar(H_,NL,mbe),gbe={kernelName:H_,backendName:"cpu",kernelFunc:WM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UW(s,e,t){const n=_p(-1,t);return NL([],e,n,s,t)}function ybe(s){const{inputs:e,backend:t}=s,{x:n}=e;zt(n,"neg");const i=t.data.get(n.dataId).values,[r,a]=UW(i,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,r)}const xbe={kernelName:PE,backendName:"cpu",kernelFunc:ybe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=Di((s,e)=>s!==e?1:0),vbe=ar(UE,$W,null,"bool"),bbe={kernelName:UE,backendName:"cpu",kernelFunc:vbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(s,e,t,n,i){const r=e.length,a=Xe(e),o=jt(e),l=jt(i),u=Fr(t,Xe(i));for(let c=0;c<a;++c){const f=Hx(c,r,o),d=new Array(f.length);for(let x=0;x<d.length;x++)d[x]=f[n[x]];const g=ah(d,r,l);u[g]=s[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(s){const{inputs:e,attrs:t,backend:n}=s,{x:i}=e,{perm:r}=t;zt(i,"transpose");const a=i.shape.length,o=new Array(a);for(let f=0;f<o.length;f++)o[f]=i.shape[r[f]];const l=n.data.get(i.dataId).values,u=RL(l,i.shape,i.dtype,r,o);return{dataId:n.write(u,o,i.dtype),shape:o,dtype:i.dtype}}const _be={kernelName:Ky,backendName:"cpu",kernelFunc:ro};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zW(s,e,t,n){const[i,r]=Tr(s,n),a=ko(e,"int32"),o=sa(Xe(i),a),l=Xe(r);for(let u=0;u<o.length;++u){const c=u*l;let f=1;for(let d=0;d<l;++d)f*=t[c+d];o[u]=f}return{outVals:o,outShape:i,outDtype:a}}function Sbe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;zt(i,"prod");const o=i.shape.length,l=kn(r,i.shape),u=ri(l,o);let c=l,f=i;const d=[];u!=null&&(f=ro({inputs:{x:i},backend:t,attrs:{perm:u}}),d.push(f),c=Ri(c.length,o));const g=t.data.get(f.dataId).values,{outVals:x,outShape:S,outDtype:b}=zW(f.shape,f.dtype,g,c);let _=S;return a&&(_=Ni(S,l)),d.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.makeTensorInfo(_,b,x)}const Abe={kernelName:WE,backendName:"cpu",kernelFunc:Sbe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(s,e,t){s.forEach((n,i)=>{if(n<0||n>=t){const r=Hx(i,e.length,jt(e)).join(",");throw new Error(`indices[${r}] = ${n} is not in [0, ${t})`)}})}function wbe(s,e){for(let t=0;t<s.length;++t){const n=s[t],i=t===s.length-1?e:s[t+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<n.length;++r)if(n[r-1]>n[r])throw new Error("Ragged splits must be sorted in ascending order")}}function Cbe(s,e,t,n){const i=[];let r=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);wbe(t,n);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let f=1;f<l+1;++f)o[u].push(f*c)}for(let u=0;u<s.length;++u){let c=s[u],f=s[u]+1;for(let d=0;d<t.length;++d){const g=t[d],x=d+e.length-1;if(x>=0){const S=o[x],b=S[S.length-1]-g[c];for(let _=c;_<f;++_)o[x].push(g[_+1]+b)}c=g[c],f=g[f]}f!==c&&(i.push([c,f]),r+=f-c)}return{outSplits:o,valueSlices:i,numValues:r}}function Ebe(s){const e=[];for(let t=0;t<s.length;++t){const n=s[t].length,i=Mi("int32",n);e.push(i),s[t].forEach((r,a)=>i[a]=r)}return e}function I$(s,e){const t=s.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<s.length;n++)t[e-1]*=s[n];return t}function Mbe(s,e,t,n,i,r){const a=I$(e,2)[1],o=I$(r,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let f=0;f<n;++f)i[l*o+f]=s[c*a+f];++l}}function Nbe(s,e,t,n,i){const r=e.slice();r[0]=i;const a=Mi(t,Xe(r)),o=s.length,l=o===0?0:o/e[0];return Mbe(s,e,n,l,a,r),[a,r]}function GW(s,e,t,n,i,r,a,o){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Tbe(r,a,l),n.length===0)throw new Error("params.rank must be nonzero");const u=n[0],{outSplits:c,valueSlices:f,numValues:d}=Cbe(r,a,s,u),g=Ebe(c),x=Nbe(t,n,i,f,d);return[g,x[0],x[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$=2147483647;function HW(s,e,t,n,i,r,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=i.length===0,u=a.length===0,c=[];o||c.push(e[0]),l||c.push(i[0]),u||c.push(a[0]);for(let b=1;b<c.length;++b)if(c[b]!==c[b-1])throw new Error("starts, limits, and deltas must have the same shape");const f=c.length===0?1:c[0],d=Mi("int32",f+1);d[0]=0;for(let b=0;b<f;++b){const _=o?s[0]:s[b],T=l?n[0]:n[b],E=u?r[0]:r[b];if(E===0)throw new Error("Requires delta != 0");let C;if(E>0&&T<_||E<0&&T>_)C=0;else if(C=Math.ceil(Math.abs((T-_)/E)),C>D$)throw new Error(`Requires ((limit - start) / delta) <= ${D$}`);d[b+1]=d[b]+C}const g=d[f],x=Mi(t,g);let S=0;for(let b=0;b<f;++b){const _=d[b+1]-d[b];let T=o?s[0]:s[b];const E=u?r[0]:r[b];for(let C=0;C<_;++C)x[S++]=T,T+=E}return[d,x]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Kl=Yu;class uC{constructor(e,t,n,i,r,a,o,l,u,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=i,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=TH(c),this.raggedRank=wH(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Kl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Kl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Kl.VALUE_ROWIDS:return uC.getMaxWidthValueRowID(t);case Kl.ROW_SPLITS:return uC.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Kl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let n=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>n&&(n=r)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let n=0,i=e[0],r=0;for(let a=1;a<t;++a){const o=e[a];o!==i&&(i=o,r=Math.max(a-n,r),n=a)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return B$(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;CH(n,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=AH(this.raggedRank,i,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,n){const i=Math.min(e,n),r=[];let a=0;for(let o=0;o<i;++o,a+=t)r.push(a);for(let o=i;o<e;++o)r.push(-1);return K(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,n,i){const r=e.length,a=[];for(let o=0;o<r-1;++o){const l=e[o+1]-e[o];let u=Math.min(i,l),c=t[o];c===-1&&(u=0);for(let f=0;f<u;++f)a.push(c),c+=n;for(let f=0;f<l-u;++f)a.push(-1)}if(r>0&&a.length!==e[r-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,i){const r=e.length,a=[];if(r===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];a.push(u);for(let c=1;c<r;++c){const f=e[c];if(f===l)u>=0&&(++o,o<i?u+=n:u=-1);else{if(o=0,l=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);u=t[f]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,i){const r=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Kl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,i);case Kl.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,n,i);default:throw new Error(`Unsupported partition type: ${Kl[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Kl.FIRST_DIM_SIZE:return e[0];case Kl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Kl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Kl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*n[l+1];const r=B$(n,!1),a=Mi(this.valuesDType,Xe(r));if(i[0]*n[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],n[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,i[u],n[u]);this.setOutput(this.raggedRank,l,a,r)}return[r,a]}setOutput(e,t,n,i){if(n.length===0)return;const r=this.values,a=n;let o=i.slice();o=o.slice(e+1);const l=Xe(o),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const x=this.defaultValueShape;we(()=>{const S=xe(c,x);c=Zy(S,o).dataSync()})}let f=0,d=0,g=0;for(let x=0;x<=u;++x){let S=x<u?t[x]:-1;if(S===g){++g;continue}if(d<g){const b=r.subarray(f*l),_=a.subarray(d*l),T=(g-d)*l;O$(_,b,T)}if(x>=u){const b=n.length;S=Math.floor(b/l)}if(S>g)if(this.defaultValue.length===1)a.subarray(g*l,S*l).fill(this.defaultValue[0]),g=S;else for(;S>g;){const b=a.slice(g*l);O$(b,c,l),++g}S<0?(f=x+1,d=g):(f=x,d=g,g=d+1)}}}function O$(s,e,t){for(let n=0;n<t;n++)s[n]=e[n]}function B$(s,e){const t=[];for(let n of s){if(n<0){if(!e)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}t.push(n)}return t}function VW(s,e,t,n,i,r,a,o,l,u){return new uC(s,e,t,n,i,r,a,o,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WW(s,e,t,n){const i=s===e,r=s<e&&t<0,a=e<s&&t>1;if(i||r||a)return sa(0,n);const o=Math.abs(Math.ceil((e-s)/t)),l=sa(o,n);e<s&&t===1&&(t=-1),l[0]=s;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XW=vh(s=>1/Math.sqrt(s)),Rbe=Rp(K_,XW),Ibe={kernelName:K_,backendName:"cpu",kernelFunc:Rbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cg(s,e,t,n,i,r,a,o,l,u){const c=[n/i,i],f=s.values,d=e.values;if(n===0)return Mn(t,e.dtype);const g=l instanceof nr?l:Mn(c,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let x=0;x<r;x++){const S=[];let b=0;for(let _=0;_<a;_++){const T=f[x*a+_];S.push(T),b+=T*o[_]}if(b<0||b>=n/i)throw new Error(`Invalid indices: ${S} does not index into ${t}`);for(let _=0;_<i;_++)u?g.values[b*i+_]+=d[x*i+_]:g.values[b*i+_]=e.rank===0?d[0]:d[x*i+_]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dbe=vh(s=>1/(1+Math.exp(-s))),qW=bs(eS,s=>1/(1+Math.exp(-s))),Obe={kernelName:eS,backendName:"cpu",kernelFunc:qW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jW(s,e,t,n,i){const r=Lk(n,e,t),a=Xe(t),o=jt(n);if(r){const f=Fk(e,o);return i==="string"?s.slice(f,f+a):s.subarray(f,f+a)}const l=i==="string"?wf(s):s,u=Mn(n,i,l),c=Mn(t,i);for(let f=0;f<c.size;++f){const d=c.indexToLoc(f),g=d.map((x,S)=>x+e[S]);c.set(u.get(...g),...d)}return i==="string"?XH(c.values):c.values}function Hg(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{begin:r,size:a}=n;zt(i,"slice");const[o,l]=RM(i,r,a);Bk(i,o,l);const u=t.data.get(i.dataId).values,c=jW(u,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,c)}const Bbe={kernelName:JE,backendName:"cpu",kernelFunc:Hg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KW(s,e,t,n,i,r,a){const o=e[0],l=r[0],u=new Array(l),c=new Array(o),f=e[1];if(l===0){if(o!==0)throw new Error(OH(o));const b=Mi(t,0),_=Mi(i,0);return[b,[0,f],_,u,c]}let d=!0,g=0;const x=new Array(l).fill(0);for(let b=0;b<o;++b){const _=s[b*f];if(_<0)throw new Error(BH(b,_));if(_>=l)throw new Error(kH(b,_,l));++x[_],d=d&&_>=g,g=_}let S=!0;for(let b=0;b<l;++b){const _=x[b]===0;u[b]=_,S=S&&!_,x[b]=Math.max(x[b],1),b>0&&(x[b]+=x[b-1])}if(S&&d){const b=s,_=n;for(let T=0;T<o;++T)c[T]=T;return[b,[o,f],_,u,c]}else{const b=x[l-1],_=Mi(t,b*f),T=Mi(i,b),E=new Array(l).fill(0);for(let C=0;C<o;++C){const R=s[C*f],I=E[R],L=(R===0?0:x[R-1])+I;E[R]++;for(let P=0;P<f;++P)_[L*f+P]=s[C*f+P];T[L]=n[C],c[C]=L}for(let C=0;C<l;++C)if(E[C]===0){const I=C===0?0:x[C-1];_[I*f+0]=C;for(let L=1;L<f;++L)_[I*f+L]=0;T[I]=a}return[_,[b,f],T,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(s,e,t,n,i){const r=Xe(n),a=e[0],o=i.length,l=[];let u=1,c=-1;for(let b=0;b<o;++b){const _=i[b];if(_===-1){if(c!==-1)throw new Error(LH(c,b));c=b,l.push(1)}else{if(_<0)throw new Error(FH(b,_));u*=_,l.push(_)}}if(c!==-1){if(u<=0)throw new Error(PH());const b=Math.trunc(r/u);if(u*b!==r)throw new Error(UH(n,l));l[c]=b}if(Xe(l)!==r)throw new Error($H(n,l));const d=n.length,g=[];if(d>0){g[d-1]=1;for(let b=d-2;b>=0;--b)g[b]=g[b+1]*n[b+1]}const x=[];if(o>0){x[o-1]=1;for(let b=o-2;b>=0;--b)x[b]=x[b+1]*l[b+1]}const S=Mi(t,a*o);for(let b=0;b<a;++b){let _=0;for(let T=0;T<d;++T)_+=s[b*d+T]*g[T];for(let T=0;T<o;++T)S[b*o+T]=Math.trunc(_/x[T]),_%=x[T]}return[S,[a,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IL(s,e,t,n,i,r=!1,a=0){const o=n.length,l=[e[0],s.length/e[0]],u=l[1],f=o>0?i[o-1]+1:0;if(f<0)throw new Error(zD());const d=e.slice();d[0]=f;const g=d.reduce((E,C)=>E*C,1),x=Mi(t,g);if(o===0)return f>0&&x.fill(a),[x,d];if(f<=0)throw new Error(zD());let S=0,b=1,_=0,T=i[S];for(;;){let E=0;if(b<o){if(E=i[b],T===E){++b;continue}if(T>=E)throw new Error(zH())}if(T<0||T>=f)throw new Error(GH(T,f));T>_&&x.fill(a,_*u,T*u);for(let C=S;C<b;++C){const R=n[C];if(R<0||R>=l[0])throw new Error(HH(C,n[C],l[0]));for(let I=0;I<u;I++)x[T*u+I]+=s[R*u+I]}if(r)for(let C=0;C<u;C++)x[T*u+C]/=b-S;if(S=b,++b,_=T+1,T=E,b>o)break}return _<f&&x.fill(a,_*u,f*u),[x,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kbe=vh(s=>Math.sqrt(s)),Lbe=bs(nS,s=>Math.sqrt(s)),Fbe={kernelName:nS,backendName:"cpu",kernelFunc:Lbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JW=Di((s,e)=>{const t=s-e;return t*t}),Pbe=ar(sS,JW),Ube={kernelName:sS,backendName:"cpu",kernelFunc:Pbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZW=vh((s,e)=>{const{pattern:t,replaceGlobal:n,rewrite:i}=e;return s.replace(new RegExp(t,n?"g":""),i)}),$be=Rp(nM,ZW),zbe={kernelName:nM,backendName:"cpu",kernelFunc:$be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QW(s,e,t,n){const i=Mn(s,e.dtype);for(let r=0;r<i.size;r++){const a=i.indexToLoc(r),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*t[l]+n[l];i.set(e.get(...o),...a)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gbe{constructor(e,t,n,i,r,a){this.separator=Yd(e),this.nGramWidths=t,this.leftPad=Yd(n),this.rightPad=Yd(i),this.padWidth=r,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,i,r,a){for(let o=0;o<r;++o){const l=this.getPadWidth(a),u=Math.max(0,l-o),c=Math.max(0,l-(r-(o+1))),f=a-(u+c),d=t+(u>0?0:o-l);let g=0;g+=u*this.leftPad.length;for(let T=0;T<f;++T)g+=e[d+T].length;g+=c*this.rightPad.length;const x=u+c+f-1;g+=x*this.separator.length,n[i+o]=new Uint8Array(g);const S=n[i+o];let b=0;const _=T=>T.forEach(E=>S[b++]=E);for(let T=0;T<u;++T)_(this.leftPad),_(this.separator);for(let T=0;T<f-1;++T)_(e[d+T]),_(this.separator);if(f>0){_(e[d+f-1]);for(let T=0;T<c;++T)_(this.separator),_(this.rightPad)}else{for(let T=0;T<c-1;++T)_(this.rightPad),_(this.separator);_(this.rightPad)}}}compute(e,t){const n=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<i;++u){let c=t[u]>=l;if(c=c&&t[u]<=n,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${n}]`);l=t[u]}if(l!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${l}`)}const r=i-1,a=Mi("int32",i);if(n===0||i===0){const l=new Array(n);for(let u=0;u<=r;++u)a[u]=0;return[l,a]}a[0]=0;for(let l=1;l<=r;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(f=>{c+=this.getNumNGrams(u,f)}),this.preserveShort&&u>0&&c===0&&(c=1),a[l]=a[l-1]+c}const o=new Array(a[r]);for(let l=0;l<r;++l){const u=t[l];let c=a[l];if(this.nGramWidths.forEach(f=>{const d=t[l+1]-t[l],g=this.getNumNGrams(d,f);this.createNGrams(e,u,o,c,g,f),c+=g}),this.preserveShort&&c===a[l]){const f=t[l+1]-t[l];if(f===0)continue;const d=f+2*this.padWidth;this.createNGrams(e,u,o,c,1,d)}}return[o,a]}}function eX(s,e,t,n,i,r,a,o){return new Gbe(t,n,i,r,a,o).compute(s,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(s,e,t,n){if(!s.length)return;if(e.length===0){for(let r=0;r<s.length;++r)n.push(s.subarray(r,r+1));return}if(e.length===1){const r=e[0];let a=s.indexOf(r);for(;a!==-1;){const o=s.subarray(0,a);(!t||o.length!==0)&&n.push(o),s=s.subarray(a+1),a=s.indexOf(r)}(!t||s.length!==0)&&n.push(s);return}let i=0;for(let r=0;r<s.length+1;r++)if(r===s.length||e.indexOf(s[r])!==-1){const a=s.subarray(i,r);(!t||a.length!==0)&&n.push(a),i=r+1}}function tX(s,e,t){const n=s.length,i=[];let r=0,a=0;const o=new Array(n);for(let d=0;d<n;++d){const g=i.length;Hbe(s[d],e,t,i);const x=i.length-g;o[d]=x,r+=x,a=Math.max(a,x)}const l=Mi("int32",r*2),u=new Array(r),c=[n,a];let f=0;for(let d=0;d<n;++d)for(let g=0;g<o[d];++g)l[f*2]=d,l[f*2+1]=g,u[f]=i[f],++f;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(s,e){const t=Mi("int32",s.length);for(let n=0;n<s.length;++n)t[n]=sle(s[n]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sX=Di((s,e)=>s-e),Vbe=EL((s,e,t,n)=>({real:s-t,imag:e-n})),DL=ar(iS,sX,Vbe),Wbe={kernelName:iS,backendName:"cpu",kernelFunc:DL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(s,e){const t=new Array(s.rank);for(let i=0;i<t.length;i++)t[i]=s.shape[i]*e[i];const n=Mn(t,s.dtype);for(let i=0;i<n.values.length;++i){const r=n.indexToLoc(i),a=new Array(s.rank);for(let l=0;l<a.length;l++)a[l]=r[l]%s.shape[l];const o=s.locToIndex(a);n.values[i]=s.values[o]}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1=(s,e)=>{const t=e.value-s.value;return t===0?s.index-e.index:t};function rX(s,e,t=0,n=s.length-1){for(;n>t;){if(n-t>600){const o=n-t+1,l=e-t+1,u=Math.log(o),c=.5*Math.exp(2*u/3),f=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),d=Math.max(t,Math.floor(e-l*c/o+f)),g=Math.min(n,Math.floor(e+(o-l)*c/o+f));rX(s,e,d,g)}const i=s[e];let r=t,a=n;for(By(s,t,e),j1(s[n],i)>0&&By(s,t,n);r<a;){for(By(s,r,a),r++,a--;j1(s[r],i)<0;)r=r+1;for(;j1(s[a],i)>0;)a=a-1}j1(s[t],i)===0?By(s,t,a):(a=a+1,By(s,a,n)),a<=e&&(t=a+1),e<=a&&(n=a-1)}}function aX(s,e,t,n,i){const r=e[e.length-1],[a,o]=[s.length/r,r],l=Fr(t,a*n),u=Fr("int32",a*n);for(let f=0;f<a;f++){const d=f*o,g=s.subarray(d,d+o);let x=new Array(g.length);g.forEach((T,E)=>x[E]={value:T,index:E}),n<x.length&&(rX(x,n),x=x.slice(0,n)),i&&x.sort(j1);const S=f*n,b=l.subarray(S,S+n),_=u.subarray(S,S+n);for(let T=0;T<n;T++)b[T]=x[T].value,_[T]=x[T].index}const c=e.slice();return c[c.length-1]=n,[Mn(c,t,l),Mn(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(s,e,t,n){const i=kn(e,t)[0],r=[1,t[0],1];for(let x=0;x<i;x++)r[0]*=t[x];r[1]=t[i];for(let x=i+1;x<t.length;x++)r[2]*=t[x];const a=new Map,o=new Int32Array(t[i]),l=new nr(r,n,s),u=[],c=r[0]===1&&r[2]===1;for(let x=0;x<t[i];x++){let S;if(c)S=s[x].toString();else{const _=[];for(let T=0;T<r[0];T++)for(let E=0;E<r[2];E++)_.push(l.get(T,x,E));S=_.join(",")}const b=a.get(S);if(b!=null)o[x]=b;else{const _=a.size;a.set(S,_),o[x]=_,u.push(x)}}const f=r.slice();f[1]=a.size;const d=new nr(f,n);u.forEach((x,S)=>{for(let b=0;b<r[0];b++)for(let _=0;_<r[2];_++)d.set(l.get(b,x,_),b,S,_)});const g=t.slice();return g[i]=f[1],{outputValues:d.values,outputShape:g,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xbe=Object.freeze(Object.defineProperty({__proto__:null,addImpl:gW,bincountImpl:ML,bincountReduceImpl:yW,bitwiseAndImpl:xW,castImpl:mW,ceilImpl:vW,concatImpl:bW,equalImpl:_W,expImpl:AW,expm1Impl:wW,floorDivImpl:EW,floorImpl:CW,gatherNdImpl:MW,gatherV2Impl:NW,greaterEqualImpl:IW,greaterImpl:RW,lessEqualImpl:OW,lessImpl:DW,linSpaceImpl:BW,logImpl:kW,maxImpl:LW,maximumImpl:FW,minimumImpl:PW,multiplyImpl:NL,negImpl:UW,notEqualImpl:$W,prodImpl:zW,raggedGatherImpl:GW,raggedRangeImpl:HW,raggedTensorToTensorImpl:VW,rangeImpl:WW,rsqrtImpl:XW,scatterImpl:cg,sigmoidImpl:Dbe,simpleAbsImpl:pW,sliceImpl:jW,sparseFillEmptyRowsImpl:KW,sparseReshapeImpl:YW,sparseSegmentReductionImpl:IL,sqrtImpl:kbe,squaredDifferenceImpl:JW,staticRegexReplaceImpl:ZW,stridedSliceImpl:QW,stringNGramsImpl:eX,stringSplitImpl:tX,stringToHashBucketFastImpl:nX,subImpl:sX,tileImpl:iX,topKImpl:aX,transposeImpl:RL,uniqueImpl:oX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */O8("cpu",()=>new VM,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lX=bs(E_,s=>s>=0?s:Math.exp(s)-1),qbe={kernelName:E_,backendName:"cpu",kernelFunc:lX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{alpha:r}=n;zt([i],"leakyRelu");const a=Xe(i.shape),o=t.data.get(i.dataId).values,l=Fr("float32",a);for(let u=0;u<o.length;u++)l[u]=o[u]<0?r*o[u]:o[u];return t.makeTensorInfo(i.shape,"float32",l)}const jbe={kernelName:wE,backendName:"cpu",kernelFunc:uX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kbe=Di((s,e)=>s<0?e*s:s);function cX(s){const{inputs:e,backend:t}=s,{x:n,alpha:i}=e;zt([n,i],"prelu");const r=t.data.get(n.dataId).values,a=t.data.get(i.dataId).values,[o,l]=Kbe(n.shape,i.shape,r,a,"float32");return t.makeTensorInfo(l,"float32",o)}const Ybe={kernelName:VE,backendName:"cpu",kernelFunc:cX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX=bs(X_,s=>Math.max(0,s)),Jbe={kernelName:X_,backendName:"cpu",kernelFunc:hX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fX=bs(q_,s=>Math.min(Math.max(0,s),6)),Zbe={kernelName:q_,backendName:"cpu",kernelFunc:fX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(s,e,t,n,i){if(t==="linear")return mh({inputs:{x:e},backend:s});if(t==="relu")return hX({inputs:{x:e},backend:s});if(t==="elu")return lX({inputs:{x:e},backend:s});if(t==="relu6")return fX({inputs:{x:e},backend:s});if(t==="prelu")return cX({inputs:{x:e,alpha:n},backend:s});if(t==="leakyrelu")return uX({inputs:{x:e},backend:s,attrs:{alpha:i}});if(t==="sigmoid")return qW({inputs:{x:e},backend:s});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{shape:r}=n,a=Xe(i.shape),o=u8(r,a),l=Xe(o);K(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const u=t.data.get(i.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,f=u.complexTensorInfos.imag;c.shape=o,f.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const Qbe={kernelName:XE,backendName:"cpu",kernelFunc:Us};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(s){const{inputs:e,backend:t,attrs:n}=s,{a:i,b:r}=e,{transposeA:a,transposeB:o}=n;zt([i,r],"matMul");const l=i.shape.length,u=r.shape.length,c=a?i.shape[l-2]:i.shape[l-1],f=o?r.shape[u-1]:r.shape[u-2],d=a?i.shape[l-1]:i.shape[l-2],g=o?r.shape[u-2]:r.shape[u-1],x=i.shape.slice(0,-2),S=r.shape.slice(0,-2),b=Xe(x),_=Xe(S),E=gn(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,g]);K(c===f,()=>`Error in matMul: inner shapes (${c}) and (${f}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${a} and transposeB=${o} must match.`);const C=a?[b,c,d]:[b,d,c],R=o?[_,g,f]:[_,f,g],I=Us({inputs:{x:i},backend:t,attrs:{shape:C}}),L=Us({inputs:{x:r},backend:t,attrs:{shape:R}}),P=a?I.shape[1]:I.shape[2],D=a?I.shape[2]:I.shape[1],O=o?L.shape[1]:L.shape[2],F=Math.max(b,_),X=t.data.get(I.dataId).values,q=t.data.get(L.dataId).values,J=jt(I.shape),Y=jt(L.shape),[$,W,V]=a?[J[0],1,J[1]]:[J[0],J[1],1],[se,G,ne]=o?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],oe=D*O,ue=Mn([F,D,O],I.dtype),re=ue.values,ce=t.blockSize;for(let Te=0;Te<F;Te++){const Be=Te%b,Ke=Te%_;for(let ut=0;ut<D;ut+=ce){const ct=Math.min(ut+ce,D);for(let xt=0;xt<O;xt+=ce){const kt=Math.min(xt+ce,O);for(let Et=0;Et<P;Et+=ce){const le=Math.min(Et+ce,P);for(let Wt=ut;Wt<ct;Wt++)for(let ze=xt;ze<kt;ze++){let Fe=0;for(let Pe=Et;Pe<le;Pe++){const ht=X[Be*$+Wt*W+Pe*V],ke=q[Pe*se+ze*G+Ke*ne];Fe+=ht*ke}re[Te*oe+(Wt*O+ze)]+=Fe}}}}}return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(L),t.makeTensorInfo(E,ue.dtype,ue.values)}const e_e={kernelName:uE,backendName:"cpu",kernelFunc:dX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_e(s){const{inputs:e,backend:t,attrs:n}=s,{a:i,b:r,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:f}=n;let d,g,x;const S=[];d=dX({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:u},backend:t}),a&&(g=Ex({inputs:{a:d,b:a},backend:t}),S.push(d),d=g),c&&(x=cC(t,d,c,o,f),S.push(d),d=x);for(const _ of S)t.disposeIntermediateTensorInfo(_);return d}const n_e={kernelName:H2,backendName:"cpu",kernelFunc:t_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s_e=bs(p_,s=>Math.acos(s)),i_e={kernelName:p_,backendName:"cpu",kernelFunc:s_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_e=bs(m_,s=>Math.acosh(s)),a_e={kernelName:m_,backendName:"cpu",kernelFunc:r_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_e(s){const{inputs:e,backend:t}=s,n=e;zt(e,"addN");const i=n.map(o=>t.data.get(o.dataId).values),r=Mn(n[0].shape,n[0].dtype),a=r.values;for(let o=0;o<n.length;o++){const l=i[o];for(let u=0;u<a.length;u++)a[u]+=l[u]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const l_e={kernelName:iE,backendName:"cpu",kernelFunc:o_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;zt(i,"all");const o=kn(r,i.shape);let l=o;const u=ri(l,i.shape.length);let c=i;u!=null&&(c=ro({inputs:{x:i},backend:t,attrs:{perm:u}}),l=Ri(l.length,i.shape.length)),$r("all",l,c.shape.length);const[f,d]=Tr(c.shape,l),g=Xe(d),x=sa(Xe(f),c.dtype),S=t.data.get(c.dataId).values;for(let _=0;_<x.length;++_){const T=_*g;let E=S[T];for(let C=0;C<g;++C){const R=S[T+C];E=E&&R}x[_]=E}u!=null&&t.disposeIntermediateTensorInfo(c);const b=t.makeTensorInfo(f,c.dtype,x);if(a){const _=Ni(f,o),T=Us({inputs:{x:b},backend:t,attrs:{shape:_}});return t.disposeIntermediateTensorInfo(b),T}return b}const c_e={kernelName:$O,backendName:"cpu",kernelFunc:u_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;zt(i,"any");const o=kn(r,i.shape);let l=o;const u=ri(l,i.shape.length);let c=i;u!=null&&(c=ro({inputs:{x:i},backend:t,attrs:{perm:u}}),l=Ri(l.length,i.shape.length)),$r("any",l,c.shape.length);const[f,d]=Tr(c.shape,l),g=Xe(d),x=sa(Xe(f),c.dtype),S=t.data.get(c.dataId).values;for(let _=0;_<x.length;++_){const T=_*g;let E=S[T];for(let C=0;C<g;++C){const R=S[T+C];E=E||R}x[_]=E}u!=null&&t.disposeIntermediateTensorInfo(c);const b=t.makeTensorInfo(f,c.dtype,x);if(a){const _=Ni(f,o),T=Us({inputs:{x:b},backend:t,attrs:{shape:_}});return t.disposeIntermediateTensorInfo(b),T}return b}const f_e={kernelName:zO,backendName:"cpu",kernelFunc:h_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r}=n;zt(i,"argMax");let a=kn(r,i.shape);const o=ri(a,i.shape.length);let l=i;const u=[];o!=null&&(l=ro({inputs:{x:i},backend:t,attrs:{perm:o}}),u.push(l),a=Ri(a.length,l.shape.length)),a=[a[0]],$r("argMax",a,l.shape.length);const[c,f]=Tr(l.shape,a),d=Xe(c),g=sa(d,"int32"),x=Xe(f),S=t.data.get(l.dataId).values;for(let b=0;b<g.length;++b){const _=b*x;let T=S[_],E=0;for(let C=0;C<x;++C){const R=S[_+C];R>T&&(T=R,E=C)}g[b]=E}return u.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(c,"int32",g)}const p_e={kernelName:rE,backendName:"cpu",kernelFunc:d_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r}=n;zt(i,"argMin");let a=kn(r,i.shape);const o=ri(a,i.shape.length);let l=i;const u=[];o!=null&&(l=ro({inputs:{x:i},backend:t,attrs:{perm:o}}),u.push(l),a=Ri(a.length,l.shape.length)),a=[a[0]],$r("argMin",a,l.shape.length);const[c,f]=Tr(l.shape,a),d=Xe(c),g=sa(d,"int32"),x=Xe(f),S=t.data.get(l.dataId).values;for(let b=0;b<g.length;++b){const _=b*x;let T=S[_],E=0;for(let C=0;C<x;++C){const R=S[_+C];R<T&&(T=R,E=C)}g[b]=E}return u.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(c,"int32",g)}const g_e={kernelName:aE,backendName:"cpu",kernelFunc:m_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y_e=bs(g_,s=>Math.asin(s)),x_e={kernelName:g_,backendName:"cpu",kernelFunc:y_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_e=bs(y_,s=>Math.asinh(s)),b_e={kernelName:y_,backendName:"cpu",kernelFunc:v_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const __e=bs(x_,s=>Math.atan(s)),S_e={kernelName:x_,backendName:"cpu",kernelFunc:__e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A_e=Di((s,e)=>Math.atan2(s,e)),T_e=ar(b_,A_e),w_e={kernelName:b_,backendName:"cpu",kernelFunc:T_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C_e=bs(v_,s=>Math.atanh(s)),E_e={kernelName:v_,backendName:"cpu",kernelFunc:C_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OL(s,e,t,n,i,r){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,u=i.dilationWidth,c=i.effectiveFilterHeight,f=i.effectiveFilterWidth,d=i.padInfo.top,g=i.padInfo.left,x=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=Mn(i.outShape,t),b=S.values,_=i.outShape[1]*i.outShape[2]*i.outShape[3],T=i.outShape[2]*i.outShape[3],E=i.outShape[3];for(let C=0;C<i.batchSize;++C){const R=C*_,I=C*n[0];for(let L=0;L<i.inChannels;++L)for(let P=0;P<i.outHeight;++P){const D=P*a-d,O=Math.max(0,D),F=Math.min(i.inHeight,c+D),X=R+P*T;for(let q=0;q<i.outWidth;++q){const J=q*o-g,Y=Math.max(0,J),$=Math.min(i.inWidth,f+J);let W=x,V=0,se=0;for(let ne=O;ne<F;ne+=l){const oe=I+ne*n[1];for(let ue=Y;ue<$;ue+=u){const re=oe+ue*n[2],ce=s[re+L];r==="max"&&ce>W?W=ce:r==="avg"&&(V+=ce,se++)}if(isNaN(W))break}const G=X+q*E+L;b[G]=r==="avg"?V/se:W}}}return S}function pX(s,e,t,n,i=!1,r=!1){const a=Mn(n.outShape,"int32"),o=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,f=n.effectiveFilterHeight,d=n.effectiveFilterWidth,g=n.padInfo.top,x=n.padInfo.left,S=Mn(e,t,s);for(let b=0;b<n.batchSize;++b)for(let _=0;_<n.inChannels;++_)for(let T=0;T<n.outHeight;++T){const E=T*o-g;let C=E;for(;C<0;)C+=u;const R=Math.min(n.inHeight,f+E);for(let I=0;I<n.outWidth;++I){const L=I*l-x;let P=L;for(;P<0;)P+=c;const D=Math.min(n.inWidth,d+L);let O=Number.NEGATIVE_INFINITY,F=-1;for(let X=C;X<R;X+=u){const q=X-E;for(let J=P;J<D;J+=c){const Y=J-L,$=S.get(b,X,J,_);$>O&&(O=$,i?F=r?((b*n.inHeight+X)*n.inWidth+J)*n.inChannels+_:(X*n.inWidth+J)*n.inChannels+_:F=q*d+Y)}}a.set(F,b,T,I,_)}}return a}function mX(s,e,t,n,i,r){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,u=i.dilationDepth,c=i.dilationHeight,f=i.dilationWidth,d=i.effectiveFilterDepth,g=i.effectiveFilterHeight,x=i.effectiveFilterWidth,S=i.padInfo.front,b=i.padInfo.top,_=i.padInfo.left,T=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,E=Mn(i.outShape,t),C=E.values,R=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],I=i.outShape[2]*i.outShape[3]*i.outShape[4],L=i.outShape[3]*i.outShape[4],P=i.outShape[4];for(let D=0;D<i.batchSize;++D){const O=D*R,F=D*n[0];for(let X=0;X<i.inChannels;++X)for(let q=0;q<i.outDepth;++q){const J=q*a-S;let Y=J;for(;Y<0;)Y+=u;const $=Math.min(i.inDepth,d+J),W=O+q*I;for(let V=0;V<i.outHeight;++V){const se=V*o-b;let G=se;for(;G<0;)G+=c;const ne=Math.min(i.inHeight,g+se),oe=W+V*L;for(let ue=0;ue<i.outWidth;++ue){const re=ue*l-_;let ce=re;for(;ce<0;)ce+=f;const Te=Math.min(i.inWidth,x+re),Be=oe+ue*P;let Ke=T,ut=0,ct=0;for(let kt=Y;kt<$;kt+=u){const Et=F+kt*n[1];for(let le=G;le<ne;le+=c){const Wt=Et+le*n[2];for(let ze=ce;ze<Te;ze+=f){const Fe=Wt+ze*n[3],Pe=s[Fe+X];if(r==="max"&&Pe>Ke?Ke=Pe:r==="avg"&&(ut+=Pe,ct++),isNaN(Ke))break}if(isNaN(Ke))break}if(isNaN(Ke))break}const xt=Be+X;C[xt]=r==="avg"?ut/Math.max(ct,1):Ke}}}}return E}function M_e(s,e){const t=Mn(e.outShape,"int32"),n=e.strideDepth,i=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;for(let S=0;S<e.batchSize;++S)for(let b=0;b<e.inChannels;++b)for(let _=0;_<e.outDepth;++_){const T=_*n-d;let E=T;for(;E<0;)E+=a;const C=Math.min(e.inDepth,u+T);for(let R=0;R<e.outHeight;++R){const I=R*i-g;let L=I;for(;L<0;)L+=o;const P=Math.min(e.inHeight,c+I);for(let D=0;D<e.outWidth;++D){const O=D*r-x;let F=O;for(;F<0;)F+=l;const X=Math.min(e.inWidth,f+O);let q=Number.NEGATIVE_INFINITY,J=-1;for(let Y=E;Y<C;Y+=a){const $=Y-T;for(let W=L;W<P;W+=o){const V=W-I;for(let se=F;se<X;se+=l){const G=se-O,ne=s.get(S,Y,W,se,b);ne>=q&&(q=ne,J=$*c*f+V*c+G)}}}t.set(J,S,_,R,D,b)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e;zt(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=n,u=1;K(Ur(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=pu(i.shape,r,a,u,o,l);let f;if(c.filterWidth===1&&c.filterHeight===1&&Wn(c.inShape,c.outShape))f=mh({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,g=jt(i.shape),x=OL(d,i.shape,i.dtype,g,c,"avg");f=t.makeTensorInfo(c.outShape,i.dtype,x.values)}return f}const R_e={kernelName:oE,backendName:"cpu",kernelFunc:N_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=n;zt(i,"avgPool3d");const c=Mf(i.shape,r,a,1,o,l,u),f=t.data.get(i.dataId).values,d=mX(f,i.shape,i.dtype,jt(i.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const D_e={kernelName:lE,backendName:"cpu",kernelFunc:I_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_e(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=n;zt([i,r],"avgPool3DGrad");const c=Mf(r.shape,a,o,1,l,u),f=c.strideDepth,d=c.strideHeight,g=c.strideWidth,x=c.filterDepth,S=c.filterHeight,b=c.filterWidth,_=c.dilationDepth,T=c.dilationHeight,E=c.dilationWidth,C=c.effectiveFilterDepth,R=c.effectiveFilterHeight,I=c.effectiveFilterWidth,L=C-1-c.padInfo.front,P=I-1-c.padInfo.left,D=R-1-c.padInfo.top,O=Mn(r.shape,"float32"),F=1/(x*S*b),X=t.bufferSync(i);for(let q=0;q<c.batchSize;++q)for(let J=0;J<c.inChannels;++J)for(let Y=0;Y<c.inDepth;++Y)for(let $=0;$<c.inHeight;++$)for(let W=0;W<c.inWidth;++W){const V=Y-L,se=$-D,G=W-P;let ne=0;for(let oe=0;oe<C;oe+=_){const ue=(V+oe)/f;if(!(ue<0||ue>=c.outDepth||Math.floor(ue)!==ue))for(let re=0;re<R;re+=T){const ce=(se+re)/d;if(!(ce<0||ce>=c.outHeight||Math.floor(ce)!==ce))for(let Te=0;Te<I;Te+=E){const Be=(G+Te)/g;if(Be<0||Be>=c.outWidth||Math.floor(Be)!==Be)continue;const Ke=X.get(q,ue,ce,Be,J);ne+=Ke}}}O.set(ne*F,q,Y,$,W,J)}return t.makeTensorInfo(O.shape,O.dtype,O.values)}const B_e={kernelName:HO,backendName:"cpu",kernelFunc:O_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_e(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,a=r;zt([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=n,c=pu(a.shape,o,l,1,u),f=c.strideHeight,d=c.strideWidth,g=c.filterHeight,x=c.filterWidth,S=c.dilationHeight,b=c.dilationWidth,_=c.effectiveFilterHeight,T=c.effectiveFilterWidth,E=T-1-c.padInfo.left,C=_-1-c.padInfo.top,R=Mn(a.shape,"float32"),I=1/(g*x),L=t.data.get(i.dataId).values,P=Mn(i.shape,"float32",L);for(let D=0;D<c.batchSize;++D)for(let O=0;O<c.inChannels;++O)for(let F=0;F<c.inHeight;++F)for(let X=0;X<c.inWidth;++X){const q=F-C,J=X-E;let Y=0;for(let $=0;$<_;$+=S){const W=(q+$)/f;if(!(W<0||W>=c.outHeight||Math.floor(W)!==W))for(let V=0;V<T;V+=b){const se=(J+V)/d;if(se<0||se>=c.outWidth||Math.floor(se)!==se)continue;const G=P.get(D,W,se,O);Y+=G}}R.set(Y*I,D,F,X,O)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const L_e={kernelName:GO,backendName:"cpu",kernelFunc:k_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,scale:r,offset:a,mean:o,variance:l}=e;K(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(r==null||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),zt([i,o,l,r,a],"batchNorm");let{varianceEpsilon:u}=n;u==null&&(u=.001);const c=t.data.get(i.dataId).values,f=t.data.get(o.dataId).values,d=t.data.get(l.dataId).values,g=r?t.data.get(r.dataId).values:new Float32Array([1]),x=a?t.data.get(a.dataId).values:new Float32Array([0]),S=new Float32Array(c.length),b=x.length,_=g.length,T=d.length,E=f.length;let C=0,R=0,I=0,L=0;for(let P=0;P<c.length;++P)S[P]=x[C++]+(c[P]-f[R++])*g[I++]/Math.sqrt(d[L++]+u),C>=b&&(C=0),R>=E&&(R=0),I>=_&&(I=0),L>=T&&(L=0);return t.makeTensorInfo(i.shape,i.dtype,S)}const P_e={kernelName:SE,backendName:"cpu",kernelFunc:F_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockShape:r,crops:a}=n;zt([i],"batchToSpaceND");const o=r.reduce((_,T)=>_*T),l=yS(i.shape,r,o),u=xS(l.length,r.length),c=vS(i.shape,r,o),f=Gk(a,r.length),d=Hk(c,a,r.length),g=Us({inputs:{x:i},backend:t,attrs:{shape:l}}),x=ro({inputs:{x:g},backend:t,attrs:{perm:u}}),S=Us({inputs:{x},backend:t,attrs:{shape:c}}),b=Hg({inputs:{x:S},backend:t,attrs:{begin:f,size:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),b}const $_e={kernelName:cE,backendName:"cpu",kernelFunc:U_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,weights:r}=e,{size:a}=n,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,u=ML(o,l,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,u)}const G_e={kernelName:VO,backendName:"cpu",kernelFunc:z_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_e(s){const{inputs:e,backend:t}=s,{s0:n,s1:i}=e,r=t.data.get(n.dataId).values,a=t.data.get(i.dataId).values,o=gn(Array.from(r),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const V_e={kernelName:WO,backendName:"cpu",kernelFunc:H_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_e=bs(A_,(s,e)=>{const t=e;return s>t.clipValueMax?t.clipValueMax:s<t.clipValueMin?t.clipValueMin:s}),X_e={kernelName:A_,backendName:"cpu",kernelFunc:W_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=s=>{const{x:e}=s.inputs,t=s.backend,n=new Float32Array(Xe(e.shape)),i=t.data.get(e.dataId),r=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],f=l[u];n[u]=Math.hypot(c,f)}return t.makeOutput(n,e.shape,"float32")},j_e={kernelName:fE,backendName:"cpu",kernelFunc:q_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(s){const{inputs:e,backend:t}=s,{input:n}=e,i=t.data.get(n.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const K_e={kernelName:cB,backendName:"cpu",kernelFunc:Mx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nx(s){const{inputs:e,backend:t,attrs:n}=s,{axis:i}=n,r=kn(i,e[0].shape)[0],a=e.map(S=>S.shape);Uk(a,r);let o=oh(e.map(S=>S.shape),r);if(Xe(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(S=>Xe(S.shape)>0);if(l.length===1)return mh({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const S=l.map(C=>Gg({inputs:{input:C},backend:t})),b=l.map(C=>Mx({inputs:{input:C},backend:t})),_=Nx({inputs:S,backend:t,attrs:{axis:r}}),T=Nx({inputs:b,backend:t,attrs:{axis:r}}),E=Co({inputs:{real:_,imag:T},backend:t});return S.forEach(C=>t.disposeIntermediateTensorInfo(C)),b.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(T),E}const u=l.map(S=>{const _=[-1,Xe(S.shape.slice(r))];return Us({inputs:{x:S},backend:t,attrs:{shape:_}})}),c=u.map(S=>({vals:t.data.get(S.dataId).values,shape:S.shape}));o=oh(u.map(S=>S.shape),1);const f=u[0].shape[0]===1,d=bW(c,o,e[0].dtype,f),g=oh(l.map(S=>S.shape),r),x=t.makeTensorInfo(g,e[0].dtype,d);return u.forEach(S=>t.disposeIntermediateTensorInfo(S)),x}const Y_e={kernelName:dE,backendName:"cpu",kernelFunc:Nx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=n;zt([i,r],"conv2d");const f=Nf(l),d=Ar(i.shape,r.shape,a,u,o,c,!1,f),g=d.filterHeight,x=d.filterWidth,S=d.dilationHeight,b=d.dilationWidth,_=d.padInfo.left,T=d.padInfo.top,E=d.dataFormat==="channelsLast",C=new nr(d.outShape,i.dtype),R=jt(i.shape),I=jt(r.shape),L=R[0],P=E?R[1]:R[2],D=E?R[2]:1,O=E?1:R[1],F=C.strides[0],X=E?C.strides[1]:C.strides[2],q=E?C.strides[2]:1,J=E?1:C.strides[1],Y=t.data.get(i.dataId).values,$=t.data.get(r.dataId).values,W=C.values;for(let V=0;V<d.batchSize;++V){const se=V*L,G=V*F;for(let ne=0;ne<d.outHeight;++ne){const oe=G+ne*X,ue=ne*d.strideHeight-T;for(let re=0;re<g;++re){const ce=ue+re*S;if(ce<0||ce>=d.inHeight)continue;const Te=re*I[0],Be=se+ce*P;for(let Ke=0;Ke<d.outWidth;++Ke){const ut=oe+Ke*q,ct=Ke*d.strideWidth-_;for(let xt=0;xt<x;++xt){const kt=ct+xt*b;if(kt<0||kt>=d.inWidth)continue;const Et=Te+xt*I[1],le=Be+kt*D;let Wt=Et;for(let ze=0;ze<d.inChannels;++ze){const Fe=Y[le+ze*O];for(let Pe=0;Pe<d.outChannels;++Pe)W[ut+Pe*J]+=Fe*$[Wt+Pe];Wt+=d.outChannels}}}}}}return t.makeTensorInfo(C.shape,C.dtype,W)}const J_e={kernelName:pE,backendName:"cpu",kernelFunc:gX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=n;zt([i,r],"conv2dBackpropFilter");const f=Nf(l),d=Ar(i.shape,c,a,1,o,u,!1,f),{strideHeight:g,strideWidth:x,filterHeight:S,filterWidth:b}=d,_=d.dataFormat==="channelsLast",T=new nr(d.filterShape,"float32"),E=d.padInfo.left,C=d.padInfo.top,R=t.data.get(i.dataId).values,I=t.data.get(r.dataId).values,L=new nr(i.shape,i.dtype,R),P=new nr(r.shape,r.dtype,I);for(let D=0;D<S;++D){const O=Math.max(0,Math.ceil((C-D)/g)),F=Math.min(d.outHeight,(d.inHeight+C-D)/g);for(let X=0;X<b;++X){const q=Math.max(0,Math.ceil((E-X)/x)),J=Math.min(d.outWidth,(d.inWidth+E-X)/x);for(let Y=0;Y<d.inChannels;++Y)for(let $=0;$<d.outChannels;++$){let W=0;for(let V=0;V<d.batchSize;++V)for(let se=O;se<F;++se){const G=D+se*g-C;for(let ne=q;ne<J;++ne){const oe=X+ne*x-E;_?W+=L.get(V,G,oe,Y)*P.get(V,se,ne,$):W+=L.get(V,Y,G,oe)*P.get(V,$,se,ne)}}T.set(W,D,X,Y,$)}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const Q_e={kernelName:qO,backendName:"cpu",kernelFunc:Z_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eSe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=n;zt([i,r],"conv2dBackpropInput");const f=jt(r.shape),d=jt(i.shape);let g=Nf(u);const x=Ar(a,r.shape,o,1,l,c,!1,g),S=new nr(x.inShape,"float32"),b=S.values,_=t.data.get(i.dataId).values,T=t.data.get(r.dataId).values,[E,C,R]=f,{batchSize:I,filterHeight:L,filterWidth:P,inChannels:D,inHeight:O,inWidth:F,outChannels:X,outHeight:q,outWidth:J,strideHeight:Y,strideWidth:$}=x;g=x.dataFormat;const W=L-1-x.padInfo.top,V=P-1-x.padInfo.left,se=g==="channelsLast",G=S.strides[0],ne=se?S.strides[1]:S.strides[2],oe=se?S.strides[2]:1,ue=se?1:S.strides[1],re=d[0],ce=se?d[1]:d[2],Te=se?d[2]:1,Be=se?1:d[1];for(let Ke=0;Ke<I;++Ke)for(let ut=0;ut<D;++ut)for(let ct=0;ct<O;++ct){const xt=ct-W,kt=Math.max(0,Math.ceil(xt/Y)),Et=Math.min(q,(L+xt)/Y);for(let le=0;le<F;++le){const Wt=le-V,ze=Math.max(0,Math.ceil(Wt/$)),Fe=Math.min(J,(P+Wt)/$);let Pe=0;for(let ke=kt;ke<Et;++ke){const ie=ke*Y-xt;for(let j=ze;j<Fe;++j){const Ae=j*$-Wt,Ue=re*Ke+ce*ke+Te*j,Ye=E*(L-1-ie)+C*(P-1-Ae)+R*ut;for(let qe=0;qe<X;++qe){const mt=_[Ue+Be*qe],at=T[Ye+qe];Pe+=mt*at}}}const ht=G*Ke+ne*ct+oe*le+ue*ut;b[ht]=Pe}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const tSe={kernelName:mE,backendName:"cpu",kernelFunc:eSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=n;zt([i,r],"conv3d");const u=Tp(i.shape,r.shape,a,l,o),{filterDepth:c,filterHeight:f,filterWidth:d,dilationDepth:g,dilationHeight:x,dilationWidth:S,padInfo:b}=u,_=b.front,T=b.left,E=b.top,C=new nr(u.outShape,i.dtype),R=t.data.get(i.dataId).values,I=t.data.get(r.dataId).values,L=C.values,P=jt(i.shape),D=jt(r.shape);for(let O=0;O<u.batchSize;++O){const F=O*P[0],X=O*C.strides[0];for(let q=0;q<u.outDepth;++q){const J=X+q*C.strides[1],Y=q*u.strideDepth-_;for(let $=0;$<c;++$){const W=Y+$*g;if(W<0||W>=u.inDepth)continue;const V=$*D[0],se=F+W*P[1];for(let G=0;G<u.outHeight;++G){const ne=J+G*C.strides[2],oe=G*u.strideHeight-E;for(let ue=0;ue<f;++ue){const re=oe+ue*x;if(re<0||re>=u.inHeight)continue;const ce=V+ue*D[1],Te=se+re*P[2];for(let Be=0;Be<u.outWidth;++Be){const Ke=ne+Be*u.outChannels,ut=Be*u.strideWidth-T;for(let ct=0;ct<d;++ct){const xt=ut+ct*S;if(xt<0||xt>=u.inWidth)continue;const kt=ce+ct*D[2],Et=Te+xt*u.inChannels;let le=kt;for(let Wt=0;Wt<u.inChannels;++Wt){const ze=R[Et+Wt];for(let Fe=0;Fe<u.outChannels;++Fe)L[Ke+Fe]+=ze*I[le+Fe];le+=u.outChannels}}}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const sSe={kernelName:gE,backendName:"cpu",kernelFunc:nSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,pad:o,filterShape:l}=n;zt([i,r],"conv3dBackpropFilterV2");const u=jt(i.shape),c=jt(r.shape),f=Tp(i.shape,l,a,1,o),d=f.strideDepth,g=f.strideHeight,x=f.strideWidth,S=f.filterDepth,b=f.filterHeight,_=f.filterWidth,T=new nr(f.filterShape,"float32"),E=T.values,[C,R,I,L]=T.strides,P=t.data.get(r.dataId).values,[D,O,F,X]=c,q=t.data.get(i.dataId).values,[J,Y,$,W]=u,V=f.padInfo.front,se=f.padInfo.left,G=f.padInfo.top;for(let ne=0;ne<S;++ne){const oe=Math.max(0,Math.ceil((V-ne)/d)),ue=Math.min(f.outDepth,(f.inDepth+V-ne)/d),re=ne*C;for(let ce=0;ce<b;++ce){const Te=Math.max(0,Math.ceil((G-ce)/g)),Be=Math.min(f.outHeight,(f.inHeight+G-ce)/g),Ke=ce*R+re;for(let ut=0;ut<_;++ut){const ct=Math.max(0,Math.ceil((se-ut)/x)),xt=Math.min(f.outWidth,(f.inWidth+se-ut)/x),kt=ut*I+Ke;for(let Et=0;Et<f.inChannels;++Et){const le=Et*L+kt;for(let Wt=0;Wt<f.outChannels;++Wt){let ze=0;for(let Fe=0;Fe<f.batchSize;++Fe){const Pe=Fe*J,ht=Fe*D;for(let ke=oe;ke<ue;++ke){const j=(ne+ke*d-V)*Y+Pe,Ae=ke*O+ht;for(let Ue=Te;Ue<Be;++Ue){const qe=(ce+Ue*g-G)*$+j,mt=Ue*F+Ae;for(let at=ct;at<xt;++at){const dn=(ut+at*x-se)*W+qe,lt=at*X+mt;ze+=q[dn+Et]*P[lt+Wt]}}}}E[le+Wt]=ze}}}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const rSe={kernelName:jO,backendName:"cpu",kernelFunc:iSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aSe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{pad:a,strides:o,inputShape:l}=n;zt([i],"conv3dBackpropInputV2");const u=jt(i.shape),c=jt(r.shape),f=Tp(l,r.shape,o,1,a),d=new nr(f.inShape,"float32"),g=d.values,[x,S,b,_]=d.strides,T=t.data.get(i.dataId).values,[E,C,R,I]=u,L=t.data.get(r.dataId).values,[P,D,O,F]=c,{batchSize:X,filterDepth:q,filterHeight:J,filterWidth:Y,inChannels:$,inDepth:W,inHeight:V,inWidth:se,outChannels:G,outDepth:ne,outHeight:oe,outWidth:ue,strideDepth:re,strideHeight:ce,strideWidth:Te}=f,Be=q-1-f.padInfo.front,Ke=J-1-f.padInfo.top,ut=Y-1-f.padInfo.left;for(let ct=0;ct<X;++ct)for(let xt=0;xt<$;++xt)for(let kt=0;kt<W;++kt){const Et=kt-Be,le=Math.max(0,Math.ceil(Et/re)),Wt=Math.min(ne,(q+Et)/re);for(let ze=0;ze<V;++ze){const Fe=ze-Ke,Pe=Math.max(0,Math.ceil(Fe/ce)),ht=Math.min(oe,(J+Fe)/ce);for(let ke=0;ke<se;++ke){const ie=ke-ut,j=Math.max(0,Math.ceil(ie/Te)),Ae=Math.min(ue,(Y+ie)/Te);let Ue=0;for(let Ye=le;Ye<Wt;++Ye){const qe=Ye*re-Et;for(let mt=Pe;mt<ht;++mt){const at=mt*ce-Fe;for(let gt=j;gt<Ae;++gt){const dn=gt*Te-ie,lt=E*ct+C*Ye+R*mt+I*gt,Dt=P*(q-1-qe)+D*(J-1-at)+O*(Y-1-dn)+F*xt;for(let Ft=0;Ft<G;++Ft){const Pt=T[lt+Ft],vt=L[Dt+Ft];Ue+=Pt*vt}}}}g[x*ct+S*kt+b*ze+_*ke+xt]=Ue}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const oSe={kernelName:KO,backendName:"cpu",kernelFunc:aSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lSe=bs(T_,s=>Math.cos(s)),uSe={kernelName:T_,backendName:"cpu",kernelFunc:lSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cSe=bs(w_,s=>Math.cosh(s)),hSe={kernelName:w_,backendName:"cpu",kernelFunc:cSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fSe(s){const{inputs:e,backend:t,attrs:n}=s,{image:i,boxes:r,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=n,[c,f,d,g]=i.shape,x=r.shape[0],[S,b]=o,_=Mn([x,S,b,g],"float32"),T=t.data.get(r.dataId).values,E=t.data.get(a.dataId).values,C=t.data.get(i.dataId).values,R=jt(i.shape),I=jt(_.shape);for(let L=0;L<x;L++){const P=L*4,D=T[P],O=T[P+1],F=T[P+2],X=T[P+3],q=E[L];if(q>=c)continue;const J=S>1?(F-D)*(f-1)/(S-1):0,Y=b>1?(X-O)*(d-1)/(b-1):0;for(let $=0;$<S;$++){const W=S>1?D*(f-1)+$*J:.5*(D+F)*(f-1);if(W<0||W>f-1){for(let V=0;V<b;V++)for(let se=0;se<g;se++){const G=se+V*I[2]+$*I[1]+L*I[0];_.values[G]=u}continue}if(l==="bilinear"){const V=Math.floor(W),se=Math.ceil(W),G=W-V;for(let ne=0;ne<b;ne++){const oe=b>1?O*(d-1)+ne*Y:.5*(O+X)*(d-1);if(oe<0||oe>d-1){for(let Te=0;Te<g;Te++){const Be=Te+ne*I[2]+$*I[1]+L*I[0];_.values[Be]=u}continue}const ue=Math.floor(oe),re=Math.ceil(oe),ce=oe-ue;for(let Te=0;Te<g;Te++){let Be=Te+ue*R[2]+V*R[1]+q*R[0];const Ke=C[Be];Be=Te+re*R[2]+V*R[1]+q*R[0];const ut=C[Be];Be=Te+ue*R[2]+se*R[1]+q*R[0];const ct=C[Be];Be=Te+re*R[2]+se*R[1]+q*R[0];const xt=C[Be],kt=Ke+(ut-Ke)*ce,Et=ct+(xt-ct)*ce;Be=Te+ne*I[2]+$*I[1]+L*I[0],_.values[Be]=kt+(Et-kt)*G}}}else for(let V=0;V<b;++V){const se=b>1?O*(d-1)+V*Y:.5*(O+X)*(d-1);if(se<0||se>d-1){for(let oe=0;oe<g;oe++){const ue=oe+V*I[2]+$*I[1]+L*I[0];_.values[ue]=u}continue}const G=Math.round(se),ne=Math.round(W);for(let oe=0;oe<g;oe++){const ue=oe+G*R[2]+ne*R[1]+q*R[0],re=oe+V*I[2]+$*I[1]+L*I[0];_.values[re]=C[ue]}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const dSe={kernelName:JO,backendName:"cpu",kernelFunc:fSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,exclusive:a,reverse:o}=n;zt(i,"cumprod");const l=ri([r],i.shape.length);let u=i;l!=null&&(u=ro({inputs:{x:i},backend:t,attrs:{perm:l}}));const c=Ri(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const f=ko(u.dtype,"int32"),d=PO(Xe(u.shape),f),g=t.data.get(u.dataId).values,x=u.shape[u.shape.length-1],S=o?(_,T)=>_+x-T-1:(_,T)=>_+T;for(let _=0;_<g.length;_+=x)for(let T=0;T<x;T++){const E=S(_,T);if(T===0)d[E]=a?1:g[E];else{const C=S(_,T-1);d[E]=a?g[C]*d[C]:g[E]*d[C]}}const b=t.makeTensorInfo(u.shape,f,d);if(l!=null){const _=wp(l),T=ro({inputs:{x:b},backend:t,attrs:{perm:_}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(u),T}return b}const mSe={kernelName:YO,backendName:"cpu",kernelFunc:pSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,exclusive:a,reverse:o}=n;zt(i,"cumsum");const l=ri([r],i.shape.length);let u=i;l!=null&&(u=ro({inputs:{x:i},backend:t,attrs:{perm:l}}));const c=Ri(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const f=ko(u.dtype,"int32"),d=sa(Xe(u.shape),f),g=t.data.get(u.dataId).values,x=u.shape[u.shape.length-1],S=o?(_,T)=>_+x-T-1:(_,T)=>_+T;for(let _=0;_<g.length;_+=x)for(let T=0;T<x;T++){const E=S(_,T);if(T===0)d[E]=a?0:g[E];else{const C=S(_,T-1);d[E]=a?g[C]+d[C]:g[E]+d[C]}}const b=t.makeTensorInfo(u.shape,f,d);if(l!=null){const _=wp(l),T=ro({inputs:{x:b},backend:t,attrs:{perm:_}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(u),T}return b}const ySe={kernelName:yE,backendName:"cpu",kernelFunc:gSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,weights:r}=e,{size:a,binaryOutput:o}=n;if(i.shape.length===1){const l=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,c=ML(l,u,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,c)}else if(i.shape.length===2){const l=t.bufferSync(i),u=t.bufferSync(r),c=yW(l,u,a,o);return t.makeTensorInfo(c.shape,r.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const vSe={kernelName:ZO,backendName:"cpu",kernelFunc:xSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bSe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockSize:r,dataFormat:a}=n;K(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=i.shape[0],l=i.shape[1],u=i.shape[2],c=i.shape[3],f=l*r,d=u*r,g=c/(r*r),x=t.data.get(i.dataId).values,S=new Float32Array(o*f*d*g);let b=0;for(let _=0;_<o;++_)for(let T=0;T<f;++T){const E=Math.floor(T/r),C=T%r;for(let R=0;R<d;++R){const I=Math.floor(R/r),L=R%r,P=(C*r+L)*g;for(let D=0;D<g;++D){const F=D+P+c*(I+u*(E+l*_));S[b++]=x[F]}}}return t.makeTensorInfo([o,f,d,g],i.dtype,S)}const _Se={kernelName:QO,backendName:"cpu",kernelFunc:bSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yX(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=n;zt([i,r],"depthwiseConv2DNative");const c=jt(i.shape),f=jt(r.shape);let d=l;d==null&&(d=[1,1]),K(Ur(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const g=Ar(i.shape,r.shape,a,d,o,u,!0),{filterHeight:x,filterWidth:S,dilationHeight:b,dilationWidth:_,padInfo:T}=g,E=T.left,C=T.top,R=g.outChannels/g.inChannels,I=new nr(g.outShape,i.dtype),L=t.data.get(i.dataId).values,P=t.data.get(r.dataId).values,D=I.values;for(let O=0;O<g.batchSize;++O){const F=O*c[0],X=O*I.strides[0];for(let q=0;q<g.outHeight;++q){const J=X+q*I.strides[1],Y=q*g.strideHeight-C;for(let $=0;$<x;++$){const W=Y+$*b;if(W<0||W>=g.inHeight)continue;const V=$*f[0],se=F+W*c[1];for(let G=0;G<g.outWidth;++G){const ne=J+G*I.strides[2],oe=G*g.strideWidth-E;for(let ue=0;ue<S;++ue){const re=oe+ue*_;if(re<0||re>=g.inWidth)continue;const ce=V+ue*f[1],Te=se+re*g.inChannels;let Be=ne,Ke=ce;for(let ut=0;ut<g.inChannels;++ut){const ct=L[Te+ut];for(let xt=0;xt<R;++xt)D[Be+xt]+=ct*P[Ke+xt];Be+=R,Ke+=R}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const SSe={kernelName:xE,backendName:"cpu",kernelFunc:yX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ASe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=n;zt([i,r],"depthwiseConv2dNativeBackpropFilter");const f=Ar(i.shape,c,a,o,l,u,!0),{strideHeight:d,strideWidth:g,filterHeight:x,filterWidth:S}=f,b=new nr(f.filterShape,"float32"),_=f.padInfo.left,T=f.padInfo.top,E=f.outChannels/f.inChannels,C=t.data.get(i.dataId).values,R=new nr(i.shape,i.dtype,C),I=t.data.get(r.dataId).values,L=new nr(r.shape,r.dtype,I);for(let P=0;P<x;++P){const D=Math.max(0,Math.ceil((T-P)/d)),O=Math.min(f.outHeight,(f.inHeight+T-P)/d);for(let F=0;F<S;++F){const X=Math.max(0,Math.ceil((_-F)/g)),q=Math.min(f.outWidth,(f.inWidth+_-F)/g);for(let J=0;J<f.outChannels;++J){const Y=Math.trunc(J/E),$=J%E;let W=0;for(let V=0;V<f.batchSize;++V)for(let se=D;se<O;++se){const G=P+se*d-T;for(let ne=X;ne<q;++ne){const oe=F+ne*g-_;W+=R.get(V,G,oe,Y)*L.get(V,se,ne,J)}}b.set(W,P,F,Y,$)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const TSe={kernelName:eB,backendName:"cpu",kernelFunc:ASe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wSe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=n;zt([i,r],"depthwiseConv2DNativeBackpropInput");const f=jt(i.shape),d=jt(r.shape),g=Ar(c,r.shape,a,o,l,u,!0),x=new nr(g.inShape,"float32"),S=x.values,[b,_,T]=x.strides,E=t.data.get(i.dataId).values,[C,R,I]=f,L=t.data.get(r.dataId).values,[P,D,O]=d,{batchSize:F,filterHeight:X,filterWidth:q,inChannels:J,inHeight:Y,inWidth:$,outChannels:W,outHeight:V,outWidth:se,strideHeight:G,strideWidth:ne}=g,oe=X-1-g.padInfo.top,ue=q-1-g.padInfo.left,re=W/J;for(let ce=0;ce<F;++ce)for(let Te=0;Te<J;++Te)for(let Be=0;Be<Y;++Be){const Ke=Be-oe,ut=Math.max(0,Math.ceil(Ke/G)),ct=Math.min(V,(X+Ke)/G);for(let xt=0;xt<$;++xt){const kt=xt-ue,Et=Math.max(0,Math.ceil(kt/ne)),le=Math.min(se,(q+kt)/ne);let Wt=0;for(let ze=ut;ze<ct;++ze){const Fe=ze*G-Ke;for(let Pe=Et;Pe<le;++Pe){const ht=Pe*ne-kt,ke=C*ce+R*ze+I*Pe,ie=P*(X-1-Fe)+D*(q-1-ht)+O*Te;for(let j=0;j<re;++j){const Ae=Te*re+j,Ue=E[ke+Ae],Ye=L[ie+j];Wt+=Ue*Ye}}}S[b*ce+_*Be+T*xt+Te]=Wt}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const CSe={kernelName:tB,backendName:"cpu",kernelFunc:wSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ESe(s){const{inputs:e,backend:t}=s,{x:n}=e,i=Xe(n.shape),r=t.data.get(n.dataId).values,a=Mn([i,i],n.dtype),o=a.values;for(let u=0;u<r.length;u++)o[u*i+u]=r[u];const l=[...n.shape,...n.shape];return t.makeTensorInfo(l,a.dtype,a.values)}const MSe={kernelName:nB,backendName:"cpu",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NSe={kernelName:vE,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:i}=s,{strides:r,pad:a,dilations:o}=t,l=e,u=l.data.get(n.dataId).values,c=n.shape.length,f=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:g,inHeight:x,inWidth:S,inChannels:b,outHeight:_,outWidth:T,padInfo:E,strideHeight:C,strideWidth:R,filterHeight:I,filterWidth:L,dilationHeight:P,dilationWidth:D,outShape:O}=cS(n.shape,i.shape,r,a,"NHWC",o),F=Xe(O),X=O.length,q=Mi(n.dtype,F);for(let Y=0;Y<g;++Y)for(let $=0;$<_;++$){const W=$*C-E.top;for(let V=0;V<T;++V){const se=V*R-E.left;for(let G=0;G<b;++G){let ne=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<I;++ue){const re=W+ue*P;if(re>=0&&re<x)for(let ce=0;ce<L;++ce){const Te=se+ce*D;if(Te>=0&&Te<S){const Be=ah([Y,re,Te,G],c,jt(n.shape)),Ke=ah([ue,ce,G],d,jt(i.shape)),ut=u[Be]+f[Ke];ut>ne&&(ne=ut)}}}const oe=ah([Y,$,V,G],X,jt(O));q[oe]=ne}}}return{dataId:l.write(Jg(q,n.dtype),O,n.dtype),shape:O,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RSe={kernelName:SD,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:i,dy:r}=s,{strides:a,pad:o,dilations:l}=t,u=e,c=au(n.shape,u.data.get(n.dataId).values),f=au(i.shape,u.data.get(i.dataId).values),{batchSize:d,inHeight:g,inWidth:x,inChannels:S,outHeight:b,outWidth:_,padInfo:T,strideHeight:E,strideWidth:C,filterHeight:R,filterWidth:I,dilationHeight:L,dilationWidth:P,outShape:D}=cS(n.shape,i.shape,a,o,"NHWC",l);K(r.rank===D.length,()=>`Error in ${SD}, dy must have the same rank as output ${D.length}, but got ${r.rank}`);const O=au(D,u.data.get(r.dataId).values),F=f8(i.shape,i.dtype);for(let q=0;q<d;++q)for(let J=0;J<b;++J){const Y=J*E-T.top;for(let $=0;$<_;++$){const W=$*C-T.left;for(let V=0;V<S;++V){let se=Number.MIN_SAFE_INTEGER,G=0,ne=0;for(let oe=0;oe<R;++oe){const ue=Y+oe*L;if(ue>=0&&ue<g)for(let re=0;re<I;++re){const ce=W+re*P;if(ce>=0&&ce<x){const Te=c[q][ue][ce][V]+f[oe][re][V];Te>se&&(se=Te,G=oe,ne=re)}}}F[G][ne][V]+=O[q][J][$][V]}}}return{dataId:u.write(Jg(F,n.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ISe={kernelName:_D,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:i,dy:r}=s,{strides:a,pad:o,dilations:l}=t,u=e,c=au(n.shape,u.data.get(n.dataId).values),f=au(i.shape,u.data.get(i.dataId).values),{batchSize:d,inHeight:g,inWidth:x,inChannels:S,outHeight:b,outWidth:_,padInfo:T,strideHeight:E,strideWidth:C,filterHeight:R,filterWidth:I,dilationHeight:L,dilationWidth:P,outShape:D}=cS(n.shape,i.shape,a,o,"NHWC",l);K(r.rank===D.length,()=>`Error in ${_D}, dy must have the same rank as output ${D.length}, but got ${r.rank}`);const O=au(D,u.data.get(r.dataId).values),F=f8(n.shape,n.dtype);for(let q=0;q<d;++q)for(let J=0;J<b;++J){const Y=J*E-T.top;for(let $=0;$<_;++$){const W=$*C-T.left;for(let V=0;V<S;++V){let se=Number.MIN_SAFE_INTEGER,G=Y<0?0:Y,ne=W<0?0:W;for(let oe=0;oe<R;++oe){const ue=Y+oe*L;if(ue>=0&&ue<g)for(let re=0;re<I;++re){const ce=W+re*P;if(ce>=0&&ce<x){const Te=c[q][ue][ce][V]+f[oe][re][V];Te>se&&(se=Te,G=ue,ne=ce)}}}F[q][G][ne][V]+=O[q][J][$][V]}}}return{dataId:u.write(Jg(F,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(s){const{inputs:e,backend:t,attrs:n}=s,{image:i}=e,{canvas:r,options:a}=n,{contextOptions:o,imageOptions:l}=a||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const f=r.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${c} type.`);const[d,g]=i.shape.slice(0,2),x=i.shape.length===2?1:i.shape[2],S=t.data.get(i.dataId).values,b=i.dtype==="float32"?255:1,_=new Uint8ClampedArray(g*d*4);for(let E=0;E<d*g;++E){const C=[0,0,0,255*u];for(let I=0;I<x;I++){const L=S[E*x+I];if(i.dtype==="float32"){if(L<0||L>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${L}.`)}else if(i.dtype==="int32"&&(L<0||L>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${L}.`);x===1?(C[0]=L*b,C[1]=L*b,C[2]=L*b):C[I]=L*b}const R=E*4;_[R+0]=Math.round(C[0]),_[R+1]=Math.round(C[1]),_[R+2]=Math.round(C[2]),_[R+3]=Math.round(C[3])}r.width=g,r.height=d;const T=new ImageData(_,g,d);return f.putImageData(T,0,0),i}const OSe={kernelName:qoe,backendName:"cpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;zt(i,"sum");let o;i.dtype==="bool"?o=mp({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):o=mh({inputs:{x:i},backend:t});const l=o.shape.length,u=kn(r,o.shape),c=ri(u,l);let f=u,d=o;c!=null&&(d=ro({inputs:{x:o},backend:t,attrs:{perm:c}}),f=Ri(f.length,l)),$r("sum",f,d.shape.length);const[g,x]=Tr(d.shape,f),S=ko(d.dtype,"int32");let b=lC(t,g,S);const _=Xe(x),T=t.data.get(b.dataId).values,E=t.data.get(d.dataId).values;for(let C=0;C<T.length;++C){const R=C*_;let I=0;for(let L=0;L<_;++L)I+=E[R+L];T[C]=I}if(a){const C=Ni(b.shape,u),R=b;b=Us({inputs:{x:b},backend:t,attrs:{shape:C}}),t.disposeIntermediateTensorInfo(R)}return t.disposeIntermediateTensorInfo(o),c!=null&&t.disposeIntermediateTensorInfo(d),b}const BSe={kernelName:ZE,backendName:"cpu",kernelFunc:MS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kSe(s){const{inputs:e,backend:t,attrs:n}=s,{equation:i}=n,r=e,{allDims:a,summedDims:o,idDims:l}=Jk(i,r.length);Qk(a.length,l,r);const{path:u,steps:c}=eL(o,l),f=c.length;let d=null,g=a.length;const x=[];for(let S=0;S<f;++S){for(const b of c[S]){const{permutationIndices:_,expandDims:T}=Zk(g,l[b]);let E;tL(_)?E=r[b]:(E=ro({inputs:{x:r[b]},backend:t,attrs:{perm:_}}),x.push(E));const C=E.shape.slice();for(let R=0;R<T.length;++R)C.splice(T[R],0,1);Wn(E.shape,C)||(E=Us({inputs:{x:E},backend:t,attrs:{shape:C}}),x.push(E)),d===null?d=E:(d=WM({inputs:{a:E,b:d},backend:t}),x.push(d))}S<f-1&&(u[S]>=0&&(d=MS({inputs:{x:d},backend:t,attrs:{axis:u[S]-(a.length-g),keepDims:!1}}),x.push(d)),g--)}for(const S of x)S!==d&&t.disposeIntermediateTensorInfo(S);return d}const LSe={kernelName:sB,backendName:"cpu",kernelFunc:kSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FSe(s){const{inputs:e,backend:t}=s,{dy:n,y:i}=e;zt([n,i],"eluGrad");const r=new Float32Array(Xe(i.shape)),a=t.data.get(i.dataId).values,o=t.data.get(n.dataId).values;for(let l=0;l<a.length;++l){const u=a[l];u>=0?r[l]=o[l]:r[l]=o[l]*(u+1)}return t.makeTensorInfo(i.shape,"float32",r)}const PSe={kernelName:iB,backendName:"cpu",kernelFunc:FSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const USe=Vk,$Se=Wk,zSe=Xk,GSe=qk,HSe=jk,VSe=Kk,WSe=bs(M_,s=>{const e=Math.sign(s),t=Math.abs(s),n=1/(1+USe*t);return e*(1-((((VSe*n+HSe)*n+GSe)*n+zSe)*n+$Se)*n*Math.exp(-t*t))}),XSe={kernelName:M_,backendName:"cpu",kernelFunc:WSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(s){const{inputs:e,backend:t,attrs:n}=s,{input:i}=e,{dim:r}=n,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(K(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),Us({inputs:{x:i},backend:t,attrs:{shape:o}})}const qSe={kernelName:_E,backendName:"cpu",kernelFunc:hC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jSe=Di((s,e)=>s/e),BL=ar(C_,jSe),u3={kernelName:C_,backendName:"cpu",kernelFunc:BL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xX(s,e,t){const n=s.shape,i=n[0],r=n[1],a=t.data.get(s.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[i,r],c=Xe(u),f=Fr("float32",c),d=Fr("float32",c);for(let b=0;b<i;b++){const _=Hg({inputs:{x:o},backend:t,attrs:{begin:[b,0],size:[1,r]}}),T=Hg({inputs:{x:l},backend:t,attrs:{begin:[b,0],size:[1,r]}}),E=Co({inputs:{real:_,imag:T},backend:t}),{real:C,imag:R}=KSe(E,e,t),I=Tf(C,R);for(let L=0;L<r;L++){const P=Yk(I,L);f[b*r+L]=P.real,d[b*r+L]=P.imag}t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(E)}const g=t.makeTensorInfo(u,"float32",f),x=t.makeTensorInfo(u,"float32",d),S=Co({inputs:{real:g,imag:x},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),S}function KSe(s,e,t){const n=Xe(s.shape),i=t.data.get(s.dataId),r=t.data.get(i.complexTensorInfos.real.dataId).values,a=t.data.get(i.complexTensorInfos.imag.dataId).values;if(YSe(n)){const o=c3(r,a,n,e,t),l=[s.shape[0],s.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",o.real),c=t.makeTensorInfo(l,"float32",o.imag),f=t.makeTensorInfo([],"float32",_p(n,"float32")),d=mh({inputs:{x:f},backend:t}),g=u3.kernelFunc({inputs:{a:u,b:f},backend:t}),x=u3.kernelFunc({inputs:{a:c,b:d},backend:t}),S=t.data.get(g.dataId).values,b=t.data.get(x.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),{real:S,imag:b}}return o}else{const o=Tf(r,a),l=JSe(o,n,e);return EH(l)}}function YSe(s){return(s&s-1)===0}function c3(s,e,t,n,i){if(t===1)return{real:s,imag:e};const r=Tf(s,e),a=t/2,o=MH(r),l=o.real,u=o.imag,c=[l.length],f=i.makeTensorInfo(c,"float32",l),d=i.makeTensorInfo(c,"float32",u),g=Co({inputs:{real:f,imag:d},backend:i}),x=NH(r),S=x.real,b=x.imag,_=[S.length],T=i.makeTensorInfo(_,"float32",S),E=i.makeTensorInfo(_,"float32",b),C=Co({inputs:{real:T,imag:E},backend:i}),R=c3(l,u,a,n,i),I=R.real,L=R.imag,P=[I.length],D=i.makeTensorInfo(P,"float32",I),O=i.makeTensorInfo(P,"float32",L),F=Co({inputs:{real:D,imag:O},backend:i}),X=c3(S,b,a,n,i),q=X.real,J=X.imag,Y=[q.length],$=i.makeTensorInfo(Y,"float32",q),W=i.makeTensorInfo(Y,"float32",J),V=Co({inputs:{real:$,imag:W},backend:i}),se=IH(t,n),G=[se.real.length],ne=i.makeTensorInfo(G,"float32",se.real),oe=i.makeTensorInfo(G,"float32",se.imag),ue=Co({inputs:{real:ne,imag:oe},backend:i}),re=WM({inputs:{a:ue,b:V},backend:i}),ce=Ex({inputs:{a:F,b:re},backend:i}),Te=DL({inputs:{a:F,b:re},backend:i}),Be=Gg({inputs:{input:ce},backend:i}),Ke=Gg({inputs:{input:Te},backend:i}),ut=Mx({inputs:{input:ce},backend:i}),ct=Mx({inputs:{input:Te},backend:i}),xt=Nx({inputs:[Be,Ke],backend:i,attrs:{axis:0}}),kt=Nx({inputs:[ut,ct],backend:i,attrs:{axis:0}}),Et=i.data.get(xt.dataId).values,le=i.data.get(kt.dataId).values;return i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(ne),i.disposeIntermediateTensorInfo(oe),i.disposeIntermediateTensorInfo(ue),i.disposeIntermediateTensorInfo(re),i.disposeIntermediateTensorInfo(ce),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(Be),i.disposeIntermediateTensorInfo(ut),i.disposeIntermediateTensorInfo(Ke),i.disposeIntermediateTensorInfo(ct),i.disposeIntermediateTensorInfo(xt),i.disposeIntermediateTensorInfo(kt),{real:Et,imag:le}}function JSe(s,e,t){const n=new Float32Array(e*2);for(let i=0;i<e;i++){let r=0,a=0;for(let o=0;o<e;o++){const l=DH(i*o,e,t),u=Yk(s,o);r+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}t&&(r/=e,a/=e),RH(n,r,a,i)}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZSe(s){const{inputs:e,backend:t}=s,{input:n}=e,i=Xe(n.shape),r=n.shape[n.shape.length-1],a=i/r,o=Us({inputs:{x:n},backend:t,attrs:{shape:[a,r]}}),l=xX(o,!1,t),u=Us({inputs:{x:l},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}const QSe={kernelName:rB,backendName:"cpu",kernelFunc:ZSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kL(s){const{backend:e,attrs:t}=s,{shape:n,value:i,dtype:r}=t,a=r||Gx(i),o=Mi(a,Xe(n));return tAe(o,i,a),e.makeTensorInfo(n,a,o)}const eAe={kernelName:aB,backendName:"cpu",kernelFunc:kL};function tAe(s,e,t){s.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nAe={kernelName:oB,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,i=t,r=Fr(n.dtype,Xe(n.shape)),[a,o,l,u]=n.shape,c=i.data.get(n.dataId).values;for(let d=0;d<a;d++){const g=d*l*o*u;for(let x=0;x<o;x++){const S=x*(l*u);for(let b=0;b<l;b++){const _=b*u;for(let T=0;T<u;T++){const E=Math.round(l-b-1),C=g+S+_+T;let R=c[C];if(E>=0&&E<l){const I=E*u,L=g+S+I+T;R=c[L]}r[C]=R}}}}return{dataId:i.write(r,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:f,dimRoundingMode:d,activation:g,leakyreluAlpha:x}=n;let S=gX({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:f,dimRoundingMode:d}});if(a){const b=S;if(c==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const _=Us({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});S=Ex({inputs:{a:S,b:_},backend:t}),t.disposeIntermediateTensorInfo(_)}else S=Ex({inputs:{a:S,b:a},backend:t});t.disposeIntermediateTensorInfo(b)}if(g){const b=S;if(c==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const _=Us({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});S=cC(t,S,g,_,x),t.disposeIntermediateTensorInfo(_)}else S=cC(t,S,g,o,x);t.disposeIntermediateTensorInfo(b)}return S}const iAe={kernelName:V2,backendName:"cpu",kernelFunc:sAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:f,dimRoundingMode:d,activation:g,leakyreluAlpha:x}=n;let S=yX({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:f,dimRoundingMode:d}});if(a){const b=S;S=Ex({inputs:{a:S,b:a},backend:t}),t.disposeIntermediateTensorInfo(b)}if(g){const b=S;S=cC(t,S,g,o,x),t.disposeIntermediateTensorInfo(b)}return S}const aAe={kernelName:W2,backendName:"cpu",kernelFunc:rAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oAe(s){const{inputs:e,backend:t}=s,{params:n,indices:i}=e,r=Xe(n.shape),a=i.shape,o=a[a.length-1],[l,u,c,f]=Ok(n,i);if(u===0)return t.makeTensorInfo(l,n.dtype,[]);const d=t.data.get(i.dataId).values,g=t.bufferSync(n),x=MW(d,g,n.dtype,u,o,c,f,n.shape,r);return t.makeTensorInfo(l,n.dtype,x.values)}const lAe={kernelName:lB,backendName:"cpu",kernelFunc:oAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,indices:r}=e,{axis:a,batchDims:o}=n;zt([i,r],"gatherV2");const l=kn(a,i.shape)[0],u=t.data.get(r.dataId).values,c=i.shape[l];for(let C=0;C<u.length;++C){const R=u[C];K(R<=c-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${c-1}]`)}let f=o;o==null&&(f=0);const d=Xe(r.shape),g=sL(i,r,l,f),x=Us({inputs:{x:i},backend:t,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),S=Us({inputs:{x:r},backend:t,attrs:{shape:[g.batchSize,d/g.batchSize]}}),b=[g.batchSize,g.outerSize,d/g.batchSize,g.sliceSize],_=t.bufferSync(S),T=t.bufferSync(x),E=NW(T,_,b);return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),t.makeTensorInfo(g.outputShape,E.dtype,E.values)}const cAe={kernelName:AE,backendName:"cpu",kernelFunc:uAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hAe(s){const{inputs:e,backend:t}=s,{input:n}=e,i=Xe(n.shape),r=n.shape[n.shape.length-1],a=i/r,o=Us({inputs:{x:n},backend:t,attrs:{shape:[a,r]}}),l=xX(o,!0,t),u=Us({inputs:{x:l},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}const fAe={kernelName:uB,backendName:"cpu",kernelFunc:hAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dAe=bs(k_,s=>Number.isFinite(s)?1:0,"bool"),pAe={kernelName:k_,backendName:"cpu",kernelFunc:dAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mAe=bs(L_,s=>Math.abs(s)===1/0?1:0,"bool"),gAe={kernelName:L_,backendName:"cpu",kernelFunc:mAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yAe=bs(F_,s=>Number.isNaN(s)?1:0,"bool"),xAe={kernelName:F_,backendName:"cpu",kernelFunc:yAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vAe(s){const{backend:e,attrs:t}=s,{start:n,stop:i,num:r}=t,a=BW(n,i,r);return e.makeTensorInfo([a.length],"float32",a)}const bAe={kernelName:hB,backendName:"cpu",kernelFunc:vAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ae=bs(U_,s=>Math.log1p(s)),SAe={kernelName:U_,backendName:"cpu",kernelFunc:_Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AAe=Di((s,e)=>s&&e),TAe=ar(ME,AAe,null,"bool"),wAe={kernelName:ME,backendName:"cpu",kernelFunc:TAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CAe=bs(NE,s=>s?0:1,"bool"),EAe={kernelName:NE,backendName:"cpu",kernelFunc:CAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MAe=Di((s,e)=>s||e),NAe=ar(RE,MAe,null,"bool"),RAe={kernelName:RE,backendName:"cpu",kernelFunc:NAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{depthRadius:r,bias:a,alpha:o,beta:l}=n;zt(i,"LRN");const u=i.shape[3],c=u-1,f=t.data.get(i.dataId).values,d=Xe(i.shape),g=new Float32Array(d);function x(S){const b=S%u;let _=S-b+Math.max(0,b-r);const T=S-b+Math.min(b+r,c);let E=0;for(;_<=T;_++){const C=f[_];E+=C*C}return E}for(let S=0;S<d;S++){const b=x(S),_=f[S]*Math.pow(a+o*b,-l);g[S]=_}return t.makeTensorInfo(i.shape,i.dtype,g)}const DAe={kernelName:IE,backendName:"cpu",kernelFunc:IAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,y:r,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=n;zt(a,"LRNGrad");const f=Xe(a.shape),d=a.shape[3],g=t.data.get(a.dataId).values,x=t.data.get(i.dataId).values,S=t.data.get(r.dataId).values,b=new Float32Array(f),_=f;for(let T=0;T<_;T++){const E=T%d,C=T-E+Math.max(0,E-o),R=T-E+Math.min(d,E+o+1);let I=0;for(let L=C;L<R;L++)I+=Math.pow(x[L],2);I=u*I+l;for(let L=C;L<R;L++){let P=-2*u*c*x[L]*S[T]/I;T===L&&(P+=Math.pow(I,-c)),P*=g[T],b[L]+=P}}return t.makeTensorInfo(a.shape,i.dtype,b)}const BAe={kernelName:fB,backendName:"cpu",kernelFunc:OAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vX(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{reductionIndices:r,keepDims:a}=n,o=t;let l=i.shape;const u=l.length,c=kn(r,l);let f=c;const d=ri(f,u);let g=o.data.get(i.dataId).values;if(d!=null){const C=new Array(u);for(let R=0;R<C.length;R++)C[R]=l[d[R]];g=RL(g,l,i.dtype,d,C),f=Ri(f.length,u),l=C}zt(i,"max"),$r("max",f,u);const[x,S]=Tr(l,f),b=Xe(S),_=LW(g,b,x,i.dtype),T=o.write(_,x,i.dtype);let E=x;return a&&(E=Ni(x,c)),{dataId:T,shape:E,dtype:i.dtype}}const kAe={kernelName:DE,backendName:"cpu",kernelFunc:vX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e;zt(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=n,u=1;K(Ur(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=pu(i.shape,r,a,u,o,l);let f;if(c.filterWidth===1&&c.filterHeight===1&&Wn(c.inShape,c.outShape))f=mh({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,g=jt(i.shape),x=OL(d,i.shape,i.dtype,g,c,"max");f=t.makeTensorInfo(c.outShape,i.dtype,x.values)}return f}const FAe={kernelName:OE,backendName:"cpu",kernelFunc:LAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=n;zt(i,"maxPool3d");const c=Mf(i.shape,r,a,1,o,l,u),f=t.data.get(i.dataId).values,d=mX(f,i.shape,i.dtype,jt(i.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const UAe={kernelName:BE,backendName:"cpu",kernelFunc:PAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ae(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=n;zt([i,r],"maxPool3DGrad");const c=Mf(r.shape,a,o,1,l,u),f=t.bufferSync(r),d=M_e(f,c),g=c.strideDepth,x=c.strideHeight,S=c.strideWidth,b=c.dilationDepth,_=c.dilationHeight,T=c.dilationWidth,E=c.effectiveFilterDepth,C=c.effectiveFilterHeight,R=c.effectiveFilterWidth,I=E-1-c.padInfo.front,L=R-1-c.padInfo.left,P=C-1-c.padInfo.top,D=Mn(r.shape,"float32"),O=t.bufferSync(i);for(let F=0;F<c.batchSize;++F)for(let X=0;X<c.inChannels;++X)for(let q=0;q<c.inDepth;++q)for(let J=0;J<c.inHeight;++J)for(let Y=0;Y<c.inWidth;++Y){const $=q-I,W=J-P,V=Y-L;let se=0;for(let G=0;G<E;G+=b){const ne=($+G)/g;if(!(ne<0||ne>=c.outDepth||Math.floor(ne)!==ne))for(let oe=0;oe<C;oe+=_){const ue=(W+oe)/x;if(!(ue<0||ue>=c.outHeight||Math.floor(ue)!==ue))for(let re=0;re<R;re+=T){const ce=(V+re)/S;if(ce<0||ce>=c.outWidth||Math.floor(ce)!==ce)continue;const Te=E*C*R-1-d.get(F,ne,ue,ce,X),Be=G*C*R+oe*R+re,Ke=Te===Be?1:0;if(Ke===0)continue;const ut=O.get(F,ne,ue,ce,X);se+=ut*Ke}}}D.set(se,F,q,J,Y,X)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const zAe={kernelName:pB,backendName:"cpu",kernelFunc:$Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GAe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r,output:a}=e,o=r;zt([r,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:f}=n,d=pu(o.shape,l,u,1,c,f),g=t.data.get(o.dataId).values,x=Mn(d.outShape,o.dtype,pX(g,o.shape,o.dtype,d).values),S=d.strideHeight,b=d.strideWidth,_=d.dilationHeight,T=d.dilationWidth,E=d.effectiveFilterHeight,C=d.effectiveFilterWidth,R=C-1-d.padInfo.left,I=E-1-d.padInfo.top,L=Mn(o.shape,"float32"),P=t.data.get(i.dataId).values,D=Mn(i.shape,"float32",P);for(let O=0;O<d.batchSize;++O)for(let F=0;F<d.inChannels;++F)for(let X=0;X<d.inHeight;++X)for(let q=0;q<d.inWidth;++q){const J=X-I,Y=q-R;let $=0;for(let W=0;W<E;W+=_){const V=(J+W)/S;if(!(V<0||V>=d.outHeight||Math.floor(V)!==V))for(let se=0;se<C;se+=T){const G=(Y+se)/b;if(G<0||G>=d.outWidth||Math.floor(G)!==G)continue;const ne=E*C-1-x.get(O,V,G,F),oe=W*C+se,ue=ne===oe?1:0;if(ue===0)continue;const re=D.get(O,V,G,F);$+=re*ue}}L.set($,O,X,q,F)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const HAe={kernelName:dB,backendName:"cpu",kernelFunc:GAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VAe(s,e,t,n,i){const r=jt(e),a=OL(s,e,t,r,i,"max"),o=pX(s,e,t,i,!0,n);return[a.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WAe={kernelName:mB,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=e,l=t;zt(n,"MaxPoolWithArgmax");const u=l.data.get(n.dataId).values,c=pu(n.shape,i,r,[1,1],a),[f,d]=VAe(u,n.shape,n.dtype,o,c),g=l.write(f,c.outShape,n.dtype),x=l.write(d,c.outShape,n.dtype);return[{dataId:g,shape:c.outShape,dtype:n.dtype},{dataId:x,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n,o=kn(r,i.shape),u=Tr(i.shape,o)[1],c=Xe(u),f=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));f.push(d);const g=mp({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});f.push(g);const x=BL({inputs:{a:g,b:d},backend:t});f.push(x);const S=MS({inputs:{x},backend:t,attrs:{axis:r,keepDims:a}});return f.forEach(b=>t.disposeIntermediateTensorInfo(b)),S}const qAe={kernelName:kE,backendName:"cpu",kernelFunc:XAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;zt(i,"min");const o=kn(r,i.shape);let l=o;const u=ri(l,i.shape.length);let c=i;u!=null&&(c=ro({inputs:{x:i},backend:t,attrs:{perm:u}}),l=Ri(l.length,i.shape.length)),$r("min",l,c.shape.length);const[f,d]=Tr(c.shape,l),g=Xe(d),x=sa(Xe(f),c.dtype),S=t.data.get(c.dataId).values;for(let _=0;_<x.length;++_){const T=_*g;let E=S[T];for(let C=0;C<g;++C){const R=S[T+C];(Number.isNaN(R)||R<E)&&(E=R)}x[_]=E}u!=null&&t.disposeIntermediateTensorInfo(c);const b=t.makeTensorInfo(f,c.dtype,x);if(a){const _=Ni(f,o),T=Us({inputs:{x:b},backend:t,attrs:{shape:_}});return t.disposeIntermediateTensorInfo(b),T}return b}const KAe={kernelName:LE,backendName:"cpu",kernelFunc:jAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YAe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{paddings:r,mode:a}=n;zt(i,"mirrorPad");const o=r.map((E,C)=>E[0]+i.shape[C]+E[1]),l=r.map(E=>E[0]),u=r.map((E,C)=>E[0]+i.shape[C]),c=a==="reflect"?0:1,f=t.data.get(i.dataId).values,d=i.shape.length,g=jt(i.shape),x=Xe(o),S=o.length,b=jt(o),_=Fr(i.dtype,x);for(let E=0;E<x;E++){let C=Hx(E,S,b);for(let I=0;I<S;I++)C[I]<l[I]?C[I]=l[I]*2-C[I]-c:C[I]>=u[I]&&(C[I]=(u[I]-1)*2-C[I]+c);C=C.map((I,L)=>I-l[L]);const R=ah(C,d,g);_[E]=f[R]}return{dataId:t.write(_,o,i.dtype),shape:o,dtype:i.dtype}}const JAe={kernelName:FE,backendName:"cpu",kernelFunc:YAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZAe=Di((s,e)=>{const t=s%e;return s<0&&e<0||s>=0&&e>=0?t:(t+e)%e}),QAe=ar(G_,ZAe),eTe={kernelName:G_,backendName:"cpu",kernelFunc:QAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bX(s){const{inputs:e,backend:t,attrs:n}=s,{logits:i}=e,{dim:r}=n,a=i.shape.length;let o=r;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=kn([o],i.shape),u=vX({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=Ni(u.shape,l),f=Us({inputs:{x:u},backend:t,attrs:{shape:c}}),d=DL({inputs:{a:i,b:f},backend:t}),g=TW({inputs:{x:d},backend:t}),x=MS({inputs:{x:g},backend:t,attrs:{axis:l,keepDims:!1}}),S=Us({inputs:{x},backend:t,attrs:{shape:c}}),b=BL({inputs:{a:g,b:S},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),b}const tTe={kernelName:tM,backendName:"cpu",kernelFunc:bX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nTe(s){const{inputs:e,backend:t,attrs:n}=s,{logits:i}=e,{numSamples:r,seed:a,normalized:o}=n;zt(i,"multinomial");const l=o?i:bX({inputs:{logits:i},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],f=t.data.get(l.dataId).values,d=[u,r],g=sa(Xe(d),"int32");for(let x=0;x<u;++x){const S=x*c,b=new Float32Array(c-1);b[0]=f[S];for(let E=1;E<b.length;++E)b[E]=b[E-1]+f[S+E];const _=bM.alea(a.toString()),T=x*r;for(let E=0;E<r;++E){const C=_();g[T+E]=b.length;for(let R=0;R<b.length;R++)if(C<b[R]){g[T+E]=R;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",g)}const sTe={kernelName:gB,backendName:"cpu",kernelFunc:nTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iTe=Ck;function rTe(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=n;zt(i,"NonMaxSuppression");const u=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,{selectedIndices:f}=iTe(u,c,a,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const aTe={kernelName:yB,backendName:"cpu",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oTe=Ek;function lTe(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=n;zt(i,"NonMaxSuppressionPadded");const c=t.data.get(i.dataId).values,f=t.data.get(r.dataId).values,{selectedIndices:d,validOutputs:g}=oTe(c,f,a,o,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const uTe={kernelName:xB,backendName:"cpu",kernelFunc:lTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cTe=Mk;function hTe(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=n;zt(i,"NonMaxSuppressionWithScore");const c=t.data.get(i.dataId).values,f=t.data.get(r.dataId).values,d=a,g=o,x=l,S=u,{selectedIndices:b,selectedScores:_}=cTe(c,f,d,g,x,S);return[t.makeTensorInfo([b.length],"int32",new Int32Array(b)),t.makeTensorInfo([_.length],"float32",new Float32Array(_))]}const fTe={kernelName:vB,backendName:"cpu",kernelFunc:hTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dTe(s){const{inputs:e,backend:t,attrs:n}=s,{indices:i}=e,{dtype:r,depth:a,onValue:o,offValue:l}=n;zt(i,"oneHot");const u=Xe(i.shape),c=new Float32Array(u*a);c.fill(l);const f=t.data.get(i.dataId).values;for(let d=0;d<u;++d)f[d]>=0&&f[d]<a&&(c[d*a+f[d]]=o);return t.makeTensorInfo([...i.shape,a],r,c)}const pTe={kernelName:zE,backendName:"cpu",kernelFunc:dTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fC(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){const i=Gg({inputs:{input:n},backend:t}),r=fC({inputs:{x:i},backend:t}),a=Mx({inputs:{input:n},backend:t}),o=fC({inputs:{x:a},backend:t}),l=Co({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return kL({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}const mTe={kernelName:rM,backendName:"cpu",kernelFunc:fC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){const i=Gg({inputs:{input:n},backend:t}),r=_X({inputs:{x:i},backend:t}),a=Mx({inputs:{input:n},backend:t}),o=fC({inputs:{x:a},backend:t}),l=Co({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return kL({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}const gTe={kernelName:$E,backendName:"cpu",kernelFunc:_X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SX(s){const{inputs:e,backend:t,attrs:n}=s,{axis:i}=n;if(e.length===1)return hC({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(c=>{zo(r,c.shape,"All tensors passed to stack must have matching shapes"),K(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(c=>{const f=hC({inputs:{input:c},backend:t,attrs:{dim:i}});return o.push(f),f}),u=Nx({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const yTe={kernelName:GE,backendName:"cpu",kernelFunc:SX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xTe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{paddings:r,constantValue:a}=n;zt(i,"pad");const o=r.map((T,E)=>T[0]+i.shape[E]+T[1]),l=r.map(T=>T[0]),u=t.data.get(i.dataId).values,c=Xe(i.shape),f=i.shape.length,d=jt(i.shape),g=Xe(o),x=o.length,S=jt(o),b=Fr(i.dtype,g);a!==0&&b.fill(a);for(let T=0;T<c;T++){const C=Hx(T,f,d).map((I,L)=>I+l[L]),R=ah(C,x,S);b[R]=u[T]}return{dataId:t.write(b,o,i.dtype),shape:o,dtype:i.dtype}}const AX={kernelName:HE,backendName:"cpu",kernelFunc:xTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vTe=Di((s,e)=>Math.pow(s,e)),bTe=ar(V_,vTe),_Te={kernelName:V_,backendName:"cpu",kernelFunc:bTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function STe(s){const{inputs:e,backend:t,attrs:n}=s,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=e,{outputRaggedRank:o}=n,l=i.map(_=>t.data.get(_.dataId).values),u=i.map(_=>_.shape),c=t.data.get(r.dataId).values,f=t.data.get(a.dataId).values,[d,g,x]=GW(l,u,c,r.shape,r.dtype,f,a.shape),S=d.map(_=>t.makeTensorInfo([_.length],"int32",_)),b=t.makeTensorInfo(x,r.dtype,g);return S.concat([b])}const ATe={kernelName:bB,backendName:"cpu",kernelFunc:STe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TTe(s){const{inputs:e,backend:t}=s,{starts:n,limits:i,deltas:r}=e,a=t.data.get(n.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[u,c]=HW(a,n.shape,n.dtype,o,i.shape,l,r.shape),f=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],n.dtype,c);return[f,d]}const wTe={kernelName:_B,backendName:"cpu",kernelFunc:TTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CTe(s){const{inputs:e,backend:t,attrs:n}=s,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=n,u=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,f=t.data.get(a.dataId).values,d=o.map(b=>t.data.get(b.dataId).values),g=o.map(b=>b.shape),[x,S]=VW(u,i.shape,c,r.shape,r.dtype,f,a.shape,d,g,l);return t.makeTensorInfo(x,r.dtype,S)}const ETe={kernelName:SB,backendName:"cpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTe(s){const{backend:e,attrs:t}=s,{start:n,stop:i,dtype:r,step:a}=t,o=WW(n,i,a,r);return e.makeTensorInfo([o.length],r,o)}const NTe={kernelName:AB,backendName:"cpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RTe=bs(W_,s=>1/s),ITe={kernelName:W_,backendName:"cpu",kernelFunc:RTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DTe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=n;zt(i,"resizeBilinear");const l=jt(i.shape),[u,c]=o,[f,d,g,x]=i.shape,S=t.data.get(i.dataId).values,b=new Float32Array(Xe([f,u,c,x])),_=[r&&u>1?d-1:d,r&&c>1?g-1:g],T=[r&&u>1?u-1:u,r&&c>1?c-1:c];let E=0;const C=_[0]/T[0],R=_[1]/T[1];for(let I=0;I<f;I++)for(let L=0;L<u;L++){let P;a?P=C*(L+.5)-.5:P=C*L;const D=Math.max(0,Math.floor(P)),O=P-D,F=Math.min(d-1,Math.ceil(P)),X=I*l[0]+D*l[1],q=I*l[0]+F*l[1];for(let J=0;J<c;J++){let Y;a?Y=R*(J+.5)-.5:Y=R*J;const $=Math.max(0,Math.floor(Y)),W=Y-$,V=Math.min(g-1,Math.ceil(Y)),se=X+$*l[2],G=q+$*l[2],ne=X+V*l[2],oe=q+V*l[2];for(let ue=0;ue<x;ue++){const re=S[se+ue],ce=S[G+ue],Te=S[ne+ue],Be=S[oe+ue],Ke=re+(Te-re)*W,ut=ce+(Be-ce)*W,ct=Ke+(ut-Ke)*O;b[E++]=ct}}}return t.makeTensorInfo([f,u,c,x],"float32",b)}const OTe={kernelName:jE,backendName:"cpu",kernelFunc:DTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BTe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i,dy:r}=e,{alignCorners:a}=n;zt([r,i],"resizeBilinearGrad");const o=jt(i.shape),[l,u,c,f]=i.shape,[,d,g]=r.shape,x=new Float32Array(l*u*c*f),S=[a&&d>1?u-1:u,a&&g>1?c-1:c],b=[a&&d>1?d-1:d,a&&g>1?g-1:g],_=S[0]/b[0],T=S[1]/b[1],E=t.data.get(r.dataId).values;let C=0;for(let R=0;R<l;R++){const I=R*o[0];for(let L=0;L<d;L++){const P=L*_,D=Math.floor(P),O=Math.min(Math.ceil(P),u-1),F=I+D*o[1],X=I+O*o[1],q=P-D,J=1-q;for(let Y=0;Y<g;Y++){const $=Y*T,W=Math.floor($),V=Math.min(Math.ceil($),c-1),se=$-W,G=1-se,ne=F+W*o[2],oe=F+V*o[2],ue=X+W*o[2],re=X+V*o[2],ce=J*G,Te=J*se,Be=q*G,Ke=q*se;for(let ut=0;ut<f;ut++){const ct=E[C++];x[ne+ut]+=ct*ce,x[oe+ut]+=ct*Te,x[ue+ut]+=ct*Be,x[re+ut]+=ct*Ke}}}}return t.makeTensorInfo([l,c,u,f],"float32",x)}const kTe={kernelName:CB,backendName:"cpu",kernelFunc:BTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LTe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=n;zt(i,"resizeNearestNeighbor");const l=jt(i.shape),[u,c]=o,[f,d,g,x]=i.shape,S=t.data.get(i.dataId).values,b=new Float32Array(f*u*c*x),_=[r&&u>1?d-1:d,r&&c>1?g-1:g],T=[r&&u>1?u-1:u,r&&c>1?c-1:c],E=_[0]/T[0],C=_[1]/T[1];let R=0;for(let I=0;I<f;I++){const L=I*l[0];for(let P=0;P<u;P++){const D=a?E*(P+.5):E*P;let O=Math.min(d-1,r?Math.round(D):Math.floor(D));a&&(O=Math.max(0,O));const F=L+O*l[1];for(let X=0;X<c;X++){const q=a?C*(X+.5):C*X;let J=Math.min(g-1,r?Math.round(q):Math.floor(q));a&&(J=Math.max(0,J));const Y=F+J*l[2];for(let $=0;$<x;$++){const W=S[Y+$];b[R++]=W}}}}return t.makeTensorInfo([f,u,c,x],i.dtype,b)}const FTe={kernelName:qE,backendName:"cpu",kernelFunc:LTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PTe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i,dy:r}=e,{alignCorners:a}=n;zt([r,i],"resizeNearestNeighborGrad");const o=jt(i.shape),l=jt(r.shape),[u,c,f,d]=i.shape,[,g,x]=r.shape,S=new Float32Array(u*c*f*d),b=t.data.get(r.dataId).values,_=[a&&g>1?c-1:c,a&&x>1?f-1:f],T=[a&&g>1?g-1:g,a&&x>1?x-1:x],E=_[0]/T[0],C=_[1]/T[1],R=1/E,I=1/C,L=Math.ceil(R)*2+2,P=Math.ceil(I)*2+2;for(let D=0;D<u;D++){const O=D*o[0];for(let F=0;F<c;F++){const X=O+F*o[1],q=Math.floor(F*R),J=Math.floor(q-L/2);for(let Y=0;Y<f;Y++){const $=X+Y*o[2],W=Math.floor(Y*I),V=Math.floor(W-P/2);for(let se=0;se<d;se++){let G=0;for(let ne=0;ne<L;ne++){const oe=ne+J;if(oe<0||oe>=g)continue;const ue=O+oe*l[1],re=oe*E,ce=Math.min(c-1,a?Math.round(re):Math.floor(re));if(F===ce)for(let Te=0;Te<P;Te++){const Be=Te+V;if(Be<0||Be>=x)continue;const Ke=ue+Be*l[2],ut=Be*C,ct=Math.min(f-1,a?Math.round(ut):Math.floor(ut));Y===ct&&(G+=b[Ke+se])}}S[$+se]=G}}}}return t.makeTensorInfo(i.shape,i.dtype,S)}const UTe={kernelName:wB,backendName:"cpu",kernelFunc:PTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{dims:r}=n;zt(i,"reverse");const a=i.shape.length,o=kn(r,i.shape);if(a===0)return mh({inputs:{x:i},backend:t});const l=new nr(i.shape,i.dtype),u=t.bufferSync(i);for(let c=0;c<l.size;c++){const f=l.indexToLoc(c),d=f.slice();o.forEach(g=>d[g]=i.shape[g]-1-d[g]),l.set(u.get(...d),...f)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const zTe={kernelName:KE,backendName:"cpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GTe={kernelName:HB,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,{radians:i,fillValue:r,center:a}=e,o=t,l=Fr(n.dtype,Xe(n.shape)),[u,c,f,d]=n.shape,[g,x]=zk(a,c,f),S=255,b=Math.sin(i),_=Math.cos(i),T=o.data.get(n.dataId).values;for(let C=0;C<u;C++){const R=C*f*c*d;for(let I=0;I<c;I++){const L=I*(f*d);for(let P=0;P<f;P++){const D=P*d;for(let O=0;O<d;O++){const F=[u,I,P,O],X=F[2],q=F[1];let J=(X-g)*_-(q-x)*b,Y=(X-g)*b+(q-x)*_;J=Math.round(J+g),Y=Math.round(Y+x);let $=r;if(typeof r!="number"&&(O===3?$=S:$=r[O]),J>=0&&J<f&&Y>=0&&Y<c){const V=Y*(f*d),se=J*d,G=R+V+se+O;$=T[G]}const W=R+L+D+O;l[W]=$}}}}return{dataId:o.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HTe=bs(j_,s=>{const e=Math.floor(s);return s-e<.5?Math.floor(s):s-e>.5?Math.ceil(s):e%2===0?e:e+1}),VTe={kernelName:j_,backendName:"cpu",kernelFunc:HTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(s){const{inputs:e,backend:t,attrs:n}=s,{indices:i,updates:r}=e,{shape:a}=n,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:f}=t0(r,i,a),d=!0,g=t.bufferSync(i),x=t.bufferSync(r),S=cg(g,x,a,f,u,l,o,c,0,d);return t.makeTensorInfo(a,S.dtype,S.values)}const XTe={kernelName:EB,backendName:"cpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(s,e){let t=0,n=s.length,i=0;for(;t<n;)i=Math.floor((t+n)/2),s[i]<e?t=i+1:n=i;return n}function jTe(s,e){let t=0,n=s.length,i=0;for(;t<n;)i=Math.floor((t+n)/2),s[i]<=e?t=i+1:n=i;return n}function KTe(s,e,t,n,i,r){const a=Mi("int32",t*i);for(let o=0;o<t;++o){const l=s.slice(o*n,(o+1)*n),u=o*i;for(let c=0;c<i;++c)a[u+c]=r==="left"?qTe(l,e[c+u]):jTe(l,e[c+u])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YTe(s){const{inputs:e,backend:t,attrs:n}=s,{sortedSequence:i,values:r}=e,{side:a}=n,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,u=KTe(o,l,i.shape[0],i.shape[1],r.shape[1],a);return t.makeTensorInfo(r.shape,"int32",u)}const JTe={kernelName:NB,backendName:"cpu",kernelFunc:YTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZTe(s){const{inputs:e,backend:t}=s,{condition:n,t:i,e:r}=e;zt([n,i,r],"select");const a=n.shape.length,o=t.data.get(n.dataId).values,l=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,c=ko(i.dtype,r.dtype),f=sa(Xe(i.shape),c);let d=0;const g=a===0||a>1||i.shape.length===1?1:Xe(i.shape.slice(1));for(let x=0;x<o.length;x++)for(let S=0;S<g;S++)o[x]===1?f[d++]=l[x]:f[d++]=u[x];return t.makeTensorInfo(i.shape,c,f)}const QTe={kernelName:YE,backendName:"cpu",kernelFunc:ZTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe=DM,twe=OM,nwe=bs(Y_,s=>s>=0?twe*s:ewe*(Math.exp(s)-1)),swe={kernelName:Y_,backendName:"cpu",kernelFunc:nwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iwe=bs(Q_,s=>s<0?-1:s>0?1:0),rwe={kernelName:Q_,backendName:"cpu",kernelFunc:iwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const awe=bs(J_,s=>Math.sin(s)),owe={kernelName:J_,backendName:"cpu",kernelFunc:awe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe=bs(Z_,s=>Math.sinh(s)),uwe={kernelName:Z_,backendName:"cpu",kernelFunc:lwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cwe=11920928955078125e-23,k$=Math.log(cwe)+2,hwe=bs(tS,s=>{const e=s>-k$,t=s<k$,n=Math.exp(s);let i;return t?i=n:e?i=s:i=Math.log(1+n),i}),fwe={kernelName:tS,backendName:"cpu",kernelFunc:hwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dwe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockShape:r,paddings:a}=n;zt([i],"spaceToBatchND");const o=Xe(r),l=[[0,0]];l.push(...a);for(let I=1+r.length;I<i.shape.length;++I)l.push([0,0]);const u=AX.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),c=yS(u.shape,r,o,!1),f=xS(c.length,r.length,!1),d=vS(u.shape,r,o,!1),S=Us({inputs:{x:u},backend:t,attrs:{shape:c}}),T=ro({inputs:{x:S},backend:t,attrs:{perm:f}}),R=Us({inputs:{x:T},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(T),R}const pwe={kernelName:QE,backendName:"cpu",kernelFunc:dwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mwe(s){const{inputs:e,backend:t}=s,{indices:n,values:i,denseShape:r,defaultValue:a}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(n.dataId).values,l=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values[0],[f,d,g,x,S]=KW(o,n.shape,n.dtype,l,i.dtype,u,c);return[t.makeTensorInfo(d,n.dtype,f),t.makeTensorInfo([d[0]],i.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(b=>Number(b)))),t.makeTensorInfo([S.length],n.dtype,new Int32Array(S))]}const gwe={kernelName:RB,backendName:"cpu",kernelFunc:mwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ywe(s){const{inputs:e,backend:t}=s,{inputIndices:n,inputShape:i,newShape:r}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(t.data.get(i.dataId).values),o=t.data.get(n.dataId).values,l=Array.from(t.data.get(r.dataId).values),[u,c,f]=YW(o,n.shape,n.dtype,a,l);return[t.makeTensorInfo(c,n.dtype,u),t.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const xwe={kernelName:IB,backendName:"cpu",kernelFunc:ywe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwe(s){const{inputs:e,backend:t}=s,{data:n,indices:i,segmentIds:r}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(n.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[u,c]=IL(a,n.shape,n.dtype,o,l,!0);return t.makeTensorInfo(c,n.dtype,u)}const bwe={kernelName:DB,backendName:"cpu",kernelFunc:vwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(s){const{inputs:e,backend:t}=s,{data:n,indices:i,segmentIds:r}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(n.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[u,c]=IL(a,n.shape,n.dtype,o,l);return t.makeTensorInfo(c,n.dtype,u)}const Swe={kernelName:OB,backendName:"cpu",kernelFunc:_we};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Awe(s){const{inputs:e,backend:t,attrs:n}=s,{sparseIndices:i,sparseValues:r,defaultValue:a}=e,{outputShape:o}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:f,outputSize:d}=t0(r,i,o),g=!1,x=t.bufferSync(i);let S;switch(r.dtype){case"bool":{const b=t.bufferSync(r),_=!!t.data.get(a.dataId).values[0];S=cg(x,b,o,d,c,u,l,f,_,g);break}case"float32":{const b=t.bufferSync(r),_=t.data.get(a.dataId).values[0];S=cg(x,b,o,d,c,u,l,f,_,g);break}case"int32":{const b=t.bufferSync(r),_=t.data.get(a.dataId).values[0];S=cg(x,b,o,d,c,u,l,f,_,g);break}case"string":{const b=t.bufferSync(r),_=ap(t.data.get(a.dataId).values[0]);S=cg(x,b,o,d,c,u,l,f,_,g);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return t.makeTensorInfo(o,S.dtype,S.values)}const Twe={kernelName:BB,backendName:"cpu",kernelFunc:Awe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{numOrSizeSplits:r,axis:a}=n,o=kn(a,i.shape)[0],l=nL(i,r,o),u=new Array(i.shape.length).fill(0),c=i.shape.slice();return l.map(f=>{const d=[...c];d[o]=f;const g=Hg({inputs:{x:i},backend:t,attrs:{begin:u,size:d}});return u[o]+=f,g})}const Cwe={kernelName:eM,backendName:"cpu",kernelFunc:wwe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ewe={kernelName:kB,backendName:"cpu",kernelFunc:({inputs:s,backend:e})=>{const{x:t}=s,n=e;zt(t,"square");const i=n.data.get(t.dataId).values,r=new Float32Array(i.length);for(let o=0;o<i.length;++o){const l=i[o];r[o]=l*l}return{dataId:n.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mwe=bs(lS,(s,e)=>{const t=e;return isNaN(s)?NaN:s>0?1:t.alpha}),Nwe={kernelName:lS,backendName:"cpu",kernelFunc:Mwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{begin:r,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:f,shrinkAxisMask:d}=n;zt(i,"stridedSlice");const{finalShapeSparse:g,finalShape:x,isIdentity:S,sliceDim0:b,isSimpleSlice:_,begin:T,end:E,strides:C}=Pk(i.shape,r,a,o,l,u,c,f,d);let R;if(S)R=Us({inputs:{x:i},backend:t,attrs:{shape:x}});else if(b||_){K(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const I=kk(T,E,C),L=Hg({inputs:{x:i},backend:t,attrs:{begin:T,size:I}});R=Us({inputs:{x:L},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(L)}else{const I=t.bufferSync(i),L=QW(g,I,C,T);R=t.makeTensorInfo(x,L.dtype,L.values)}return R}const Iwe={kernelName:LB,backendName:"cpu",kernelFunc:Rwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(s){const{inputs:e,backend:t,attrs:n}=s,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=n,{data:c,dataSplits:f}=e,d=t.data.get(c.dataId).values,g=t.data.get(f.dataId).values,[x,S]=eX(d,g,i,r,a,o,l,u);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",S)]}const Owe={kernelName:FB,backendName:"cpu",kernelFunc:Dwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bwe(s){const{inputs:e,backend:t,attrs:n}=s,{skipEmpty:i}=n,{input:r,delimiter:a}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values[0],[u,c,f]=tX(o,l,i),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const kwe={kernelName:PB,backendName:"cpu",kernelFunc:Bwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(s){const{inputs:e,backend:t,attrs:n}=s,{numBuckets:i}=n,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(r.dataId).values,o=nX(a,i);return t.makeTensorInfo(r.shape,"int32",o)}const Fwe={kernelName:UB,backendName:"cpu",kernelFunc:Lwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pwe=bs(rS,s=>Math.tan(s)),Uwe={kernelName:rS,backendName:"cpu",kernelFunc:Pwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $we=bs(aS,s=>Math.tanh(s)),zwe={kernelName:aS,backendName:"cpu",kernelFunc:$we};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(s){const{inputs:e,backend:t}=s,{tensor:n,indices:i,updates:r}=e,{sliceRank:a,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=t0(r,i,n.shape),f=!1,d=t.bufferSync(i),g=t.bufferSync(r),x=t.bufferSync(n),S=cg(d,g,n.shape,c,l,o,a,u,x,f);return t.makeTensorInfo(n.shape,S.dtype,S.values)}const Hwe={kernelName:MB,backendName:"cpu",kernelFunc:Gwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{reps:r}=n;zt(i,"tile");const a=iX(t.bufferSync(i),r);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Wwe={kernelName:oS,backendName:"cpu",kernelFunc:Vwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xwe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{k:r,sorted:a}=n;zt(i,"topk");const o=t.data.get(i.dataId).values,[l,u]=aX(o,i.shape,i.dtype,r,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const qwe={kernelName:$B,backendName:"cpu",kernelFunc:Xwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(s){const{inputs:e,attrs:t,backend:n}=s,{image:i,transforms:r}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=t,[c,f,d,g]=i.shape,[x,S]=u??[f,d],b=[c,x,S,g],_=jt(i.shape),T=_[0],E=_[1],C=_[2],R=jt(b),I=R[0],L=R[1],P=R[2],D=Fr(i.dtype,Xe(b));D.fill(l);const O=n.data.get(i.dataId).values,F=n.data.get(r.dataId).values;for(let q=0;q<c;++q){const J=r.shape[0]===1?F:F.subarray(q*8,q*8+8);for(let Y=0;Y<x;++Y)for(let $=0;$<S;++$)for(let W=0;W<g;++W){let V;const se=J[6]*$+J[7]*Y+1;if(se===0)continue;const G=(J[0]*$+J[1]*Y+J[2])/se,ne=(J[3]*$+J[4]*Y+J[5])/se,oe=L$(G,d,o),ue=L$(ne,f,o);switch(a){case"nearest":V=e2e(O,f,d,T,E,C,q,ue,oe,W,l);break;case"bilinear":V=t2e(O,f,d,T,E,C,q,ue,oe,W,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const re=q*I+Y*L+$*P+W;D[re]=V}return n.makeTensorInfo(b,i.dtype,D)}return{dataId:n.write(D,b,i.dtype),shape:i.shape,dtype:i.dtype}}const Kwe={kernelName:zB,backendName:"cpu",kernelFunc:jwe};function L$(s,e,t){switch(t){case"reflect":return Ywe(s,e);case"wrap":return Jwe(s,e);case"nearest":return Qwe(s,e);case"constant":default:return Zwe(s)}}function Ywe(s,e){let t=s;if(t<0)if(e<=1)t=0;else{const n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{const n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return Rg(0,t,e-1)}function Jwe(s,e){let t=s;if(t<0)if(e<=1)t=0;else{const n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{const n=e-1;t-=e*Math.trunc(t/n)}return Rg(0,t,e-1)}function Zwe(s,e){return s}function Qwe(s,e){return Rg(0,s,e-1)}function K1(s,e,t,n,i,r,a,o,l,u,c){const f=a*n+o*i+l*r+u;return 0<=o&&o<e&&0<=l&&l<t?s[f]:c}function e2e(s,e,t,n,i,r,a,o,l,u,c){const f=Math.round(o),d=Math.round(l);return K1(s,e,t,n,i,r,a,f,d,u,c)}function t2e(s,e,t,n,i,r,a,o,l,u,c){const f=Math.floor(o),d=Math.floor(l),g=f+1,x=d+1,S=(x-l)*K1(s,e,t,n,i,r,a,f,d,u,c)+(l-d)*K1(s,e,t,n,i,r,a,f,x,u,c),b=(x-l)*K1(s,e,t,n,i,r,a,g,d,u,c)+(l-d)*K1(s,e,t,n,i,r,a,g,x,u,c);return(g-o)*S+(o-f)*b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2e(s){const{inputs:e,attrs:t,backend:n}=s,{axis:i}=t,{x:r}=e;zt(r,"unique");const a=n.data.get(r.dataId).values,{outputValues:o,outputShape:l,indices:u}=oX(a,i,r.shape,r.dtype);return[n.makeTensorInfo(l,r.dtype,o),n.makeTensorInfo([u.length],"int32",u)]}const s2e={kernelName:GB,backendName:"cpu",kernelFunc:n2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2e(s){const{inputs:e,backend:t,attrs:n}=s,{value:i}=e;let{axis:r}=n;r<0&&(r+=i.shape.length);const a=i.shape.length,o=i.shape[r],l=new Array(a-1);let u=0;for(let g=0;g<a;g++)g!==r&&(l[u++]=i.shape[g]);const c=new Array(a).fill(0),f=i.shape.slice();f[r]=1;const d=new Array(o);for(let g=0;g<d.length;g++){c[r]=g;const x=Hg({inputs:{x:i},backend:t,attrs:{begin:c,size:f}});d[g]=Us({inputs:{x},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(x)}return d}const r2e={kernelName:sM,backendName:"cpu",kernelFunc:i2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,segmentIds:r}=e,{numSegments:a}=n;zt(i,"unsortedSegmentSum");const o=i.shape.length,l=r.shape.length,u=[],c=[],f=o-l;let d=r;for(let x=0;x<f;++x){const S=hC({inputs:{input:d},backend:t,attrs:{dim:x+1}});d=S,c.push(S)}for(let x=0;x<a;++x){const S=_p(x,"int32"),b=t.makeTensorInfo([],"int32",S),_=SW({inputs:{a:b,b:d},backend:t}),T=mp({inputs:{x:_},backend:t,attrs:{dtype:"float32"}}),E=WM({inputs:{a:T,b:i},backend:t}),C=MS({inputs:{x:E},backend:t,attrs:{axis:0,keepDims:!1}});u.push(C),c.push(b),c.push(_),c.push(T),c.push(E),c.push(C)}const g=SX({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const o2e={kernelName:iM,backendName:"cpu",kernelFunc:a2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l2e=[n_e,L1e,i_e,a_e,G1e,l_e,c_e,f_e,p_e,g_e,x_e,b_e,S_e,w_e,E_e,R_e,D_e,B_e,L_e,e_e,P_e,$_e,G_e,V1e,V_e,$1e,X1e,X_e,F1e,j_e,Y_e,J_e,Q_e,tSe,sSe,rSe,oSe,uSe,hSe,dSe,mSe,ySe,vSe,_Se,SSe,TSe,CSe,MSe,NSe,RSe,ISe,OSe,LSe,qbe,PSe,q1e,XSe,j1e,qSe,Y1e,QSe,eAe,nAe,Z1e,ebe,iAe,aAe,lAe,cAe,nbe,ibe,P1e,fAe,K_e,pAe,gAe,xAe,jbe,abe,lbe,bAe,cbe,SAe,wAe,EAe,RAe,DAe,BAe,kAe,fbe,FAe,UAe,zAe,HAe,WAe,qAe,KAe,pbe,JAe,eTe,sTe,gbe,xbe,aTe,uTe,fTe,bbe,pTe,gTe,yTe,AX,_Te,Ybe,Abe,ATe,wTe,ETe,NTe,U1e,u3,ITe,Jbe,Zbe,Qbe,OTe,kTe,FTe,UTe,zTe,GTe,VTe,Ibe,XTe,JTe,QTe,swe,Obe,rwe,owe,uwe,Bbe,tTe,fwe,pwe,gwe,xwe,bwe,Swe,Twe,Cwe,Fbe,Ewe,Ube,zbe,Nwe,Iwe,Owe,kwe,Fwe,Wbe,BSe,Uwe,zwe,Hwe,Wwe,qwe,Kwe,_be,s2e,r2e,o2e,mTe];for(const s of l2e)m8(s);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tg={},fw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function u2e(s,e){tg[s]=e}function oc(s,e){if(!(s in tg)||e!=null){const n=h2e(s,e);if(n!==null)tg[s]=n;else return console.log("Could not get context for WebGL version",s),null}const t=tg[s];return t==null||t.isContextLost()?(delete tg[s],oc(s)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),tg[s])}function c2e(s){if(!Ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&s===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function h2e(s,e){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??c2e(s);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete tg[s]},!1),Ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(fw.failIfMajorPerformanceCaveat=!1),s===1?t.getContext("webgl",fw)||t.getContext("experimental-webgl",fw):t.getContext("webgl2",fw)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Hb;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(Hb||(Hb={}));var ml;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(ml||(ml={}));var Or;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Or||(Or={}));function NS(s,e){return[e,s]}function f2e(s,e){return s*e}function dw(s){const e=Xe(s),t=Math.ceil(e/4);return yD(t)}function Jx(s,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(s/2))]}function d2e(s,e){const[t,n]=Jx(s,e);return t*n*4}function LL(s,e){const t=s;let n,i,r,a,o,l,u,c,f,d;return Ie().getNumber("WEBGL_VERSION")===2?(n=t.R32F,i=t.R16F,r=t.RGBA16F,a=t.RGBA32F,o=t.RED,u=4,c=1,f=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(n=s.RGBA,i=s.RGBA,r=s.RGBA,a=t.RGBA,o=s.RGBA,u=4,c=4,f=e!=null?e.HALF_FLOAT_OES:null,d=s.FLOAT,l=s.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:f,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot(s,e){const t=e();return Ie().getBool("DEBUG")&&p2e(s),t}function p2e(s){const e=s.getError();if(e!==s.NO_ERROR)throw new Error("WebGL Error: "+x2e(s,e))}const m2e=596e-10,g2e=65504;function y2e(s){return!!(Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||m2e<Math.abs(s)&&Math.abs(s)<g2e)}function x2e(s,e){switch(e){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function pw(s,e){return Df(s,()=>s.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function v2e(s,e){const t=Df(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ot(s,()=>s.shaderSource(t,e)),Ot(s,()=>s.compileShader(t)),s.getShaderParameter(t,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function b2e(s,e){const t=Df(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ot(s,()=>s.shaderSource(t,e)),Ot(s,()=>s.compileShader(t)),Ie().get("ENGINE_COMPILE_ONLY"))return t;if(s.getShaderParameter(t,s.COMPILE_STATUS)===!1)throw TX(e,s.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const _2e=/ERROR: [0-9]+:([0-9]+):/g;function TX(s,e){const t=_2e.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(s);return}const n=+t[1],i=s.split(`
`),r=i.length.toString().length+2,a=i.map((f,d)=>jy((d+1).toString(),r)+f);let o=0;for(let f=0;f<a.length;f++)o=Math.max(a[f].length,o);const l=a.slice(0,n-1),u=a.slice(n-1,n),c=a.slice(n);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${jy(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function S2e(s){return Df(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function A2e(s,e){if(Ot(s,()=>s.linkProgram(e)),!Ie().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(e,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function _I(s,e){if(Ot(s,()=>s.validateProgram(e)),s.getProgramParameter(e,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function T2e(s,e){const t=Df(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return Ot(s,()=>s.bindBuffer(s.ARRAY_BUFFER,t)),Ot(s,()=>s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW)),t}function w2e(s,e){const t=Df(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return Ot(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t)),Ot(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,e,s.STATIC_DRAW)),t}function C2e(s){return Df(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function E2e(s,e){const t=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||e<=0){const n=`[${s}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(s>t||e>t){const n=`[${s}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+i+".")}}function M2e(s){return Df(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function F$(s,e,t,n,i,r,a){const o=s.getAttribLocation(e,t);return o===-1?!1:(Ot(s,()=>s.bindBuffer(s.ARRAY_BUFFER,n)),Ot(s,()=>s.vertexAttribPointer(o,i,s.FLOAT,!1,r,a)),Ot(s,()=>s.enableVertexAttribArray(o)),!0)}function N2e(s,e,t){B2e(s,t),Ot(s,()=>s.activeTexture(s.TEXTURE0+t)),Ot(s,()=>s.bindTexture(s.TEXTURE_2D,e))}function R2e(s,e,t){return Df(s,()=>s.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function I2e(s,e,t){return s.getUniformLocation(e,t)}function D2e(s,e,t,n){Ot(s,()=>N2e(s,e,n)),Ot(s,()=>s.uniform1i(t,n))}function SI(s,e,t){Ot(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,t)),Ot(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0))}function P$(s,e){Ot(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,e)),Ot(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function mw(s){const e=s.checkFramebufferStatus(s.FRAMEBUFFER);if(e!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+O2e(s,e))}function O2e(s,e){switch(e){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Df(s,e,t){const n=Ot(s,()=>e());if(n==null)throw new Error(t);return n}function B2e(s,e){const t=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+s.TEXTURE0;if(n<s.TEXTURE0||n>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Rx(s,e=2){return Xe(s.slice(0,s.length-e))}function Ix(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function gw(s){let e=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(e=[Rx(s),...Ix(s)]),e}function k2e(s,e=!1){let t=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=Ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&Ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=t/2),e&&(t=t*2,n=n*2,s=s.map((o,l)=>l>=s.length-2?FO(s[l]):s[l]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=bp(s).newShape);let i=Xe(s),r=null;s.length<=1&&i<=t?r=[1,i]:s.length===2&&s[0]<=t&&s[1]<=t?r=s:s.length===3&&s[0]*s[1]<=t&&s[2]<=t?r=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=t&&s[1]*s[2]<=t?r=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=t&&s[3]<=t?r=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=t&&s[1]*s[2]*s[3]<=t&&(r=[s[0],s[1]*s[2]*s[3]]);const a=r!=null&&Math.max(...r)>n&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||a)if(e){const o=Rx(s);let l=2,u=2;s.length&&([l,u]=Ix(s)),i=o*(l/2)*(u/2),r=yD(i).map(c=>c*2)}else r=yD(i);return r}function yw(s){return s%2===0}function dC(s,e){if(s=s.slice(-2),e=e.slice(-2),Wn(s,e)||!s.length||!e.length||s[0]===0||s[1]===0||e[0]===0||e[1]===0)return!0;if(s.length!==e.length){const t=s[s.length-1],n=e[e.length-1];if(t===n||yw(t)&&yw(n)&&(s[0]===1||e[0]===1))return!0}return s[1]===e[1]&&yw(s[0])&&yw(e[0])}let AI,TI;function L2e(s){if(AI==null){const e=oc(s);AI=e.getParameter(e.MAX_TEXTURE_SIZE)}return AI}function F2e(s){if(TI==null){const e=oc(s);TI=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,TI)}function P2e(s){if(s===0)return 0;let e;const t=oc(s);return ru(t,"EXT_disjoint_timer_query_webgl2")&&s===2?e=2:ru(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ru(s,e){return s.getExtension(e)!=null}function U$(s){try{if(oc(s)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function U2e(s){if(s===0)return!1;const e=oc(s);if(s===1){if(!ru(e,"OES_texture_float"))return!1}else if(!ru(e,"EXT_color_buffer_float"))return!1;return h3(e)}function $2e(s){if(s===0)return!1;const e=oc(s);if(s===1){if(!ru(e,"OES_texture_float")||!ru(e,"WEBGL_color_buffer_float"))return!1}else{if(ru(e,"EXT_color_buffer_float"))return h3(e);const n="EXT_color_buffer_half_float";if(ru(e,n)){const i=e.getExtension(n);return z2e(e,i)}return!1}return h3(e)}function h3(s){const e=LL(s),t=s.createTexture();s.bindTexture(s.TEXTURE_2D,t),s.texImage2D(s.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,r),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0);const a=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(t),s.deleteFramebuffer(r),a}function z2e(s,e){const t=LL(s,e),n=s.createTexture();s.bindTexture(s.TEXTURE_2D,n),s.texImage2D(s.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,a),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,n,0);const o=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(n),s.deleteFramebuffer(a),o}function G2e(s){return s!==2?!1:oc(s).fenceSync!=null}function RS(s,e){Array.isArray(s)||(s=[s]),s.forEach(t=>{t!=null&&K(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ht=Ie();Ht.registerFlag("HAS_WEBGL",()=>Ht.getNumber("WEBGL_VERSION")>0);Ht.registerFlag("WEBGL_VERSION",()=>U$(2)?2:U$(1)?1:0);Ht.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ht.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ht.get("WEBGL_VERSION")===2);Ht.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ht.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ht.registerFlag("WEBGL_PACK",()=>Ht.getBool("HAS_WEBGL"));Ht.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_CLIP",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_REDUCE",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_CONV_IM2COL",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ht.getBool("WEBGL_PACK"));Ht.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>L2e(Ht.getNumber("WEBGL_VERSION")));Ht.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>F2e(Ht.getNumber("WEBGL_VERSION")));Ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=Ht.getNumber("WEBGL_VERSION");return s===0?0:P2e(s)});Ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ht.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!M8());Ht.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>U2e(Ht.getNumber("WEBGL_VERSION")));Ht.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ht.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ht.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ht.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>$2e(Ht.getNumber("WEBGL_VERSION")));Ht.registerFlag("WEBGL_FENCE_API_ENABLED",()=>G2e(Ht.getNumber("WEBGL_VERSION")));Ht.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ht.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ht.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(typeof s!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${s}.`);if(s<0&&s!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${s}.`)});Ht.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>M8()?1:-1,s=>{if(typeof s!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${s}.`);if(s<0&&s!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${s}.`)});Ht.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ht.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ht.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ht.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ht.registerFlag("WEBGL_EXP_CONV",()=>!1);Ht.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ht.getBool("IS_TEST"));Ht.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ht.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ht.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ht.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(){let s,e,t,n,i,r,a,o,l,u;return Ie().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",e="in",t="out",n="in",i="texture",r="outputColor",a="out vec4 outputColor;",o=Ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",e="attribute",t="varying",n="varying",i="texture2D",r="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:e,varyingVs:t,varyingFs:n,texture2D:i,output:r,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0(s,e,t="index"){const n=jt(e);return n.map((i,r)=>{const a=`int ${s[r]} = ${t} / ${i}`,o=r===n.length-1?`int ${s[r+1]} = ${t} - ${s[r]} * ${i}`:`index -= ${s[r]} * ${i}`;return`${a}; ${o};`}).join("")}function XM(s,e,t="index"){const n=jt(e);return n.map((i,r)=>{const a=`int ${s[r]} = ${t} / outShapeStrides[${r}]`,o=r===n.length-1?`int ${s[r+1]} = ${t} - ${s[r]} * outShapeStrides[${r}]`:`index -= ${s[r]} * outShapeStrides[${r}]`;return`${a}; ${o};`}).join("")}function H2e(s,e){const t=s.length,n=s.map(r=>`${e}[${r}]`),i=new Array(t-1);i[t-2]=n[t-1];for(let r=t-3;r>=0;--r)i[r]=`(${i[r+1]} * ${n[r+1]})`;return i}function V2e(s,e,t="index"){const n=s.map((r,a)=>a),i=H2e(n,e);return i.map((r,a)=>{const o=`int ${s[a]} = ${t} / ${i[a]}`,l=a===i.length-1?`int ${s[a+1]} = ${t} - ${s[a]} * ${i[a]}`:`index -= ${s[a]} * ${i[a]}`;return`${o}; ${l};`}).join("")}function FL(s){const e=jt(s).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function PL(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const wX=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:CX}=oge;function W2e(s,e,t){const n=[];if(s.forEach(g=>{const x=Xe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?n.push(`uniform float ${g.name}${x>1?`[${x}]`:""};`):(n.push(`uniform sampler2D ${g.name};`),n.push(`uniform int offset${g.name};`)),t.enableShapeUniforms){const{uniformShape:S}=UL(t.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(S.length){case 1:n.push(`uniform int ${g.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${g.name}Shape;`);break}n.push(`uniform ivec2 ${g.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(g=>{n.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const i=n.join(`
`),r=s.map(g=>X2e(g,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=Oa(),l=K2e(o);let u,c,f=Z2e(o);return e.isPacked?(u=q2e(e.logicalShape,a,t.enableShapeUniforms),c=J2e(o)):(u=j2e(e.logicalShape,a,t.enableShapeUniforms),c=Y2e(o)),t.packedInputs&&(f+=nCe),[f,l,c,i,u,r,t.userCode].join(`
`)}function Zx(s,e=!1){const t=s.shapeInfo.logicalShape;switch(t.length){case 0:return pCe(s,e);case 1:return gCe(s,e);case 2:return xCe(s,e);case 3:return bCe(s,e);case 4:return SCe(s,e);case 5:return ACe(s);case 6:return TCe(s);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function EX(s,e){switch(s.shapeInfo.logicalShape.length){case 0:return dCe(s);case 1:return mCe(s,e);case 2:return yCe(s,e);case 3:return vCe(s,e);default:return _Ce(s,e)}}function X2e(s,e,t=!1,n){let i="";t?i+=EX(s,n):i+=Zx(s,n);const r=s.shapeInfo.logicalShape,a=e.logicalShape;return r.length<=a.length&&(t?i+=wCe(s,e):i+=CCe(s,e)),i}function q2e(s,e,t){switch(s.length){case 0:return MX();case 1:return sCe(s,e,t);case 2:return hCe(s,e,t);case 3:return rCe(s,e,t);default:return oCe(s,e,t)}}function j2e(s,e,t){switch(s.length){case 0:return MX();case 1:return iCe(s,e,t);case 2:return fCe(s,e,t);case 3:return aCe(s,e,t);case 4:return lCe(s,e,t);case 5:return uCe(s,e);case 6:return cCe(s,e);default:throw new Error(`${s.length}-D output sampling is not yet supported`)}}function K2e(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${s.texture2D}(textureSampler, uv).r;
    }
  `}function Y2e(s){return`
    void setOutput(float val) {
      ${s.output} = vec4(val, 0, 0, 0);
    }
  `}function J2e(s){return`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `}function Z2e(s){return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFs} vec2 resultUV;
    ${s.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${s.defineSpecialNaN}
    ${s.defineSpecialInf}
    ${s.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Q2e}
    ${eCe}
    ${tCe}
  `}const Q2e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,eCe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,tCe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nCe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function MX(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function sCe(s,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function iCe(s,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function rCe(s,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(s[2]/2),r=i*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function aCe(s,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${XM(["r","c","d"],s)}
    return ivec3(r, c, d);
  }
`;const n=i0(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function oCe(s,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(s[s.length-1]/2),r=i*Math.ceil(s[s.length-2]/2);let a=r,o="",l="b, r, c";for(let u=2;u<s.length-1;u++)a*=s[s.length-u-1],o=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+o,l=`b${u}, `+l;return`
    ivec${s.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${o}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${s.length}(${l});
    }
  `}function lCe(s,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${XM(["r","c","d","d2"],s)}
      return ivec4(r, c, d, d2);
    }
  `;const n=i0(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function uCe(s,e){const t=i0(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function cCe(s,e){const t=i0(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function hCe(s,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Wn(s,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;const i=Math.ceil(s[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function fCe(s,e,t){return Wn(s,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:s[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `}function r0(s){return`offset${s}`}function dCe(s){const e=s.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Oa();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function pCe(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(s.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[i,r]=s.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=r0(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=s.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function mCe(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=s.shapeInfo.texShape,r=Oa();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${r.texture2D}(${t}, uv);
    }
  `}function gCe(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(s.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Qx(s)}
      }
    `;const i=s.shapeInfo.texShape,r=i[0],a=i[1];if(a===1&&r===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=r0(t);return a===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${r}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function yCe(s,e){const t=s.shapeInfo.logicalShape,n=s.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=s.shapeInfo.texShape,a=r[0],o=r[1],l=Oa();if(r!=null&&Wn(t,r))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${l.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `;const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `}function xCe(s,e){const t=s.shapeInfo.logicalShape,n=s.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=s.shapeInfo.texShape;if(r!=null&&Wn(t,r)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;const d=r[0],g=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${d}.0);
      return sampleTexture(${n}, uv);
    }
  `}const{newShape:a,keptDims:o}=bp(t),l=a;if(l.length<t.length){const d=ev(s,l),g=["row","col"];return`
      ${Zx(d,e)}
      float ${i}(int row, int col) {
        return ${i}(${tv(g,o)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Qx(s)}
      }
    `;const u=r[0],c=r[1],f=r0(n);return c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${n}, uv);
    }
  `:u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function vCe(s,e){const t=s.shapeInfo.logicalShape,n=s.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=s.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const d=t.slice(1),g=[1,2],x=ev(s,d),S=["b","row","col"];return`
        ${EX(x,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${tv(S,g)});
        }
      `}const o=Oa();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${n}, uv);
    }
  `;const l=a[0],u=a[1],c=Math.ceil(t[2]/2),f=c*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${f}, ${c}, b, row, col);
      return ${o.texture2D}(${n}, uv);
    }
  `}function bCe(s,e){const t=s.shapeInfo.logicalShape,n=s.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[1]*t[2],a=t[2],{newShape:o,keptDims:l}=bp(t),u=o;if(u.length<t.length){const S=ev(s,u),b=["row","col","depth"];return`
        ${Zx(S,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${tv(b,l)});
        }
      `}if(s.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${a}, 1)));
        ${Qx(s)}
      }
    `;const c=s.shapeInfo.texShape,f=c[0],d=c[1],g=s.shapeInfo.flatOffset;if(d===r&&g==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${f}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(d===a&&g==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${n}, uv);
    }
  `;const x=r0(n);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${a} + depth + ${x};
        vec2 uv = uvFromFlat(${f}, ${d}, index);
        return sampleTexture(${n}, uv);
      }
  `}function _Ce(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Oa();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const r=s.shapeInfo.logicalShape,a=r.length,o=s.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],f=Math.ceil(r[a-1]/2);let d=f*Math.ceil(r[a-2]/2),g="int b, int row, int col",x=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let S=2;S<a-1;S++)g=`int b${S}, `+g,d*=r[a-S-1],x=`b${S} * ${d} + `+x;return`
    vec4 ${n}(${g}) {
      int index = ${x};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${i.texture2D}(${t}, uv);
    }
  `}function SCe(s,e){const t=s.shapeInfo.logicalShape,n=s.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[3],a=t[2]*r,o=t[1]*a,{newShape:l,keptDims:u}=bp(t);if(l.length<t.length){const T=ev(s,l),E=["row","col","depth","depth2"];return`
      ${Zx(T,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${tv(E,u)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${r}, 1)));
        ${Qx(s)}
      }
    `;const c=s.shapeInfo.flatOffset,f=s.shapeInfo.texShape,d=f[0],g=f[1],x=`int stride2 = ${n}Shape[3];`,S=`int stride1 = ${n}Shape[2] * stride2;`,b=`int stride0 = ${n}Shape[1] * stride1;`;if(g===o&&c==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${x}
        ${S}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===r&&c==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const _=r0(n);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${S}
      ${b}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${_});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${d}, ${g}, index + ${_});
      return sampleTexture(${n}, uv);
    }
  `}function ACe(s){const e=s.shapeInfo.logicalShape,t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,a=e[2]*r,o=e[1]*a,{newShape:l,keptDims:u}=bp(e);if(l.length<e.length){const S=ev(s,l),b=["row","col","depth","depth2","depth3"];return`
      ${Zx(S)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${tv(b,u)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${r}, ${i})) +
          depth3;
        ${Qx(s)}
      }
    `;const c=s.shapeInfo.flatOffset,f=s.shapeInfo.texShape,d=f[0],g=f[1];if(g===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===i&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=r0(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${r} +
          depth2 * ${i} + depth3 + ${x};
      vec2 uv = uvFromFlat(${d}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function TCe(s){const e=s.shapeInfo.logicalShape,t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=bp(e);if(i.length<e.length){const b=ev(s,i),_=["row","col","depth","depth2","depth3","depth4"];return`
      ${Zx(b)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${tv(_,r)});
      }
    `}const a=e[5],o=e[4]*a,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Qx(s)}
      }
    `;const f=s.shapeInfo.flatOffset,d=s.shapeInfo.texShape,g=d[0],x=d[1];if(x===c&&f==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(x===a&&f==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;const S=r0(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${S};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Qx(s){const e=s.name,t=Xe(s.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function wCe(s,e){const t=s.name,n=t.charAt(0).toUpperCase()+t.slice(1),i="get"+n+"AtOutCoords",r=s.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=CX(s.shapeInfo.logicalShape,e.logicalShape),l=Es(a),u=a-r;let c;const f=["x","y","z","w","u","v"];r===0?c="":a<2&&o.length>=1?c="coords = 0;":c=o.map(T=>`coords.${f[T+u]} = 0;`).join(`
`);let d="";a<2&&r>0?d="coords":d=s.shapeInfo.logicalShape.map((T,E)=>`coords.${f[E+u]}`).join(", ");let g="return outputValue;";const S=Xe(s.shapeInfo.logicalShape)===1,_=Xe(e.logicalShape)===1;if(r===1&&!S&&!_)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(S&&!_)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const T=r-2,E=r-1;o.indexOf(T)>-1&&o.indexOf(E)>-1?g="return vec4(outputValue.x);":o.indexOf(T)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(E)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${d});
      ${g}
    }
  `}function CCe(s,e){const t=s.name,n=t.charAt(0).toUpperCase()+t.slice(1),i="get"+n+"AtOutCoords",r=e.texShape,a=s.shapeInfo.texShape,o=s.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!s.shapeInfo.isUniform&&o===l&&s.shapeInfo.flatOffset==null&&Wn(a,r))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=Es(l),c=CX(s.shapeInfo.logicalShape,e.logicalShape),f=l-o;let d;const g=["x","y","z","w","u","v"];o===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(S=>`coords.${g[S+f]} = 0;`).join(`
`);let x="";return l<2&&o>0?x="coords":x=s.shapeInfo.logicalShape.map((S,b)=>`coords.${g[b+f]}`).join(", "),`
    float ${i}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${n}(${x});
    }
  `}function Es(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error(`GPU for rank ${s} is not yet supported`)}function UL(s,e,t){const{newShape:n,keptDims:i}=bp(e),r=e.length,a=s&&r===3&&e[0]===1,o=a?e.slice(1):n,l=!s&&r>1&&!Wn(e,t)&&n.length<r||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:i}}function ev(s,e){const t=JSON.parse(JSON.stringify(s));return t.shapeInfo.logicalShape=e,t}function tv(s,e){return e.map(t=>s[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(s,e,t,n){const i=t.map((c,f)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:d}}),r=i.map(c=>c.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},o=W2e(i,a,e),l=b2e(s.gl,o),u=s.createProgram(l);return Ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:r,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(s.buildVao(u),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:r,outShapeInfo:a},NX(s,e,u)))}function NX(s,e,t){const n=[],i=[];let r,a,o,l=null,u=null;u=s.getUniformLocation(t,"NAN",!1),Ie().getNumber("WEBGL_VERSION")===1&&(l=s.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const f of e.variableNames){const d={name:f,uniform:s.getUniformLocation(t,f,c),offset:s.getUniformLocation(t,`offset${f}`,c)};e.enableShapeUniforms&&(d.shape=s.getUniformLocation(t,`${f}Shape`,c),d.texShape=s.getUniformLocation(t,`${f}TexShape`,c)),n.push(d)}if(e.enableShapeUniforms&&(r=s.getUniformLocation(t,"outShape",c),o=s.getUniformLocation(t,"outShapeStrides",c),a=s.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const f of e.customUniforms)i.push(s.getUniformLocation(t,f.name,c));return{variablesLocations:n,customUniformLocations:i,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:o,outTexShapeLocation:a}}function $$(s,e){if(s.length!==e.length)throw Error(`Binary was compiled with ${s.length} inputs, but was executed with ${e.length} inputs`);s.forEach((t,n)=>{const i=t.logicalShape,r=e[n],a=r.shape;if(!Wn(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(t.isUniform&&r.isUniform)return;const o=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!Wn(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function MCe(s,e,t,n,i){e.program.enableShapeUniforms||($$(e.inShapeInfos,t),$$([e.outShapeInfo],[n]));const r=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?s.setOutputPackedMatrixTexture(r.texture,a[0],a[1]):s.setOutputMatrixTexture(r.texture,a[0],a[1]),s.setProgram(e.webGLProgram),s.bindVertexArray(e.webGLProgram.vao),Ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&s.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&s.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:f,shape:d,texShape:g}=e.variablesLocations[l];if(d){const{uniformShape:x}=UL(e.program.packedInputs,u.shape,u.texData.texShape);switch(x.length){case 1:s.gl.uniform1iv(d,new Int32Array(x));break;case 2:s.gl.uniform2iv(d,new Int32Array(x));break;case 3:s.gl.uniform3iv(d,new Int32Array(x));break;case 4:s.gl.uniform4iv(d,new Int32Array(x));break}}if(g&&s.gl.uniform2i(g,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Xe(u.shape)<2)s.gl.uniform1f(c,u.uniformValues[0]);else{let x=u.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),s.gl.uniform1fv(c,x)}continue}u.texData.slice!=null&&f!=null&&s.gl.uniform1i(f,u.texData.slice.flatOffset),s.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=e.outShapeLocation;if(o)switch(n.shape.length){case 1:s.gl.uniform1iv(o,new Int32Array(n.shape));break;case 2:s.gl.uniform2iv(o,new Int32Array(n.shape));break;case 3:s.gl.uniform3iv(o,new Int32Array(n.shape));break;case 4:s.gl.uniform4iv(o,new Int32Array(n.shape));break}if(e.outShapeStridesLocation){const l=jt(n.shape);switch(n.shape.length){case 2:s.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:s.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:s.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&s.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],f=i[l];if(u.type==="float")s.gl.uniform1fv(c,f);else if(u.type==="vec2")s.gl.uniform2fv(c,f);else if(u.type==="vec3")s.gl.uniform3fv(c,f);else if(u.type==="vec4")s.gl.uniform4fv(c,f);else if(u.type==="int")s.gl.uniform1iv(c,f);else if(u.type==="ivec2")s.gl.uniform2iv(c,f);else if(u.type==="ivec3")s.gl.uniform3iv(c,f);else if(u.type==="ivec4")s.gl.uniform4iv(c,f);else throw Error(`uniform type ${u.type} is not supported yet.`)}s.executeProgram()}function NCe(s,e,t){let n="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:f}=UL(s.packedInputs,a.shape,l);let d="",g="",x="";if(c.length===1&&s.packedInputs){const R=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${R[0]>1}_${R[1]>1}`}else if(c.length===2&&!s.packedInputs)g=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!s.packedInputs){const R=jt(c);x=`${R[0]===l[1]}_${R[R.length-1]===l[1]}`}const S=a.shape.length,b=c.length===2&&Wn(a.shape,l),_=Xe(a.shape)===1,T=Ax(a.shape,t.shape),E=!s.packedInputs&&S===t.shape.length&&Wn(l,t.texData.texShape),C=s.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;n+=`${S}_${E}_${u?f:""}_${c.length}_${_}_${T}_${b}_${d}_${g}_${x}_${C}_${o}`}else{const l=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${l}_${o}`}});const i=s.userCode;let r=s.constructor.name;return r+="_"+n+"_"+i+`${Ie().getNumber("WEBGL_VERSION")}`,r}function ra(s){return Ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RCe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Hb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Oa();this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?XM(["r","c","d"],e):i0(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ICe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Hb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Oa();this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?XM(["r","c","d"],e):i0(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DCe{constructor(e){this.variableNames=["A"],this.outTexUsage=ml.DOWNLOAD;const t=Oa();this.outputShape=e,this.userCode=`
      ${wX}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OCe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ml.DOWNLOAD;const t=Oa();this.outputShape=e,this.userCode=`
      ${wX}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BCe={R:0,G:1,B:2,A:3};class z${constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Oa();this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let a="";for(let o=0;o<n.length;o++){const l=n[o];a+=`
          if(offset == ${o}) {
            result = values[${BCe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?PL():FL(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${a}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kCe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Oa();this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=a*2+o;i+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?PL():FL(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${n.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LCe(s){const e=Oa(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return v2e(s,t)}function FCe(s){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return T2e(s,e)}function PCe(s){const e=new Uint16Array([0,1,2,2,1,3]);return w2e(s,e)}function IS(s,e,t,n,i,r){E2e(e,t);const a=C2e(s),o=s.TEXTURE_2D;return Ot(s,()=>s.bindTexture(o,a)),Ot(s,()=>s.texParameteri(o,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),Ot(s,()=>s.texParameteri(o,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),Ot(s,()=>s.texParameteri(o,s.TEXTURE_MIN_FILTER,s.NEAREST)),Ot(s,()=>s.texParameteri(o,s.TEXTURE_MAG_FILTER,s.NEAREST)),Ie().getNumber("WEBGL_VERSION")===1?Ot(s,()=>s.texImage2D(o,0,n,e,t,0,i,r,null)):Ot(s,()=>s.texStorage2D(o,1,n,e,t)),Ot(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function RX(s){return s.internalFormatFloat}function UCe(s,e,t,n){const[i,r]=NS(e,t);return IS(s,i,r,RX(n),n.textureFormatFloat,s.FLOAT)}function IX(s){return s.internalFormatHalfFloat}function $Ce(s,e,t,n){const[i,r]=NS(e,t);return IS(s,i,r,IX(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function DX(s){return s.downloadTextureFormat}function zCe(s,e,t,n){const[i,r]=NS(e,t);return IS(s,i,r,DX(n),s.RGBA,s.UNSIGNED_BYTE)}function OX(s){return s.internalFormatPackedFloat}function GCe(s,e,t,n){const[i,r]=Jx(e,t);return IS(s,i,r,OX(n),s.RGBA,s.FLOAT)}function BX(s){return s.internalFormatPackedHalfFloat}function HCe(s,e,t,n){const[i,r]=Jx(e,t);return IS(s,i,r,BX(n),s.RGBA,n.textureTypeHalfFloat)}function VCe(s,e,t){return Ot(s,()=>s.bindBuffer(s.ARRAY_BUFFER,t)),F$(s,e,"clipSpacePos",t,3,20,0)&&F$(s,e,"uv",t,2,20,12)}function WCe(s,e,t,n,i,r){Ot(s,()=>s.bindTexture(s.TEXTURE_2D,e));let a,o,l;i instanceof Uint8Array?(a=new Uint8Array(t*n*4),o=s.UNSIGNED_BYTE,l=s.RGBA):(a=new Float32Array(t*n*4),o=s.FLOAT,l=r.internalFormatPackedFloat),a.set(i),Ie().getNumber("WEBGL_VERSION")===2?Ot(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,t,n,s.RGBA,o,a)):Ot(s,()=>s.texImage2D(s.TEXTURE_2D,0,l,t,n,0,s.RGBA,o,a)),Ot(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function XCe(s,e,t){Ot(s,()=>s.bindTexture(s.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ie().getNumber("WEBGL_VERSION")===2?Ot(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,t.width,t.height,s.RGBA,s.UNSIGNED_BYTE,t.data)):Ot(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,t.width,t.height,0,s.RGBA,s.UNSIGNED_BYTE,t.data)):Ie().getNumber("WEBGL_VERSION")===2?Ot(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,t)):Ot(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,t)),Ot(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function qCe(s,e,t,n){const i=s.createBuffer();Ot(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,i));const o=4*4*e*t;return Ot(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,o,s.STREAM_READ)),Ot(s,()=>s.readPixels(0,0,t,e,s.RGBA,s.FLOAT,0)),Ot(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),i}function jCe(s,e,t){const n=s,i=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,i),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),i}function KCe(s,e,t,n){const[i,r]=NS(e,t),a=4,o=new Uint8Array(f2e(e*t,a));return Ot(s,()=>s.readPixels(0,0,i,r,n.downloadTextureFormat,s.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function YCe(s,e,t,n,i,r,a,o){const l=s,u=new Float32Array(d2e(r,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function JCe(s,e,t){const n=new Float32Array(e*t*4);return Ot(s,()=>s.readPixels(0,0,t,e,s.RGBA,s.FLOAT,n)),n}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wI{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,u2e(t,e)):this.gl=oc(t),e=this.gl,Ie().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>Ot(r,()=>r.createVertexArray()),this.bindVertexArray=a=>Ot(r,()=>r.bindVertexArray(a)),this.deleteVertexArray=a=>Ot(r,()=>r.deleteVertexArray(a)),this.getVertexArray=()=>Ot(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ot(e,()=>r.createVertexArrayOES()),this.bindVertexArray=a=>Ot(e,()=>r.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ot(e,()=>r.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ot(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ie().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=pw(this.gl,r),ru(this.gl,a))this.textureHalfFloatExtension=pw(this.gl,a);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ru(this.gl,i))this.colorBufferHalfFloatExtension=pw(this.gl,i);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ru(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(ru(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=FCe(this.gl),this.indexBuffer=PCe(this.gl),this.framebuffer=M2e(this.gl),this.textureConfig=LL(this.gl,this.textureHalfFloatExtension)}get debug(){return Ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ot(e,()=>e.finish()),Ot(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ot(e,()=>e.deleteFramebuffer(this.framebuffer)),Ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ot(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ot(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),UCe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),$Ce(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),zCe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),XCe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,i){this.throwIfDisposed(),WCe(this.gl,e,t,n,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),HCe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),GCe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(P$(this.gl,this.framebuffer),this.outputTexture=null),Ot(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>KCe(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,i,r,a){return YCe(this.gl,e,t,n,i,r,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return jCe(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const i=qCe(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Ie().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const a=i.clientWaitSync(r,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},t=r}else Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>JCe(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=LCe(t));const n=S2e(t);Ot(t,()=>t.attachShader(n,this.vertexShader)),Ot(t,()=>t.attachShader(n,e)),A2e(t,n);const i=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&_I(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ot(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),VCe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ot(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&_I(this.gl,this.program),Ot(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?R2e(this.gl,e,t):I2e(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ot(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),D2e(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[i,r]=Jx(t,n);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,n,i){this.setOutputMatrixWriteRegionDriver(n,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,n,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&_I(this.gl,this.program),mw(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ot(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ot(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=pw(this.gl,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await xU(()=>this.disposed||this.isQueryAvailable(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{const n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const n=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1(),i=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=ZCe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ie().platform&&(n=Ie().platform.setTimeoutCustom.bind(Ie().platform)),xU(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),SI(this.gl,e,this.framebuffer),this.debug&&mw(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(SI(this.gl,this.outputTexture,this.framebuffer),this.debug&&mw(this.gl)):P$(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const i=this.gl;SI(i,e,this.framebuffer),this.debug&&mw(i),this.outputTexture=e,Ot(i,()=>i.viewport(0,0,t,n)),Ot(i,()=>i.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,i){this.throwIfDisposed(),Ot(this.gl,()=>this.gl.scissor(e,t,n,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function ZCe(s){let e=0;for(;e<s.length&&s[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:QCe,bincountImpl:kX,bincountReduceImpl:eEe,bitwiseAndImpl:tEe,castImpl:nEe,ceilImpl:sEe,concatImpl:iEe,equalImpl:rEe,expImpl:aEe,expm1Impl:oEe,floorImpl:lEe,gatherNdImpl:uEe,gatherV2Impl:cEe,greaterImpl:hEe,greaterEqualImpl:fEe,lessImpl:dEe,lessEqualImpl:pEe,linSpaceImpl:mEe,logImpl:gEe,maxImpl:yEe,maximumImpl:xEe,minimumImpl:vEe,multiplyImpl:bEe,negImpl:_Ee,notEqualImpl:SEe,prodImpl:AEe,raggedGatherImpl:TEe,raggedRangeImpl:wEe,raggedTensorToTensorImpl:CEe,rangeImpl:EEe,rsqrtImpl:MEe,scatterImpl:NEe,sigmoidImpl:REe,simpleAbsImpl:LX,sliceImpl:IEe,sparseFillEmptyRowsImpl:DEe,sparseReshapeImpl:OEe,sparseSegmentReductionImpl:FX,sqrtImpl:BEe,staticRegexReplaceImpl:kEe,stridedSliceImpl:LEe,stringNGramsImpl:FEe,stringSplitImpl:PEe,stringToHashBucketFastImpl:UEe,subImpl:$Ee,tileImpl:zEe,topKImpl:GEe,transposeImpl:$L,uniqueImpl:HEe}=Xbe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(s,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${s}.${t}`)}function Ta(s,e){return e===1?[s]:PX(s,e)}function VEe(s,e){if(s===1)return"rc";let t="";for(let n=0;n<s;n++)t+=e[n],n<s-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WEe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ra(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Ta("rc",this.rank),n=Es(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let i=0;i<=1;i++){let r=`${n===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)r=`${e[e.length-1-a]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UX{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length);let n="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),n+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${XEe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?PL():FL(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}}function XEe(s,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?V2e(["r","c","d"],"inputShape"):i0(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qEe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const i=H$(t,n),r=V$(e,i,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=G$(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[r].pop();return this.usedTextures[r].push(l),l}let o;return i===Or.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Or.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Or.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Or.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Or.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,n,i){if(this.freeTextures==null)return;const r=H$(n,i),a=V$(t,r,i);a in this.freeTextures||(this.freeTextures[a]=[]);const o=G$(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[a],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function jEe(s,e){const t=s;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===s.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function G$(s,e,t,n,i){const r=KEe(e,n);let a;if(i){const[l,u]=Jx(s[0],s[1]);a=l*u}else{const[l,u]=NS(s[0],s[1]);a=l*u}const o=jEe(t,r);return a*o}function KEe(s,e){switch(s){case Or.PACKED_2X2_FLOAT32:return OX(e);case Or.PACKED_2X2_FLOAT16:return BX(e);case Or.UNPACKED_FLOAT32:return RX(e);case Or.UNPACKED_FLOAT16:return IX(e);case Or.PACKED_4X1_UNSIGNED_BYTE:return DX(e);default:throw new Error(`Unknown physical texture type ${s}`)}}function YEe(s){return Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?Or.PACKED_2X2_FLOAT32:Or.UNPACKED_FLOAT32:s?Or.PACKED_2X2_FLOAT16:Or.UNPACKED_FLOAT16}function H$(s,e){if(s===ml.UPLOAD)return Or.PACKED_2X2_FLOAT32;if(s===ml.RENDER||s==null)return YEe(e);if(s===ml.DOWNLOAD||s===ml.PIXELS)return Or.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${s}`)}function V$(s,e,t){return`${s[0]}_${s[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eh{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const gu="if (isnan(x)) return x;",JEe="return x;",W$="return abs(x);",ZEe="return (x >= 0.0) ? x : (exp(x) - 1.0);",QEe=gu+`
  return (x < 0.0) ? 0.0 : x;
`,eMe=gu+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,kd="return x;",tMe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nMe="return x;",sMe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,iMe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rMe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,aMe="return 1.0 / (1.0 + exp(-1.0 * x));";class Vd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length);const t=e.length,n=Ta("rc",t),i=Es(t),r=VEe(t,n),a=n.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lMe=Ak,uMe=1e-7,cMe=1e-4,xw={};function hMe(s){return s in xw||(xw[s]={}),xw[s]}const fMe=Ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),dMe=600;function pMe(){return Ie().global.screen==null?1024:Ie().global.screen.height*Ie().global.screen.width*window.devicePixelRatio*dMe/1024/1024}class qM extends LO{nextDataId(){return qM.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof wI)t=e;else{const n=oc(Ie().getNumber("WEBGL_VERSION"),e);t=new wI(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const n=oc(Ie().getNumber("WEBGL_VERSION"));t=new wI(n),this.binaryCache=hMe(Ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new qEe(this.gpgpu),this.numMBBeforeWarning=pMe(),this.texData=new l8(this,qc())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,i,r,a){const o=this.makeTensorInfo(t,n),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const u=gw(t),c=new z$(u,!1,a),f=this.runWebGLProgram(c,[o],n,[[i,r]]);return f.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(e,t,n){if((Ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:n,values:e,usage:ml.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,i,r){if(Ie().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:i,values:t,usage:ml.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:i,complexTensorInfos:r,slice:a,shape:o,isPacked:l}=t;if(a!=null){let d;l?d=new Vd(o,kd):d=new eh(o,kd);const g=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:i}],i),x=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(n!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return n;const u=this.activeTimers!=null;let c;u&&(c=Za());let f;if(i==="complex64"){const d=this.readSync(r.real.dataId),g=this.readSync(r.imag.dataId);f=Tf(d,g)}else f=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Za()-c),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const x=this.pendingRead.get(e);return new Promise(S=>x.push(S))}const t=this.texData.get(e),{values:n,shape:i,slice:r,dtype:a,complexTensorInfos:o,isPacked:l}=t;if(r!=null){let x;l?x=new Vd(i,kd):x=new eh(i,kd);const S=this.runWebGLProgram(x,[{dataId:e,shape:i,dtype:a}],a),b=this.read(S.dataId);return this.disposeIntermediateTensorInfo(S),b}if(n!=null)return this.convertAndCacheOnCPU(e);if(Ie().getBool("DEBUG")&&!Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&Ie().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const x=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(x.texture.texture,...dw(i))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const x=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),S=x[0],b=x[1];f=Tf(S,b)}else if(u==null)f=this.getValuesFromTexture(e);else{const x=Xe(i);f=this.gpgpu.downloadFloat32MatrixFromBuffer(u,x)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const x=this.gpgpu.gl;Ot(x,()=>x.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(x=>x(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&qc().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const n=this.texData.get(e),{values:i,shape:r,slice:a,dtype:o,isPacked:l,texture:u}=n;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;l?g=new Vd(r,kd):g=new eh(r,kd);const x=this.runWebGLProgram(g,[{dataId:e,shape:r,dtype:o}],o),S=this.readToGPU(x,t);return this.disposeIntermediateTensorInfo(x),S}if(u==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),f=qc().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:f},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(i=>ap(i));return Mn(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Mn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const n=e[t];if(!y2e(n))throw Ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:i}=this.texData.get(e),r=Xe(t);if(Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),g=this.texData.get(d.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...dw(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(d),x}const a=Ie().getBool("WEBGL_PACK")&&i===!0,o=a?gw(t):t,l=a?new OCe(o):new DCe(o),u=this.runWebGLProgram(l,[{shape:o,dtype:n,dataId:e}],"float32"),c=this.texData.get(u.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(u),f}timerAvailable(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=Dg(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Dg(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);o.kernelMs=Ooe(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Za(),endMs:null}}endTimer(e){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Za(),e)}async getQueryTime(e){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:i,usage:r,isPacked:a,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,n),this.textureManager.releaseTexture(t,i,r,a)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=fMe){return Ie().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&Xe(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){cl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return lMe(e.shape,t)}packedUnaryOp(e,t,n){const i=new Vd(e.shape,t),r=this.compileAndRun(i,[e],n);return qc().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=LX(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,W$,e.dtype);const t=new eh(e.shape,W$),n=this.compileAndRun(t,[e]);return qc().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let i;if(t==="string"&&n!=null&&n.length>0&&d_(n[0])){const r=n.map(a=>Yd(a));i=this.write(r,e,t)}else i=this.write(n,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,n){return qc().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new oMe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new WEe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[Rx(e.shape),...Ix(e.shape)],i={dtype:e.dtype,shape:n,dataId:e.dataId},r=[Rx(t),...Ix(t)],a=new UX(r,n),o=!0,l=[n],u=this.runWebGLProgram(a,[i],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:i,shape:r,dtype:a}=n;if(t!=null){const d=Xe(r),g=t[0]*t[1]*4;K(d<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=gw(r);let l;i?l=new ICe(o):l=new RCe(o);const u=!0,c=[t??dw(o)],f=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:e}],a,c,u,t);return{dtype:a,shape:r,dataId:f.dataId}}runWebGLProgram(e,t,n,i,r=!1,a){const o=this.makeTensorInfo(e.outputShape,n),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Hb.DENSE){const _=a??dw(e.outputShape);l.texShape=_.map(T=>T*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Xe(o.shape)===0)return l.values=Fr(o.dtype,0),o;const u=[],c=t.map(_=>{if(_.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(_.dataId);if(T.texture==null){if(!e.packedInputs&&Xe(_.shape)<=Ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:_.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=_.shape)}if(this.uploadToGPU(_.dataId),!!T.isPacked!=!!e.packedInputs)_=T.isPacked?this.unpackTensor(_):this.packTensor(_),u.push(_),T=this.texData.get(_.dataId);else if(T.isPacked&&!dC(T.shape,_.shape)){const E=_,C=_.shape;_.shape=T.shape,_=this.packedReshape(_,C),u.push(_),T=this.texData.get(_.dataId),E.shape=C}return{shape:_.shape,texData:T,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:l,isUniform:!1},d=NCe(e,c,f),g=this.getAndSaveBinary(d,()=>ECe(this.gpgpu,e,c,f)),x=this.activeTimers!=null;let S;x&&(S=this.startTimer()),Ie().get("ENGINE_COMPILE_ONLY")||MCe(this.gpgpu,g,c,f,i),u.forEach(_=>this.disposeIntermediateTensorInfo(_)),x&&(S=this.endTimer(S),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(S)}));const b=Ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(b>0){const _=Za();_-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=_)}if(!Ie().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const _=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),_}return o}compileAndRun(e,t,n,i,r=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=we(()=>{if(!Ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ie().getBool("DEBUG");Ie().set("DEBUG",!1);const t=this.abs(Jt(1e-8)).dataSync()[0];if(Ie().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?uMe:cMe}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:i,values:r,texture:a,usage:o,isPacked:l}=t;if(a!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Za());let f=t.texShape;if(f==null&&(f=k2e(n,l),t.texShape=f),r!=null){const d=gw(n);let g,x=f[1],S=f[0];const b=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!b)&&([x,S]=Jx(f[0],f[1])),l?g=new kCe(d,b):g=new z$(d,b);const _=b?[S,x]:f,T=this.makeTensorInfo(_,i),E=this.texData.get(T.dataId);b?E.usage=ml.PIXELS:E.usage=ml.UPLOAD,E.texShape=_,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),x,S,r);const C=[[S,x]],I=this.runWebGLProgram(g,[T],i,C,!0),L=this.texData.get(I.dataId);t.texShape=L.texShape,t.isPacked=L.isPacked,t.usage=L.usage,Ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(t.texture=L.texture,t.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(T),u&&(this.uploadWaitMs+=Za()-c)}else{const d=this.acquireTexture(f,o,i,l);t.texture=d}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:i}=n;return t!=null&&(n.values=mMe(t,i)),n.values}acquireTexture(e,t,n,i){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*G2(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await SH(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(TX(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:i,nanLoc:r,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:l}=NX(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=i,e.nanLoc=r,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:a,channels:o}=e,l=qc().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(i,t,n,r,a,o);return qc().makeTensorFromDataId(u,t,n,l)}}qM.nextDataId=0;function mMe(s,e){if(e==="float32"||e==="complex64")return s;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let n=0;n<t.length;++n)t[n]=Math.round(s[n]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */N8()&&O8("webgl",()=>new qM,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zL=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Vg{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=gn(t,n),this.enableShapeUniforms=ra(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class nv{constructor(e,t,n,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=gn(t,n);const r=this.outputShape.length;this.enableShapeUniforms=ra(r);let a="";if(i)if(r===0||Xe(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Es(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Ta("coords",r);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $o(s){const{inputs:e,backend:t}=s,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const gMe={kernelName:B_,backendName:"webgl",kernelFunc:$o};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(s){const{inputs:e,backend:t}=s,{real:n,imag:i}=e,r=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(r.dataId),o=$o({inputs:{x:n},backend:t}),l=$o({inputs:{x:i},backend:t});return a.complexTensorInfos={real:o,imag:l},r}const yMe={kernelName:XO,backendName:"webgl",kernelFunc:Ip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X="return (a < 0.) ? b * a : a;",zX=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function xMe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{alpha:r}=n,a=t.makeTensorInfo([],"float32",_p(r,"float32")),o=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nv(zX,i.shape,a.shape):new Vg($X,i.shape,a.shape),l=t.runWebGLProgram(o,[i,a],"float32");return t.disposeIntermediateTensorInfo(a),l}const vMe={kernelName:wE,backendName:"webgl",kernelFunc:xMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GX="return (a < 0.) ? b * a : a;",HX=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function bMe(s){const{inputs:e,backend:t}=s,{x:n,alpha:i}=e,r=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nv(HX,n.shape,i.shape):new Vg(GX,n.shape,i.shape);return t.runWebGLProgram(r,[n,i],"float32")}const _Me={kernelName:VE,backendName:"webgl",kernelFunc:bMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv="if (isnan(x)) return x;";function ns({opSnippet:s,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:i,backend:r})=>{const{x:a}=i,o=r,l=n||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const f=o.texData.get(a.dataId),d=t(f.values,l);return o.makeTensorInfo(a.shape,l,d)}const u=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new Vd(a.shape,e):c=new eh(a.shape,s),o.runWebGLProgram(c,[a],l)}}function Gr({opSnippet:s,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:i,dtype:r}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(n&&l.dtype==="complex64"){const x=c.texData.get(l.dataId),S=c.texData.get(u.dataId),[b,_]=[[x.complexTensorInfos.real,S.complexTensorInfos.real],[x.complexTensorInfos.imag,S.complexTensorInfos.imag]].map(E=>{const[C,R]=E,I={dataId:C.dataId,dtype:C.dtype,shape:l.shape},L={dataId:R.dataId,dtype:R.dtype,shape:u.shape},P=new Vg(s,l.shape,u.shape);return c.runWebGLProgram(P,[I,L],ko(C.dtype,R.dtype))}),T=Ip({inputs:{real:b,imag:_},backend:c});return c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(_),T}const f=r||ko(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&i!=null){const x=c.texData.get(l.dataId).values,S=c.texData.get(u.dataId).values,b=l.dtype==="string"?wf(x):x,_=l.dtype==="string"?wf(S):S,[T,E]=i(l.shape,u.shape,b,_,f),C=c.makeTensorInfo(E,f),R=c.texData.get(C.dataId);return R.values=T,C}const d=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return d?g=new nv(e,l.shape,u.shape,t):g=new Vg(s,l.shape,u.shape),c.runWebGLProgram(g,[l,u],f)}}function Vb(s,e=!1){if(s==="linear")return e?nMe:JEe;if(s==="relu")return e?iMe:QEe;if(s==="elu")return e?sMe:ZEe;if(s==="relu6")return e?rMe:eMe;if(s==="prelu")return e?HX:GX;if(s==="leakyrelu")return e?zX:$X;if(s==="sigmoid")return e?aMe:tMe;throw new Error(`Activation ${s} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VX{constructor(e,t,n,i=!1,r=!1,a=!1,o=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ra(this.outputShape.length);const c=i?e[1]:e[2],f=Math.ceil(c/2),d=i?"i * 2, rc.y":"rc.y, i * 2",g=r?"rc.z, i * 2":"i * 2, rc.z",x=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],S=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let b="",_="";o&&(l?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:b=`vec4 activation(vec4 x) {
          ${o}
        }`,_="result = activation(result);");const T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let E="rc.x",C="rc.x";e[0]<t[0]?E=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(C=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${b}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${E};
        int batchB = ${C};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${x[0]} * ${S[0]});
          result += (${x[1]} * ${S[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${_}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X$={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class q${constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=gn(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j$="return a * b;";function GL(s){const{inputs:e,backend:t}=s,{a:n,b:i}=e,r=ko(n.dtype,i.dtype);if(n.dtype==="complex64"){const o=t.texData.get(n.dataId),l=t.texData.get(i.dataId),u=new q$(X$.REAL,n.shape,i.shape),c=new q$(X$.IMAG,n.shape,i.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:n.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],d=t.runWebGLProgram(u,f,"float32"),g=t.runWebGLProgram(c,f,"float32"),x=Ip({inputs:{real:d,imag:g},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),x}if(t.shouldExecuteOnCPU([n,i])){const o=t.texData.get(n.dataId),l=t.texData.get(i.dataId),[u,c]=bEe(n.shape,i.shape,o.values,l.values,r),f=t.makeTensorInfo(c,r),d=t.texData.get(f.dataId);return d.values=u,f}let a;return Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new nv(j$,n.shape,i.shape):a=new Vg(j$,n.shape,i.shape),t.runWebGLProgram(a,[n,i],r)}const SMe={kernelName:H_,backendName:"webgl",kernelFunc:GL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AMe(s,e,t){const n=[Rx(s.shape),...Ix(s.shape)],i={dtype:s.dtype,shape:n,dataId:s.dataId},r=[Rx(e),...Ix(e)],a=new UX(r,n),o=!0,l=[n],u=t.runWebGLProgram(a,[i],s.dtype,l,o);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function St(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{shape:r}=n,a=t,o=Xe(i.shape),l=u8(r,o),u=Xe(l);K(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=a.texData.get(i.dataId);return c.isPacked&&!dC(i.shape,l)&&!(c.texture!==null&&dC(c.shape,l))?AMe(i,l,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const TMe={kernelName:XE,backendName:"webgl",kernelFunc:St};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K${constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];const o=Math.floor(n/4)*4,l=n%4;let u="sumValue += dot(values, ones);";if(t!=null){const f=1/t;u=`sumValue += dot(values * ${bx(f)?f.toPrecision(2):f}, ones);`}let c="";r%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wMe{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(n/4)*4,f=n%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let x="";r%n>0&&(x=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CMe(s){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:s[1],n=IM(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function o0(s,e,t,n){const i=CMe(s.shape);let r=s;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:u}=i[a];let c,f;t==="mean"?c=a===0?new K$({windowSize:l,inSize:o,batchSize:s.shape[0],outSize:u},o):new K$({windowSize:l,inSize:o,batchSize:s.shape[0],outSize:u}):c=new wMe({windowSize:l,inSize:o,batchSize:s.shape[0],outSize:u},t),f=r,r=n.runWebGLProgram(c,[r],e),f.dataId!==s.dataId&&n.disposeIntermediateTensorInfo(f)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EMe{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const i=Es(this.rank),r=MMe(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}}function MMe(s){const e=s.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let i=0;i<s.length;i++)n[s[i]]=t[i];return n.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NMe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Es(this.rank),r=PX("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=r[c];const o=`vec2(${a.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(s,e,t){const n=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NMe(s.shape,e):new EMe(s.shape,e);return t.runWebGLProgram(n,[s],s.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RMe(s,e,t,n){const i=e,r=s.shape.length,a=kn(i,s.shape);let o=a;const l=ri(o,r),u=l!=null;let c=s;u&&(c=jM(s,l,n),o=Ri(o.length,r)),$r("sum",o,r);const[f,d]=Tr(c.shape,o);let g=f;t&&(g=Ni(f,a));const x=Xe(d),b=Xe(s.shape)/x,_=St({inputs:{x:c},attrs:{shape:[b,x]},backend:n}),T=VB(s.dtype),E=o0(_,T,"sum",n),C=St({inputs:{x:E},attrs:{shape:g},backend:n});return n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(E),u&&n.disposeIntermediateTensorInfo(c),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n;return RMe(i,r,a,t)}const IMe={kernelName:ZE,backendName:"webgl",kernelFunc:KM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{perm:r}=n,a=t,o=i.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=i.shape[r[c]];let u;if(a.shouldExecuteOnCPU([i])){const f=a.texData.get(i.dataId).values,d=$L(f,i.shape,i.dtype,r,l);u=a.makeTensorInfo(l,i.dtype);const g=a.texData.get(u.dataId);g.values=d}else u=jM(i,r,a);return u}const DMe={kernelName:Ky,backendName:"webgl",kernelFunc:Na};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WX=1e3;function pC({a:s,b:e,transposeA:t,transposeB:n,backend:i,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=s.shape.length,c=e.shape.length,f=t?s.shape[u-2]:s.shape[u-1],d=n?e.shape[c-1]:e.shape[c-2],g=t?s.shape[u-1]:s.shape[u-2],x=n?e.shape[c-2]:e.shape[c-1],S=s.shape.slice(0,-2),b=e.shape.slice(0,-2),_=Xe(S),T=Xe(b),C=gn(s.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,x]);K(f===d,()=>`Error in matMul: inner shapes (${f}) and (${d}) of Tensors with shapes ${s.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);const R=t?[_,f,g]:[_,g,f],I=n?[T,x,d]:[T,d,x],L=St({inputs:{x:s},backend:i,attrs:{shape:R}}),P=St({inputs:{x:e},backend:i,attrs:{shape:I}}),D=[L,P],O=Math.max(_,T),F=t?L.shape[1]:L.shape[2],X=r!=null,q=a!=null,J=l==="leakyrelu",Y=l!=null?Vb(l,!0):null,$=X||q||J||Y!=null;let W;if((g===1||x===1)&&F>WX&&$===!1){let se=L,G=P;t&&(se=Na({inputs:{x:L},backend:i,attrs:{perm:[0,2,1]}}),D.push(se)),n&&(G=Na({inputs:{x:P},backend:i,attrs:{perm:[0,2,1]}}),D.push(G));const ne=x!==1,oe=x===1;let ue=se;ne&&(ue=St({inputs:{x:se},backend:i,attrs:{shape:[O,F,1]}}),D.push(ue));const re=x===1?2:1;let ce=G;oe&&(ce=St({inputs:{x:G},backend:i,attrs:{shape:[O,1,F]}}),D.push(ce));const Te=GL({inputs:{a:ue,b:ce},backend:i});W=KM({inputs:{x:Te},backend:i,attrs:{axis:re,keepDims:!0}}),D.push(Te)}else{const se=ko(s.dtype,e.dtype),G=new VX(R,I,[O,g,x],t,n,X,Y,q,J),ne=[L,P];if(r!=null&&ne.push(r),q&&ne.push(a),J){const oe=i.makeTensorInfo([],"float32",_p(o,"float32"));ne.push(oe),D.push(oe)}W=i.runWebGLProgram(G,ne,se)}const V=St({inputs:{x:W},backend:i,attrs:{shape:C}});D.push(W);for(const se of D)i.disposeIntermediateTensorInfo(se);return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OMe(s){const{inputs:e,backend:t,attrs:n}=s,{a:i,b:r,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:f}=n;return pC({a:i,b:r,transposeA:l,transposeB:u,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:c})}const BMe={kernelName:H2,backendName:"webgl",kernelFunc:OMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$="return abs(x);";function kMe(s){const{inputs:e,backend:t}=s,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){const r=t.texData.get(n.dataId),a=LX(r.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Vd(n.shape,Y$):i=new eh(n.shape,Y$),t.runWebGLProgram(i,[n],n.dtype)}const LMe={kernelName:sE,backendName:"webgl",kernelFunc:kMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FMe=gu+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,PMe=ns({opSnippet:FMe}),UMe={kernelName:p_,backendName:"webgl",kernelFunc:PMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Me=gu+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,zMe=ns({opSnippet:$Me}),GMe={kernelName:m_,backendName:"webgl",kernelFunc:zMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$="return a + b;",HMe=Gr({opSnippet:J$,packedOpSnippet:J$,supportsComplex:!0,cpuKernelImpl:QCe}),VMe={kernelName:Vx,backendName:"webgl",kernelFunc:HMe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WMe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,a)=>`T${a}`);const n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XMe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,a)=>`T${a}`);const n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(s){const{inputs:e,backend:t}=s,n=e;if(n.length===1)return $o({inputs:{x:n[0]},backend:t});if(n.length>Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(n.length/2),u=zw({inputs:n.slice(0,l),backend:t}),c=zw({inputs:n.slice(l),backend:t});return zw({inputs:[u,c],backend:t})}const i=n.map(l=>l.dtype).reduce((l,u)=>ko(l,u)),r=n.map(l=>l.shape),o=Ie().getBool("WEBGL_PACK")?new XMe(n[0].shape,r):new WMe(n[0].shape,r);return t.runWebGLProgram(o,n,i)}const qMe={kernelName:iE,backendName:"webgl",kernelFunc:zw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jMe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n,o=i.shape.length,l=kn(r,i.shape);let u=l;const c=ri(u,o);let f=i;c!=null&&(f=Na({inputs:{x:i},backend:t,attrs:{perm:c}}),u=Ri(u.length,o)),$r("all",u,o);const[d,g]=Tr(f.shape,u),x=Xe(g),S=St({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),b=o0(S,S.dtype,"all",t);let _;if(a){const T=Ni(d,l);_=St({inputs:{x:b},backend:t,attrs:{shape:T}})}else _=St({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(b),c!=null&&t.disposeIntermediateTensorInfo(f),_}const KMe={kernelName:$O,backendName:"webgl",kernelFunc:jMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YMe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n,o=i.shape.length,l=kn(r,i.shape);let u=l;const c=ri(u,o);let f=i;c!=null&&(f=Na({inputs:{x:i},backend:t,attrs:{perm:c}}),u=Ri(u.length,o)),$r("any",u,o);const[d,g]=Tr(f.shape,u),x=Xe(g),S=St({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),b=o0(S,S.dtype,"any",t);let _;if(a){const T=Ni(d,l);_=St({inputs:{x:b},backend:t,attrs:{shape:T}})}else _=St({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(b),c!=null&&t.disposeIntermediateTensorInfo(f),_}const JMe={kernelName:zO,backendName:"webgl",kernelFunc:YMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZMe{constructor(e,t,n){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,a];const o=t==="max"?">":"<",l=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QMe{constructor(e,t,n,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,K(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],a=Math.ceil(r/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Es(l),c=Ta("coords",l);let f,d;if(a===1){d=l+1;const P=Es(d);f=`
        ${P} sourceLocR = ${P}(${c.join()}, 0);
        ++${c[l-1]};
        ${P} sourceLocG = ${P}(${c.join()}, 0);
        ++${c[l-2]};
        ${P} sourceLocA = ${P}(${c.join()}, 0);
        --${c[l-1]};
        ${P} sourceLocB = ${P}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,f=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,d),x="."+g[d-1],S=g.map(P=>"int "+P),b=Ta("sourceLocR",d-1).concat("inIdx.r"),_=Ta("sourceLocG",d-1).concat("inIdx.g"),T=Ta("sourceLocB",d-1).concat("inIdx.b"),E=Ta("sourceLocA",d-1).concat("inIdx.a"),C=n==="max"?"greaterThan":"lessThan",R=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${_.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${E.join()})));`,I=`vec4(
            getAChannel(${b.join()}),
            hasNextCol ? getAChannel(${_.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${E.join()}) : 0.)`,L=i?"":`
      float getBestIndicesAChannel(${S.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${S.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${L}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${x}, sourceLocG${x},
          sourceLocB${x}, sourceLocA${x}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XX(s,e,t,n=null){let i=e.shape[0],r=e.shape[1];n!=null&&(i=n.shape[0],r=n.shape[1]);const a=IM(r),o={windowSize:a,inSize:r,batchSize:i,outSize:Math.ceil(r/a)},l=new ZMe(o,t,n==null),u=[e];n!=null&&u.push(n);const c=s.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const f=XX(s,e,t,c);return s.disposeIntermediateTensorInfo(c),f}function qX(s,e,t,n=null){const i=n!=null?n.shape:e.shape,r=i[i.length-1],a=IM(r),o=new QMe(i,a,t,n==null),l=n==null?[e]:[e,n],u=s.runWebGLProgram(o,l,"int32");if(u.shape.length===e.shape.length){const c=qX(s,e,t,u);return s.disposeIntermediateTensorInfo(u),c}return u}function jX(s,e,t,n){const i=[t];if($r("arg"+n.charAt(0).toUpperCase()+n.slice(1),i,e.shape.length),!Ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const r=[],a=s.texData.get(e.dataId),o=a!==null&&a.isPacked;let l=e;o&&(l=s.unpackTensor(e),r.push(l));const[u,c]=Tr(l.shape,i),f=Xe(c),d=St({inputs:{x:l},backend:s,attrs:{shape:[-1,f]}});r.push(d);const g=XX(s,d,n);r.push(g);const x=St({inputs:{x:g},backend:s,attrs:{shape:u}});return r.forEach(S=>s.disposeIntermediateTensorInfo(S)),x}return qX(s,e,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eNe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r}=n;let a=kn(r,i.shape);const o=ri(a,i.shape.length);let l=i;const u=[];o!=null&&(l=Na({inputs:{x:i},backend:t,attrs:{perm:o}}),u.push(l),a=Ri(a.length,l.shape.length)),$r("argMax",[a[0]],l.shape.length);const c=jX(t,l,a[0],"max");return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),c}const tNe={kernelName:rE,backendName:"webgl",kernelFunc:eNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nNe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r}=n;let a=kn(r,i.shape);const o=ri(a,i.shape.length);let l=i;const u=[];o!=null&&(l=Na({inputs:{x:i},backend:t,attrs:{perm:o}}),u.push(l),a=Ri(a.length,l.shape.length)),$r("argMin",[a[0]],l.shape.length);const c=jX(t,l,a[0],"min");return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),c}const sNe={kernelName:aE,backendName:"webgl",kernelFunc:nNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iNe=gu+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,rNe=ns({opSnippet:iNe}),aNe={kernelName:g_,backendName:"webgl",kernelFunc:rNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oNe=gu+"return log(x + sqrt(x * x + 1.0));",lNe=ns({opSnippet:oNe}),uNe={kernelName:y_,backendName:"webgl",kernelFunc:lNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cNe=gu+`
  return atan(x);
`,hNe=ns({opSnippet:cNe}),fNe={kernelName:x_,backendName:"webgl",kernelFunc:hNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dNe=zL+`
  return atan(a, b);
`,pNe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+a0+`
  return result;
`,mNe=Gr({opSnippet:dNe,packedOpSnippet:pNe}),gNe={kernelName:b_,backendName:"webgl",kernelFunc:mNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yNe=gu+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,xNe=ns({opSnippet:yNe}),vNe={kernelName:v_,backendName:"webgl",kernelFunc:xNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wb{constructor(e,t,n,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg",b=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,_=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let T="0.0";if(S||(T="-1.0 / 1e-20"),n){const P=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${g}, ${x});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${P} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?b:_:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const R=Math.floor(a/4)*4,I=a%4,L=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${g}, ${x});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${L}
          }

          int xC = xCCorner + ${R};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${L}
          }
        }
        setOutput(${C});
      }
    `}}class HL{constructor(e,t,n,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,f=e.dilationHeight,d=e.dilationWidth,g=e.effectiveFilterDepth,x=e.effectiveFilterHeight,S=e.effectiveFilterWidth,b=e.padInfo.front,_=e.padInfo.top,T=e.padInfo.left;this.outputShape=e.outShape;const E=t==="avg";let C="0.0";if(E||(C="-1.0 / 1e-20"),n){const O=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${b}, ${_}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${x};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${S};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${O} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${x} * ${S} +
                      wR * ${S} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const R="max";let I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");const L=Math.floor(a/4)*4,P=a%4,D=`
      if (${E}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${b}, ${_}, ${T});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${L}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${L};
            if (${P===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${P===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${P===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${I});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bNe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e;RS(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=n,u=1;K(Ur(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=pu(i.shape,r,a,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Wn(c.inShape,c.outShape))return $o({inputs:{x:i},backend:t});const f=new Wb(c,"avg",!1);return t.runWebGLProgram(f,[i],"float32")}const _Ne={kernelName:oE,backendName:"webgl",kernelFunc:bNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SNe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=n,c=[1,1,1],f=Mf(i.shape,r,a,c,o,l,u),d=new HL(f,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const ANe={kernelName:lE,backendName:"webgl",kernelFunc:SNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TNe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,f=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${f});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class wNe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,i=e.filterWidth,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,g=e.effectiveFilterWidth,x=f-1-e.padInfo.front,S=d-1-e.padInfo.top,b=g-1-e.padInfo.left,_=1/(t*n*i);this.userCode=`
      const ivec3 pads = ivec3(${x}, ${S}, ${b});
      const float avgMultiplier = float(${_});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CNe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,a=r,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=n,f=[1,1,1],d=Mf(a.shape,o,l,f,u,c),g=new wNe(d);return t.runWebGLProgram(g,[i],a.dtype)}const ENe={kernelName:HO,backendName:"webgl",kernelFunc:CNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MNe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,a=r;RS([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=n,c=pu(a.shape,o,l,1,u),f=new TNe(c);return t.runWebGLProgram(f,[i],a.dtype)}const NNe={kernelName:GO,backendName:"webgl",kernelFunc:MNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RNe(s){const{inputs:e,backend:t,attrs:n}=s,{a:i,b:r}=e,{transposeA:a,transposeB:o}=n;return pC({a:i,b:r,transposeA:a,transposeB:o,backend:t})}const INe={kernelName:uE,backendName:"webgl",kernelFunc:RNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DNe{constructor(e,t,n,i,r,a){this.outputShape=[],this.variableNames=["x","mean","variance"],gn(e,t),gn(e,n);let o="0.0";i!=null&&(gn(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";r!=null&&(gn(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ONe{constructor(e,t,n,i,r,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],gn(e,t),gn(e,n);let o="vec4(0.0)";i!=null&&(gn(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(gn(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BNe=({inputs:s,backend:e,attrs:t})=>{const{x:n,mean:i,variance:r,offset:a,scale:o}=s;K(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),K(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),K(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[n,i,r];let c=null;a!=null&&(c=a.shape,u.push(a));let f=null;o!=null&&(f=o.shape,u.push(o));const d=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new ONe(n.shape,i.shape,r.shape,c,f,l):new DNe(n.shape,i.shape,r.shape,c,f,l);return e.runWebGLProgram(d,u,u[0].dtype)},kNe={kernelName:SE,backendName:"webgl",kernelFunc:BNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LNe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Es(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=FNe(this.rank);let i;const r=e.map((a,o)=>`sourceLoc.${f3[o]} = start[${o}] + coords.${f3[o]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${n}));
      }
    `}}const f3=["x","y","z","w","u","v"];function FNe(s){if(s===1)return"sourceLoc";if(s<=6)return f3.slice(0,s).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PNe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Es(this.rank),n=Ta("coords",this.rank),i=Ta("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${r})`,o=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${a};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,f)=>`start[${f}]`).join()});`:e.map((c,f)=>`${i[f]} = ${n[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UNe(s,e,t,n){const i=n.texData.get(s.dataId),r=n.makeTensorInfo(t,s.dtype),a=n.texData.get(r.dataId);Object.assign(a,i),a.refCount=1,a.shape=t,a.dtype=s.dtype;let o=Fk(e,jt(s.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||s.dataId};const l=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,l+1),r}function iv(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{begin:r,size:a}=n,[o,l]=RM(i,r,a);if(Bk(i,o,l),Xe(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const f=t.texData.get(i.dataId),d=IEe(f.values,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,d)}const{isPacked:u}=t.texData.get(i.dataId),c=Lk(i.shape,o,l);if(u||!c){const f=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PNe(l):new LNe(l),d=[o];return t.runWebGLProgram(f,[i],i.dtype,d)}return t.uploadToGPU(i.dataId),UNe(i,o,l,t)}const $Ne={kernelName:JE,backendName:"webgl",kernelFunc:iv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zNe=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockShape:r,crops:a}=n;K(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((T,E)=>T*E),l=yS(i.shape,r,o),u=xS(l.length,r.length),c=vS(i.shape,r,o),f=Gk(a,r.length),d=Hk(c,a,r.length),g=[],x=St({inputs:{x:i},backend:t,attrs:{shape:l}}),S=Na({inputs:{x},backend:t,attrs:{perm:u}}),b=St({inputs:{x:S},backend:t,attrs:{shape:c}}),_=iv({inputs:{x:b},backend:t,attrs:{begin:f,size:d}});return g.push(x),g.push(S),g.push(b),g.forEach(T=>t.disposeIntermediateTensorInfo(T)),_},GNe={kernelName:cE,backendName:"webgl",kernelFunc:zNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HNe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,weights:r}=e,{size:a}=n,o=t.readSync(i.dataId),l=t.readSync(r.dataId),u=kX(o,l,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,u)}const VNe={kernelName:VO,backendName:"webgl",kernelFunc:HNe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WNe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,XNe=`
  return float(int(a.r) & int(b.r));
`;function qNe(s){const{inputs:e,backend:t}=s,{a:n,b:i}=e,r=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=Ie().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([n,i])||a===1){const l=t.texData.get(n.dataId).values,u=t.texData.get(i.dataId).values,[c,f]=tEe(n.shape,i.shape,l,u,n.dtype),d=t.makeTensorInfo(f,n.dtype),g=t.texData.get(d.dataId);return g.values=c,d}let o;return r?o=new nv(WNe,n.shape,i.shape,!1):o=new Vg(XNe,n.shape,i.shape),t.runWebGLProgram(o,[n,i],n.dtype)}const jNe={kernelName:hE,backendName:"webgl",kernelFunc:qNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KNe(s){const{inputs:e,backend:t}=s,{s0:n,s1:i}=e,r=t.readSync(n.dataId),a=t.readSync(i.dataId),o=gn(Array.from(r),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const YNe={kernelName:WO,backendName:"webgl",kernelFunc:KNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JNe="return float(a != b);",KX=Gr({opSnippet:JNe,cpuKernelImpl:SEe,dtype:"bool"}),ZNe={kernelName:UE,backendName:"webgl",kernelFunc:KX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(s){const{inputs:e,backend:t}=s,{input:n}=e,i=t.texData.get(n.dataId);return $o({inputs:{x:i.complexTensorInfos.real},backend:t})}const QNe={kernelName:TB,backendName:"webgl",kernelFunc:DS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eRe="return float(int(x));";function tRe(s,e){const t=new eh(s.shape,eRe),n=e.runWebGLProgram(t,[s],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{dtype:r}=n;if(r==="complex64"){if(i.dtype==="complex64")return $o({inputs:{x:i},backend:t});const a=Qi(i.shape),o=d3({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Ip({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),l}if(i.dtype==="complex64"){const a=DS({inputs:{input:i},backend:t}),o=d3({inputs:{x:a},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(a),o}if(!c8(i.dtype,r)){const a=$o({inputs:{x:i},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const a=t.texData.get(i.dataId).values,[o,l,u]=nEe(a,i.shape,i.dtype,r);return t.makeTensorInfo(o,l,u)}if(r==="int32")return tRe(i,t);if(r==="bool"){const a=t.makeTensorInfo([],"bool",Fr("bool",1)),l=KX({inputs:{a:i,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const nRe={kernelName:__,backendName:"webgl",kernelFunc:d3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$="return ceil(x);",sRe=ns({opSnippet:Z$,packedOpSnippet:Z$,cpuKernelImpl:sEe}),iRe={kernelName:S_,backendName:"webgl",kernelFunc:sRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rRe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aRe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{clipValueMin:r,clipValueMax:a}=n;let o;Ie().getBool("WEBGL_PACK_CLIP")?o=new aRe(i.shape):o=new rRe(i.shape);const l=[[r],[a]];return t.runWebGLProgram(o,[i],i.dtype,l)}const lRe={kernelName:A_,backendName:"webgl",kernelFunc:oRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uRe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(s,e){return{dataId:e.dataId,dtype:e.dtype,shape:s.shape}}function cRe(s){const{inputs:e,backend:t}=s,{x:n}=e,i=t.texData.get(n.dataId),r=new uRe(n.shape),a=[Q$(n,i.complexTensorInfos.real),Q$(n,i.complexTensorInfos.imag)];return t.runWebGLProgram(r,a,a[0].dtype)}const hRe={kernelName:fE,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fRe{constructor(e){this.outputShape=[],this.outputShape=oh(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const i=t.length,r=t[t.length-1];n.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dRe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=oh(e,t);const n=this.outputShape,i=n.length,r=Es(i),a=Ta("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((S,b)=>`T${b}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let S=1;S<l.length;S++)l[S]=l[S-1]+e[S][t];const u=o[t],c=o.slice(-2),f=o.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${c.join()}));
        }`;for(let S=1;S<l.length;S++){const b=l[S-1];d+=`
        if (${u} < ${l[S]}  && ${u} >= ${l[S-1]}) {
          return getChannel(
            getT${S}(${vw(o,u,b)}),
            vec2(${vw(c,u,b)}));
        }`}const g=l.length,x=l[l.length-1];d+=`
        return getChannel(
          getT${g}(${vw(o,u,x)}),
          vec2(${vw(c,u,x)}));`,this.userCode=`
      float getValue(${o.map(S=>"int "+S)}) {
        ${d}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[i-1]} = ${a[i-1]} + 1;
        if (${a[i-1]} < ${n[i-1]}) {
          result.g = getValue(${a});
        }

        ${a[i-2]} = ${a[i-2]} + 1;
        if (${a[i-2]} < ${n[i-2]}) {
          result.a = getValue(${a});
        }

        ${a[i-1]} = ${a[i-1]} - 1;
        if (${a[i-2]} < ${n[i-2]} &&
            ${a[i-1]} < ${n[i-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function vw(s,e,t){const n=s.indexOf(e);return s.map((r,a)=>a===n?`${r} - ${t}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(s){const{inputs:e,backend:t}=s,{input:n}=e,i=t.texData.get(n.dataId);return $o({inputs:{x:i.complexTensorInfos.imag},backend:t})}const pRe={kernelName:cB,backendName:"webgl",kernelFunc:YM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(s,e,t){const n=s[0].dtype;if(n==="complex64"){const g=s.map(T=>DS({inputs:{input:T},backend:t})),x=s.map(T=>YM({inputs:{input:T},backend:t})),S=Y1(g,e,t),b=Y1(x,e,t),_=Ip({inputs:{real:S,imag:b},backend:t});return g.forEach(T=>t.disposeIntermediateTensorInfo(T)),x.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(b),_}let i=t.shouldExecuteOnCPU(s);if(n==="string"&&(i=!0),i){const g=s.map(C=>{const I=[-1,Xe(C.shape.slice(e))];return St({inputs:{x:C},backend:t,attrs:{shape:I}})}),x=g.map(C=>({vals:t.readSync(C.dataId),shape:C.shape})),S=oh(g.map(C=>C.shape),1),b=g[0].shape[0]===1,_=iEe(x,S,n,b),T=oh(s.map(C=>C.shape),e),E=t.makeTensorInfo(T,n,_);return g.forEach(C=>t.disposeIntermediateTensorInfo(C)),E}const r=s.filter(g=>Xe(g.shape)>0),a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const g=a?new eh(s[0].shape,kd):new Vd(s[0].shape,kd);return t.runWebGLProgram(g,s,n)}const o=Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>o){const g=[];for(let S=0;S<r.length;S+=o){const b=r.slice(S,S+o);g.push(Y1(b,e,t))}const x=Y1(g,e,t);for(const S of g)t.disposeIntermediateTensorInfo(S);return x}if(a){const g=new dRe(r.map(x=>x.shape),e);return t.runWebGLProgram(g,r,n)}const{tensors2D:l,outShape:u}=mRe(r,e,t),c=new fRe(l.map(g=>g.shape)),f=t.runWebGLProgram(c,l,n);l.forEach(g=>t.disposeIntermediateTensorInfo(g));const d=St({inputs:{x:f},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(f),d}function mRe(s,e,t){const n=oh(s.map(r=>r.shape),e);return{tensors2D:s.map(r=>St({inputs:{x:r},attrs:{shape:[-1,Xe(r.shape.slice(e))]},backend:t})),outShape:n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(s){const{inputs:e,backend:t,attrs:n}=s,{axis:i}=n,r=kn(i,e[0].shape)[0],a=e.map(u=>u.shape);Uk(a,r);const o=oh(e.map(u=>u.shape),r);if(Xe(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(u=>Xe(u.shape)>0);return l.length===1?$o({inputs:{x:l[0]},backend:t}):Y1(l,r,t)}const gRe={kernelName:dE,backendName:"webgl",kernelFunc:YX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JX{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,f=e.dilationWidth,d=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,S=e.inChannels%4,b=e.dataFormat==="channelsLast",_=b?1:2,T=b?2:3,E=b?3:1;let C="",R="";n&&(i?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:C=`
          float activation(float x) {
            ${n}
          }
        `,R="result = activation(result);");const I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${E}];

        ivec2 xRCCorner =
            ivec2(coords[${_}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${x}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${b}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${S===1}) {

              if (${b}) {
                dotProd +=
                    getX(batch, xR, xC, ${x}) *
                    getW(wR, wC, ${x}, d2);
              } else {
                dotProd +=
                    getX(batch, ${x}, xR, xC) *
                    getW(wR, wC, ${x}, d2);
              }

            } else if (${S===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2)
              );

              if (${b}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${S===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${x}, d2),
                getW(wR, wC, ${x} + 1, d2),
                getW(wR, wC, ${x} + 2, d2)
              );

              if (${b}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${x}),
                  getX(batch, xR, xC, ${x} + 1),
                  getX(batch, xR, xC, ${x} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${x}, xR, xC),
                  getX(batch, ${x} + 1, xR, xC),
                  getX(batch, ${x} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${R}
        setOutput(result);
      }
    `}}class yRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,i=e.padInfo.left,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,f=e.filterDepth,d=e.filterHeight,g=e.filterWidth,x=Math.floor(e.inChannels/4)*4,S=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${n}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${x}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${S===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${x}) *
                  getW(wF, wR, wC, ${x}, d2);
              } else if (${S===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${S===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${x}),
                  getX(batch, xF, xR, xC, ${x} + 1),
                  getX(batch, xF, xR, xC, ${x} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${x}, d2),
                  getW(wF, wR, wC, ${x} + 1, d2),
                  getW(wF, wR, wC, ${x} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZX{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ra(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,f=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<c;b++)d+=`
           vec4 xTexelC${b*2};
           int xTexelC${b*2}Ready;
           vec4 xTexelC${b*2+1};
           int xTexelC${b*2+1}Ready;
           vec4 xC${b};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let b=0;b<c;b++)d+=`
           xTexelC${b*2} = vec4(0.0);
           xTexelC${b*2}Ready = 0;
           xTexelC${b*2+1} = vec4(0.0);
           xTexelC${b*2+1}Ready = 0;
           xC${b} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let b=0;b<(f+1)/2;b++){const _=b*2;if(d+=`
           xC = xCCorner + ${_*l};
           `,o===1){if(_<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                   xTexelC${_} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_}.zw = vec2(0.0);
                   }
                   xTexelC${_}Ready = 1;
                 }
               `,l===1&&_>0?d+=`
                 xC${_} = vec4(xTexelC${_-2}.zw, xTexelC${_}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${_} = vec4(previous.zw, xTexelC${_}.xy);
                   } else {
                     xC${_} = vec4(0.0, 0.0, xTexelC${_}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                   xTexelC${_} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${_}.zw = vec2(0.0);
                   }
                   xTexelC${_}Ready = 1;
                 }

                 xC${_} = xTexelC${_};
                 `,_+1<c)){const T=a%2===0?FO(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                     xTexelC${_+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${_+1}.zw = vec2(0.0);
                     }
                     xTexelC${_+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${_+1} = vec4(previous.zw, xTexelC${_+1}.xy);
                     } else {
                      xC${_+1} = vec4(0.0, 0.0, xTexelC${_+1}.xy);
                     }
                     `:d+=`
                     xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.xy);
                     `):T===1?d+=`
                     xC${_+1} = xTexelC${_};
                     `:d+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                       xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${_+1}.zw = vec2(0.0);
                       }
                       xTexelC${_+1}Ready = 1;
                     }

                     xC${_+1} = xTexelC${_+1};
                     `}}else _<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                   xTexelC${_} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_}.zw = vec2(0.0);
                   }
                   xTexelC${_}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_+1}Ready == 0) {
                   xTexelC${_+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${_+1}.zw = vec2(0.0);
                   }
                   xTexelC${_+1}Ready = 1;
                 }

                 xC${_} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
               `,_+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${_+1} = vec4(xTexelC${_+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                   xTexelC${_} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${_}.zw = vec2(0.0);
                   }
                   xTexelC${_}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                   xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_+1}.zw = vec2(0.);
                   }
                   xTexelC${_+1}Ready = 1;
                 }

                 xC${_} = vec4(
                   xTexelC${_}.xy, xTexelC${_+1}.xy);
               `,_+1<c&&(d+=`
                   xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
                 `)));_<c&&(d+=`
             wTexel = getW(r, ${_}, d1, d2);
             dotProd += xC${_}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${_}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,_+1<c&&(d+=`
               wTexel = getW(r, ${_+1}, d1, d2);
               dotProd += xC${_+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${_+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let g="",x="";n&&(i?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:r?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:g=`vec4 activation(vec4 x) {
           ${n}
         }`,x="result = activation(result);");const S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${S}
         ${x}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xRe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ra(this.outputShape.length);const{dataFormat:n}=t,i=Oa(),r=n==="channelsLast",a=r?1:2,o=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)u+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(s,e){const t=s.length;return t>=3?e?[...s.slice(0,-3),s[t-3]*s[t-2],s[t-1]]:[...s.slice(0,-3),s[t-3],s[t-2]*s[t-1]]:!e&&t===1&&s[0]>1?[s[0],1]:null}function QX({x:s,filter:e,convInfo:t,backend:n,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const l=s.shape,u=n.texData.get(s.dataId),c=t.inChannels,f=l[0]*l[1]*l[2],d=t.outChannels,g=t.dataFormat==="channelsLast",x=!1,S=!1;let b;const _=[];if(r!=null){const C=mC(r.shape,g);C!=null&&(r=St({inputs:{x:r},backend:n,attrs:{shape:C}}),_.push(r))}if(i!=null){const C=mC(i.shape,g);C!=null&&(i=St({inputs:{x:i},backend:n,attrs:{shape:C}}),_.push(i))}if(!((f===1||d===1)&&c>WX)&&u.isPacked&&g&&u.texture!=null&&l[2]%2!==0&&Wn(u.shape.slice(-3),l.slice(-3))){const C=l[0]*l[1]*(l[2]+1),R={dataId:s.dataId,shape:[1,C,t.inChannels],dtype:s.dtype},I=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,K(dC(u.shape,R.shape),()=>`packed reshape ${u.shape} to ${R.shape} isn't free`);const L=St({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});_.push(L);const P=pC({a:R,b:L,backend:n,transposeA:x,transposeB:S,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),D=n.texData.get(P.dataId);K(D.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=I,D.shape=t.outShape,b=$o({inputs:{x:P},backend:n}),b.shape=t.outShape,_.push(P)}else{const C=t.outHeight*t.outWidth,R=St({inputs:{x:s},backend:n,attrs:{shape:g?[t.batchSize,C,t.inChannels]:[t.batchSize,t.inChannels,C]}}),I=St({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),L=pC({a:g?R:I,b:g?I:R,transposeA:!g,transposeB:S,backend:n,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a});b=St({inputs:{x:L},backend:n,attrs:{shape:t.outShape}}),_.push(R),_.push(I),_.push(L)}for(const C of _)n.disposeIntermediateTensorInfo(C);return b}function eq({x:s,filter:e,convInfo:t,backend:n,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:f,outHeight:d,dataFormat:g}=t,x=g==="channelsLast",S=l*u*c,b=d*f,_=[t.batchSize,S,b],T=!0,E=!1,C=[];if(r!=null){const V=mC(r.shape,x);V!=null&&(r=St({inputs:{x:r},backend:n,attrs:{shape:V}}),C.push(r))}if(i!=null){const V=mC(i.shape,x);V!=null&&(i=St({inputs:{x:i},backend:n,attrs:{shape:V}}),C.push(i))}const R=St({inputs:{x:e},backend:n,attrs:{shape:[1,S,Xe(e.shape)/S]}});C.push(R);const I=new xRe(_,t),L=[s.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],P=n.runWebGLProgram(I,[s],"float32",L),D=St({inputs:{x:P},backend:n,attrs:{shape:_}});C.push(P),C.push(D);const O=i!=null,F=r!=null,X=o==="leakyrelu",q=o?Vb(o,!0):null,J=new VX(x?D.shape:R.shape,x?R.shape:D.shape,x?[t.batchSize,b,t.outChannels]:[t.batchSize,t.outChannels,b],T,E,O,q,F,X),Y=x?[D,R]:[R,D];if(i&&Y.push(i),F&&Y.push(r),X){const V=n.makeTensorInfo([],"float32",_p(a,"float32"));Y.push(V),C.push(V)}const $=n.runWebGLProgram(J,Y,"float32"),W=St({inputs:{x:$},backend:n,attrs:{shape:t.outShape}});C.push($);for(const V of C)n.disposeIntermediateTensorInfo(V);return W}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=n,f=Nf(l),d=Ar(i.shape,r.shape,a,u,o,c,!1,f);let g;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))g=QX({x:i,filter:r,convInfo:d,backend:t});else if(d.strideWidth<=2&&f==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const S=new ZX(d),b=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];g=t.runWebGLProgram(S,[i,r],"float32",b)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))g=eq({x:i,filter:r,convInfo:d,backend:t});else{const S=new JX(d);g=t.runWebGLProgram(S,[i,r],"float32")}const x=St({inputs:{x:g},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(g),x}const bRe={kernelName:pE,backendName:"webgl",kernelFunc:vRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Re{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class SRe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=n-1-e.padInfo.left,u=a?1:2,c=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ARe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,i=e.strideWidth,r=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class TRe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,i=e.filterWidth,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,u=n-1-e.padInfo.top,c=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=n,f=Nf(l),d=Ar(i.shape,c,a,1,o,u,!1,f),g=new _Re(d);return t.runWebGLProgram(g,[i,r],"float32")}const CRe={kernelName:qO,backendName:"webgl",kernelFunc:wRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ERe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=ra(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,i=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MRe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=n,f=Nf(u),d=Ar(a,r.shape,o,1,l,c,!1,f);if(Ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[d.strideHeight,d.strideWidth]],x=new ERe(d);return t.runWebGLProgram(x,[i,r],"float32",g)}else{const g=new SRe(d);return t.runWebGLProgram(g,[i,r],"float32")}}const NRe={kernelName:mE,backendName:"webgl",kernelFunc:MRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=n,u=Tp(i.shape,r.shape,a,l,o),c=new yRe(u);return t.runWebGLProgram(c,[i,r],"float32")}const IRe={kernelName:gE,backendName:"webgl",kernelFunc:RRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,pad:o,filterShape:l}=n,u=Tp(i.shape,l,a,1,o),c=new ARe(u);return t.runWebGLProgram(c,[i,r],"float32")}const ORe={kernelName:jO,backendName:"webgl",kernelFunc:DRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BRe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{pad:a,strides:o,inputShape:l}=n,u=Tp(l,r.shape,o,1,a),c=new TRe(u);return t.runWebGLProgram(c,[i,r],"float32")}const kRe={kernelName:KO,backendName:"webgl",kernelFunc:BRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LRe=sv+`
  return cos(x);
`,FRe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${a0}
  return result;
`,PRe=ns({opSnippet:LRe,packedOpSnippet:FRe}),URe={kernelName:T_,backendName:"webgl",kernelFunc:PRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Re=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,zRe=ns({opSnippet:$Re}),GRe={kernelName:w_,backendName:"webgl",kernelFunc:zRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HRe{constructor(e,t,n,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,u]=e,[c]=t,[f,d]=n;this.outputShape=[c,f,d,u];const g=i==="bilinear"?1:0,[x,S]=[`${o-1}.0`,`${l-1}.0`],[b,_,T]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[E,C,R]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${S} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${S}`];this.userCode=`
      const float height_ratio = float(${b});
      const float width_ratio = float(${E});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${_};
        float width_scale = ${C};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${x} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${S} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VRe=s=>{const{inputs:e,backend:t,attrs:n}=s,{image:i,boxes:r,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=n,c=new HRe(i.shape,r.shape,o,l,u);return t.runWebGLProgram(c,[i,r,a],"float32")},WRe={kernelName:JO,backendName:"webgl",kernelFunc:VRe};var Xb;(function(s){s.Prod="*",s.Sum="+"})(Xb||(Xb={}));class ez{constructor(e,t,n,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,a=this.op===Xb.Prod?"1.0":"0.0",o=n?a:`getX(${tz(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";n?(u=i?`end != ${l-1}`:"end != 0",c=i?"end + 1":"end - 1"):(u=i?`end + pow2 < ${l}`:"end >= pow2",c=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Es(r)} coords = getOutputCoords();
        int end = ${nz(r,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${nz(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${tz(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function tz(s,e,t){if(s===1)return`${e}`;if(s===2)return`${e}.x, ${e}.y`;if(s===3)return`${e}.x, ${e}.y, ${e}.z`;if(s===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${s} is not yet supported`)}function nz(s,e,t){if(s===1)return`${e}`;if(s===2)return`${e}.y`;if(s===3)return`${e}.z`;if(s===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tq(s,e,t,n,i,r){const a=e.shape.length,o=ri([n],a);let l=e;o!=null&&(l=Na({inputs:{x:e},backend:t,attrs:{perm:o}}));const u=Ri(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);const c=l.shape[u];let f=$o({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const g=new ez(s,l.shape,!1,r),x=[[d]],S=f;f=t.runWebGLProgram(g,[f],f.dtype,x),t.disposeIntermediateTensorInfo(S)}if(i){const d=new ez(s,l.shape,i,r),g=f;f=t.runWebGLProgram(d,[f],f.dtype),t.disposeIntermediateTensorInfo(g)}if(o!=null){const d=wp(o),g=Na({inputs:{x:f},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,exclusive:a,reverse:o}=n;return tq(Xb.Prod,i,t,r,a,o)}const qRe={kernelName:YO,backendName:"webgl",kernelFunc:XRe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,exclusive:a,reverse:o}=n;return tq(Xb.Sum,i,t,r,a,o)}const KRe={kernelName:yE,backendName:"webgl",kernelFunc:jRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,weights:r}=e,{size:a,binaryOutput:o}=n;if(i.shape.length===1){const l=t.readSync(i.dataId),u=t.readSync(r.dataId),c=kX(l,u,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,c)}else if(i.shape.length===2){const l=t.bufferSync(i),u=t.bufferSync(r),c=eEe(l,u,a,o);return t.makeTensorInfo(c.shape,r.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const JRe={kernelName:ZO,backendName:"webgl",kernelFunc:YRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZRe{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockSize:r,dataFormat:a}=n,o=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],u=a==="NHWC"?i.shape[2]:i.shape[3],c=a==="NHWC"?i.shape[3]:i.shape[1],f=l*r,d=u*r,g=c/(r*r),x=a==="NHWC"?[o,f,d,g]:[o,g,f,d],S=new ZRe(x,r,a);return t.runWebGLProgram(S,[i],i.dtype)}const eIe={kernelName:QO,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nq{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ra(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";n&&(i?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sq{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ra(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,f=e.filterWidth,d=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let _=0;_<f;_++)g+=`
          vec4 xTexelC${_*2};
          int xTexelC${_*2}Ready;
          vec4 xTexelC${_*2+1};
          int xTexelC${_*2+1}Ready;
          vec4 xC${_};`;g+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let _=0;_<f;_++)g+=`
          xTexelC${_*2} = vec4(0.0);
          xTexelC${_*2}Ready = 0;
          xTexelC${_*2+1} = vec4(0.0);
          xTexelC${_*2+1}Ready = 0;
          xC${_} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let _=0;_<(d+1)/2;_++){const T=_*2;if(g+=`
          xC = xCCorner + ${T*u};
          `,l===1){if(T<f&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,u===1&&T>0?g+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<f)){const E=o%2===0?FO(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${E};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,u>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:g+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):E===1?g+=`
                    xC${T+1} = xTexelC${T};
                    `:g+=`
                    xCOffset = xC + ${E};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<f&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<f&&(g+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<f&&(g+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<f&&(g+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let x="",S="";n&&(i?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`vec4 activation(vec4 x) {
          ${n}
        }`,S="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${b}
        ${S}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tIe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=n;let c=l;c==null&&(c=[1,1]),K(Ur(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const f=Ar(i.shape,r.shape,a,c,o,u,!0);let d;Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?d=new sq(f):d=new nq(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(d,[i,r],"float32",g)}const nIe={kernelName:xE,backendName:"webgl",kernelFunc:tIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sIe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iIe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,dy:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=n,f=Ar(i.shape,c,a,o,l,u,!0),d=new sIe(f);return t.runWebGLProgram(d,[i,r],"float32")}const aIe={kernelName:eB,backendName:"webgl",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oIe(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,filter:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=n,f=Ar(c,r.shape,a,o,l,u,!0),d=new iIe(f);return t.runWebGLProgram(d,[i,r],"float32")}const lIe={kernelName:tB,backendName:"webgl",kernelFunc:oIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uIe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cIe(s){const{inputs:e,backend:t}=s,{x:n}=e,i=[...n.shape,...n.shape],r=Xe(n.shape),a=St({inputs:{x:n},backend:t,attrs:{shape:[r]}}),o=new uIe(r),l=t.runWebGLProgram(o,[a],a.dtype),u=St({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const hIe={kernelName:nB,backendName:"webgl",kernelFunc:cIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fIe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:i,strideHeight:r,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:f,left:d}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${a});
      const ivec2 pads = ivec2(${f}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dIe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=n,u=cS(i.shape,r.shape,a,o,"NHWC",l);let c;const f=new fIe(u);c=t.runWebGLProgram(f,[i,r],"float32");const d=St({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const pIe={kernelName:vE,backendName:"webgl",kernelFunc:dIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mIe(s){const{inputs:e,backend:t,attrs:n}=s,{equation:i}=n,r=e,{allDims:a,summedDims:o,idDims:l}=Jk(i,r.length);Qk(a.length,l,r);const{path:u,steps:c}=eL(o,l),f=c.length;let d=null,g=a.length;const x=[];for(let S=0;S<f;++S){for(const b of c[S]){const{permutationIndices:_,expandDims:T}=Zk(g,l[b]);let E;tL(_)?E=r[b]:(E=Na({inputs:{x:r[b]},backend:t,attrs:{perm:_}}),x.push(E));const C=E.shape.slice();for(let R=0;R<T.length;++R)C.splice(T[R],0,1);Wn(E.shape,C)||(E=St({inputs:{x:E},backend:t,attrs:{shape:C}}),x.push(E)),d===null?d=E:(d=GL({inputs:{a:E,b:d},backend:t}),x.push(d))}S<f-1&&(u[S]>=0&&(d=KM({inputs:{x:d},backend:t,attrs:{axis:u[S]-(a.length-g),keepDims:!1}}),x.push(d)),g--)}for(const S of x)S!==d&&t.disposeIntermediateTensorInfo(S);return d}const gIe={kernelName:sB,backendName:"webgl",kernelFunc:mIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yIe="return (x >= 0.0) ? x : (exp(x) - 1.0);",xIe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vIe=ns({opSnippet:yIe,packedOpSnippet:xIe}),bIe={kernelName:E_,backendName:"webgl",kernelFunc:vIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ie="return (b >= 0.0) ? a : a * (b + 1.0);",SIe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,AIe=s=>{const{inputs:e,backend:t}=s,{dy:n,y:i}=e,r=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new nv(SIe,n.shape,i.shape):new Vg(_Ie,n.shape,i.shape);return t.runWebGLProgram(r,[n,i],n.dtype)},TIe={kernelName:iB,backendName:"webgl",kernelFunc:AIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wIe=`
  return vec4(equal(a, b));
`,CIe="return float(a == b);",EIe=Gr({opSnippet:CIe,packedOpSnippet:wIe,dtype:"bool",cpuKernelImpl:rEe}),MIe={kernelName:bE,backendName:"webgl",kernelFunc:EIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NIe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Vk};
  float a1 = ${Wk};
  float a2 = ${Xk};
  float a3 = ${qk};
  float a4 = ${jk};
  float a5 = ${Kk};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,RIe=ns({opSnippet:NIe}),IIe={kernelName:M_,backendName:"webgl",kernelFunc:RIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DIe=sv+`
  return exp(x);
`,OIe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iq=ns({opSnippet:DIe,packedOpSnippet:OIe,cpuKernelImpl:aEe,dtype:"float32"}),BIe={kernelName:N_,backendName:"webgl",kernelFunc:iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(s){const{inputs:e,attrs:t,backend:n}=s,{dim:i}=t,{input:r}=e,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(K(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),St({inputs:{x:r},backend:n,attrs:{shape:o}})}const kIe={kernelName:_E,backendName:"webgl",kernelFunc:p3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sz="return exp(x) - 1.0;",LIe=ns({opSnippet:sz,packedOpSnippet:sz,cpuKernelImpl:oEe}),FIe={kernelName:R_,backendName:"webgl",kernelFunc:LIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iz{constructor(e,t,n){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${i}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rq(s,e,t){const n=t.texData.get(s.dataId),i=Xe(s.shape),r=s.shape[s.shape.length-1],a=i/r,o=St({inputs:{x:s},backend:t,attrs:{shape:[a,r]}}),l=o.shape,u=new iz("real",l,e),c=new iz("imag",l,e),f=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,f,"float32"),g=t.runWebGLProgram(c,f,"float32"),x=Ip({inputs:{real:d,imag:g},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g);const S=St({inputs:{x},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(x),S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PIe(s){const{inputs:e,backend:t}=s,{input:n}=e;return rq(n,!1,t)}const UIe={kernelName:rB,backendName:"webgl",kernelFunc:PIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Ie{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(s){const{backend:e,attrs:t}=s,{shape:n,value:i}=t;let{dtype:r}=t;if(r=r||Gx(i),r==="string"){const a=Mi(r,Xe(n));return a.fill(i),e.makeTensorInfo(n,r,a)}else{const a=new $Ie(n,i),o=[[i]];return e.runWebGLProgram(a,[],r,o)}}const zIe={kernelName:aB,backendName:"webgl",kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GIe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HIe={kernelName:oB,backendName:"webgl",kernelFunc:({inputs:s,backend:e})=>{const{image:t}=s,n=e,i=new GIe(t.shape);return n.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rz="return floor(x);",VIe=ns({opSnippet:rz,packedOpSnippet:rz,cpuKernelImpl:lEe}),WIe={kernelName:I_,backendName:"webgl",kernelFunc:VIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XIe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,qIe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,jIe=Gr({opSnippet:XIe,packedOpSnippet:qIe,dtype:"int32"}),KIe={kernelName:D_,backendName:"webgl",kernelFunc:jIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YIe{constructor(e){this.variableNames=["A"];const t=Oa(),[n,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JIe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Oa(),[n,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZIe={kernelName:AD,backendName:"webgl",kernelFunc:QIe};let Oy,CI=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function QIe(s){const{inputs:e,backend:t,attrs:n}=s;let{pixels:i}=e;const{numChannels:r}=n,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,u]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],c=[u,l],f=[u,l,r];if(o||a){const S=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Oy==null||S!==CI)&&(CI=S,Oy=document.createElement("canvas").getContext("2d",{willReadFrequently:CI})),Oy.canvas.width=l,Oy.canvas.height=u,Oy.drawImage(i,0,0,l,u),i=Oy.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=ml.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),i);const g=Ie().getBool("WEBGL_PACK")?new JIe(f):new YIe(f),x=t.runWebGLProgram(g,[d],"int32");return t.disposeData(d.dataId),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eDe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:f,dimRoundingMode:d,activation:g,leakyreluAlpha:x}=n,S=Nf(c),b=Ar(i.shape,r.shape,l,f,u,d,!1,S);let _;const T=[],E=a!=null,C=o!=null,R=g==="leakyrelu",I=()=>{const P=[i,r],D=(O,F)=>{if(F==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const X=St({inputs:{x:O},backend:t,attrs:{shape:[O.shape[0],1,1]}});return T.push(X),X}return O};if(E&&P.push(D(a,c)),C&&P.push(D(o,c)),R){const O=t.makeTensorInfo([],"float32",_p(x,"float32"));P.push(O),T.push(O)}return P};if(b.filterHeight===1&&b.filterWidth===1&&b.dilationHeight===1&&b.dilationWidth===1&&b.strideHeight===1&&b.strideWidth===1&&(b.padInfo.type==="SAME"||b.padInfo.type==="VALID"))_=QX({x:i,filter:r,convInfo:b,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else if(b.strideWidth<=2&&S==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const P=g?Vb(g,!0):null,D=new ZX(b,E,P,C,R),O=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],F=I();_=t.runWebGLProgram(D,F,"float32",O)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))_=eq({x:i,filter:r,convInfo:b,backend:t,bias:a,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else{const P=g?Vb(g,!1):null,D=new JX(b,E,P,C,R),O=I();_=t.runWebGLProgram(D,O,"float32")}const L=St({inputs:{x:_},backend:t,attrs:{shape:b.outShape}});return T.push(_),T.forEach(P=>t.disposeIntermediateTensorInfo(P)),L}const tDe={kernelName:V2,backendName:"webgl",kernelFunc:eDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nDe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:f,activation:d,leakyreluAlpha:g}=n,x=[];let S=c;S==null&&(S=[1,1]),K(Ur(l,S),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${S}'`);const b=Ar(i.shape,r.shape,l,S,u,f,!0),_=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,T=d?Vb(d,_):null,E=[i,r],C=a!=null,R=o!=null,I=d==="leakyrelu";if(C&&E.push(a),R&&E.push(o),I){const O=t.makeTensorInfo([],"float32",_p(g,"float32"));E.push(O),x.push(O)}let L;_?L=new sq(b,C,T,R,I):L=new nq(b,C,T,R,I);const P=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],D=t.runWebGLProgram(L,E,"float32",P);return x.forEach(O=>t.disposeIntermediateTensorInfo(O)),D}const sDe={kernelName:W2,backendName:"webgl",kernelFunc:nDe};class iDe{constructor(e,t,n,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=n;const r=Es(n.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rDe(s){const{inputs:e,backend:t}=s,{params:n,indices:i}=e,r=i.shape,a=r[r.length-1],o=Xe(n.shape),[l,u,c,f]=Ok(n,i),d=St({inputs:{x:i},backend:t,attrs:{shape:[u,a]}}),g=St({inputs:{x:n},backend:t,attrs:{shape:[Xe(n.shape)/c,c]}});if(t.shouldExecuteOnCPU([n,i])||n.dtype==="string"){const _=t.readSync(i.dataId),T=t.bufferSync(n),E=uEe(_,T,n.dtype,u,a,c,f,n.shape,o);return t.makeTensorInfo(l,n.dtype,E.values)}const x=new iDe(a,f,[u,c],n.shape),S=t.runWebGLProgram(x,[g,d],g.dtype),b=St({inputs:{x:S},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(S),b}const aDe={kernelName:lB,backendName:"webgl",kernelFunc:rDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oDe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Es(this.rank),i=lDe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function lDe(s,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<s.length;i++)i===2?n.push("index"):n.push(`${t[i]}`);return n.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aq(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,indices:r}=e,{axis:a,batchDims:o}=n,l=kn(a,i.shape)[0];if(Ie().get("DEBUG")){const T=t.readSync(r.dataId),E=i.shape[l];for(let C=0;C<T.length;++C){const R=T[C];K(R<=E-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${E-1}]`)}}const u=sL(i,r,l,o),c=Xe(r.shape),f=[],d=St({inputs:{x:i},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),g=St({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});f.push(d),f.push(g);const x=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const T=t.bufferSync(g),E=t.bufferSync(d),C=cEe(E,T,x);return f.forEach(R=>t.disposeIntermediateTensorInfo(R)),t.makeTensorInfo(u.outputShape,C.dtype,C.values)}const S=new oDe(d.shape,x),b=t.runWebGLProgram(S,[d,g],d.dtype);f.push(b);const _=St({inputs:{x:b},backend:t,attrs:{shape:u.outputShape}});return f.forEach(T=>t.disposeIntermediateTensorInfo(T)),_}const uDe={kernelName:AE,backendName:"webgl",kernelFunc:aq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cDe="return float(a > b);",hDe=`
  return vec4(greaterThan(a, b));
`,fDe=Gr({opSnippet:cDe,packedOpSnippet:hDe,cpuKernelImpl:hEe,dtype:"bool"}),dDe={kernelName:TE,backendName:"webgl",kernelFunc:fDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pDe="return float(a >= b);",mDe=`
  return vec4(greaterThanEqual(a, b));
`,gDe=Gr({opSnippet:pDe,packedOpSnippet:mDe,dtype:"bool",cpuKernelImpl:fEe}),yDe={kernelName:O_,backendName:"webgl",kernelFunc:gDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xDe(s){const{inputs:e,backend:t}=s,{input:n}=e;return rq(n,!0,t)}const vDe={kernelName:uB,backendName:"webgl",kernelFunc:xDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bDe="return float(!isnan(x) && !isinf(x));",_De=ns({opSnippet:bDe,dtype:"bool"}),SDe={kernelName:k_,backendName:"webgl",kernelFunc:_De};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ADe="return float(isinf(x));",TDe=ns({opSnippet:ADe,dtype:"bool"}),wDe={kernelName:L_,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CDe="return float(isnan(x));",EDe=ns({opSnippet:CDe,dtype:"bool"}),MDe={kernelName:F_,backendName:"webgl",kernelFunc:EDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NDe="return float(a < b);",RDe=`
  return vec4(lessThan(a, b));
`,IDe=Gr({opSnippet:NDe,packedOpSnippet:RDe,cpuKernelImpl:dEe,dtype:"bool"}),DDe={kernelName:CE,backendName:"webgl",kernelFunc:IDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ODe="return float(a <= b);",BDe=`
  return vec4(lessThanEqual(a, b));
`,kDe=Gr({opSnippet:ODe,packedOpSnippet:BDe,cpuKernelImpl:pEe,dtype:"bool"}),LDe={kernelName:EE,backendName:"webgl",kernelFunc:kDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FDe(s){const{backend:e,attrs:t}=s,{start:n,stop:i,num:r}=t,a=mEe(n,i,r);return e.makeTensorInfo([a.length],"float32",a)}const PDe={kernelName:hB,backendName:"webgl",kernelFunc:FDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UDe=sv+`
  return x < 0.0 ? 0./0. : log(x);
`,$De=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,zDe=ns({opSnippet:UDe,packedOpSnippet:$De,cpuKernelImpl:gEe}),GDe={kernelName:P_,backendName:"webgl",kernelFunc:zDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HDe=sv+`
  return log(1.0 + x);
`,VDe=ns({opSnippet:HDe}),WDe={kernelName:U_,backendName:"webgl",kernelFunc:VDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XDe="return float(a >= 1.0 && b >= 1.0);",qDe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,jDe=Gr({opSnippet:XDe,packedOpSnippet:qDe,dtype:"bool"}),KDe={kernelName:ME,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YDe="return float(!(x >= 1.0));",JDe=ns({opSnippet:YDe}),ZDe={kernelName:NE,backendName:"webgl",kernelFunc:JDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QDe="return float(a >= 1.0 || b >= 1.0);",e3e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,t3e=Gr({opSnippet:QDe,packedOpSnippet:e3e,dtype:"bool"}),n3e={kernelName:RE,backendName:"webgl",kernelFunc:t3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s3e{constructor(e,t,n,i,r){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let l;const u=`float(${n}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${u})`:r===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i3e{constructor(e,t,n,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let l;const u=`float(${n}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${u})`:r===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3e=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{depthRadius:r,bias:a,alpha:o,beta:l}=n,u=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new i3e(i.shape,r,a,o,l):new s3e(i.shape,r,a,o,l);return t.runWebGLProgram(u,[i],i.dtype)},a3e={kernelName:IE,backendName:"webgl",kernelFunc:r3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o3e{constructor(e,t,n,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l3e=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:i,y:r,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=n,f=new o3e(i.shape,o,l,u,c);return t.runWebGLProgram(f,[i,r,a],i.dtype)},u3e={kernelName:fB,backendName:"webgl",kernelFunc:l3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3e(s,e,t,n){const i=Xe(e),a=Xe(s.shape)/i,o=St({inputs:{x:s},attrs:{shape:[a,i]},backend:n}),l=o0(o,s.dtype,"max",n),u=St({inputs:{x:l},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oq(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{reductionIndices:r,keepDims:a}=n,o=i.shape.length,l=kn(r,i.shape);let u=l;const c=ri(u,o),f=c!=null,d=t.shouldExecuteOnCPU([i]);let g=i;if(f){if(d){const E=t.texData.get(g.dataId).values,C=new Array(o);for(let L=0;L<C.length;L++)C[L]=i.shape[c[L]];const R=$L(E,i.shape,i.dtype,c,C);g=t.makeTensorInfo(C,i.dtype);const I=t.texData.get(g.dataId);I.values=R}else g=jM(i,c,t);u=Ri(u.length,o)}$r("max",u,o);const[x,S]=Tr(g.shape,u);let b=x;a&&(b=Ni(x,l));let _;if(d){const E=t.texData.get(g.dataId).values,C=yEe(E,Xe(S),b,i.dtype);_=t.makeTensorInfo(b,i.dtype);const R=t.texData.get(_.dataId);R.values=C}else _=c3e(g,S,b,t);return f&&t.disposeIntermediateTensorInfo(g),_}const h3e={kernelName:DE,backendName:"webgl",kernelFunc:oq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f3e=zL+`
  return max(a, b);
`,d3e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+a0+`
  return result;
`,p3e=Gr({opSnippet:f3e,packedOpSnippet:d3e,cpuKernelImpl:xEe}),m3e={kernelName:$_,backendName:"webgl",kernelFunc:p3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e;RS(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=n,u=1;K(Ur(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=pu(i.shape,r,a,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Wn(c.inShape,c.outShape))return $o({inputs:{x:i},backend:t});const f=new Wb(c,"max",!1);return t.runWebGLProgram(f,[i],i.dtype)}const y3e={kernelName:OE,backendName:"webgl",kernelFunc:g3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{filterSize:r,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=n,c=[1,1,1],f=Mf(i.shape,r,a,c,o,u,l),d=new HL(f,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const v3e={kernelName:BE,backendName:"webgl",kernelFunc:x3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,i=e.dilationHeight,r=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=r-1-e.padInfo.top,l=a-1-e.padInfo.left,u=r*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class _3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,f=l-1-e.padInfo.front,d=u-1-e.padInfo.top,g=c-1-e.padInfo.left,x=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${d}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${x} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3e(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r}=e,a=r,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=n,f=[1,1,1],d=Mf(a.shape,o,l,f,u,c),g=new HL(d,"max",!0),x=t.runWebGLProgram(g,[a],a.dtype),S=new _3e(d),b=t.runWebGLProgram(S,[i,x],a.dtype);return t.disposeIntermediateTensorInfo(x),b}const A3e={kernelName:pB,backendName:"webgl",kernelFunc:S3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3e(s){const{inputs:e,backend:t,attrs:n}=s,{dy:i,input:r,output:a}=e,o=r;RS([r,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:f}=n,d=pu(o.shape,l,u,1,c,f),g=!0,x=new Wb(d,"max",g),S=t.runWebGLProgram(x,[o],o.dtype),b=new b3e(d),_=t.runWebGLProgram(b,[i,S],o.dtype);return t.disposeIntermediateTensorInfo(S),_}const w3e={kernelName:dB,backendName:"webgl",kernelFunc:T3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3e(s,e,t,n){let i=new Wb(t,"max",!1);const r=n.runWebGLProgram(i,[s],"float32");i=new Wb(t,"max",!0,!0,e);const a=n.runWebGLProgram(i,[s],"float32");return[r,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E3e={kernelName:mB,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=e,l=t;K(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);const u=[1,1];K(Ur(r,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`);const c=pu(n.shape,i,r,u,a),[f,d]=C3e(n,o,c,l);return[f,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3e(s,e,t,n){const i=Xe(e),a=Xe(s.shape)/i,o=St({inputs:{x:s},attrs:{shape:[a,i]},backend:n}),l=o0(o,"float32","mean",n),u=St({inputs:{x:l},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3e={kernelName:kE,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{keepDims:i,axis:r}=e,a=t,o=n.shape.length,l=kn(r,n.shape);let u=l;const c=ri(u,o),f=c!=null,d=a.shouldExecuteOnCPU([n]),g=[];let x=n;if(f){if(d){const C=a.texData.get(x.dataId).values,R=new Array(o);for(let P=0;P<R.length;P++)R[P]=n.shape[c[P]];const I=$L(C,n.shape,n.dtype,c,R);x=a.makeTensorInfo(R,n.dtype);const L=a.texData.get(x.dataId);L.values=I}else x=jM(n,c,a);g.push(x),u=Ri(u.length,o)}$r("sum",u,o);const[S,b]=Tr(x.shape,u);let _=S;i&&(_=Ni(S,l));const T=M3e(x,b,_,a);for(const E of g)a.disposeIntermediateTensorInfo(E);return T}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3e(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n,o=i.shape.length,l=kn(r,i.shape);let u=l;const c=ri(u,o);let f=i;c!=null&&(f=Na({inputs:{x:i},backend:t,attrs:{perm:c}}),u=Ri(u.length,i.shape.length)),$r("min",u,o);const[d,g]=Tr(f.shape,u),x=Xe(g),S=St({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),b=o0(S,S.dtype,"min",t);let _;if(a){const T=Ni(d,l);_=St({inputs:{x:b},backend:t,attrs:{shape:T}})}else _=St({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(b),c!=null&&t.disposeIntermediateTensorInfo(f),_}const I3e={kernelName:LE,backendName:"webgl",kernelFunc:R3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3e=zL+`
  return min(a, b);
`,O3e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+a0+`
  return result;
`,B3e=Gr({opSnippet:D3e,packedOpSnippet:O3e,cpuKernelImpl:vEe}),k3e={kernelName:z_,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L3e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,f)=>c[0]+e[f]+c[1]);const i=e.length,r=Es(i),a=t.map(c=>c[0]).join(","),o=t.map((c,f)=>c[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),u=n==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F3e{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((x,S)=>x[0]+e[S]+x[1]);const i=e.length,r=Es(i),a=t.map(x=>x[0]).join(","),o=t.map((x,S)=>x[0]+e[S]).join(","),l=Ta("rc",i),u=Ta("source",i),c=`${l[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${u.slice(-2).join()})`,d=n==="reflect"?0:1;let g="";if(i===1){const x=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;g=`
        ${r} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${u.join()}), ${f});
        ${l[i-1]} += 1;
        if(${c}) {
          ${x}
          result[1] = getChannel(getX(${u.join()}), ${f});
        }
      `}else{const x=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;g=`
        ${r} rc = outputLoc;
        ${x}
        result[0] = getChannel(getX(${u.join()}), ${f});
        ${l[i-1]} += 1;
        if(${c}) {
          ${x}
          result[1] = getChannel(getX(${u.join()}), ${f});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${x}
          result[2] = getChannel(getX(${u.join()}), ${f});
          ${l[i-1]} += 1;
          if(${c}) {
            ${x}
            result[3] = getChannel(getX(${u.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P3e=({inputs:s,backend:e,attrs:t})=>{const{x:n}=s,{paddings:i,mode:r}=t,a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new F3e(n.shape,i,r):new L3e(n.shape,i,r);return e.runWebGLProgram(a,[n],n.dtype)},U3e={kernelName:FE,backendName:"webgl",kernelFunc:P3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $3e=`if (b == 0.0) return NAN;
  return mod(a, b);`,z3e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+a0+`
  return result;
`,G3e=Gr({opSnippet:$3e,packedOpSnippet:z3e}),H3e={kernelName:G_,backendName:"webgl",kernelFunc:G3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V3e{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W3e=`
if (a == b) {
  return 1.0;
};
return a / b;`,X3e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,lq=Gr({opSnippet:W3e,packedOpSnippet:X3e,checkOutOfBounds:!0}),q3e={kernelName:C_,backendName:"webgl",kernelFunc:lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const az="return a - b;",uq=Gr({opSnippet:az,packedOpSnippet:az,supportsComplex:!0,cpuKernelImpl:$Ee}),j3e={kernelName:iS,backendName:"webgl",kernelFunc:uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(s){const{inputs:e,backend:t,attrs:n}=s,{logits:i}=e,{dim:r}=n,a=kn([r],i.shape),o=oq({inputs:{x:i},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=Ni(o.shape,a),u=St({inputs:{x:o},backend:t,attrs:{shape:l}}),c=uq({inputs:{a:i,b:u},backend:t}),f=iq({inputs:{x:c},backend:t}),d=KM({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:!1}}),g=St({inputs:{x:d},backend:t,attrs:{shape:l}}),x=lq({inputs:{a:f,b:g},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),x}const K3e={kernelName:tM,backendName:"webgl",kernelFunc:cq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3e(s){const{inputs:e,backend:t,attrs:n}=s,{logits:i}=e,{numSamples:r,seed:a,normalized:o}=n,l=o?i:cq({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),u=l.shape[0],c=l.shape[1],f=new V3e(u,c,r),d=[[a]],g=t.runWebGLProgram(f,[l],"int32",d);return o||t.disposeIntermediateTensorInfo(l),g}const J3e={kernelName:gB,backendName:"webgl",kernelFunc:Y3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z3e=gu+`
  return -x;
`,Q3e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function eOe(s){const{inputs:e,backend:t}=s,{x:n}=e;if(t.shouldExecuteOnCPU([n])){const r=t.texData.get(n.dataId),[a,o]=_Ee(r.values,n.shape,n.dtype);return t.makeTensorInfo(o,n.dtype,a)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Vd(n.shape,Q3e):i=new eh(n.shape,Z3e),t.runWebGLProgram(i,[n],n.dtype)}const tOe={kernelName:PE,backendName:"webgl",kernelFunc:eOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nOe=Ck;function sOe(s){cl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=n,u=t.readSync(i.dataId),c=t.readSync(r.dataId),{selectedIndices:f}=nOe(u,c,a,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const iOe={kernelName:yB,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rOe=Ek;function aOe(s){cl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=n,c=t.readSync(i.dataId),f=t.readSync(r.dataId),{selectedIndices:d,validOutputs:g}=rOe(c,f,a,o,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const oOe={kernelName:xB,backendName:"webgl",kernelFunc:aOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lOe=Mk;function uOe(s){cl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=n,c=t.readSync(i.dataId),f=t.readSync(r.dataId),d=a,g=o,x=l,S=u,{selectedIndices:b,selectedScores:_}=lOe(c,f,d,g,x,S);return[t.makeTensorInfo([b.length],"int32",new Int32Array(b)),t.makeTensorInfo([_.length],"float32",new Float32Array(_))]}const cOe={kernelName:vB,backendName:"webgl",kernelFunc:uOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hOe{constructor(e,t,n,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${n}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fOe=s=>{const{inputs:e,backend:t,attrs:n}=s,{indices:i}=e,{dtype:r,depth:a,onValue:o,offValue:l}=n,u=Xe(i.shape),c=new hOe(u,a,o,l),f=St({inputs:{x:i},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[f],r);t.disposeIntermediateTensorInfo(f);const g=[...i.shape,a],x=St({inputs:{x:d},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(d),x},dOe={kernelName:zE,backendName:"webgl",kernelFunc:fOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gC(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="complex64"){const i=DS({inputs:{input:n},backend:t}),r=gC({inputs:{x:i},backend:t}),a=YM({inputs:{input:n},backend:t}),o=gC({inputs:{x:a},backend:t}),l=Ip({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return OS({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}const pOe={kernelName:rM,backendName:"webgl",kernelFunc:gC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hq(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){const i=DS({inputs:{input:n},backend:t}),r=hq({inputs:{x:i},backend:t}),a=YM({inputs:{input:n},backend:t}),o=gC({inputs:{x:a},backend:t}),l=Ip({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return OS({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}const mOe={kernelName:$E,backendName:"webgl",kernelFunc:hq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gOe(s){const{inputs:e,backend:t,attrs:n}=s,{axis:i}=n;if(e.length===1)return p3({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(c=>{zo(r,c.shape,"All tensors passed to stack must have matching shapes"),K(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(c=>{const f=p3({inputs:{input:c},backend:t,attrs:{dim:i}});return o.push(f),f}),u=YX({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const yOe={kernelName:GE,backendName:"webgl",kernelFunc:gOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xOe{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const i=e.length,r=Es(i),a=t.map(u=>u[0]).join(","),o=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vOe{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((S,b)=>S[0]+e[b]+S[1]);const i=e.length,r=Es(i),a=t.map(S=>S[0]).join(","),o=t.map((S,b)=>S[0]+e[b]).join(","),l=Ta("rc",i),u=Ta("source",i),c=`${l[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${c}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${c}) {`],g=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let S=0,b=i===1?2:4;S<b;S++)x+=`
        ${d[S]}
        if (${g}) {
          result[${S}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${S}] = getChannel(getX(${u.join()}), ${f});
        }
      `;x+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fq=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{paddings:r,constantValue:a}=n;if(Xe(i.shape)===0){const u=r.map((c,f)=>c[0]+i.shape[f]+c[1]);return OS({backend:t,attrs:{shape:u,value:a,dtype:i.dtype}})}const o=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vOe(i.shape,r,a):new xOe(i.shape,r,a),l=[[a]];return t.runWebGLProgram(o,[i],i.dtype,l)},bOe={kernelName:HE,backendName:"webgl",kernelFunc:fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Oe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,SOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+a0+`
  return result;
`,AOe=Gr({opSnippet:_Oe,packedOpSnippet:SOe}),TOe={kernelName:V_,backendName:"webgl",kernelFunc:AOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wOe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{axis:r,keepDims:a}=n,o=i.shape.length,l=[],u=kn(r,i.shape);let c=u;const f=ri(c,o);let d=i;f!=null&&(d=Na({inputs:{x:i},backend:t,attrs:{perm:f}}),c=Ri(c.length,o),l.push(d)),$r("prod",c,o);let g;if(t.shouldExecuteOnCPU([d])){const x=t.texData.get(d.dataId).values,{outVals:S,outShape:b,outDtype:_}=AEe(d.shape,d.dtype,x,c);g=t.makeTensorInfo(b,_,S)}else{const[x,S]=Tr(d.shape,c),b=Xe(S),_=St({inputs:{x:d},backend:t,attrs:{shape:[-1,b]}}),T=VB(i.dtype),E=o0(_,T,"prod",t);g=St({inputs:{x:E},backend:t,attrs:{shape:x}}),l.push(_),l.push(E)}if(a){l.push(g);const x=Ni(g.shape,u);g=St({inputs:{x:g},backend:t,attrs:{shape:x}})}return l.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const COe={kernelName:WE,backendName:"webgl",kernelFunc:wOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EOe(s){const{inputs:e,backend:t,attrs:n}=s,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=e,{outputRaggedRank:o}=n,l=i.map(_=>t.readSync(_.dataId)),u=i.map(_=>_.shape),c=t.readSync(r.dataId),f=t.readSync(a.dataId),[d,g,x]=TEe(l,u,c,r.shape,r.dtype,f,a.shape,o),S=d.map(_=>t.makeTensorInfo([_.length],"int32",_)),b=t.makeTensorInfo(x,r.dtype,g);return S.concat([b])}const MOe={kernelName:bB,backendName:"webgl",kernelFunc:EOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NOe(s){const{inputs:e,backend:t}=s,{starts:n,limits:i,deltas:r}=e,a=t.readSync(n.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[u,c]=wEe(a,n.shape,n.dtype,o,i.shape,l,r.shape),f=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],n.dtype,c);return[f,d]}const ROe={kernelName:_B,backendName:"webgl",kernelFunc:NOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IOe(s){const{inputs:e,backend:t,attrs:n}=s,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=n,u=t.readSync(i.dataId),c=t.readSync(r.dataId),f=t.readSync(a.dataId),d=o.map(b=>t.readSync(b.dataId)),g=o.map(b=>b.shape),[x,S]=CEe(u,i.shape,c,r.shape,r.dtype,f,a.shape,d,g,l);return t.makeTensorInfo(x,r.dtype,S)}const DOe={kernelName:SB,backendName:"webgl",kernelFunc:IOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dq=s=>{const{backend:e,attrs:t}=s,{start:n,stop:i,step:r,dtype:a}=t,o=EEe(n,i,r,a);return e.makeTensorInfo([o.length],a,o)},OOe={kernelName:AB,backendName:"webgl",kernelFunc:dq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BOe="return 1.0 / x;",kOe=ns({opSnippet:BOe}),LOe={kernelName:W_,backendName:"webgl",kernelFunc:kOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FOe=gu+`
  return (x < 0.0) ? 0.0 : x;
`,POe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UOe=ns({opSnippet:FOe,packedOpSnippet:POe}),$Oe={kernelName:X_,backendName:"webgl",kernelFunc:UOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zOe=gu+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,GOe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HOe=ns({opSnippet:zOe,packedOpSnippet:GOe}),VOe={kernelName:q_,backendName:"webgl",kernelFunc:HOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WOe{constructor(e,t,n,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,u]=e;this.outputShape=[a,t,n,u];const c=[i&&t>1?o-1:o,i&&n>1?l-1:l],f=[i&&t>1?t-1:t,i&&n>1?n-1:n];let d;r?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/f[0]},
          ${c[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XOe{constructor(e,t,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,u]=e;this.outputShape=[a,t,n,u];const c=[i&&t>1?o-1:o,i&&n>1?l-1:l],f=[i&&t>1?t-1:t,i&&n>1?n-1:n];let d;r?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/f[0]},
          ${c[1]/f[1]},
          ${c[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qOe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=n,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new XOe(i.shape,l,u,r,a):new WOe(i.shape,l,u,r,a);return t.runWebGLProgram(c,[i],"float32")}const jOe={kernelName:jE,backendName:"webgl",kernelFunc:qOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KOe{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,a,o]=e,l=[n&&a>1?i-1:i,n&&o>1?r-1:r],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=l[0]/u[0],f=l[1]/u[1],d=1/c,g=1/f,x=Math.ceil(d)*2+2,S=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${f});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${S});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YOe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i,dy:r}=e,{alignCorners:a}=n,o=new KOe(r.shape,i.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const JOe={kernelName:CB,backendName:"webgl",kernelFunc:YOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZOe{constructor(e,t,n,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,u]=e;this.outputShape=[a,t,n,u];const c=[i&&t>1?o-1:o,i&&n>1?l-1:l],f=[i&&t>1?t-1:t,i&&n>1?n-1:n],d=i?"0.5":"0.0";let g;r?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/f[0]},
          ${c[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QOe{constructor(e,t,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,u]=e;this.outputShape=[a,t,n,u];const c=[i&&t>1?o-1:o,i&&n>1?l-1:l],f=[i&&t>1?t-1:t,i&&n>1?n-1:n],d=i?"0.5":"0.0";let g;r?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/f[0]},
          ${c[1]/f[1]},
          ${c[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eBe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=n,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new QOe(i.shape,l,u,r,a):new ZOe(i.shape,l,u,r,a);return t.runWebGLProgram(c,[i],i.dtype)}const tBe={kernelName:qE,backendName:"webgl",kernelFunc:eBe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nBe{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,a,o]=e,l=[n&&a>1?i-1:i,n&&o>1?r-1:r],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],c=l[0]/u[0],f=l[1]/u[1],d=1/c,g=1/f,x=Math.ceil(d)*2+2,S=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${f});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${g});

        const int winHeight = int(${x});
        const int winWidth = int(${S});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sBe(s){const{inputs:e,backend:t,attrs:n}=s,{images:i,dy:r}=e,{alignCorners:a}=n,o=new nBe(r.shape,i.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const iBe={kernelName:wB,backendName:"webgl",kernelFunc:sBe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rBe{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,r=e.map((o,l)=>i(l)).join(","),a=Es(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aBe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const i=Ta("rc",n),r=`${i[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${i[n-2]} + 1 < ${this.outputShape[n-2]}`,o=Es(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${u(i.slice())};
          }
          if(${a}) {
            result.b = ${c(i.slice())};
            if(${r}) {
              result.a = ${f(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(x){return d(x)}function u(x){return x[n-1]="("+x[n-1]+" + 1)",d(x)}function c(x){return x[n-2]="("+x[n-2]+" + 1)",d(x)}function f(x){return x[n-1]="("+x[n-1]+" + 1)",x[n-2]="("+x[n-2]+" + 1)",d(x)}function d(x){const S=e.map((T,E)=>g(E,x)),b=S.join(","),_=S.slice(-2).join(",");return`getChannel(getX(${b}), vec2(${_}))`}function g(x,S){return t.indexOf(x)!==-1&&e[x]!==1?`${e[x]} - ${S[x]} - 1`:`${S[x]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oBe(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{dims:r}=n,a=i.shape.length,o=kn(r,i.shape);if(a===0)return $o({inputs:{x:i},backend:t});const l=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aBe(i.shape,o):new rBe(i.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const lBe={kernelName:KE,backendName:"webgl",kernelFunc:oBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uBe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cBe={kernelName:HB,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,{radians:i,fillValue:r,center:a}=e,o=t,l=new uBe(n.shape,r),[u,c]=zk(a,n.shape[1],n.shape[2]),f=[[u,c,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[n],n.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hBe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,fBe=ns({opSnippet:hBe}),dBe={kernelName:j_,backendName:"webgl",kernelFunc:fBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pBe="return inversesqrt(x);",mBe=ns({opSnippet:pBe,cpuKernelImpl:MEe}),gBe={kernelName:K_,backendName:"webgl",kernelFunc:mBe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VL{constructor(e,t,n,i,r,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=Es(r.length),c=Es(a.length);let f="";n===1?f="i":n===2&&(f="i, j");const d=`getIndices(${f})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let S="";l&&(S="coords[0], coords[1]");const b=`getDefaultValue(${S})`,_=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${_};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${x};
              found = true;
            }
          }
          setOutput(mix(${b}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yBe{constructor(e,t,n,i,r,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=Es(r.length),c=Es(a.length);let f="";n===1?f="i":n===2&&(f="i, j");const d=`getIndices(${f})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const x=`getUpdates(${g})`;let S="";l&&(S="coords[0], coords[1]");const b=`getDefaultValue(${S})`,_=t>1?"strides[j]":"strides",T=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${_};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${x};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${b}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xBe(s){const{inputs:e,backend:t,attrs:n}=s,{indices:i,updates:r}=e,{shape:a}=n,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:f}=t0(r,i,a),d=[f/u,u];if(f===0)return t.makeTensorInfo(a,i.dtype);const g=St({inputs:{x:i},backend:t,attrs:{shape:[l,o]}}),x=St({inputs:{x:r},backend:t,attrs:{shape:[l,u]}}),S=t.makeTensorInfo([],"float32",new Float32Array([0]));let b;Ie().getBool("WEBGL_PACK")?b=new yBe(l,o,g.shape.length,x.shape.length,c,d):b=new VL(l,o,g.shape.length,x.shape.length,c,d);const _=t.runWebGLProgram(b,[x,g,S],x.dtype),T=St({inputs:{x:_},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(S),T}const vBe={kernelName:EB,backendName:"webgl",kernelFunc:xBe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bBe{constructor(e,t,n,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=Ie().getNumber("WEBGL_VERSION")===2?r:a,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Be(s){const{inputs:e,backend:t,attrs:n}=s,{sortedSequence:i,values:r}=e,{side:a}=n,o=new bBe(i.shape[0],i.shape[1],r.shape[1],a),l=[[i.shape[1]]];return t.runWebGLProgram(o,[i,r],"int32",l)}const SBe={kernelName:NB,backendName:"webgl",kernelFunc:_Be};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ABe{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let i,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${o[c]}`),c<e&&l.push(`${o[c]}`);i=l.join(),r=u.join()}const a=Es(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TBe(s){const{inputs:e,backend:t}=s,{condition:n,t:i,e:r}=e,a=new ABe(n.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(a,[n,i,r],ko(i.dtype,r.dtype))}const wBe={kernelName:YE,backendName:"webgl",kernelFunc:TBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CBe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${DM};
  float scale = ${OM};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,EBe=ns({opSnippet:CBe}),MBe={kernelName:Y_,backendName:"webgl",kernelFunc:EBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NBe=sv+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,RBe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,IBe=ns({opSnippet:NBe,packedOpSnippet:RBe,cpuKernelImpl:REe}),DBe={kernelName:eS,backendName:"webgl",kernelFunc:IBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OBe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,BBe=ns({opSnippet:OBe}),kBe={kernelName:Q_,backendName:"webgl",kernelFunc:BBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LBe=sv+`
  return sin(x);
`,FBe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${a0}
  return result;
`,PBe=ns({opSnippet:LBe,packedOpSnippet:FBe}),UBe={kernelName:J_,backendName:"webgl",kernelFunc:PBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Be=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,zBe=ns({opSnippet:$Be}),GBe={kernelName:Z_,backendName:"webgl",kernelFunc:zBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HBe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,VBe=ns({opSnippet:HBe}),WBe={kernelName:tS,backendName:"webgl",kernelFunc:VBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XBe=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{blockShape:r,paddings:a}=n;K(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((_,T)=>_*T),l=[[0,0]];l.push(...a);for(let _=1+r.length;_<i.shape.length;++_)l.push([0,0]);const u=[],c=fq({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),f=yS(c.shape,r,o,!1),d=xS(f.length,r.length,!1),g=vS(c.shape,r,o,!1),x=St({inputs:{x:c},backend:t,attrs:{shape:f}}),S=Na({inputs:{x},backend:t,attrs:{perm:d}}),b=St({inputs:{x:S},backend:t,attrs:{shape:g}});return u.push(c),u.push(x),u.push(S),u.forEach(_=>t.disposeIntermediateTensorInfo(_)),b},qBe={kernelName:QE,backendName:"webgl",kernelFunc:XBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jBe(s){const{inputs:e,backend:t}=s,{indices:n,values:i,denseShape:r,defaultValue:a}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(n.dataId),l=t.readSync(i.dataId),u=t.readSync(r.dataId),c=t.readSync(a.dataId)[0],[f,d,g,x,S]=DEe(o,n.shape,n.dtype,l,i.dtype,u,c);return[t.makeTensorInfo(d,n.dtype,f),t.makeTensorInfo([d[0]],i.dtype,g),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(b=>Number(b)))),t.makeTensorInfo([S.length],n.dtype,new Int32Array(S))]}const KBe={kernelName:RB,backendName:"webgl",kernelFunc:jBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YBe(s){const{inputs:e,backend:t}=s,{inputIndices:n,inputShape:i,newShape:r}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(t.readSync(i.dataId)),o=t.readSync(n.dataId),l=Array.from(t.readSync(r.dataId)),[u,c,f]=OEe(o,n.shape,n.dtype,a,l);return[t.makeTensorInfo(c,n.dtype,u),t.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const JBe={kernelName:IB,backendName:"webgl",kernelFunc:YBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZBe(s){const{inputs:e,backend:t}=s,{data:n,indices:i,segmentIds:r}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const a=t.readSync(n.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[u,c]=FX(a,n.shape,n.dtype,o,l,!0);return t.makeTensorInfo(c,n.dtype,u)}const QBe={kernelName:DB,backendName:"webgl",kernelFunc:ZBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eke(s){const{inputs:e,backend:t}=s,{data:n,indices:i,segmentIds:r}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const a=t.readSync(n.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[u,c]=FX(a,n.shape,n.dtype,o,l);return t.makeTensorInfo(c,n.dtype,u)}const tke={kernelName:OB,backendName:"webgl",kernelFunc:eke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nke(s){const{inputs:e,backend:t,attrs:n}=s,{sparseIndices:i,sparseValues:r,defaultValue:a}=e,{outputShape:o}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:f,outputSize:d}=t0(r,i,o),g=!1;if(r.dtype==="string"){const _=t.bufferSync(i),T=t.bufferSync(r),E=ap(t.readSync(a.dataId)[0]),C=NEe(_,T,o,d,c,u,l,f,E,g);return t.makeTensorInfo(o,C.dtype,C.values)}const x=new VL(u,l,i.shape.length,r.shape.length,f,[d,1],g),S=t.runWebGLProgram(x,[r,i,a],r.dtype),b=St({inputs:{x:S},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(S),b}const ske={kernelName:BB,backendName:"webgl",kernelFunc:nke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ike(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{numOrSizeSplits:r,axis:a}=n,o=kn(a,i.shape)[0],l=nL(i,r,o),u=i.shape.length,c=new Array(u).fill(0),f=i.shape.slice();return l.map(d=>{const g=[...f];g[o]=d;const x=iv({inputs:{x:i},backend:t,attrs:{begin:c,size:g}});return c[o]+=d,x})}const rke={kernelName:eM,backendName:"webgl",kernelFunc:ike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oz="return sqrt(x);",ake=ns({opSnippet:oz,packedOpSnippet:oz,cpuKernelImpl:BEe}),oke={kernelName:nS,backendName:"webgl",kernelFunc:ake};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lke="return x * x;",uke=ns({opSnippet:lke}),cke={kernelName:kB,backendName:"webgl",kernelFunc:uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lz="return (a - b) * (a - b);",hke=Gr({opSnippet:lz,packedOpSnippet:lz}),fke={kernelName:sS,backendName:"webgl",kernelFunc:hke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dke(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const r=t.readSync(i.dataId),a=wf(r),o=kEe(a,"string",n);return t.makeTensorInfo(i.shape,"string",o)}const pke={kernelName:nM,backendName:"webgl",kernelFunc:dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mke({inputs:s,attrs:e,backend:t}){const{x:n}=s,i=gu+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,r=new eh(n.shape,i);return t.runWebGLProgram(r,[n],n.dtype)}const gke={kernelName:lS,backendName:"webgl",kernelFunc:mke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yke{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const i=n.length,r=Es(n.length),a=Es(n.length);let o="";if(i===1)o="coords * strides + begin";else{let l=0;o=n.map((u,c)=>(l++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xke(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{begin:r,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:f,shrinkAxisMask:d}=n,{finalShapeSparse:g,finalShape:x,isIdentity:S,sliceDim0:b,isSimpleSlice:_,begin:T,end:E,strides:C}=Pk(i.shape,r,a,o,l,u,c,f,d);let R;if(S)R=St({inputs:{x:i},backend:t,attrs:{shape:x}});else if(b||_){K(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const L=kk(T,E,C),P=iv({inputs:{x:i},backend:t,attrs:{begin:T,size:L}});R=St({inputs:{x:P},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(P)}else if(t.shouldExecuteOnCPU([i])){const P=t.readSync(i.dataId),D=Mn(i.shape,i.dtype,P),O=LEe(g,D,C,T);R=t.makeTensorInfo(x,i.dtype,O.values)}else{const P=new yke(T,C,g);R=t.runWebGLProgram(P,[i],i.dtype)}const I=St({inputs:{x:R},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(R),I}const vke={kernelName:LB,backendName:"webgl",kernelFunc:xke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bke(s){const{inputs:e,backend:t,attrs:n}=s,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=n,{data:c,dataSplits:f}=e,d=t.readSync(c.dataId),g=t.readSync(f.dataId),[x,S]=FEe(d,g,i,r,a,o,l,u);return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(f.shape,"int32",S)]}const _ke={kernelName:FB,backendName:"webgl",kernelFunc:bke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ske(s){const{inputs:e,backend:t,attrs:n}=s,{skipEmpty:i}=n,{input:r,delimiter:a}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(r.dataId),l=t.readSync(a.dataId)[0],[u,c,f]=PEe(o,l,i),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const Ake={kernelName:PB,backendName:"webgl",kernelFunc:Ske};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tke(s){const{inputs:e,backend:t,attrs:n}=s,{numBuckets:i}=n,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(r.dataId),o=UEe(a,i);return t.makeTensorInfo(r.shape,"int32",o)}const wke={kernelName:UB,backendName:"webgl",kernelFunc:Tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cke="return tan(x);",Eke=ns({opSnippet:Cke}),Mke={kernelName:rS,backendName:"webgl",kernelFunc:Eke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nke=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Rke=ns({opSnippet:Nke}),Ike={kernelName:aS,backendName:"webgl",kernelFunc:Rke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dke(s){const{inputs:e,backend:t,attrs:n}=s,{tensor:i,indices:r,updates:a}=e,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:f}=t0(a,r,i.shape),d=[f/u,u];if(f===0)return t.makeTensorInfo(i.shape,r.dtype);const g=St({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),x=St({inputs:{x:a},backend:t,attrs:{shape:[l,u]}}),S=St({inputs:{x:i},backend:t,attrs:{shape:d}}),b=new VL(l,o,g.shape.length,x.shape.length,c,d,!1,!0),_=t.runWebGLProgram(b,[x,g,S],S.dtype),T=St({inputs:{x:_},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(_),T}const Oke={kernelName:MB,backendName:"webgl",kernelFunc:Dke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bke{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const i=Es(this.rank),r=kke(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function kke(s){const e=s.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${s[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let i=0;i<s.length;i++)n.push(`imod(${t[i]}, ${s[i]})`);return n.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pq(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{reps:r}=n;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),u=i.dtype==="string"?l.map(d=>ap(d)):l,c=Mn(i.shape,i.dtype,u),f=zEe(c,r);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new Bke(i.shape,r);return t.runWebGLProgram(a,[i],i.dtype)}const Lke={kernelName:oS,backendName:"webgl",kernelFunc:pq};class Fke{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Pke{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gm(s,e){e!==null&&s.disposeIntermediateTensorInfo(e)}function uz(s){let e=1;for(;e<s;)e*=2;return e}function Uke(s){const{inputs:e,backend:t,attrs:n}=s,{x:i}=e,{k:r,sorted:a}=n,o=Ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=i.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([i])||c<o||r>l){const O=t.readSync(i.dataId),[F,X]=GEe(O,u,i.dtype,r,a);return[t.makeTensorInfo(F.shape,F.dtype,F.values),t.makeTensorInfo(X.shape,X.dtype,X.values)]}if(r===0)return u[u.length-1]=0,[t.makeTensorInfo(u,i.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[i,OS({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const f=t.texData.get(i.dataId),d=f!==null&&f.isPacked,g=d?t.unpackTensor(i):i,S=Xe(u)/c,b=St({inputs:{x:g},attrs:{shape:[S,c]},backend:t});d&&Gm(t,g);const _=uz(r),T=uz(c);let E=null;const C=()=>E===null?[b,b]:[b,E],R=(O,F,X)=>{const q=C(),J=new Fke(X),$=[[c],[E===null?1:0],[Number.NEGATIVE_INFINITY],[O],[F]],W=E;E=t.runWebGLProgram(J,q,"int32",$),Gm(t,W)};for(let O=1;O<_;O*=2){const F=O*2;for(let X=O;X>=1;X/=2)R(F,X,[S,T])}for(let O=T;O>_;O/=2){const F=C(),X=new Pke([S,O/2]),J=[[c],[E===null?1:0],[_]],Y=E;E=t.runWebGLProgram(X,F,"int32",J),Gm(t,Y);const $=_/2,W=$*2;for(let V=$;V>=1;V/=2)R(W,V,E.shape)}let I=E;E=iv({inputs:{x:E},backend:t,attrs:{begin:0,size:[S,r]}}),Gm(t,I);let L=aq({inputs:{x:b,indices:E},backend:t,attrs:{axis:1,batchDims:1}});Gm(t,b);const P=u.slice(0,-1);P.push(r),I=E,E=St({inputs:{x:E},attrs:{shape:P},backend:t}),Gm(t,I);const D=L;return L=St({inputs:{x:L},attrs:{shape:P},backend:t}),Gm(t,D),[L,E]}const $ke={kernelName:$B,backendName:"webgl",kernelFunc:Uke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zke{constructor(e,t,n,i,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=n==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gke(s){const{inputs:e,backend:t,attrs:n}=s,{image:i,transforms:r}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,f,d,g]=i.shape,[x,S]=u??[f,d],b=[c,x,S,g],_=new zke(f,d,a,o,l,b);return t.runWebGLProgram(_,[i,r],"float32")}const Hke={kernelName:zB,backendName:"webgl",kernelFunc:Gke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vke(s){const{inputs:e,attrs:t,backend:n}=s,{axis:i}=t,{x:r}=e;RS(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=n.readSync(r.dataId),{outputValues:o,outputShape:l,indices:u}=HEe(a,i,r.shape,r.dtype);return[n.makeTensorInfo(l,r.dtype,o),n.makeTensorInfo([u.length],"int32",u)]}const Wke={kernelName:GB,backendName:"webgl",kernelFunc:Vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xke(s){const{inputs:e,backend:t,attrs:n}=s,{value:i}=e;let{axis:r}=n;r<0&&(r+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[r],u=new Array(o-1);let c=0;for(let S=0;S<o;S++)S!==r&&(u[c++]=a.shape[S]);const f=[],d=new Array(o).fill(0),g=a.shape.slice();g[r]=1;const x=new Array(l);for(let S=0;S<x.length;S++){d[r]=S;const b=iv({inputs:{x:a},backend:t,attrs:{begin:d,size:g}}),_=St({inputs:{x:b},backend:t,attrs:{shape:u}});x[S]=_,f.push(b)}return f.forEach(S=>t.disposeIntermediateTensorInfo(S)),x}const qke={kernelName:sM,backendName:"webgl",kernelFunc:Xke};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jke{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,i=e.batchSize,r=e.inSize,a=e.numSegments,o=a*Math.ceil(r/n);this.outputShape=[i,o];const l="0.0",u="sumValue",c=Math.floor(n/4)*4,f=n%4,d=`
        sumValue += dot(values, segFilter);
    `;let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let x="";r%n>0&&(x=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${x}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kke(s){const{inputs:e,backend:t,attrs:n}=s,{x:i,segmentIds:r}=e,{numSegments:a}=n,o=i.shape.length,l=[];let u=0;const c=ri([u],o);let f=i;c!=null&&(f=Na({inputs:{x:i},backend:t,attrs:{perm:c}}),l.push(f),u=Ri(1,o)[0]);const d=WH(f.shape,u,a),g=Xe([f.shape[u]]),x=St({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}});l.push(x);const S=VB(i.dtype),b=(C,R,I,L,P)=>{const D=C.shape[0],O=C.shape[1],F=VH(O,P),X={windowSize:F,inSize:O,batchSize:D,numSegments:P},q=new jke(X,R),J=t.compileAndRun(q,[C,I],L);if(l.push(J),J.shape[1]===P)return J;const Y=dq({backend:t,attrs:{start:0,stop:P,step:1,dtype:"float32"}}),$=pq({inputs:{x:Y},backend:t,attrs:{reps:[O/F]}});return l.push(Y),l.push($),b(J,R,$,L,P)},_=b(x,"unsortedSegmentSum",r,S,a),T=St({inputs:{x:_},backend:t,attrs:{shape:d}});let E=T;if(c!=null){l.push(T);const C=wp(c);E=Na({inputs:{x:E},backend:t,attrs:{perm:C}})}return l.forEach(C=>t.disposeIntermediateTensorInfo(C)),E}const Yke={kernelName:iM,backendName:"webgl",kernelFunc:Kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jke=[BMe,LMe,UMe,GMe,VMe,qMe,KMe,JMe,tNe,sNe,aNe,uNe,fNe,gNe,vNe,_Ne,ANe,ENe,NNe,INe,kNe,GNe,VNe,jNe,YNe,nRe,iRe,lRe,yMe,hRe,gRe,bRe,CRe,NRe,IRe,ORe,kRe,URe,GRe,WRe,qRe,KRe,JRe,eIe,nIe,aIe,lIe,hIe,pIe,gIe,bIe,TIe,MIe,IIe,BIe,kIe,FIe,UIe,zIe,HIe,WIe,KIe,ZIe,tDe,sDe,aDe,uDe,dDe,yDe,gMe,vDe,pRe,SDe,wDe,MDe,vMe,DDe,LDe,PDe,GDe,WDe,KDe,ZDe,n3e,a3e,u3e,h3e,m3e,y3e,v3e,A3e,w3e,E3e,N3e,I3e,k3e,U3e,H3e,J3e,SMe,tOe,iOe,oOe,cOe,ZNe,dOe,mOe,yOe,bOe,TOe,_Me,COe,MOe,ROe,DOe,OOe,QNe,q3e,LOe,$Oe,VOe,TMe,jOe,JOe,tBe,iBe,lBe,cBe,dBe,gBe,vBe,SBe,wBe,MBe,DBe,kBe,UBe,GBe,$Ne,K3e,WBe,qBe,KBe,JBe,QBe,tke,ske,rke,oke,cke,fke,pke,gke,vke,_ke,Ake,wke,j3e,IMe,Mke,Ike,Oke,Lke,$ke,Hke,DMe,Wke,qke,Yke,pOe];for(const s of Jke)m8(s);/**
    * @license
    * Copyright 2020 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var m3=function(){return(m3=Object.assign||function(s){for(var e,t=1,n=arguments.length;t<n;t++)for(var i in e=arguments[t])Object.prototype.hasOwnProperty.call(e,i)&&(s[i]=e[i]);return s}).apply(this,arguments)};function bg(s,e,t,n){return new(t||(t=Promise))(function(i,r){function a(u){try{l(n.next(u))}catch(c){r(c)}}function o(u){try{l(n.throw(u))}catch(c){r(c)}}function l(u){var c;u.done?i(u.value):(c=u.value,c instanceof t?c:new t(function(f){f(c)})).then(a,o)}l((n=n.apply(s,[])).next())})}function _g(s,e){var t,n,i,r,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(r[Symbol.iterator]=function(){return this}),r;function o(l){return function(u){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,n&&(i=2&c[0]?n.return:c[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,c[1])).done)return i;switch(n=0,i&&(c=[2&c[0],i.value]),c[0]){case 0:case 1:i=c;break;case 4:return a.label++,{value:c[1],done:!1};case 5:a.label++,n=c[1],c=[0];continue;case 7:c=a.ops.pop(),a.trys.pop();continue;default:if(i=a.trys,!((i=i.length>0&&i[i.length-1])||c[0]!==6&&c[0]!==2)){a=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){a.label=c[1];break}if(c[0]===6&&a.label<i[1]){a.label=i[1],i=c;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(c);break}i[2]&&a.ops.pop(),a.trys.pop();continue}c=e.call(s,a)}catch(f){c=[6,f],n=0}finally{t=i=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}const mq=s=>({startEndTensor:s,startPoint:bn(s,[0,0],[-1,2]),endPoint:bn(s,[0,2],[-1,2])}),Zke={strides:[8,16],anchors:[2,6]};function cz(s,e){let t,n,i;if(s.topLeft instanceof ls&&s.bottomRight instanceof ls){const[a,o]=we(()=>[js([wt(e-1,s.topLeft.slice(0,1)),s.topLeft.slice(1,1)]),js([wt(e-1,s.bottomRight.slice(0,1)),s.bottomRight.slice(1,1)])]);t=a,n=o,s.landmarks!=null&&(i=we(()=>{const l=wt(mi([e-1,0]),s.landmarks),u=mi([1,-1]);return pe(l,u)}))}else{const[a,o]=s.topLeft,[l,u]=s.bottomRight;t=[e-1-a,o],n=[e-1-l,u],s.landmarks!=null&&(i=s.landmarks.map(c=>[e-1-c[0],c[1]]))}const r={topLeft:t,bottomRight:n};return i!=null&&(r.landmarks=i),s.probability!=null&&(r.probability=s.probability instanceof ls?s.probability.clone():s.probability),r}function hz(s,e){return we(()=>{let t;return t=s.hasOwnProperty("box")?s.box:s,((n,i)=>{const r=pe(n.startPoint,i),a=pe(n.endPoint,i),o=uM([r,a],1);return mq(o)})(t,e).startEndTensor.squeeze()})}class Qke{constructor(e,t,n,i,r,a){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=i,this.anchorsData=function(o,l,u){const c=[];for(let f=0;f<u.strides.length;f++){const d=u.strides[f],g=Math.floor((l+d-1)/d),x=Math.floor((o+d-1)/d),S=u.anchors[f];for(let b=0;b<g;b++){const _=d*(b+.5);for(let T=0;T<x;T++){const E=d*(T+.5);for(let C=0;C<S;C++)c.push([E,_])}}}return c}(t,n,Zke),this.anchors=Jd(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=mi([t,n]),this.iouThreshold=r,this.scoreThreshold=a}async getBoundingBoxes(e,t,n=!0){const[i,r,a]=we(()=>{const S=e.resizeBilinear([this.width,this.height]),b=pe(wt(S.div(255),.5),2),_=this.blazeFaceModel.predict(b).squeeze(),T=function(C,R,I){const L=bn(C,[0,1],[-1,2]),P=it(L,R),D=bn(C,[0,3],[-1,2]),O=Ut(D,I),F=Ut(P,I),X=Ut(O,2),q=wt(F,X),J=it(F,X),Y=pe(q,I),$=pe(J,I);return uM([Y,$],1)}(_,this.anchors,this.inputSize),E=bn(_,[0,0],[-1,1]);return[_,T,ec(E).squeeze()]}),o=console.warn;console.warn=()=>{};const l=pl.nonMaxSuppression(r,a,this.maxFaces,this.iouThreshold,this.scoreThreshold);console.warn=o;const u=await l.array();l.dispose();let c=u.map(S=>bn(r,[S,0],[1,-1]));t||(c=await Promise.all(c.map(async S=>{const b=await S.array();return S.dispose(),b})));const f=e.shape[1],d=e.shape[2];let g;g=t?Ut([d,f],this.inputSize):[d/this.inputSizeData[0],f/this.inputSizeData[1]];const x=[];for(let S=0;S<c.length;S++){const b=c[S],_=we(()=>{const T=mq(b instanceof ls?b:Jd(b));if(!n)return T;const E=u[S];let C;return C=t?this.anchors.slice([E,0],[1,2]):this.anchorsData[E],{box:T,landmarks:bn(i,[E,5],[1,-1]).squeeze().reshape([6,-1]),probability:bn(a,[E],[1]),anchor:C}});x.push(_)}return r.dispose(),a.dispose(),i.dispose(),{boxes:x,scaleFactor:g}}async estimateFaces(e,t=!1,n=!1,i=!0){const[,r]=function(u){return u instanceof ls?[u.shape[0],u.shape[1]]:[u.height,u.width]}(e),a=we(()=>(e instanceof ls||(e=dH(e)),e.toFloat().expandDims(0))),{boxes:o,scaleFactor:l}=await this.getBoundingBoxes(a,t,i);return a.dispose(),t?o.map(u=>{const c=hz(u,l);let f={topLeft:c.slice([0],[2]),bottomRight:c.slice([2],[2])};if(i){const{landmarks:d,probability:g,anchor:x}=u,S=d.add(x).mul(l);f.landmarks=S,f.probability=g}return n&&(f=cz(f,r)),f}):Promise.all(o.map(async u=>{const c=hz(u,l);let f;if(i){const[d,g,x]=await Promise.all([u.landmarks,c,u.probability].map(async E=>E.array())),S=u.anchor,[b,_]=l,T=d.map(E=>[(E[0]+S[0])*b,(E[1]+S[1])*_]);f={topLeft:g.slice(0,2),bottomRight:g.slice(2),landmarks:T,probability:x},(E=>{E.startEndTensor.dispose(),E.startPoint.dispose(),E.endPoint.dispose()})(u.box),u.landmarks.dispose(),u.probability.dispose()}else{const d=await c.array();f={topLeft:d.slice(0,2),bottomRight:d.slice(2)}}return c.dispose(),n&&(f=cz(f,r)),f}))}}async function eLe({maxFaces:s=10,inputWidth:e=128,inputHeight:t=128,iouThreshold:n=.3,scoreThreshold:i=.75}={}){const r=await dW("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0});return new Qke(r,e,t,s,n,i)}var EI={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function gq(s){return[Math.abs(s.endPoint[0]-s.startPoint[0]),Math.abs(s.endPoint[1]-s.startPoint[1])]}function g3(s){return[s.startPoint[0]+(s.endPoint[0]-s.startPoint[0])/2,s.startPoint[1]+(s.endPoint[1]-s.startPoint[1])/2]}function fz(s,e){e===void 0&&(e=1.5);var t=g3(s),n=gq(s),i=[e*n[0]/2,e*n[1]/2];return{startPoint:[t[0]-i[0],t[1]-i[1]],endPoint:[t[0]+i[0],t[1]+i[1]],landmarks:s.landmarks}}function dz(s,e){var t,n=Math.PI/2-Math.atan2(-(e[1]-s[1]),e[0]-s[0]);return(t=n)-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function pz(s,e){return[[1,0,s],[0,1,e],[0,0,1]]}function Ym(s,e){for(var t=0,n=0;n<s.length;n++)t+=s[n]*e[n];return t}function tLe(s,e){for(var t=[],n=0;n<s.length;n++)t.push(s[n][e]);return t}function mz(s,e){for(var t=[],n=s.length,i=0;i<n;i++){t.push([]);for(var r=0;r<n;r++)t[i].push(Ym(s[i],tLe(e,r)))}return t}function gz(s,e){var t=Math.cos(s),n=Math.sin(s),i=[[t,-n,0],[n,t,0],[0,0,1]],r=mz(pz(e[0],e[1]),i);return mz(r,pz(-e[0],-e[1]))}var yz=[1,168],xz=[3,2],nLe=function(){function s(e,t,n,i,r,a){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=n,this.meshHeight=i,this.maxContinuousChecks=r,this.maxFaces=a}return s.prototype.transformRawCoords=function(e,t,n,i){var r,a,o,l,u=this,c=gq({startPoint:t.startPoint,endPoint:t.endPoint}),f=[c[0]/this.meshWidth,c[1]/this.meshHeight],d=e.map(function(T){return[f[0]*(T[0]-u.meshWidth/2),f[1]*(T[1]-u.meshHeight/2),T[2]]}),g=gz(n,[0,0]),x=d.map(function(T){return function(E,C){return[Ym(E,C[0]),Ym(E,C[1])]}(T,g).concat([T[2]])}),S=(a=[[(r=i)[0][0],r[1][0]],[r[0][1],r[1][1]]],o=[r[0][2],r[1][2]],l=[-Ym(a[0],o),-Ym(a[1],o)],[a[0].concat(l[0]),a[1].concat(l[1]),[0,0,1]]),b=g3({startPoint:t.startPoint,endPoint:t.endPoint}).concat([1]),_=[Ym(b,S[0]),Ym(b,S[1])];return x.map(function(T){return[T[0]+_[0],T[1]+_[1],T[2]]})},s.prototype.predict=function(e){return bg(this,void 0,void 0,function(){var t,n,i,r,a=this;return _g(this,function(o){switch(o.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(e,!1,!0)]:[3,2];case 1:return t=o.sent(),n=t.boxes,i=t.scaleFactor,n.length===0?(this.regionsOfInterest=[],[2,null]):(r=n.map(function(l){var u,c,f={startPoint:l.box.startPoint.squeeze().arraySync(),endPoint:l.box.endPoint.squeeze().arraySync()},d=fz((c=i,{startPoint:[(u=f).startPoint[0]*c[0],u.startPoint[1]*c[1]],endPoint:[u.endPoint[0]*c[0],u.endPoint[1]*c[1]]}));return m3({},d,{landmarks:l.landmarks.arraySync()})}),n.forEach(function(l){l!=null&&l.startPoint!=null&&(l.startEndTensor.dispose(),l.startPoint.dispose(),l.endPoint.dispose())}),this.updateRegionsOfInterest(r),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,o.label=3;case 3:return[2,we(function(){return a.regionsOfInterest.map(function(l,u){var c;if(l.landmarks.length===468){var f=yz[0],d=yz[1];c=dz(l.landmarks[f],l.landmarks[d])}else f=xz[0],d=xz[1],c=dz(l.landmarks[f],l.landmarks[d]);var g=g3({startPoint:l.startPoint,endPoint:l.endPoint}),x=[g[0]/e.shape[2],g[1]/e.shape[1]],S=pl.rotateWithOffset(e,c,0,x),b=gz(-c,g),_=function(O,F,X){var q=F.shape[1],J=F.shape[2],Y=[[O.startPoint[1]/q,O.startPoint[0]/J,O.endPoint[1]/q,O.endPoint[0]/J]];return pl.cropAndResize(F,Y,[0],X)}({startPoint:l.startPoint,endPoint:l.endPoint},S,[a.meshHeight,a.meshWidth]).div(255),T=a.meshDetector.predict(_),E=T[1],C=T[2],R=xe(C,[-1,3]),I=R.arraySync(),L=a.transformRawCoords(I,l,c,b),P=Jd(L),D=a.calculateLandmarksBoundingBox(L);return a.regionsOfInterest[u]=m3({},D,{landmarks:P.arraySync()}),{coords:R,scaledCoords:P,box:D,flag:E.squeeze()}})})]}})})},s.prototype.updateRegionsOfInterest=function(e){for(var t=0;t<e.length;t++){var n=e[t],i=this.regionsOfInterest[t],r=0;if(i&&i.startPoint){var a=n.startPoint,o=a[0],l=a[1],u=n.endPoint,c=u[0],f=u[1],d=i.startPoint,g=d[0],x=d[1],S=i.endPoint,b=S[0],_=S[1],T=Math.max(o,g),E=Math.max(l,x),C=(Math.min(c,b)-T)*(Math.min(f,_)-E);r=C/((c-o)*(f-l)+(b-g)*(_-l)-C)}r<.25&&(this.regionsOfInterest[t]=n)}this.regionsOfInterest=this.regionsOfInterest.slice(0,e.length)},s.prototype.clearRegionOfInterest=function(e){this.regionsOfInterest[e]!=null&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,e).concat(this.regionsOfInterest.slice(e+1)))},s.prototype.shouldUpdateRegionsOfInterest=function(){var e=this.regionsOfInterest.length,t=e===0;return this.maxFaces===1||t?t:e!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},s.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map(function(r){return r[0]}),n=e.map(function(r){return r[1]}),i={startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]};return fz({startPoint:i.startPoint,endPoint:i.endPoint})},s}(),sLe=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function iLe(s){var e={},t=e.maxContinuousChecks,n=t===void 0?5:t,i=e.detectionConfidence,r=i===void 0?.9:i,a=e.maxFaces,o=a===void 0?10:a,l=e.iouThreshold,u=l===void 0?.3:l,c=e.scoreThreshold,f=c===void 0?.75:c;return bg(this,void 0,void 0,function(){var d,g,x;return _g(this,function(S){switch(S.label){case 0:return[4,Promise.all([rLe(o,u,f),aLe()])];case 1:return d=S.sent(),g=d[0],x=d[1],[2,new oLe(g,x,n,r,o)]}})})}function rLe(s,e,t){return bg(this,void 0,void 0,function(){return _g(this,function(n){return[2,eLe({maxFaces:s,iouThreshold:e,scoreThreshold:t})]})})}function aLe(){return bg(this,void 0,void 0,function(){return _g(this,function(s){return[2,dW("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]})})}function vz(s,e){if(s.mesh instanceof ls){var t=we(function(){var o=mi([e-1,0,0]),l=mi([1,-1,1]);return we(function(){return[js([wt(e-1,s.boundingBox.topLeft.slice(0,1)),s.boundingBox.topLeft.slice(1,1)]),js([wt(e-1,s.boundingBox.bottomRight.slice(0,1)),s.boundingBox.bottomRight.slice(1,1)]),wt(o,s.mesh).mul(l),wt(o,s.scaledMesh).mul(l)]})}),n=t[0],i=t[1],r=t[2],a=t[3];return Object.assign({},s,{boundingBox:{topLeft:n,bottomRight:i},mesh:r,scaledMesh:a})}return Object.assign({},s,{boundingBox:{topLeft:[e-1-s.boundingBox.topLeft[0],s.boundingBox.topLeft[1]],bottomRight:[e-1-s.boundingBox.bottomRight[0],s.boundingBox.bottomRight[1]]},mesh:s.mesh.map(function(o){var l=o.slice(0);return l[0]=e-1-o[0],l}),scaledMesh:s.scaledMesh.map(function(o){var l=o.slice(0);return l[0]=e-1-o[0],l})})}var oLe=function(){function s(e,t,n,i,r){this.pipeline=new nLe(e,t,192,192,n,r),this.detectionConfidence=i}return s.getAnnotations=function(){return EI},s.getUVCoords=function(){return sLe},s.prototype.estimateFaces=function(e,t,n){return t===void 0&&(t=!1),n===void 0&&(n=!1),bg(this,void 0,void 0,function(){var i,r,a,o,l,u=this;return _g(this,function(c){switch(c.label){case 0:return i=function(f){return f instanceof ls?[f.shape[0],f.shape[1]]:[f.height,f.width]}(e),r=i[1],a=we(function(){return e instanceof ls||(e=dH(e)),e.toFloat().expandDims(0)}),D8()!=="webgl"?[3,2]:(l=Ie().get("WEBGL_PACK_DEPTHWISECONV"),Ie().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(a)]);case 1:return o=c.sent(),Ie().set("WEBGL_PACK_DEPTHWISECONV",l),[3,4];case 2:return[4,this.pipeline.predict(a)];case 3:o=c.sent(),c.label=4;case 4:return a.dispose(),o!=null&&o.length>0?[2,Promise.all(o.map(function(f,d){return bg(u,void 0,void 0,function(){var g,x,S,b,_,T,E,C,R,I,L,P,D,O,F=this;return _g(this,function(X){switch(X.label){case 0:return g=f.coords,x=f.scaledCoords,S=f.box,b=f.flag,_=[b],t||(_=_.concat([g,x])),[4,Promise.all(_.map(function(q){return bg(F,void 0,void 0,function(){return _g(this,function(J){return[2,q.array()]})})}))];case 1:if(T=X.sent(),E=T[0],b.dispose(),E<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(d),t)return C={faceInViewConfidence:E,mesh:g,scaledMesh:x,boundingBox:{topLeft:mi(S.startPoint),bottomRight:mi(S.endPoint)}},n?[2,vz(C,r)]:[2,C];for(O in R=T.slice(1),I=R[0],L=R[1],x.dispose(),g.dispose(),P={faceInViewConfidence:E,boundingBox:{topLeft:S.startPoint,bottomRight:S.endPoint},mesh:I,scaledMesh:L},n&&(P=vz(P,r)),D={},EI)D[O]=EI[O].map(function(q){return P.scaledMesh[q]});return P.annotations=D,[2,P]}})})}))]:[2,[]]}})})},s}();function lLe(){const s=Me.useRef(null),e=Me.useRef(null);return Me.useEffect(()=>{const t=async()=>{const i=s.current,r=await navigator.mediaDevices.getUserMedia({video:!0,audio:!1});return i.srcObject=r,new Promise(a=>{i.onloadedmetadata=()=>{i.play(),a(i)}})};(async()=>{await Sle("webgl"),await Ale();const i=await t(),r=await iLe(),a=async()=>{if(i.readyState===4&&i.videoWidth>0&&i.videoHeight>0){const o=await r.estimateFaces(i),l=e.current;l.width=i.videoWidth,l.height=i.videoHeight;const u=l.getContext("2d");u.clearRect(0,0,l.width,l.height),u.save(),u.scale(-1,1),u.translate(-l.width,0),o.length>0&&o.forEach(c=>{const f=c.scaledMesh;u.fillStyle="red";for(let d=0;d<f.length;d++){const[g,x]=f[d];u.beginPath(),u.arc(g,x,1.5,0,2*Math.PI),u.fill()}}),u.restore()}requestAnimationFrame(a)};a()})()},[]),ft.jsxs("div",{className:"relative w-full h-screen flex items-center justify-center",children:[ft.jsx("video",{ref:s,className:"absolute rounded opacity-70",autoPlay:!0,muted:!0,playsInline:!0,style:{width:640,height:480,transform:"scaleX(-1)"}}),ft.jsx("canvas",{ref:e,className:"absolute",style:{width:640,height:480}}),ft.jsx("p",{className:"absolute top-4 left-4 text-white text-sm bg-black/60 px-3 py-1 rounded",children:"AR FaceMesh active"})]})}function uLe(){return ft.jsxs("div",{className:"p-8",children:[ft.jsx("h2",{className:"text-3xl font-bold mb-4",style:{fontFamily:"IM Fell English, serif"},children:"Wetenschappelijke Feiten"}),ft.jsx("p",{className:"mb-6",children:"DNA-onderzoek onthult kenmerken zoals oogkleur, haarkleur, en huidtint, maar laat ruimte voor interpretatie."}),ft.jsx(Yb,{to:"/tools",className:"bg-[#7A3D02] hover:bg-[#5c2e01] text-[#DEBE89] text-lg px-6 py-3 rounded-lg shadow-md uppercase font-bold font-poppins transition",children:"Volgende: Instrumenten"})]})}function cLe(){return ft.jsxs("div",{className:"p-8",children:[ft.jsx("h2",{className:"text-3xl font-bold mb-4",style:{fontFamily:"IM Fell English, serif"},children:"Instrumenten & Voorwerpen"}),ft.jsx("p",{className:"mb-6",children:"De mesolithische vrouw gebruikte vuurstenen werktuigen, benen naalden en andere alledaagse objecten."}),ft.jsx(S3,{to:"/way-of-life",children:"Volgende: Leefwijze"})]})}function hLe(){return ft.jsxs("div",{className:"p-8",children:[ft.jsx("h2",{className:"text-3xl font-bold mb-4",style:{fontFamily:"IM Fell English, serif"},children:"Dagelijks Leven"}),ft.jsx("p",{className:"mb-6",children:"Ze leefden in nauwe relatie met de natuur, trokken rond, jaagden en verzamelden voedsel."}),ft.jsx("p",{className:"text-gray-600 italic",children:"(Linken naar het 3D model of landschap)"}),ft.jsx(S3,{to:"/tools",children:"Terug naar Instrumenten"})]})}function fLe(){return ft.jsx("nav",{className:"px-4 py-3",children:ft.jsx("div",{className:"flex gap-6 justify-center",children:[{to:"/",label:"Home"},{to:"/model",label:"3D Model"},{to:"/ar",label:"AR"},{to:"/facts",label:"Facts"}].map(s=>ft.jsx(Yb,{to:s.to,className:"relative text-[#5C3A1E] font-medium hover:text-[#8B5A2B] transition",children:ft.jsx("span",{className:"after:content-[''] after:absolute after:left-0 after:-bottom-1 after:w-0 after:h-[2px] after:bg-[#8B5A2B] after:transition-all after:duration-300 hover:after:w-full",children:s.label})},s.to))})})}function dLe(){const e=Ef().pathname==="/model"?"/project-3d-reconstructie-van-een-mesolithische-vrouw-mohamadmatar7/images/background2.png":"/project-3d-reconstructie-van-een-mesolithische-vrouw-mohamadmatar7/images/background.png";return ft.jsxs("div",{style:{minHeight:"100vh",backgroundImage:`url(${e})`,backgroundSize:"cover",backgroundPosition:"center",backgroundRepeat:"no-repeat"},children:[ft.jsx(fLe,{}),ft.jsxs(sK,{children:[ft.jsx(Hm,{path:"/",element:ft.jsx(PK,{})}),ft.jsx(Hm,{path:"/model",element:ft.jsx(Moe,{})}),ft.jsx(Hm,{path:"/ar",element:ft.jsx(lLe,{})}),ft.jsx(Hm,{path:"/facts",element:ft.jsx(uLe,{})}),ft.jsx(Hm,{path:"/tools",element:ft.jsx(cLe,{})}),ft.jsx(Hm,{path:"/way-of-life",element:ft.jsx(hLe,{})})]})]})}function pLe(){return ft.jsx(EK,{children:ft.jsx(dLe,{})})}dj.createRoot(document.getElementById("root")).render(ft.jsx(Me.StrictMode,{children:ft.jsx(pLe,{})}));
